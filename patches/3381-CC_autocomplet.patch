Index: src/CodeBlocks-unix.cbp
===================================================================
--- src/CodeBlocks-unix.cbp	(wersja 8785)
+++ src/CodeBlocks-unix.cbp	(kopia robocza)
@@ -1196,6 +1199,12 @@
 		<Unit filename="plugins/codecompletion/coderefactoring.h">
 			<Option target="Code-completion" />
 		</Unit>
+		<Unit filename="plugins/codecompletion/doxygen_parser.cpp">
+			<Option target="Code-completion" />
+		</Unit>
+		<Unit filename="plugins/codecompletion/doxygen_parser.h">
+			<Option target="Code-completion" />
+		</Unit>
 		<Unit filename="plugins/codecompletion/insertclassmethoddlg.cpp">
 			<Option target="Code-completion" />
 		</Unit>
Index: src/CodeBlocks.cbp
===================================================================
--- src/CodeBlocks.cbp	(wersja 8785)
+++ src/CodeBlocks.cbp	(kopia robocza)
@@ -1457,6 +1457,12 @@
 		<Unit filename="plugins/codecompletion/coderefactoring.h">
 			<Option target="Code-completion" />
 		</Unit>
+		<Unit filename="plugins/codecompletion/doxygen_parser.cpp">
+			<Option target="Code-completion" />
+		</Unit>
+		<Unit filename="plugins/codecompletion/doxygen_parser.h">
+			<Option target="Code-completion" />
+		</Unit>
 		<Unit filename="plugins/codecompletion/insertclassmethoddlg.cpp">
 			<Option target="Code-completion" />
 		</Unit>
Index: src/plugins/abbreviations/abbreviations.cpp
===================================================================
--- src/plugins/abbreviations/abbreviations.cpp	(wersja 8785)
+++ src/plugins/abbreviations/abbreviations.cpp	(kopia robocza)
@@ -198,6 +198,7 @@
             control->RegisterImage(0, wxBitmap(abbrev_xpm));
             items.Sort();
             wxString itemsStr = GetStringFromArray(items, _T(" "));
+            control->AutoCompSetSeparator(_T(' '));
             control->AutoCompShow(endPos-startPos, itemsStr);
         }
         m_IsAutoCompVisible = control->AutoCompActive();
Index: src/plugins/codecompletion/ccoptionsdlg.cpp
===================================================================
--- src/plugins/codecompletion/ccoptionsdlg.cpp	(wersja 8785)
+++ src/plugins/codecompletion/ccoptionsdlg.cpp	(kopia robocza)
@@ -35,6 +35,7 @@
 
 #include "ccoptionsdlg.h"
 #include "codecompletion.h"
+#include "doxygen_parser.h" // For DocumentationHelper
 
 static const wxString g_SampleClasses =
     _T("class A_class"
@@ -82,12 +83,16 @@
     EVT_BUTTON(XRCID("btnDelRepl"),         CCOptionsDlg::OnDelRepl)
     EVT_BUTTON(XRCID("btnColour"),          CCOptionsDlg::OnChooseColour)
     EVT_COMMAND_SCROLL(XRCID("sldCCDelay"), CCOptionsDlg::OnCCDelayScroll)
+    EVT_BUTTON(XRCID("btnDocBgColor"),      CCOptionsDlg::OnChooseColour)
+    EVT_BUTTON(XRCID("btnDocTextColor"),    CCOptionsDlg::OnChooseColour)
+    EVT_BUTTON(XRCID("btnDocLinkColor"),    CCOptionsDlg::OnChooseColour)
 END_EVENT_TABLE()
 
-CCOptionsDlg::CCOptionsDlg(wxWindow* parent, NativeParser* np, CodeCompletion* cc) :
+CCOptionsDlg::CCOptionsDlg(wxWindow* parent, NativeParser* np, CodeCompletion* cc, DocumentationHelper* dh) :
     m_NativeParser(np),
     m_CodeCompletion(cc),
-    m_Parser(np->GetParser())
+    m_Parser(np->GetParser()),
+    m_Documentation(dh)
 {
     ConfigManager* cfg = Manager::Get()->GetConfigManager(_T("code_completion"));
 
@@ -102,6 +107,7 @@
     XRCCTRL(*this, "chkEvalTooltip",        wxCheckBox)->SetValue(cfg->ReadBool(_T("/eval_tooltip"),         true));
     XRCCTRL(*this, "chkAutoSelectOne",      wxCheckBox)->SetValue(cfg->ReadBool(_T("/auto_select_one"),      false));
     XRCCTRL(*this, "chkAutoAddParentheses", wxCheckBox)->SetValue(cfg->ReadBool(_T("/auto_add_parentheses"), true));
+    XRCCTRL(*this, "chkDetectImpl",         wxCheckBox)->SetValue(cfg->ReadBool(_T("/detect_implementation"),false));
     XRCCTRL(*this, "chkAddDoxgenComment",   wxCheckBox)->SetValue(cfg->ReadBool(_T("/add_doxgen_comment"),   false));
     XRCCTRL(*this, "chkEnableHeaders",      wxCheckBox)->SetValue(cfg->ReadBool(_T("/enable_headers"),       true));
     XRCCTRL(*this, "chkAutoLaunch",         wxCheckBox)->SetValue(cfg->ReadBool(_T("/auto_launch"),          true));
@@ -172,6 +178,13 @@
     XRCCTRL(*this, "chkInheritance",        wxCheckBox)->SetValue(m_Parser.ClassBrowserOptions().showInheritance);
     XRCCTRL(*this, "chkExpandNS",           wxCheckBox)->SetValue(m_Parser.ClassBrowserOptions().expandNS);
     XRCCTRL(*this, "chkTreeMembers",        wxCheckBox)->SetValue(m_Parser.ClassBrowserOptions().treeMembers);
+    
+    //Page Documentation
+    XRCCTRL(*this, "chkDocumentation",      wxCheckBox)->SetValue(m_Documentation->Options().m_Enabled);
+    XRCCTRL(*this, "chkDocPopupAlways",     wxCheckBox)->SetValue(m_Documentation->Options().m_ShowAlways);
+    XRCCTRL(*this, "btnDocBgColor",     wxButton)->SetBackgroundColour(DocumentationHelper::ColorFromHTMLString(m_Documentation->Options().m_BackgroundColor, *wxWHITE));
+    XRCCTRL(*this, "btnDocTextColor",   wxButton)->SetBackgroundColour(DocumentationHelper::ColorFromHTMLString(m_Documentation->Options().m_TextColor, *wxBLACK));
+    XRCCTRL(*this, "btnDocLinkColor",   wxButton)->SetBackgroundColour(DocumentationHelper::ColorFromHTMLString(m_Documentation->Options().m_LinkColor, *wxBLUE));
 
 //    m_Parser.ParseBuffer(g_SampleClasses, true);
 //    m_Parser.BuildTree(*XRCCTRL(*this, "treeClasses", wxTreeCtrl));
@@ -197,6 +210,7 @@
     cfg->Write(_T("/eval_tooltip"),         (bool) XRCCTRL(*this, "chkEvalTooltip",        wxCheckBox)->GetValue());
     cfg->Write(_T("/auto_select_one"),      (bool) XRCCTRL(*this, "chkAutoSelectOne",      wxCheckBox)->GetValue());
     cfg->Write(_T("/auto_add_parentheses"), (bool) XRCCTRL(*this, "chkAutoAddParentheses", wxCheckBox)->GetValue());
+    cfg->Write(_T("/detect_implementation"),(bool) XRCCTRL(*this, "chkDetectImpl",         wxCheckBox)->GetValue());
     cfg->Write(_T("/add_doxgen_comment"),   (bool) XRCCTRL(*this, "chkAddDoxgenComment",   wxCheckBox)->GetValue());
     cfg->Write(_T("/enable_headers"),       (bool) XRCCTRL(*this, "chkEnableHeaders",      wxCheckBox)->GetValue());
     cfg->Write(_T("/auto_launch"),          (bool) XRCCTRL(*this, "chkAutoLaunch",         wxCheckBox)->GetValue());
@@ -237,6 +251,12 @@
     cfg->Write(_T("/browser_tree_members"),     (bool) XRCCTRL(*this, "chkTreeMembers", wxCheckBox)->GetValue());
     cfg->Write(_T("/scope_filter"),             (bool) XRCCTRL(*this, "chkScopeFilter", wxCheckBox)->GetValue());
 
+    // Page "Documentation"
+    cfg->Write(_T("/use_documentation_helper"), (bool) XRCCTRL(*this, "chkDocumentation", wxCheckBox)->GetValue());
+    cfg->Write(_T("/always_show_doc"),          (bool) XRCCTRL(*this, "chkDocPopupAlways", wxCheckBox)->GetValue());
+    cfg->Write(_T("/documentation_helper_background_color"), (wxColour) XRCCTRL(*this, "btnDocBgColor",       wxButton)->GetBackgroundColour());
+    cfg->Write(_T("/documentation_helper_text_color"),       (wxColour) XRCCTRL(*this, "btnDocTextColor",     wxButton)->GetBackgroundColour());
+    cfg->Write(_T("/documentation_helper_link_color"),       (wxColour) XRCCTRL(*this, "btnDocLinkColor",     wxButton)->GetBackgroundColour());
     // -----------------------------------------------------------------------
     // Handle all options that are being be read by m_Parser.ReadOptions():
     // -----------------------------------------------------------------------
@@ -261,9 +281,20 @@
     m_Parser.ClassBrowserOptions().expandNS        = XRCCTRL(*this, "chkExpandNS",    wxCheckBox)->GetValue();
     m_Parser.ClassBrowserOptions().treeMembers     = XRCCTRL(*this, "chkTreeMembers", wxCheckBox)->GetValue();
 
+    // Page "Documentation"
+    m_Documentation->RereadOptions(cfg);
+    
+    m_Parser.Options().storeDocumentation    = XRCCTRL(*this, "chkDocumentation", wxCheckBox)->GetValue();
+    m_Documentation->Options().m_Enabled     = XRCCTRL(*this, "chkDocumentation", wxCheckBox)->GetValue();
+    m_Documentation->Options().m_ShowAlways  = XRCCTRL(*this, "chkDocPopupAlways", wxCheckBox)->GetValue();
+    m_Documentation->Options().m_BackgroundColor = DocumentationHelper::ColorToHTMLString(XRCCTRL(*this, "btnDocBgColor", wxButton)->GetBackgroundColour());
+    m_Documentation->Options().m_TextColor       = DocumentationHelper::ColorToHTMLString(XRCCTRL(*this, "btnDocTextColor", wxButton)->GetBackgroundColour());
+    m_Documentation->Options().m_LinkColor       = DocumentationHelper::ColorToHTMLString(XRCCTRL(*this, "btnDocLinkColor", wxButton)->GetBackgroundColour());
+    
     // Now write the parser options and re-read them again to make sure they are up-to-date
     m_Parser.WriteOptions();
     m_NativeParser->RereadParserOptions();
+    m_Documentation->WriteOptions(cfg);
     m_CodeCompletion->RereadOptions();
 }
 
@@ -350,6 +381,7 @@
 {
     bool en = !XRCCTRL(*this, "chkNoCC",            wxCheckBox)->GetValue();
     bool al =  XRCCTRL(*this, "chkAutoLaunch",      wxCheckBox)->GetValue();
+    bool aap = XRCCTRL(*this, "chkAutoAddParentheses", wxCheckBox)->GetValue();
 
     // Page "Code Completion"
     XRCCTRL(*this, "chkUseSmartSense",              wxCheckBox)->Enable(en);
@@ -358,6 +390,7 @@
     XRCCTRL(*this, "chkEvalTooltip",                wxCheckBox)->Enable(en);
     XRCCTRL(*this, "chkAutoSelectOne",              wxCheckBox)->Enable(en);
     XRCCTRL(*this, "chkAutoAddParentheses",         wxCheckBox)->Enable(en);
+    XRCCTRL(*this, "chkDetectImpl",                 wxCheckBox)->Enable(en && aap);
     XRCCTRL(*this, "chkAddDoxgenComment",           wxCheckBox)->Enable(en);
     XRCCTRL(*this, "chkEnableHeaders",              wxCheckBox)->Enable(en);
     XRCCTRL(*this, "chkAutoLaunch",                 wxCheckBox)->Enable(en);
@@ -406,6 +439,16 @@
     XRCCTRL(*this, "chkFloatCB",              wxCheckBox)->Enable(en);
     XRCCTRL(*this, "chkTreeMembers",          wxCheckBox)->Enable(en);
     XRCCTRL(*this, "chkScopeFilter",          wxCheckBox)->Enable(en);
+    
+    // Page "Documentation"
+    en = XRCCTRL(*this, "chkDocumentation",   wxCheckBox)->GetValue();
+    XRCCTRL(*this, "chkDocPopupAlways",       wxCheckBox)->Enable(en);
+    wxWindow* next = XRCCTRL(*this, "chkDocPopupAlways", wxWindow)->GetNextSibling();
+    while(next)
+    {
+        next->Enable(en);
+        next = next->GetNextSibling();
+    }
 }
 
 void CCOptionsDlg::UpdateCCDelayLabel()
Index: src/plugins/codecompletion/ccoptionsdlg.h
===================================================================
--- src/plugins/codecompletion/ccoptionsdlg.h	(wersja 8785)
+++ src/plugins/codecompletion/ccoptionsdlg.h	(kopia robocza)
@@ -13,11 +13,12 @@
 #include "parser/parser.h"
 
 class CodeCompletion;
+class DocumentationHelper;
 
 class CCOptionsDlg : public cbConfigurationPanel
 {
 public:
-    CCOptionsDlg(wxWindow* parent, NativeParser* np, CodeCompletion* cc);
+    CCOptionsDlg(wxWindow* parent, NativeParser* np, CodeCompletion* cc, DocumentationHelper* dh);
     virtual ~CCOptionsDlg();
 
     virtual wxString GetTitle() const          { return _("Code completion"); }
@@ -31,7 +32,7 @@
     void OnDelRepl(wxCommandEvent& event);
     void OnChooseColour(wxCommandEvent& event);
     void OnCCDelayScroll(wxScrollEvent& event);
-
+    
     void OnUpdateUI(wxUpdateUIEvent& event);
 
 private:
@@ -41,7 +42,8 @@
     NativeParser*   m_NativeParser;
     CodeCompletion* m_CodeCompletion;
     ParserBase&     m_Parser;
-
+    DocumentationHelper* m_Documentation;
+    
     DECLARE_EVENT_TABLE()
 };
 
Index: src/plugins/codecompletion/codecompletion.cpp
===================================================================
--- src/plugins/codecompletion/codecompletion.cpp	(wersja 8785)
+++ src/plugins/codecompletion/codecompletion.cpp	(kopia robocza)
@@ -42,6 +42,7 @@
 #endif
 
 #include <wx/tokenzr.h>
+#include <wx/html/htmlwin.h>
 
 #include <cbstyledtextctrl.h>
 #include <editor_hooks.h>
@@ -59,6 +60,7 @@
 #include "parser/cclogger.h"
 #include "parser/parser.h"
 #include "parser/tokenizer.h"
+#include "doxygen_parser.h" // for DocumentationPopup and DoxygenParser
 
 #define CC_CODECOMPLETION_DEBUG_OUTPUT 0
 
@@ -290,14 +292,50 @@
         // Either *a or *b is null
         return *a - *b;
     }
+    
+    template<class T, class U>
+    static bool CompareFirst( const std::pair<T,U>& left, const std::pair<T,U>& right )
+    {
+        return left.first < right.first;
+    }
+    
+    static bool SortCCListStdPred(const std::pair<wxString,int>& left, const std::pair<wxString,int>& right)
+    {
+        //in the same way wxWidgets wraps CompareFinction
+        //see wxGtk/src/common/dynarray.cpp - class wxCompareLess
+        return SortCCList(left.first, right.first) < 0;
+    }
+    
+    template<class T>
+    static wxString GetStringFromVector( const std::vector<T>& vec,
+                                         const wxString& separator,
+                                         wxString T::*ptrToString )
+    {
+        wxString output;
+        output.Alloc(separator.Length()*vec.size());
+        
+        for(unsigned int i = 0; i < vec.size(); ++i ){
+          output += vec[i].*ptrToString;
+          output += separator;
+        }// for (i)
+        
+        return output;
+    }
 
     struct GotoDeclarationItem
     {
       wxString filename;
       unsigned line;
     };
-}
 
+    static wxString AutocompGetName(const wxString& selected)
+    {
+        size_t nameEnd = selected.find_first_of(_T("(: "));
+        return selected.substr(0,nameEnd);
+    }
+    
+}//namespace CodeCompletionHelper
+
 // empty bitmap for use as C++ keywords icon in code-completion list
 /* XPM */
 static const char * cpp_keyword_xpm[] = {
@@ -514,9 +552,13 @@
     m_CCLaunchDelay(300),
     m_CCMaxMatches(16384),
     m_CCAutoAddParentheses(true),
+    m_CCDetectImplementation(false),
     m_CCAutoSelectOne(false),
     m_CCEnableHeaders(false),
-    m_SystemHeadersThreadCS()
+    m_SystemHeadersThreadCS(),
+    m_AutocompNameIdx(),
+    m_LastAutocompIndex(-1),
+    m_DocHelper(this)
 {
     CCLogger::Get()->Init(this, g_idCCLogger, g_idCCDebugLogger);
 
@@ -594,6 +636,10 @@
     pm->RegisterEventSink(cbEVT_EDITOR_ACTIVATED,     new cbEventFunctor<CodeCompletion, CodeBlocksEvent>(this, &CodeCompletion::OnEditorActivated));
     pm->RegisterEventSink(cbEVT_EDITOR_TOOLTIP,       new cbEventFunctor<CodeCompletion, CodeBlocksEvent>(this, &CodeCompletion::OnEditorTooltip));
     pm->RegisterEventSink(cbEVT_EDITOR_CLOSE,         new cbEventFunctor<CodeCompletion, CodeBlocksEvent>(this, &CodeCompletion::OnEditorClosed));
+    
+    m_LastAutocompIndex = -1;
+    
+    m_DocHelper.OnAttach();
 }
 
 void CodeCompletion::OnRelease(bool appShutDown)
@@ -632,11 +678,16 @@
         m_SearchMenu->Delete(idMenuFindReferences);
         m_SearchMenu->Delete(idMenuOpenIncludeFile);
     }
+    
+    m_LastAutocompIndex = -1;
+    m_AutocompNameIdx.clear();
+    
+    m_DocHelper.OnRelease();
 }
 
 cbConfigurationPanel* CodeCompletion::GetConfigurationPanel(wxWindow* parent)
 {
-    return new CCOptionsDlg(parent, &m_NativeParser, this);
+    return new CCOptionsDlg(parent, &m_NativeParser, this, &m_DocHelper);
 }
 
 cbConfigurationPanel* CodeCompletion::GetProjectConfigurationPanel(wxWindow* parent, cbProject* project)
@@ -900,13 +951,13 @@
             wxImageList* ilist = m_NativeParser.GetImageList();
             ed->GetControl()->ClearRegisteredImages();
 
-            wxArrayString items;
-            items.Alloc(result.size());
+            AutocompNameIdxVec& items = m_AutocompNameIdx;
+            items.clear();
+            items.reserve(result.size());
             int pos   = ed->GetControl()->GetCurrentPos();
             int start = ed->GetControl()->WordStartPosition(pos, true);
             wxArrayInt already_registered;
             std::set< wxString, std::less<wxString> > unique_strings; // check against this before inserting a new string in the list
-            m_SearchItem.clear();
 
             TokenTree* tree = m_NativeParser.GetParser().GetTokenTree();
 
@@ -918,27 +969,45 @@
                 if (!token || token->m_Name.IsEmpty())
                     continue;
 
-                // check hashmap for unique_strings
-                if (unique_strings.find(token->m_Name) != unique_strings.end())
-                    continue;
-
+                wxString tmp;
+                tmp << token->m_Name;
+        
                 if (preprocessorOnly && token->m_TokenKind != tkPreprocessor)
                     continue;
+                    
+                if(token->m_TokenKind & tkAnyFunction)
+                {
+                    //tmp << token->GetFormattedArgs();
+                    tmp << _T("(): ") << token->m_FullType;
+                }
 
-                unique_strings.insert(token->m_Name);
+                else if(token->m_TokenKind == tkVariable)
+                {
+                    tmp << _T(": ") << token->m_FullType;
+                }
+
+                static const bool ignoreOverloads = false;
+                if(ignoreOverloads)
+                {
+                    // check hashmap for unique_strings
+                    if (unique_strings.find(tmp) != unique_strings.end())
+                    {
+                        continue;
+                    }
+                }
+                
+                unique_strings.insert(tmp);
+
                 int iidx = m_NativeParser.GetTokenKindImage(token);
                 if (already_registered.Index(iidx) == wxNOT_FOUND)
                 {
                     ed->GetControl()->RegisterImage(iidx, ilist->GetBitmap(iidx));
                     already_registered.Add(iidx);
                 }
+                    
+                tmp <<  wxString::Format(_T("?%d"), iidx);
+                items.push_back(std::make_pair(tmp,*it));
 
-                wxString tmp;
-                tmp << token->m_Name << wxString::Format(_T("?%d"), iidx);
-                items.Add(tmp);
-                if (m_CCAutoAddParentheses && token->m_TokenKind == tkFunction)
-                    m_SearchItem[token->m_Name] = token->GetFormattedArgs().size() - 2;
-
                 if (token->m_TokenKind == tkNamespace && token->m_Aliases.size())
                 {
                     for (size_t i = 0; i < token->m_Aliases.size(); ++i)
@@ -949,7 +1018,7 @@
                         unique_strings.insert(token->m_Aliases[i]);
                         tmp.Empty();
                         tmp << token->m_Aliases[i] << wxString::Format(_T("?%d"), iidx);
-                        items.Add(tmp);
+                        items.push_back(std::make_pair(tmp,*it));
                     }
                 }
             }
@@ -989,25 +1058,31 @@
                         wxStringTokenizer tkz(keywords, _T(" \t\r\n"), wxTOKEN_STRTOK);
                         while (tkz.HasMoreTokens())
                         {
-                            wxString kw = tkz.GetNextToken() + wxString::Format(_T("?%d"), iidx);
+                            const wxString& strTok = tkz.GetNextToken();
+                            wxString kw = strTok + wxString::Format(_T("?%d"), iidx);
                             if (kw.Lower().StartsWith(lastSearch))
-                                items.Add(kw);
+                            {
+                                items.push_back(std::make_pair(kw,-1));
+                            }
+                                
                         }
                     }
                 }
             }
 
-            if (items.IsEmpty())
+            if (items.empty())
             {
                 if (s_DebugSmartSense)
                     CCLogger::Get()->DebugLog(_T("No items found."));
+
                 return -2;
             }
-
+            
             if (caseSens)
-                items.Sort();
+                std::sort(items.begin(),items.end(), 
+                          &CodeCompletionHelper::CompareFirst<wxString,int> );
             else
-                items.Sort(CodeCompletionHelper::SortCCList);
+                std::sort(items.begin(),items.end(), &CodeCompletionHelper::SortCCListStdPred );
 
             if (s_DebugSmartSense)
                 CCLogger::Get()->DebugLog(_T("Done generating tokens list"));
@@ -1018,9 +1093,12 @@
             ed->GetControl()->AutoCompSetChooseSingle(m_IsAutoPopup ? false : m_CCAutoSelectOne);
             ed->GetControl()->AutoCompSetAutoHide(true);
             ed->GetControl()->AutoCompSetDropRestOfWord(m_IsAutoPopup ? false : true);
-            wxString final = GetStringFromArray(items, _T(" "));
-            final.RemoveLast(); // remove last space
-
+            ed->GetControl()->AutoCompSetSeparator('\n');
+            ed->GetControl()->AutoCompSetMaxWidth(80);
+            ed->GetControl()->AutoCompSetMaxHeight(16);
+            wxString final = CodeCompletionHelper::GetStringFromVector(items,
+                _T("\n"), &std::pair<wxString,int>::first );
+            
             ed->GetControl()->AutoCompShow(pos - start, final);
 
             return 0;
@@ -1177,6 +1255,7 @@
     control->RegisterImage(PARSER_IMG_PREPROCESSOR,
                            m_NativeParser.GetImageList()->GetBitmap(PARSER_IMG_PREPROCESSOR));
     control->AutoCompSetIgnoreCase(false);
+    control->AutoCompSetSeparator(_T(' '));
     control->AutoCompShow(curPos - start, GetStringFromArray(tokens, _T(" ")));
 }
 
@@ -1314,6 +1393,7 @@
         control->AutoCompSetChooseSingle(false);
         control->AutoCompSetAutoHide(true);
         control->AutoCompSetDropRestOfWord(m_IsAutoPopup ? false : true);
+        control->AutoCompSetSeparator(_T(' '));
         wxString final_str;
         CodeCompletionHelper::GetStringFromSet(final_str, files, _T("?0 "));
         final_str.RemoveLast(); // remove last space
@@ -1429,7 +1509,7 @@
     }
 
     cbStyledTextCtrl* control = editor->GetControl();
-
+    
     if      (event.GetEventType() == wxEVT_SCI_CHARADDED)
     {   TRACE(_T("wxEVT_SCI_CHARADDED")); }
     else if (event.GetEventType() == wxEVT_SCI_CHANGE)
@@ -1451,7 +1531,11 @@
 
     if (event.GetEventType() == wxEVT_SCI_AUTOCOMP_SELECTION)
     {
+        using namespace CodeCompletionHelper;
+
         wxString itemText = event.GetText();
+        itemText = AutocompGetName(itemText);
+        
         int curPos = control->GetCurrentPos();
         int startPos = control->WordStartPosition(curPos, true);
         if (   itemText.GetChar(0) == _T('~') // special handle for dtor
@@ -1510,58 +1594,143 @@
                 ch = control->GetCharAt(--pos);
             if (ch == _T('<') || ch == _T('"'))
                 startPos = pos + 1;
+                
+            if (ch == _T('"'))
+                itemText << _T('"');
+            else if (ch == _T('<'))
+                itemText << _T('>');
         }
 
+
         const wxString alreadyText = control->GetTextRange(curPos, endPos);
         if (!alreadyText.IsEmpty() && itemText.EndsWith(alreadyText))
+        {
             curPos = endPos;
+        }
 
         control->AutoCompCancel();
-        control->SetTargetStart(startPos);
-        control->SetTargetEnd(curPos);
-
-        std::map<wxString, int>::const_iterator it = m_SearchItem.find(itemText);
-        if (it != m_SearchItem.end())
+            
+        int positionModificator = 0;
+        bool insideParentheses = false;
+        int tokenIdx = GetAutocompTokenIdx();
+        if(tokenIdx != -1 && m_CCAutoAddParentheses)
         {
-            // Check if there are brace behind the target
-            wxString addString(itemText);
-            if (control->GetCharAt(curPos) != _T('('))
-                addString += _T("()");
-
-            if (control->GetTextRange(startPos, curPos) != addString)
-                control->ReplaceTarget(addString);
-            control->GotoPos(startPos + itemText.size() + 2);
-            if ((*it).second != 0)
+            CC_LOCKER_TRACK_TT_MTX_LOCK(s_TokenTreeMutex)
+            
+            TokenTree* tree = m_NativeParser.GetParser().GetTokenTree();
+            const Token* token = tree->at(tokenIdx);
+            
+            if(!token)
             {
-                control->CharLeft();
-                control->EnableTabSmartJump();
-                TRACE(_T("wxEVT_SCI_AUTOCOMP_SELECTION -> ShowCallTip"));
-                ShowCallTip();
+                CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
             }
-        }
-        else
-        {
-            if (control->IsPreprocessor(control->GetStyleAt(startPos)))
+            else
             {
-                const wxChar start = control->GetCharAt(startPos - 1);
-                if (start == _T('"'))
-                    itemText << _T('"');
-                else if (start == _T('<'))
-                    itemText << _T('>');
-            }
+                bool addParentheses = token->m_TokenKind & tkAnyFunction;
+                if(!addParentheses && (token->m_TokenKind & tkPreprocessor))
+                {
+                    if(token->m_Args.size() > 0)
+                        addParentheses = true;
+                }
+                // cache args to avoid lockig
+                wxString tokenArgs = token->GetStrippedArgs();
+                
+                CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
+             
+                if(addParentheses)
+                {
+                    bool insideFunction = true;
+                    if(m_CCDetectImplementation)
+                    {
+                        ccSearchData searchData { control, editor->GetFilename() };
+                        int funcToken;
+                        if( m_NativeParser.FindCurrentFunctionStart(&searchData, 0, 0, &funcToken) == -1)
+                        {
+                            // global scope
+                            itemText += tokenArgs;
+                            
+                            insideFunction = false;
+                        }
+                        else // Found something, but result may be false positive.
+                        {
+                            
+                            CC_LOCKER_TRACK_TT_MTX_LOCK(s_TokenTreeMutex)
+                            
+                            const Token* parent = tree->at(funcToken);
+                            // Make sure that parent is not container (class, etc)
+                            if( parent && (parent->m_TokenKind & tkAnyFunction) == 0)
+                            {
+                                // class scope
+                                itemText += tokenArgs;
+                                
+                                insideFunction = false;
+                            }
+                            
+                            CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
+                        }
+                    }
+                    
+                    if(insideFunction)
+                    {
+                        // Inside block
+                        // Check if there are brace behind the target
+                        if (control->GetCharAt(curPos) != _T('('))
+                        {
+                            itemText += _T("()");
+                            if(tokenArgs.size() > 2) //more than '()'
+                            {
+                                positionModificator = -1;
+                                insideParentheses = true;
+                            }
+                        }
+                        else
+                            positionModificator = 1; // Set caret after '('
+                    }
+//                    else
+//                    {
+//                        // Outside block, probably function declaration
+//                        // Information about implementation position might be 
+//                        // updated here.
+//                        //needReparse = true;
+//                    }
+                }
 
-            if (control->GetTextRange(startPos, curPos) != itemText)
-                control->ReplaceTarget(itemText);
-            control->GotoPos(startPos + itemText.Length());
+            }// if token
+            
+        }// if token idx
+        
+        control->SetTargetStart(startPos);
+        control->SetTargetEnd(curPos);
+        
+        if (control->GetTextRange(startPos, curPos) != itemText)
+            control->ReplaceTarget(itemText);
+        control->GotoPos(startPos + itemText.Length() + positionModificator);
 
-            if (needReparse)
-            {
-                TRACE(_T("EditorEventHook: Starting m_TimerRealtimeParsing."));
-                m_TimerRealtimeParsing.Start(1, wxTIMER_ONE_SHOT);
-            }
+        if(insideParentheses)
+        {
+            control->EnableTabSmartJump();
+            TRACE(_T("wxEVT_SCI_AUTOCOMP_SELECTION -> ShowCallTip"));
+            ShowCallTip();
         }
+        
+        if (needReparse)
+        {
+            TRACE(_T("EditorEventHook: Starting m_TimerRealtimeParsing."));
+            m_TimerRealtimeParsing.Start(1, wxTIMER_ONE_SHOT);
+        }
         control->ChooseCaretX();
+        
+        m_LastAutocompIndex = -1;
+        m_AutocompNameIdx.clear();
     }
+    
+    if (event.GetEventType() == wxEVT_SCI_AUTOCOMP_CANCELLED ||
+        event.GetEventType() == wxEVT_SCI_ESC ||
+        event.GetEventType() == wxEVT_SCI_KILLFOCUS)
+    {
+        m_LastAutocompIndex = -1;
+        m_AutocompNameIdx.clear();
+    }
 
     if (event.GetEventType() == wxEVT_SCI_CHARADDED)
     {
@@ -1741,10 +1909,11 @@
     m_CCLaunchDelay        = cfg->ReadInt(_T("/cc_delay"),              300);
     m_CCMaxMatches         = cfg->ReadInt(_T("/max_matches"),           16384);
     m_CCAutoAddParentheses = cfg->ReadBool(_T("/auto_add_parentheses"), true);
+    m_CCDetectImplementation = cfg->ReadBool(_T("/detect_implementation"),false); //depends on auto_add_parentheses
     m_CCFillupChars        = cfg->Read(_T("/fillup_chars"),             wxEmptyString);
     m_CCAutoSelectOne      = cfg->ReadBool(_T("/auto_select_one"),      false);
     m_CCEnableHeaders      = cfg->ReadBool(_T("/enable_headers"),       true);
-
+    
     if (m_ToolBar)
     {
         UpdateToolBar();
@@ -1754,6 +1923,8 @@
         TRACE(_T("CodeCompletion::RereadOptions: Starting m_TimerToolbar."));
         m_TimerToolbar.Start(TOOLBAR_REFRESH_DELAY, wxTIMER_ONE_SHOT);
     }
+    
+    m_DocHelper.RereadOptions(cfg);
 }
 
 void CodeCompletion::UpdateToolBar()
@@ -2304,6 +2475,9 @@
 {
     m_NativeParser.ReparseCurrentProject();
     event.Skip();
+    
+    m_LastAutocompIndex = -1;
+    m_AutocompNameIdx.clear();
 }
 
 void CodeCompletion::OnSelectedProjectReparse(wxCommandEvent& event)
@@ -2479,9 +2653,17 @@
         {
             FunctionsScopePerFile* funcdata = &(m_AllFunctionsScopes[ed->GetFilename()]);
             funcdata->parsed = false;
+            
+            if(ed->GetControl())
+            {
+                ed->GetControl()->Connect(wxID_ANY, wxEVT_COMMAND_LIST_ITEM_SELECTED,
+                                        (wxObjectEventFunction)&CodeCompletion::OnAutocompleteSelect,
+                                        NULL, this);
+            }
+                
         }
     }
-
+    
     event.Skip();
 }
 
@@ -2555,6 +2737,17 @@
         if (m_NativeParser.GetParser().ClassBrowserOptions().displayFilter == bdfFile)
             m_NativeParser.UpdateClassBrowser();
     }
+    
+    if(event.GetEditor())
+    {
+        cbEditor* ed = edm->GetBuiltinEditor(event.GetEditor());
+        if(ed && ed->GetControl())
+        {
+            ed->GetControl()->Disconnect(wxID_ANY, wxEVT_COMMAND_LIST_ITEM_SELECTED,
+                                         (wxObjectEventFunction)&CodeCompletion::OnAutocompleteSelect,
+                                         NULL, this);
+        }
+    }
 
     event.Skip();
 }
@@ -2588,6 +2781,9 @@
         if (m_NativeParser.GetProjectByEditor(editor) == project)
             EnableToolbarTools(false);
     }
+    
+    m_LastAutocompIndex = -1;
+    m_AutocompNameIdx.clear();
 }
 
 void CodeCompletion::OnParserEnd(wxCommandEvent& event)
@@ -2838,6 +3041,7 @@
         {
             m_CompletePPOnly = true;
             CodeComplete();
+            m_DocHelper.Hide();
         }
         return;
     }
@@ -2854,7 +3058,8 @@
         return;
 
     TRACE(_T("DoCodeComplete -> CodeComplete"));
-    CodeComplete();
+    if(CodeComplete() < 0)
+        m_DocHelper.Hide();
 }
 
 int CodeCompletion::DoClassMethodDeclImpl()
@@ -3480,6 +3685,36 @@
         m_NativeParser.OnEditorActivated(editor);
 }
 
+int CodeCompletion::GetAutocompTokenIdx(int selectedItem)
+{
+    cbEditor* editor = Manager::Get()->GetEditorManager()->GetBuiltinActiveEditor();
+    if (!editor)
+        return 0;
+    if ( !IsProviderFor(editor) )
+        return 0;
+        
+    cbStyledTextCtrl* control = editor->GetControl();
+    if(!control)
+        return 0;
+    
+    if(selectedItem < 0)
+    {
+        if(control->AutoCompActive()){
+            selectedItem = control->AutoCompGetCurrent();
+            //m_LastAutocompIndex = selectedItem;
+        }
+        else
+            selectedItem = m_LastAutocompIndex;
+    }
+    
+    if(selectedItem >= 0 && selectedItem < (int)m_AutocompNameIdx.size() &&
+       m_AutocompNameIdx[selectedItem].second != -1)
+    {
+        return m_AutocompNameIdx[selectedItem].second;
+    }
+    return -1;
+}
+
 void CodeCompletion::OnCodeCompleteTimer(cb_unused wxTimerEvent& event)
 {
     if (Manager::Get()->GetEditorManager()->FindPageFromEditor(m_LastEditor) == -1)
@@ -3642,3 +3877,24 @@
     m_TimerToolbar.Start(TOOLBAR_REFRESH_DELAY, wxTIMER_ONE_SHOT);
     TRACE(_T("OnEditorActivatedTimer() : Current activated file is %s"), curFile.wx_str());
 }
+
+void CodeCompletion::OnAutocompleteSelect(wxListEvent& event)
+{
+    event.Skip();
+    
+    cbEditor* editor = Manager::Get()->GetEditorManager()->GetBuiltinActiveEditor();
+    if (!editor)
+        return;
+    if ( !IsProviderFor(editor) )
+        return;
+        
+    TRACE(_T("OnAutocompleteSelect"));
+    
+    cbStyledTextCtrl* control = editor->GetControl();
+    if(control->AutoCompActive())
+    {
+        m_LastAutocompIndex = control->AutoCompGetCurrent();
+        
+        m_DocHelper.OnSelectionChange(event);
+    }
+}
Index: src/plugins/codecompletion/codecompletion.h
===================================================================
--- src/plugins/codecompletion/codecompletion.h	(wersja 8785)
+++ src/plugins/codecompletion/codecompletion.h	(kopia robocza)
@@ -14,6 +14,7 @@
 #include "coderefactoring.h"
 #include "nativeparser.h"
 #include "systemheadersthread.h"
+#include "doxygen_parser.h"
 
 #include <wx/arrstr.h>
 #include <wx/string.h>
@@ -26,6 +27,7 @@
 class cbEditor;
 class wxScintillaEvent;
 class wxChoice;
+class DocumentationHelper;
 
 /** Code completion plugin has those features:
  * show function call-tip when the mouse hover over the variables/functions.
@@ -58,6 +60,9 @@
     /** helper class to support FunctionsScopeVec*/
     typedef std::vector<int> ScopeMarksVec;
 
+    /** class to store token name and it's ID */
+    typedef std::vector<std::pair<wxString,int> > AutocompNameIdxVec;
+    
     struct FunctionsScopePerFile
     {
         FunctionsScopeVec m_FunctionsScope; // all functions in the file
@@ -244,6 +249,11 @@
     void EnableToolbarTools(bool enable = true);
     void DoParseOpenedProjectAndActiveEditor();
 
+    /** Returns token of autocomplete item; might be NULL.
+     *  @param itemIndex index to m_AutocompNameIdx; when itemIndex is < 0 then AutoCompGetCurrent will be used
+     */
+    int GetAutocompTokenIdx(int itemIndex = -1);
+    
     /** delayed for code completion */
     void OnCodeCompleteTimer(wxTimerEvent& event);
 
@@ -261,6 +271,9 @@
 
     /** delayed running of editor activated event, only the last activated editor should be considered*/
     void OnEditorActivatedTimer(wxTimerEvent& event);
+    
+    /** */
+    void OnAutocompleteSelect(wxListEvent& event);
 
     /** Not used*/
     int                     m_PageIndex;
@@ -323,8 +336,6 @@
 
     /** current caret line */
     int                     m_CurrentLine;
-    /** TODO */
-    std::map<wxString, int> m_SearchItem;
 
     /** the file updating the toolbar info*/
     wxString                m_LastFile;
@@ -348,6 +359,7 @@
     int                     m_CCLaunchDelay;
     size_t                  m_CCMaxMatches;
     bool                    m_CCAutoAddParentheses;
+    bool                    m_CCDetectImplementation;
     wxString                m_CCFillupChars;
     bool                    m_CCAutoSelectOne;
     bool                    m_CCEnableHeaders;
@@ -360,6 +372,18 @@
     typedef std::map<cbProject*, wxArrayString> ReparsingMap;
     ReparsingMap m_ReparsingMap;
 
+    /** names and token's ids of autocomplete items; filled up in CodeComplete */
+    AutocompNameIdxVec      m_AutocompNameIdx;
+    
+    /** which position in autocomplete list was selected? */
+    int                     m_LastAutocompIndex;
+    
+    /** Pupup window to display documentation */
+    DocumentationHelper    m_DocHelper;
+    
+    friend void DocumentationHelper::OnLink(wxHtmlLinkEvent&);
+    friend void DocumentationHelper::OnSelectionChange(wxListEvent&);
+    
     DECLARE_EVENT_TABLE()
 };
 
Index: src/plugins/codecompletion/doxygen_parser.cpp
===================================================================
--- src/plugins/codecompletion/doxygen_parser.cpp	(wersja 0)
+++ src/plugins/codecompletion/doxygen_parser.cpp	(kopia robocza)
@@ -0,0 +1,1312 @@
+/*
+ * This file is part of the Code::Blocks IDE and licensed under the GNU General Public License, version 3
+ * http://www.gnu.org/licenses/gpl-3.0.html
+ */
+
+#include <sdk.h>
+
+#include <wx/tokenzr.h>
+#include <wx/html/htmlwin.h>
+
+#include <cbstyledtextctrl.h>
+
+#include "doxygen_parser.h"
+
+#include "codecompletion.h"
+
+/** @return avarange char width */
+static int GetAverangeCharWidth( cbStyledTextCtrl* control, int style)
+{
+    const wxString allChars = _T("1234567890-=qwertyuiop[]\\asdfghjkl;'zxcvbnm,./!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?");
+    return control->TextWidth(style, allChars) / allChars.size();
+}
+
+// Doxygen documents parser
+namespace Doxygen
+{
+    /*  source: http://www.stack.nl/~dimitri/doxygen/commands.html
+        Some commands have one or more arguments. Each argument has a
+            certain range:
+
+            If <sharp> braces are used the argument is a single word.
+
+            If (round) braces are used the argument extends until the end of
+                the line on which the command was found.
+
+            If {curly} braces are used the argument extends until the next
+                paragraph. Paragraphs are delimited by a blank line or by
+                a section indicator.
+
+        If in addition to the above argument specifiers [square] brackets
+            are used the argument is optional.
+    */
+    const wxString DoxygenParser::Keywords[] = {
+        _T(""),                     // no keyword
+        _T("param"),                // \param [(dir)] <parameter-name> { parameter description }
+        _T("return"), _T("result"), // \return { description of the return value }
+        _T("brief"), _T("short"),   // \brief { brief description }
+        _T("sa"), _T("see"),        // \sa { references }
+
+        // structural commands:
+        _T("class"), _T("struct"),  //
+        _T("union"),                //
+        _T("enum"),                 //
+        _T("namespace"),            //
+
+        _T("fn"),                   //
+        _T("var"),                  //
+        _T("def"),                  //
+        
+        _T("code"),                 //
+        _T("endcode"),              //
+        
+        _T("b"),                    //
+
+    };
+
+    const int DoxygenParser::KwCount = sizeof(DoxygenParser::Keywords)/sizeof(DoxygenParser::Keywords[0]);
+
+    const wxString DoxygenParser::NewLineReplacment = _T("\n");
+
+    DoxygenParser::DoxygenParser() :
+        m_FoundKw(-1),
+        m_Pos(-1)
+    {
+        assert(KwCount == KEYWORDS_COUNT);
+    }
+
+    int DoxygenParser::FindNextKeyword(const wxString& doc)
+    {
+        ++m_Pos;
+        if(m_Pos >= (int)doc.size())
+            return KEYWORDS_COUNT;
+            
+        if(IsKeywordBegin(doc))
+        {
+            ++m_Pos;
+            int fkw = CheckKeyword(doc);
+            if(fkw != NO_KEYWORD)
+                return fkw;
+        }
+
+        return NO_KEYWORD;
+    }
+
+    int DoxygenParser::GetArgument(const wxString& doc, int range, wxString& output)
+    {
+        SkipDecorations(doc);
+        
+        int nestedArgsCount = 0;
+        switch(range)
+        {
+        case RANGE_PARAGRAPH:
+            nestedArgsCount = GetParagraphArgument(doc, output);
+            break;
+        case RANGE_WORD:
+            GetWordArgument(doc, output);
+            break;
+        case RANGE_BLOCK:
+            GetBlockArgument(doc, output);
+            break;
+        case RANGE_LINE:
+            nestedArgsCount = GetLineArgument(doc,output);
+            break;
+        default:
+            break;
+        }
+        --m_Pos;
+        return nestedArgsCount;
+    }
+    
+    int DoxygenParser::GetPosition() const
+    {
+        return m_Pos;
+    }
+    
+    void DoxygenParser::ReplaceInDoc(wxString& doc, size_t start, size_t count,
+                      const wxString& str)
+    {
+        if(start < (size_t)m_Pos)
+        {
+            doc.replace(start, count, str);
+            m_Pos += str.size() - count;
+        }
+        else
+        {
+            doc.replace(start, count, str);
+        }
+    }
+    
+    void DoxygenParser::ReplaceCurrentKeyword(wxString& doc, const wxString& str)
+    {
+        const wxString& kw = DoxygenParser::Keywords[m_FoundKw];
+        int posBegin = m_Pos - kw.size();
+        ReplaceInDoc(doc, posBegin - 1, kw.size()+1, str);
+    }
+
+    int DoxygenParser::CheckKeyword(const wxString& doc)
+    {
+        int kwLen = 0;
+        int machingKwCount = KwCount;
+        bool foundOne = false;
+        bool isKw[KEYWORDS_COUNT] = {};
+        for(int j = 0; j < KEYWORDS_COUNT; ++j )
+            isKw[j] = true;
+
+        while(m_Pos < (int)doc.size() && !foundOne)
+        {
+            for(int k = 0; k < KwCount; ++k)
+            {
+                if( isKw[k] && (kwLen >= (int)Keywords[k].size() ||
+                                   doc[m_Pos + kwLen] != Keywords[k][kwLen]) )
+                {
+                    isKw[k] = false;
+                    --machingKwCount;
+                    if(machingKwCount == 1)
+                    {
+                        foundOne = true;
+                        //end loop:
+                        k = KwCount;
+                        --kwLen;
+                    }
+                }//if
+
+            }// for (k)
+            ++kwLen;
+        }//while
+
+        if(!foundOne)
+        {
+            return NO_KEYWORD;
+        }
+
+        int foundKw = 0;
+        for(int l = 0; l < KwCount; ++l )
+        {
+            if(isKw[l])
+            {
+                foundKw = l;
+                break;
+            }
+        }// for (l)
+
+        if(doc.size() < m_Pos + Keywords[foundKw].size())
+        {
+            return NO_KEYWORD;
+        }
+
+        while(kwLen < (int)Keywords[foundKw].size())
+        {
+            if(isKw[foundKw])
+                isKw[foundKw] = doc[m_Pos + kwLen] == Keywords[foundKw][kwLen];
+            else
+            {
+                return NO_KEYWORD;
+            }
+
+            ++kwLen;
+        }
+        //now kwLen = Keywords[foundKw].size()
+
+        if(m_Pos + kwLen < (int)doc.size())
+        {
+            if( !IsOneOf(doc[m_Pos + kwLen], _T(" \t\n")))
+            {
+                return NO_KEYWORD;
+            }
+        }
+
+        //got valid keyword
+        m_FoundKw = foundKw;
+        m_Pos = m_Pos + kwLen;
+        return foundKw;
+    }
+
+    int DoxygenParser::GetParagraphArgument(const wxString& doc, wxString& output)
+    {
+        int nestedArgsCount = 0;
+        while(m_Pos < (int)doc.size())
+        {
+            int tmpPos = m_Pos;
+            nestedArgsCount += GetLineArgument(doc, output);
+            HandleNewLine(doc,output,_T(' '));
+            if(doc[m_Pos] == _T('\n') || m_Pos == tmpPos)
+            {
+                //++i;
+                break;
+            }
+
+        }
+        return nestedArgsCount;
+    }
+
+    void DoxygenParser::GetWordArgument(const wxString& doc, wxString& output)
+    {
+        bool gotWord = false;
+        while(m_Pos < (int)doc.size())
+        {
+            switch(doc[m_Pos])
+            {
+            case _T('\n'):
+            case _T(' '):
+            case _T('\t'):
+                if(gotWord)
+                    return;
+                    
+                ++m_Pos;
+                break;
+            default:
+                output += doc[m_Pos];
+                ++m_Pos;
+                gotWord = true;
+            }
+        }
+    }
+
+    void DoxygenParser::GetBlockArgument(const wxString& doc, wxString& output)
+    {
+        //TODO: add implementation
+        (void)doc;
+        (void)output;
+    }
+
+    int DoxygenParser::GetLineArgument(const wxString& doc, wxString& output)
+    {
+        int nestedArgsCount = 0;
+        while(m_Pos < (int)doc.size())
+        {
+            switch(doc[m_Pos])
+            {
+            case _T('\n'):
+                //SkipDecorations(doc);
+                return nestedArgsCount;
+                break;
+
+            case _T('@'):
+            case _T('\\'):
+                if(IsKeywordBegin(doc))
+                {
+                    int tmpI = m_Pos;
+                    ++m_Pos;
+                    int kw = CheckKeyword(doc);
+                    m_Pos = tmpI;
+                    if(kw < NESTED_KEYWORDS_BEGIN && kw != NO_KEYWORD)
+                        return nestedArgsCount;
+                    else
+                    {
+                        output += doc[m_Pos];
+                        ++nestedArgsCount;
+                    }
+                }
+                ++m_Pos;
+                break;
+
+            default:
+                output += doc[m_Pos];
+                ++m_Pos;
+            }// switch
+
+        }// while
+        return nestedArgsCount;
+    }
+
+
+    bool DoxygenParser::IsKeywordBegin(const wxString& doc) const
+    {
+        bool isSpecial = doc[m_Pos] == _T('@') || doc[m_Pos] == _T('\\');
+
+        if(!isSpecial)
+            return false;
+        else if(m_Pos > 0)
+        {
+            bool isPrevWhitespace = doc[m_Pos - 1] == _T(' ') ||
+                doc[m_Pos - 1] == _T('\n') || doc[m_Pos - 1] == _T('\t');
+
+            return isPrevWhitespace;
+        }
+        else if(m_Pos == 0)
+        {
+            return true;
+        }
+        else
+            return false;
+    }
+
+    bool DoxygenParser::IsOneOf(wxChar c, const wxChar* chars) const
+    {
+        while(*chars)
+        {
+            if(c == *chars)
+                return true;
+            ++chars;
+        }
+        return false;
+    }
+
+    bool DoxygenParser::IsEnd(const wxString& doc) const
+    {
+        return m_Pos >= (int)doc.size();
+    }
+
+    int DoxygenParser::GetEndLine(const wxString& doc) const
+    {
+        size_t endLine = doc.find(_T('\n'), m_Pos);
+        if(endLine == wxString::npos)
+            endLine = doc.size();
+        return endLine;
+    }
+
+    bool DoxygenParser::SkipDecorations(const wxString& doc)
+    {
+        //ignore everything from beginig of line to first word
+        if(doc[m_Pos] != _T('\n'))
+            return false;
+        ++m_Pos;
+
+        while(!IsEnd(doc) && IsOneOf(doc[m_Pos], _T(" \t*/")))
+        {
+            ++m_Pos;
+        }
+        return true;
+    }
+    
+    bool DoxygenParser::HandleNewLine(const wxString& doc, wxString& output,
+                                      const wxString& replaceWith)
+    {
+        if(SkipDecorations(doc))
+        {
+            output += replaceWith;
+            return true;
+        }
+        return false;
+    }
+
+}// end of Doxygen namespace
+
+
+/* Unfocusable popup */
+
+// On OSX and (possibly others) there can still be pending
+// messages/events for the list control when Scintilla wants to
+// close it, so do a pending delete of it instead of destroying
+// immediately.
+bool UnfocusablePopupWindow::Destroy()
+{
+#ifdef __WXMAC__
+    // The bottom edge of this window is not getting properly
+    // refreshed upon deletion, so help it out...
+    wxWindow* p = GetParent();
+    wxRect r(GetPosition(), GetSize());
+    r.SetHeight(r.GetHeight()+1);
+    p->Refresh(false, &r);
+#endif
+    if ( !wxPendingDelete.Member(this) )
+        wxPendingDelete.Append(this);
+    return true;
+}
+
+void UnfocusablePopupWindow::OnFocus(wxFocusEvent& event)
+{
+    ActivateParent();
+    GetParent()->SetFocus();
+    event.Skip();
+}
+
+void UnfocusablePopupWindow::ActivateParent()
+{
+    // Although we're a frame, we always want the parent to be active, so
+    // raise it whenever we get shown, focused, etc.
+    wxTopLevelWindow *frame = wxDynamicCast(
+        wxGetTopLevelParent(GetParent()), wxTopLevelWindow);
+    if (frame)
+        frame->Raise();
+}
+
+void UnfocusablePopupWindow::DoSetSize(int x, int y,
+                       int width, int height,
+                       int sizeFlags)
+{
+    // convert coords to screen coords since we're a top-level window
+    if (x != wxDefaultCoord) {
+        GetParent()->ClientToScreen(&x, NULL);
+    }
+    if (y != wxDefaultCoord) {
+        GetParent()->ClientToScreen(NULL, &y);
+    }
+    BaseClass::DoSetSize(x, y, width, height, sizeFlags);
+}
+
+bool UnfocusablePopupWindow::Show(bool show)
+{
+    bool rv = BaseClass::Show(show);
+    if (rv && show)
+        ActivateParent();
+#ifdef __WXMAC__
+    GetParent()->Refresh(false);
+#endif
+    return rv;
+}
+
+BEGIN_EVENT_TABLE(UnfocusablePopupWindow, UnfocusablePopupWindow::BaseClass)
+    EVT_SET_FOCUS(UnfocusablePopupWindow::OnFocus)
+END_EVENT_TABLE()
+
+/* end of Unfocusable popup */
+
+
+// (shamelessly stolen from mime handler plugin ;) )
+// build all HTML font sizes (1..7) from the given base size
+static void wxBuildFontSizes(int *sizes, int size)
+{
+    // using a fixed factor (1.2, from CSS2) is a bad idea as explained at
+    // http://www.w3.org/TR/CSS21/fonts.html#font-size-props but this is by far
+    // simplest thing to do so still do it like this for now
+    sizes[0] = int(size * 0.75); // exception to 1.2 rule, otherwise too small
+    sizes[1] = int(size * 0.83);
+    sizes[2] = size;
+    sizes[3] = int(size * 1.2);
+    sizes[4] = int(size * 1.44);
+    sizes[5] = int(size * 1.73);
+    sizes[6] = int(size * 2);
+}
+
+// (shamelessly stolen from mime handler plugin ;) )
+static int wxGetDefaultHTMLFontSize()
+{
+    // base the default font size on the size of the default system font but
+    // also ensure that we have a font of reasonable size, otherwise small HTML
+    // fonts are unreadable
+    int size = wxNORMAL_FONT->GetPointSize();
+    if ( size < 9 )
+        size = 9;
+
+    return size;
+}
+
+/*Documentation Popup*/
+
+BEGIN_EVENT_TABLE(DocumentationHelper,DocumentationHelper::BaseClass)
+    EVT_HTML_LINK_CLICKED(wxID_ANY, DocumentationHelper::OnLink)
+END_EVENT_TABLE()
+
+namespace HTMLTags
+{
+    static const wxString br = _T("<br>");
+    static const wxString sep = _T(" ");
+    static const wxString b1 = _T("<b>");
+    static const wxString b0 = _T("</b>");
+
+    static const wxString a1 = _T("<a>");
+    static const wxString a0 = _T("</a>");
+
+    static const wxString i1 = _T("<i>");
+    static const wxString i0 = _T("</i>");
+    
+    static const wxString pre1 = _T("<pre>");
+    static const wxString pre0 = _T("</pre>");
+
+    static const wxString nbsp(_T("&nbsp;"));
+    static const wxString tab = nbsp + nbsp + nbsp;
+}
+
+/* DocumentationPopup static member functions implementation: */
+
+wxString DocumentationHelper::DoxygenToHTML(const wxString& doc)
+{
+    using namespace HTMLTags;
+    
+    wxString arguments[5];
+    wxString &plainText = arguments[0], brief = arguments[1], params = arguments[2],
+        seeAlso = arguments[3], returns = arguments[4];
+        
+    Doxygen::DoxygenParser parser;
+    int keyword = parser.FindNextKeyword(doc);
+    while(keyword < Doxygen::KEYWORDS_COUNT)
+    {
+        using namespace Doxygen;
+        switch(keyword)
+        {
+        case NO_KEYWORD:
+            parser.GetArgument(doc, RANGE_PARAGRAPH, plainText);
+            break;
+        case PARAM:
+            params += tab;
+            parser.GetArgument(doc, RANGE_PARAGRAPH, params);
+            params += br;
+            break;
+        case BRIEF:
+        case Doxygen::SHORT:
+            parser.GetArgument(doc, RANGE_PARAGRAPH, brief);
+            break;
+        case RETURN:
+        case RESULT:
+            parser.GetArgument(doc, RANGE_PARAGRAPH, returns);
+            break;
+        case SEE:
+        case SA:
+            parser.GetArgument(doc, RANGE_PARAGRAPH, seeAlso);
+            break;
+        case CODE:
+            plainText += pre1;
+            break;
+        case ENDCODE:
+            plainText += pre0;
+            break;
+        }
+        keyword = parser.FindNextKeyword(doc);
+    }
+    //process nested keywords:
+    for(size_t i = 0; i < (size_t)(sizeof(arguments)/sizeof(arguments[0])); ++i )
+    {
+        arguments[i].Trim(true).Trim(false);
+        
+        Doxygen::DoxygenParser parser;
+        int keyword = parser.FindNextKeyword(arguments[i]);
+        while(keyword < Doxygen::KEYWORDS_COUNT)
+        {
+            using namespace Doxygen;
+            switch(keyword)
+            {
+            case B:
+                {
+                    parser.ReplaceCurrentKeyword(arguments[i], b1);
+                    wxString arg0;
+                    parser.GetArgument(arguments[i], RANGE_WORD, arg0);
+                    arguments[i].insert(parser.GetPosition() + 1, b0);
+                }
+                break;
+            }
+            keyword = parser.FindNextKeyword(arguments[i]);
+        }
+    }// for (i)
+    
+    wxString html;
+    html.reserve(doc.size());
+    
+    if(brief.size() > 0)
+    {
+        html += b1 + brief + b0 + br;
+    }
+
+    if(params.size() > 0)
+    {
+        html += b1 + _T("Parameters:") + b0 + br + params;
+    }
+
+    if(returns.size() > 0)
+    {
+        html += b1 + _T("Returns:") + b0 + br + tab + returns + br;
+    }
+
+    if(plainText.size()>0)
+    {
+        plainText.Trim(false);
+        plainText.Trim(true);
+        html += b1 + _T("Description:") + b0 + br + tab;
+        plainText.Replace(_T("\n"), br + tab);
+        html += plainText + br;
+    }
+
+    if(seeAlso.size() > 0)
+    {
+        html += b1 + _T("See also: ") + b0;
+        wxStringTokenizer tokenizer(seeAlso,_T(" \n\t,;"));
+        while( tokenizer.HasMoreTokens() )
+        {
+            const wxString& tok = tokenizer.GetNextToken();
+            if(tok.size() > 0)
+                html += CommandToAnchor(cmdSearchAll, tok, &tok) + _T(" ");
+        }
+    }
+    
+    return html;
+}
+
+wxString DocumentationHelper::ConvertTypeToAnchor(wxString fullType)
+{
+    static Token ancestorChecker(_T(""), 0, 0, 0); // Because IsValidAncestor isn't static
+    const wxString& argType = ExtractTypeAndName(fullType);
+    if(!ancestorChecker.IsValidAncestor(argType))
+        return fullType;
+    size_t found = fullType.find(argType);
+    fullType.replace(found, argType.size(), CommandToAnchor(cmdSearch, argType, &argType) );
+    return fullType;
+}
+
+wxString DocumentationHelper::ConvertArgsToAnchors(wxString args)
+{
+    if(args.size() == 0)
+        return args;
+
+    //removes '(' and ')'
+    wxStringTokenizer tokenizer(args.SubString(1,args.find_last_of(_T(')'))-1), _T(","));
+    args.clear();
+    while(tokenizer.HasMoreTokens())
+    {
+        wxString tok = tokenizer.GetNextToken();
+        args += ConvertTypeToAnchor(tok);
+        if(tokenizer.HasMoreTokens())
+            args += _T(", ");
+    }
+    return _T('(') + args +_T(')');
+}
+
+//! \return type
+wxString DocumentationHelper::ExtractTypeAndName(wxString tok, wxString* outName)
+{
+    //remove default argument
+    size_t eqPos = tok.Find(_T('='));
+    if(eqPos != wxString::npos)
+    {
+        tok.resize(eqPos);
+    }
+
+    tok.Replace(_T("*"), _T(" "),true); //remove all '*'
+    tok.Replace(_T("&"), _T(" "),true); //remove all '&'
+    if(tok.GetChar(0) != _T(' ')){
+        tok.insert(0u, _T(" ")); //it will be easer to find " const " and " volatile "
+    }
+    //remove cv:
+    tok.Replace(_T(" const "), _T(" "),true);
+    tok.Replace(_T(" volatile "), _T(" "),true);
+    tok.Trim(true);
+    //tok.Trim(false);
+
+    wxString _outName;
+    if(!outName)
+        outName = &_outName;
+
+    static const wxString whitespace = _T(" \n\t");
+    size_t found = tok.find_last_of(whitespace);
+    if(found != wxString::npos)
+    {
+        // Argument have name _or_ type, if space was found
+        *outName = tok.SubString(found+1,tok.size());
+        tok.resize(found);  //remove name
+        tok.Trim(true);
+    }
+
+    found = tok.find_last_of(whitespace);
+    if(found != wxString::npos)
+    {
+        // Argument have name _and_ type
+        tok = tok.SubString(found+1,tok.size());
+        //tok.resize(found);
+        tok.Trim(true);
+    }
+    else
+    {
+        // Argument have only type
+        // so outName already have argument type.
+        tok.swap(*outName);
+        outName->clear();
+    }
+
+    tok.Trim(false);
+    return tok;
+}
+
+wxString DocumentationHelper::CommandToAnchor(Command cmd, const wxString& name,
+                                       const wxString* args)
+{
+    if(args)
+    {
+        return _T("<a href=\"") + commandTag + wxString::Format(_T("%i"), (int)cmd) +
+            separatorTag + *args + _T("\">") + name + _T("</a>");
+    }
+    else
+    {
+        return _T("<a href=\"") + commandTag + wxString::Format(_T("%i"), (int)cmd) +
+            _T("\">") + name + _T("</a>");
+    }
+}
+
+wxString DocumentationHelper::CommandToAnchorInt(Command cmd, const wxString& name, int arg0)
+{
+    const wxString& tmp = wxString::Format(_T("%i"),arg0);
+    return CommandToAnchor(cmd, name, &tmp);
+}
+
+DocumentationHelper::Command DocumentationHelper::HrefToCommand(const wxString& href, wxString& args)
+{
+    if(!href.StartsWith(commandTag, &args))
+        return cmdNone;
+    
+    size_t separator = args.rfind(separatorTag);
+    if(separator == wxString::npos)
+        separator = args.size() + 1;
+ 
+    long int command;
+    bool gotCommand = args.SubString(0,separator-1).ToLong(&command);
+    if(!gotCommand)
+        return cmdNone;
+        
+    if(separator + 1 < args.size())
+        args = args.SubString(separator+1, args.size());
+    else
+        args.clear();
+    
+    return (Command)(command);
+}
+
+wxString DocumentationHelper::ColorToHTMLString(wxColour col)
+{
+    return wxString::Format(_T("#%02x%02x%02x"), col.Red(), col.Green(), col.Blue());
+}
+
+wxColour DocumentationHelper::ColorFromHTMLString(const wxString& str, wxColour defCol)
+{
+    if(str.size() != 7)
+        return defCol;
+    if(str[0] != _T('#'))
+        return defCol;
+    unsigned long red, green, blue;
+    
+    wxString s2 = str.Mid(1,2); // First = 1, Count = 2
+    if(!s2.ToULong(&red,16))
+        return defCol;
+    
+    s2 = str.Mid(3,2); // First = 3
+    if(!s2.ToULong(&green,16))
+        return defCol;
+    
+    s2 = str.Mid(5,2); // First = 3
+    if(!s2.ToULong(&blue,16))
+        return defCol;
+        
+    return wxColour(red,green,blue, 0xff);
+}
+
+const wxChar   DocumentationHelper::separatorTag = _T('+');
+const wxString DocumentationHelper::commandTag = _T("cmd=");
+
+/* DocumentationPopup implementation: */
+DocumentationHelper::Options::Options() :
+    m_Enabled(false),
+    m_ShowAlways(false),
+    m_BackgroundColor(_T("#000000")),
+    m_TextColor(_T("#ffffff")),
+    m_LinkColor(_T("#0000ff"))
+{
+}
+
+DocumentationHelper::DocumentationHelper(CodeCompletion* cc) :
+    BaseClass(),
+    m_Popup(0),
+    m_Html(0),
+    m_CC(cc),
+    m_CurrentTokenIdx(-1),
+    m_LastTokenIdx(-1),
+    m_Pos(),
+    m_Size(),
+    m_Opts()
+{
+}
+
+DocumentationHelper::~DocumentationHelper()
+{
+}
+
+void DocumentationHelper::Hide()
+{
+    if(m_Popup && m_Popup->IsShown())
+    {
+        m_Popup->Hide();
+    }
+}
+
+void DocumentationHelper::OnAttach()
+{
+    // Dont attach if user dont want to use documentation helper and its already attached
+    if(!m_Opts.m_Enabled || IsAttached())
+        return;
+    
+    // register event sinks
+    Manager* pm = Manager::Get();
+
+    typedef cbEventFunctor<DocumentationHelper, CodeBlocksEvent> MyFunctor;
+    void (DocumentationHelper::* onEvent)(CodeBlocksEvent&) =
+        &DocumentationHelper::OnCbEventHide;
+
+    pm->RegisterEventSink(cbEVT_WORKSPACE_CHANGED,    new MyFunctor(this, onEvent));
+
+    pm->RegisterEventSink(cbEVT_PROJECT_ACTIVATE,     new MyFunctor(this, onEvent));
+    pm->RegisterEventSink(cbEVT_PROJECT_CLOSE,        new MyFunctor(this, onEvent));
+
+
+    pm->RegisterEventSink(cbEVT_EDITOR_ACTIVATED,     new MyFunctor(this, onEvent));
+    pm->RegisterEventSink(cbEVT_EDITOR_TOOLTIP,       new MyFunctor(this, onEvent));
+
+    m_Popup = new UnfocusablePopupWindow(pm->GetAppFrame());
+    m_Html = new wxHtmlWindow(m_Popup, wxID_ANY, wxDefaultPosition,
+                            wxSize(210,320),
+                            wxHW_SCROLLBAR_AUTO | wxBORDER_SIMPLE);
+    int sizes[7] = {};
+    wxBuildFontSizes(sizes, wxGetDefaultHTMLFontSize());
+    m_Html->SetFonts(wxEmptyString, wxEmptyString, &sizes[0]);
+    
+    m_Html->Connect(wxEVT_COMMAND_HTML_LINK_CLICKED,
+                        (wxObjectEventFunction)&DocumentationHelper::OnLink,
+                         NULL, this);
+    Hide();
+    
+    m_Popup->Layout();
+    m_Popup->Fit();
+}
+
+void DocumentationHelper::OnRelease()
+{
+    if(!IsAttached())
+        return;
+    
+    Manager::Get()->RemoveAllEventSinksFor(this);
+    
+    if(m_Html)
+        m_Html->Destroy();
+    m_Html = 0;
+    
+    if(m_Popup)
+        m_Popup->Destroy();
+    m_Popup = 0;
+}
+
+bool DocumentationHelper::ShowDocumentation(const wxString& html)
+{
+    if(!m_Opts.m_Enabled || !IsAttached() || html.size() == 0)
+    {
+        Hide();
+        return false;
+    }
+
+    m_Popup->Freeze();
+    ResetSize(m_Size);
+
+    m_Html->SetPage(html);
+    
+    FitToContent();
+
+    m_Popup->SetPosition(m_Pos);
+    m_Popup->Thaw();
+    m_Popup->Show();
+
+    return true;
+}
+    
+wxString DocumentationHelper::GenerateHTML(int tokenIdx, TokenTree* tree)
+{
+    //http://docs.wxwidgets.org/2.8/wx_wxhtml.html#htmltagssupported
+    
+    using namespace HTMLTags;
+
+    if(tokenIdx == -1)
+    {
+        return wxEmptyString;
+    }
+    
+    wxString html = _T("<html><body bgcolor=\"");
+    html += m_Opts.m_BackgroundColor + _T("\" text=\"");
+    html += m_Opts.m_TextColor + _T("\" link=\"");
+    html += m_Opts.m_LinkColor + _T("\">");
+    
+    html += _T("<a name=\"top\"></a>");
+    
+    CC_LOCKER_TRACK_TT_MTX_LOCK(s_TokenTreeMutex)
+    
+    Token* token = tree->at(tokenIdx);
+    if(!token || token->m_Name.IsEmpty())
+    {
+        CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
+        
+        return wxEmptyString;
+    }
+    wxString doxyDoc = tree->GetDocumentation(tokenIdx);
+    if(!m_Opts.m_ShowAlways)
+    {
+        if(doxyDoc.size() == 0)
+        {
+            CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
+        
+            return wxEmptyString;
+        }
+    }
+    
+    m_CurrentTokenIdx = token->m_Index;
+    
+    //add parent:
+    wxString tokenNs = token->GetNamespace();
+    if(tokenNs.size() > 0)
+    {
+        html += b1 + CommandToAnchorInt(cmdDisplayToken, tokenNs.RemoveLast(2), token->m_ParentIndex) + b0 + br;
+    }
+
+    html += br;
+
+    //add scope and name:
+    switch(token->m_TokenKind)
+    {
+    case tkFunction:
+        if(token->m_Scope != tsUndefined)
+            html += i1 + token->GetTokenScopeString() + i0 + sep;
+        html += ConvertTypeToAnchor(token->m_FullType) + sep + b1 + token->m_Name + b0;
+
+        html += ConvertArgsToAnchors(token->GetFormattedArgs());
+        if(token->m_IsConst)
+            html += _T(" const");
+        html += br;
+        break;
+    case tkPreprocessor:
+        html += b1 + token->m_Name + b0 + br + token->m_FullType + br;
+        break;
+
+    case tkVariable:
+        if(token->m_Scope != tsUndefined)
+            html += i1 + token->GetTokenScopeString() + i0 + sep;
+        html += ConvertTypeToAnchor(token->m_FullType) + sep + b1 + token->m_Name + b0 + br;
+        break;
+
+    default:
+        if(token->m_Scope != tsUndefined)
+            html += i1 + token->GetTokenScopeString() + i0 + sep;
+        html += token->m_FullType + sep + b1 + token->m_Name + b0 + br;
+    }
+
+    //add kind:
+    if(token->m_TokenKind != tkUndefined)
+        html += i1 + _T("<font color=\"green\" size=3>") + _T("(") +
+            token->GetTokenKindString() +_T(")") + _T("</font>") + i0 + br;
+    
+    html += DoxygenToHTML(doxyDoc);
+
+    //add go to declaration / implementation
+    {
+        const wxString& arg0 = wxString::Format(_T("%i"), token->m_Index);
+        
+        html += br + br + CommandToAnchor(cmdOpenDecl, _T("Open declatarion"), &arg0);
+        if((token->m_TokenKind & tkAnyFunction) && token->m_ImplLine > 0)
+        {
+            html += br + CommandToAnchor(cmdOpenImpl, _T("Open implementation"), &arg0);
+        }
+    }
+
+    //add details:
+    switch(token->m_TokenKind)
+    {
+        case tkClass:
+            html += br + b1 + _T("Members:") + b0;
+            for( TokenIdxSet::iterator it = token->m_Children.begin(); it != token->m_Children.end(); ++it)
+            {
+                const Token* t2 = tree->at(*it);
+                if(t2 && !t2->m_Name.IsEmpty())
+                {
+                    html += br + sep + CommandToAnchorInt(cmdDisplayToken, t2->m_Name, *it) + 
+                        t2->GetStrippedArgs() + _T(": ") + t2->m_FullType;
+                }
+            }
+            break;
+
+        case tkEnum:
+            html += br + b1 + _T("Values:") + b0;
+            for( TokenIdxSet::iterator it = token->m_Children.begin(); it != token->m_Children.end(); ++it)
+            {
+                const Token* t2 = tree->at(*it);
+                if(t2 && !t2->m_Name.IsEmpty())
+                {
+                    html += br + sep + CommandToAnchorInt(cmdDisplayToken, t2->m_Name, *it);
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    
+    CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
+    
+    html += br + br;
+
+    //Append 'back' link:
+    if(m_LastTokenIdx >= 0)
+        html += CommandToAnchorInt(cmdDisplayToken, _T("Back"), m_LastTokenIdx);
+
+    //Append 'close' link:
+    html += _T(" ") + CommandToAnchor(cmdClose, _T("Close"));
+    html += _T(" <a href=\"#top\">Top</a> ");
+
+    html += _T("</body></html>");
+    
+    return html;
+}
+    
+wxString DocumentationHelper::GenerateHTML(const TokenIdxSet& tokensIdx, TokenTree* tree)
+{
+    using namespace HTMLTags;
+    
+    if(tokensIdx.size() == 0)
+    {
+        Hide();
+        return wxEmptyString;
+    }
+        
+    if(tokensIdx.size() == 1)
+        return GenerateHTML(*tokensIdx.begin(),tree);
+        
+    wxString html = _T("<html><body bgcolor=\"");
+    html += m_Opts.m_BackgroundColor + _T("\" text=\"");
+    html += m_Opts.m_TextColor + _T("\" link=\"");
+    html += m_Opts.m_LinkColor + _T("\">");
+    
+    html += _T("<a name=\"top\"></a>");
+    
+    html += _T("Multiple matches, please select one:<br>");
+    TokenIdxSet::const_iterator it = tokensIdx.begin();
+    
+    CC_LOCKER_TRACK_TT_MTX_LOCK(s_TokenTreeMutex)
+    
+    while(it != tokensIdx.end())
+    {
+        const Token* token = tree->at(*it);
+
+        html += token->GetNamespace() + CommandToAnchorInt(cmdDisplayToken, token->m_Name, token->m_Index);
+        html += nbsp + nbsp + token->GetTokenKindString();
+        html += _T("<br>");
+
+        ++it;
+    }
+
+    CC_LOCKER_TRACK_TT_MTX_UNLOCK(s_TokenTreeMutex)
+
+    html += _T("<br>");
+
+    //Append 'back' link:
+    if(m_LastTokenIdx >= 0)
+        html += CommandToAnchorInt(cmdDisplayToken, _T("Back"), m_LastTokenIdx);
+    
+
+    //Append 'close' link:
+    html += _T(" ") + CommandToAnchor(cmdClose, _T("Close"));
+    html += _T(" <a href=\"#top\">Top</a> ");
+
+    html += _T("</body></html>");
+    
+    return html;
+}
+
+void DocumentationHelper::OnSelectionChange(wxListEvent& event)
+{
+    event.Skip();
+    if(!m_Opts.m_Enabled)
+        return;
+    
+    wxObject* evtObj = event.GetEventObject();
+    
+    if(evtObj && ((wxWindow*)evtObj)->GetParent())
+    {
+        wxWindow* evtWin = ((wxWindow*)evtObj)->GetParent();
+        if(!m_Popup->IsShown())
+        {
+            evtWin->Connect(wxID_ANY, wxEVT_SHOW,
+                            (wxObjectEventFunction)&DocumentationHelper::OnWxEventHide,
+                            NULL, this);
+            
+            m_Pos = m_Popup->GetParent()->ScreenToClient(evtWin->GetScreenPosition());
+            m_Pos.x += evtWin->GetSize().x;
+        
+            cbEditor* editor = Manager::Get()->GetEditorManager()->GetBuiltinActiveEditor();
+            cbStyledTextCtrl* control = editor->GetControl();
+            int acMaxHeight = control->AutoCompGetMaxHeight()+1;
+            int textHeight = control->TextHeight(control->GetCurrentLine());
+            wxRect edRect = editor->GetRect();
+            
+            m_Size.x = edRect.width * 5/12;
+            m_Size.y = acMaxHeight*textHeight;
+        }
+        
+        int tokenIdx = m_CC->GetAutocompTokenIdx();
+        TokenTree* tree = m_CC->m_NativeParser.GetParser().GetTokenTree();
+
+        ShowDocumentation(GenerateHTML(tokenIdx, tree));
+    }
+}
+
+void DocumentationHelper::ResetSize(const wxSize& size)
+{
+    const wxSize& cliSize = size;
+    m_Html->SetMaxSize(cliSize);
+    m_Html->SetClientSize(cliSize);
+}
+
+bool DocumentationHelper::IsAttached() const
+{
+    return m_Popup && m_Html;
+}
+
+bool DocumentationHelper::IsVisible() const
+{
+    return IsAttached() && m_Popup->IsShown();
+}
+
+void DocumentationHelper::RereadOptions(ConfigManager* cfg)
+{
+    if(!cfg)
+        cfg = Manager::Get()->GetConfigManager(_T("code_completion"));
+    
+    m_Opts.m_Enabled = cfg->ReadBool(_T("/use_documentation_helper"), false);
+    m_Opts.m_ShowAlways = cfg->ReadBool(_T("/always_show_doc"), false);
+    
+    wxColour col = cfg->ReadColour(_T("/documentation_helper_background_color"), *wxWHITE);
+    m_Opts.m_BackgroundColor = ColorToHTMLString(col);
+    
+    col = cfg->ReadColour(_T("/documentation_helper_text_color"), *wxBLACK);
+    m_Opts.m_TextColor = ColorToHTMLString(col);
+    
+    col = cfg->ReadColour(_T("/documentation_helper_link_color"), *wxBLUE);
+    m_Opts.m_LinkColor = ColorToHTMLString(col);
+    
+    // Apply changes
+    if(m_Opts.m_Enabled)
+        OnAttach();
+    else
+        OnRelease();
+}
+
+void DocumentationHelper::WriteOptions(ConfigManager* cfg)
+{
+    if(!cfg)
+        cfg = Manager::Get()->GetConfigManager(_T("code_completion"));
+        
+    cfg->Write(_T("/use_documentation_helper"), m_Opts.m_Enabled);
+    cfg->Write(_T("/always_show_doc"), m_Opts.m_ShowAlways);
+    
+    cfg->Write(_T("/documentation_helper_background_color"), ColorFromHTMLString(m_Opts.m_BackgroundColor, *wxWHITE));
+    cfg->Write(_T("/documentation_helper_text_color"), ColorFromHTMLString(m_Opts.m_TextColor, *wxBLACK));
+    cfg->Write(_T("/documentation_helper_link_color"), ColorFromHTMLString(m_Opts.m_LinkColor, *wxBLUE));
+}
+
+void DocumentationHelper::FitToContent()
+{
+    m_Popup->Layout();
+    m_Popup->Fit();
+}
+
+void DocumentationHelper::SaveTokenIdx()
+{
+    m_LastTokenIdx = m_CurrentTokenIdx;
+}
+
+//events:
+void DocumentationHelper::OnCbEventHide(CodeBlocksEvent& event)
+{
+    event.Skip();
+    m_Popup->Hide();
+}
+
+void DocumentationHelper::OnWxEventHide(wxEvent& event)
+{
+    event.Skip();
+    Hide();
+    
+    wxObject* evtObj = event.GetEventObject();
+    if(evtObj)
+    {
+        wxWindow* evtWin = (wxWindow*)(evtObj);
+        evtWin->Disconnect(wxID_ANY, wxEVT_SHOW,
+                        (wxObjectEventFunction)&DocumentationHelper::OnWxEventHide,
+                        NULL, this);
+    }
+}
+
+void DocumentationHelper::OnLink(wxHtmlLinkEvent& event)
+{
+    TokenTree* tree = m_CC->m_NativeParser.GetParser().GetTokenTree();
+
+    const wxString& href = event.GetLinkInfo().GetHref();
+    wxString args;
+    long int  tokenIdx;
+    
+    Command command = HrefToCommand(href,args);
+    switch(command)
+    {
+    case cmdDisplayToken:
+        if(args.ToLong(&tokenIdx))
+        {
+            SaveTokenIdx();
+            ShowDocumentation(GenerateHTML(tokenIdx, tree));
+        }
+        break;
+    case cmdSearch:
+    case cmdSearchAll:
+        {
+            size_t opb = args.find_last_of(_T('('));
+            size_t clb = args.find_last_of(_T(')'));
+            int kindToSearch = tkUndefined;
+            if(opb != wxString::npos && clb != wxString::npos)
+            {
+                args = args.Truncate(opb);
+                kindToSearch = tkAnyFunction|tkPreprocessor;
+            }
+
+            TokenIdxSet result;
+            size_t scpOp = args.rfind(_T("::"));
+            if(scpOp != wxString::npos)
+            {
+                //it may be function
+                tree->FindMatches(args.SubString(scpOp+2,args.size()), result,
+                                   true, false,
+                                   TokenKind(kindToSearch));
+            }
+            else if (command == cmdSearchAll)
+            {
+                tree->FindMatches(args, result,
+                                   true, false,
+                                   TokenKind(kindToSearch));
+            }
+            else
+            {
+                tree->FindMatches(args, result, true, false, TokenKind(tkAnyContainer|tkEnum));
+            }
+
+            if(result.size() > 0)
+            {
+                SaveTokenIdx();
+                ShowDocumentation(GenerateHTML(result, tree));
+            }
+        }
+        break;
+    case cmdOpenDecl:
+        if(args.ToLong(&tokenIdx))
+        {
+            EditorManager* edMan = Manager::Get()->GetEditorManager();
+            const Token* token = tree->at(tokenIdx);
+            cbEditor* targetEditor = edMan->Open(token->GetFilename());
+            if (targetEditor)
+                targetEditor->GotoTokenPosition(token->m_Line - 1, token->m_Name);
+        }
+    case cmdOpenImpl:
+        if(args.ToLong(&tokenIdx))
+        {
+            EditorManager* edMan = Manager::Get()->GetEditorManager();
+            const Token* token = tree->at(tokenIdx);
+            cbEditor* targetEditor = edMan->Open(token->GetImplFilename());
+            if (targetEditor)
+                targetEditor->GotoTokenPosition(token->m_ImplLine - 1, token->m_Name);
+        }
+        break;
+    case cmdClose:
+        m_Popup->Hide();
+        break;
+        
+    case cmdNone:
+    default:
+        if(href.size() > 1 && href[0] == _T('#'))
+        {
+            event.Skip(); //go to anchor
+        }
+        else if(href.StartsWith(_T("www.")) || href.StartsWith(_T("http://")))
+        {
+            wxLaunchDefaultBrowser(href);
+        }
+    }
+    
+    // Dont skip this event
+}
+
+//end of Documentation popup functions
Index: src/plugins/codecompletion/doxygen_parser.h
===================================================================
--- src/plugins/codecompletion/doxygen_parser.h	(wersja 0)
+++ src/plugins/codecompletion/doxygen_parser.h	(kopia robocza)
@@ -0,0 +1,283 @@
+/*
+ * This file is part of the Code::Blocks IDE and licensed under the GNU General Public License, version 3
+ * http://www.gnu.org/licenses/gpl-3.0.html
+ */
+
+#ifndef DOXYGENPARSER_H
+#define DOXYGENPARSER_H
+
+#include <set>
+
+#if wxUSE_POPUPWIN 
+#include <wx/popupwin.h>
+#else
+#include <wx/frame.h>
+#endif // wxUSE_POPUPWIN
+
+typedef std::set< int,    std::less<int>    > TokenIdxSet;
+
+class CodeCompletion;
+class Token;
+class TokenTree;
+//class TokenIdxSet;
+class wxHtmlLinkEvent;
+class wxHtmlWindow;
+class wxPopupWindow;
+
+namespace Doxygen
+{
+    enum KeywordsIds
+    {
+        NO_KEYWORD,
+        
+        PARAM,
+        RETURN, RESULT,
+        BRIEF, SHORT,
+        SA, SEE,
+        
+        // structural keywords:
+        CLASS, STRUCT,
+        UNION,
+        ENUM,
+        NAMESPACE,
+        
+        FN,
+        VAR,
+        DEF,
+        
+        // some other keywords:
+        CODE,
+        ENDCODE,
+        
+        NESTED_KEYWORDS_BEGIN,
+        
+        B = NESTED_KEYWORDS_BEGIN,
+        
+        KEYWORDS_COUNT // Always at end
+    };
+    
+    enum KeywordsRanges
+    {
+        RANGE_UNKNOWN,
+        RANGE_PARAGRAPH,
+        RANGE_BLOCK,
+        RANGE_LINE,
+        RANGE_WORD,
+    };
+
+    
+    struct DoxygenParser
+    {
+        static const wxString Keywords[];
+        
+        static const int KwCount;
+        
+        static const wxString NewLineReplacment;
+        
+        
+        DoxygenParser();
+        
+        int FindNextKeyword(const wxString& doc);
+        
+        int GetArgument(const wxString& doc, int range, wxString& output);
+        
+        int GetPosition() const;
+        
+        void ReplaceInDoc(wxString& doc, size_t start, size_t count, const wxString& str);
+        
+        void ReplaceCurrentKeyword(wxString& doc, const wxString& str);
+        
+    protected:
+        
+        int CheckKeyword(const wxString& doc);
+        
+        int GetParagraphArgument(const wxString& doc, wxString& output);
+        
+        void GetWordArgument(const wxString& doc, wxString& output);
+        
+        void GetBlockArgument(const wxString& doc, wxString& output);
+        
+        int GetLineArgument(const wxString& doc, wxString& output);
+            
+        
+        bool IsKeywordBegin(const wxString& doc) const;
+        
+        bool IsOneOf(wxChar c, const wxChar* chars) const;
+        
+    protected:
+        
+        bool IsEnd(const wxString& doc) const;
+        
+        int GetEndLine(const wxString& doc) const;
+        
+        //! \return true if m_Pos has changed
+        bool SkipDecorations(const wxString& doc);
+        
+        //! \return true if m_Pos has changed
+        bool HandleNewLine(const wxString& doc, wxString& output, const wxString& replaceWith = NewLineReplacment);
+
+
+        int m_FoundKw;   // index to Keywors array
+        int m_Pos;          // index to doc
+    };
+
+}//namespace Doxygen
+
+
+//imported with small changes from PlatWX.cpp
+class UnfocusablePopupWindow :
+#if wxUSE_POPUPWIN
+    public wxPopupWindow
+{
+public:
+    typedef wxPopupWindow BaseClass;
+    
+    UnfocusablePopupWindow(wxWindow* parent, int style = wxBORDER_NONE) :
+        wxPopupWindow(parent, style)
+#else
+     public wxFrame
+{
+public:
+    typedef wxFrame BaseClass;
+    
+    UnfocusablePopupWindow(wxWindow* parent, int style = 0) :
+        wxFrame(parent, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize,
+                style | wxFRAME_NO_TASKBAR | wxFRAME_FLOAT_ON_PARENT | wxNO_BORDER | wxFRAME_SHAPED
+#ifdef __WXMAC__
+                | wxPOPUP_WINDOW
+#endif
+            )
+#endif // wxUSE_POPUPWIN            
+    {
+        Hide();
+    }
+
+    bool Destroy();
+
+    void OnFocus(wxFocusEvent& event);
+
+    void ActivateParent();
+
+    virtual void DoSetSize(int x, int y, int width, int height, int sizeFlags = wxSIZE_AUTO);
+
+    virtual bool Show(bool show = true);
+
+private:
+    DECLARE_EVENT_TABLE()
+};
+
+
+class DocumentationHelper : public wxEvtHandler
+{
+    typedef wxEvtHandler BaseClass;
+    
+public:
+    enum Command
+    {
+        cmdNone,
+        cmdDisplayToken,    //args: token index
+        cmdSearch,          //args: token name
+        cmdSearchAll,       //args: token name
+        cmdOpenDecl,        //args: token index
+        cmdOpenImpl,        //args: token index
+        cmdClose,           //args: -----
+    };
+    
+    //helper functions:
+    static wxString DoxygenToHTML(const wxString& doc);
+
+    static wxString ConvertTypeToAnchor(wxString fullType);
+    
+    static wxString ConvertArgsToAnchors(wxString args);
+    
+    /*! returns argument base type */
+    static wxString ExtractTypeAndName(wxString type, wxString* outName = 0);
+    
+    static wxString CommandToAnchor(Command cmd, const wxString& name, const wxString* args = 0);
+    
+    static wxString CommandToAnchorInt(Command cmd, const wxString& name, int arg0);
+    
+    static Command HrefToCommand(const wxString& href, wxString& args);
+    
+    static wxString ColorToHTMLString(wxColour col);
+    
+    static wxColour ColorFromHTMLString(const wxString& str, wxColour defCol);
+    
+    static const wxChar   separatorTag;
+    static const wxString commandTag;
+
+    struct Options
+    {
+        Options();
+        bool m_Enabled;
+        bool m_ShowAlways;
+        wxString m_BackgroundColor;
+        wxString m_TextColor;
+        wxString m_LinkColor;
+    };
+    
+    DocumentationHelper(CodeCompletion* cc);
+    
+    ~DocumentationHelper();
+
+    void Hide();
+    
+    void OnAttach();
+    
+    void OnRelease();
+
+    bool ShowDocumentation(const wxString& html);
+    
+    wxString GenerateHTML(int tokenIdx, TokenTree* tree);
+    
+    wxString GenerateHTML(const TokenIdxSet& tokensIdx, TokenTree* tree);
+    
+    void OnSelectionChange(wxListEvent& event);
+    
+    void ResetSize(const wxSize& size);
+    
+    bool IsAttached() const;
+    
+    bool IsVisible() const;
+    
+    void RereadOptions(ConfigManager* cfg);
+    
+    void WriteOptions(ConfigManager* cfg);
+    
+    Options& Options() { return m_Opts; }
+    
+protected:
+    void SaveTokenIdx();
+    
+    void FitToContent();
+    
+    //events:
+    void OnCbEventHide(CodeBlocksEvent& event);
+    
+    void OnWxEventHide(wxEvent& event);
+
+public:    
+    void OnLink(wxHtmlLinkEvent& event);
+
+    /*Members:*/
+protected:
+    UnfocusablePopupWindow* m_Popup;
+    
+    wxHtmlWindow* m_Html;
+    
+    /** Pointer to CodeComplete object */
+    CodeCompletion* m_CC;
+    
+    /** Documentation of which token was previously displayed */
+    int m_CurrentTokenIdx, m_LastTokenIdx;
+
+    wxPoint     m_Pos;
+    wxSize      m_Size;
+    
+    // User options
+    class Options m_Opts;
+
+    DECLARE_EVENT_TABLE()
+};
+
+#endif //DOXYGENPARSER_H
Index: src/plugins/codecompletion/parser/parser.cpp
===================================================================
--- src/plugins/codecompletion/parser/parser.cpp	(wersja 8785)
+++ src/plugins/codecompletion/parser/parser.cpp	(kopia robocza)
@@ -202,6 +202,9 @@
     // Token tree
     m_BrowserOptions.displayFilter   = (BrowserDisplayFilter)cfg->ReadInt(_T("/browser_display_filter"), bdfFile);
     m_BrowserOptions.sortType        = (BrowserSortType)cfg->ReadInt(_T("/browser_sort_type"),           bstKind);
+    
+    // Page "Documentation:
+    m_Options.storeDocumentation     = cfg->ReadBool(_T("/use_documentation_helper"),         false);
 
     // force e-read of file types
     ParserCommon::EFileType ft_dummy = ParserCommon::FileType(wxEmptyString, true);
@@ -231,6 +234,9 @@
     // Token tree
     cfg->Write(_T("/browser_display_filter"),        m_BrowserOptions.displayFilter);
     cfg->Write(_T("/browser_sort_type"),             m_BrowserOptions.sortType);
+    
+    // Page "Documentation:
+    // m_Options.storeDocumentation will be written by DocumentationPopup
 }
 
 void ParserBase::AddIncludeDir(const wxString& dir)
@@ -550,6 +556,8 @@
     opts.wantPreprocessor      = m_Options.wantPreprocessor;
     opts.parseComplexMacros    = m_Options.parseComplexMacros;
 
+    opts.storeDocumentation    = m_Options.storeDocumentation;
+
     opts.loader                = loader; // maybe 0 at this point
 
     bool result = false;
@@ -671,6 +679,8 @@
     opts.parseComplexMacros   = false;
 
     opts.handleFunctions      = false;
+    
+    opts.storeDocumentation    = m_Options.storeDocumentation;
 
     ParserThread thread(this, buffer, isLocal, opts, m_TokenTree);
 
@@ -696,6 +706,8 @@
     opts.parseComplexMacros   = m_Options.parseComplexMacros;
 
     opts.handleFunctions      = true;
+    
+    opts.storeDocumentation    = m_Options.storeDocumentation;
 
     ParserThread thread(this, buffer, false, opts, m_TempTokenTree);
 
@@ -718,6 +730,8 @@
     opts.followGlobalIncludes = false;
     opts.wantPreprocessor     = m_Options.wantPreprocessor;
     opts.parseComplexMacros   = false;
+    
+    opts.storeDocumentation    = m_Options.storeDocumentation;
 
     ParserThread thread(this, wxEmptyString, true, opts, m_TempTokenTree);
 
@@ -740,6 +754,8 @@
     opts.followGlobalIncludes = false;
     opts.wantPreprocessor     = m_Options.wantPreprocessor;
     opts.parseComplexMacros   = false;
+    
+    opts.storeDocumentation    = m_Options.storeDocumentation;
 
     ParserThread thread(this, wxEmptyString, false, opts, m_TempTokenTree);
 
Index: src/plugins/codecompletion/parser/parser.h
===================================================================
--- src/plugins/codecompletion/parser/parser.h	(wersja 8785)
+++ src/plugins/codecompletion/parser/parser.h	(kopia robocza)
@@ -90,6 +90,7 @@
     bool useSmartSense;        /// use real AI(scope sequence match) or not(plain text match)
     bool whileTyping;          /// reparse the active editor while editing
     bool parseComplexMacros;   /// this will let the Tokenizer to recursive expand macros
+    bool storeDocumentation;   /// should tokenizer detect and store doxygen documentation?
 };
 
 /** specify the scope of the shown symbols */
Index: src/plugins/codecompletion/parser/parserthread.cpp
===================================================================
--- src/plugins/codecompletion/parser/parserthread.cpp	(wersja 8785)
+++ src/plugins/codecompletion/parser/parserthread.cpp	(kopia robocza)
@@ -197,7 +197,8 @@
     m_IsBuffer(parserThreadOptions.useBuffer),
     m_Buffer(bufferOrFilename)
 {
-    m_Tokenizer.SetTokenizerOption(parserThreadOptions.wantPreprocessor);
+    m_Tokenizer.SetTokenizerOption(parserThreadOptions.wantPreprocessor,
+                                   parserThreadOptions.storeDocumentation);
     if (!m_TokenTree)
         cbThrow(_T("m_TokenTree is a nullptr?!"));
 }
Index: src/plugins/codecompletion/parser/parserthread.h
===================================================================
--- src/plugins/codecompletion/parser/parserthread.h	(wersja 8785)
+++ src/plugins/codecompletion/parser/parserthread.h	(kopia robocza)
@@ -59,6 +59,8 @@
         handleEnums(true),
         handleTypedefs(true),
 
+        storeDocumentation(false),
+        
         loader(nullptr)
         {}
 
@@ -84,6 +86,8 @@
     bool        handleClasses;
     bool        handleEnums;
     bool        handleTypedefs;
+    
+    bool        storeDocumentation;
 
     LoaderBase* loader; // if not NULL, load through filemanager (using threads)
 };
Index: src/plugins/codecompletion/parser/tokenizer.cpp
===================================================================
--- src/plugins/codecompletion/parser/tokenizer.cpp	(wersja 8785)
+++ src/plugins/codecompletion/parser/tokenizer.cpp	(kopia robocza)
@@ -109,6 +109,7 @@
     m_RepeatReplaceCount(0)
 {
     m_TokenizerOptions.wantPreprocessor = true;
+    m_TokenizerOptions.storeDocumentation = true;
 
     if (!m_Filename.IsEmpty())
         Init(m_Filename);
@@ -159,7 +160,9 @@
     }
 
     while (m_Filename.Replace(_T("\\"),_T("/"))) { ; }
-
+    
+    m_FileIdx = m_TokenTree->GetFileIndex(m_Filename);
+    
     m_IsOK = true;
     return true;
 }
@@ -900,31 +903,131 @@
     else
         return false;     // Not a comment, return false;
 
+    MoveToNextChar(2);    // Skip the comment prompt
+    
+    bool isDoc = false;
+    if(m_TokenizerOptions.storeDocumentation)
+    {
+        isDoc = (CurrentChar() == '!');	//	"/*!" or "//!"
+        
+        if(!isDoc && cstyle)
+        {//  "/*" + ?
+            isDoc = (CurrentChar() == '*' && NextChar() != '/');		//	"/**" but not "/**/" and not //*
+        }
+        if(!isDoc && !cstyle)
+        {// "//" + ?
+            isDoc = (CurrentChar() == '/'); // "///"
+        }   
+    }
+    
     TRACE(_T("SkipComment() : Start from line = %u"), m_LineNumber);
-    MoveToNextChar(2);    // Skip the comment prompt
 
-    // Here, we are in the comment body
-    while (true)
+    if(!isDoc)
     {
-        if (cstyle)      // C style comment
+        // Here, we are in the comment body
+        while (true)
         {
-            SkipToChar('/');
-            if (PreviousChar() == '*') // end of a C style comment
+            if (cstyle)      // C style comment
             {
-                MoveToNextChar();
+                SkipToChar('/');
+                if (PreviousChar() == '*') // end of a C style comment
+                {
+                    MoveToNextChar();
+                    break;
+                }
+                if (!MoveToNextChar())
+                    break;
+            }
+            else             // C++ style comment
+            {
+                TRACE(_T("SkipComment() : Need to call SkipToInlineCommentEnd() here at line = %u"), m_LineNumber);
+                SkipToInlineCommentEnd();
                 break;
             }
-            if (!MoveToNextChar())
-                break;
         }
-        else             // C++ style comment
+    }
+    else
+    {
+        //Inside documentation body
+        wxString doc;
+        MoveToNextChar();    // Skip '!' or '*' or '/'
+        wxChar c = CurrentChar();
+        
+        int lineToAppend = -1;
+        
+        if(c == _T('<'))
+        {//documentation for already added token - //!< or /*!< or something like this
+            MoveToNextChar();
+            c = CurrentChar();
+            lineToAppend = m_LineNumber;
+        }
+        
+        if(cstyle)
         {
-            TRACE(_T("SkipComment() : Need to call SkipToInlineCommentEnd() here at line = %u"), m_LineNumber);
-            SkipToInlineCommentEnd();
-            break;
+            while(true)
+            {
+                c = CurrentChar();
+                if(c == '*' && NextChar() == '/') //End of block comment
+                {
+                    MoveToNextChar(2); //eat '/'
+                    break;
+                }
+                else
+                {
+                    doc += c; //Appending char by char may be slow 
+                    if(!MoveToNextChar())
+                        break;
+                }
+            }
         }
+        else	// C++ style comment
+        {
+            while(true)
+            {
+                c = CurrentChar();
+                if(c == '\n' && !IsBackslashBeforeEOL())
+                {
+                    MoveToNextChar();
+                    break;
+                }
+                else
+                {
+                    doc += c;
+                    if(!MoveToNextChar())
+                        break;
+                }
+            }
+        }
+        
+        if(doc.size()>0) //dont push empty strings
+        {
+            doc += _T('\n');
+        
+            if(lineToAppend >= 0)
+            {
+                m_TokenTree->AppendDocumentation(m_FileIdx, lineToAppend, doc);
+            }
+            else
+            {
+                // Find next token's line:
+                // At first skip whitespace
+                while(SkipWhiteSpace())
+                    ;
+                // Maybe there is another coment?
+                // Recursive call
+                bool skipped = SkipComment();
+                
+                //!
+                /*!
+                */
+                if(!cstyle && skipped)
+                    doc = _T("@brief ") + doc + _T('\n');
+            
+                m_TokenTree->PrependDocumentation(m_FileIdx, m_LineNumber, doc);
+            }
+        }
+        
     }
-
     return true;
 }
 
Index: src/plugins/codecompletion/parser/tokenizer.h
===================================================================
--- src/plugins/codecompletion/parser/tokenizer.h	(wersja 8785)
+++ src/plugins/codecompletion/parser/tokenizer.h	(kopia robocza)
@@ -79,6 +79,7 @@
 struct TokenizerOptions
 {
     bool wantPreprocessor;
+    bool storeDocumentation;
 };
 
 /** @brief This is just a simple lexer class
@@ -121,9 +122,10 @@
     void     UngetToken();
 
     /** Handle condition preprocessor or not */
-    void SetTokenizerOption(bool wantPreprocessor)
+    void SetTokenizerOption(bool wantPreprocessor, bool storeDocumentation)
     {
         m_TokenizerOptions.wantPreprocessor = wantPreprocessor;
+        m_TokenizerOptions.storeDocumentation = storeDocumentation;
     };
 
     /** Set the Tokenizer skipping options. E.g. sometimes, we need to skip the statement after "=",
@@ -426,6 +428,8 @@
 
     /** Filename of the buffer */
     wxString             m_Filename;
+    /** File index, useful when parsing documentation; \sa SkipComment */
+    int                  m_FileIdx;
     /** Buffer content, all the lexical analysis is done on this */
     wxString             m_Buffer;
     /** Buffer length */
Index: src/plugins/codecompletion/parser/tokentree.cpp
===================================================================
--- src/plugins/codecompletion/parser/tokentree.cpp	(wersja 8785)
+++ src/plugins/codecompletion/parser/tokentree.cpp	(kopia robocza)
@@ -46,6 +46,84 @@
     #define TRACE2(format, args...)
 #endif
 
+namespace TokenTreeHelper
+{
+    int HashFileIdxAndLineNo(int fileIdx, int lineNo)
+    {
+        // It supports 2^13 files with maximum 2^19 lines in each.
+        // In bigger projects hash value may be not unique
+        return lineNo | (fileIdx << 19);
+    }
+    
+    static bool CompareArgumentType(wxString left, wxString right)
+    {
+        wxStringTokenizer lTokenizer (left, _T(" "));
+        wxStringTokenizer rTokenizer (right, _T(" "));
+        
+        int lSpacesCount = lTokenizer.CountTokens();
+        int rSpacesCount = rTokenizer.CountTokens();
+        
+        if(lSpacesCount == rSpacesCount)
+        {
+            while(lTokenizer.HasMoreTokens())
+            {
+                if(lTokenizer.GetNextToken() != rTokenizer.GetNextToken())
+                    return false;
+            }
+            return true;
+        }
+        else if(lSpacesCount < rSpacesCount)
+        {
+            if(rSpacesCount - lSpacesCount > 1 || lSpacesCount == 0)
+                return false;
+            
+            //left argument may doesn't have name
+            while(lTokenizer.HasMoreTokens())
+            {
+                if(lTokenizer.GetNextToken() != rTokenizer.GetNextToken())
+                    return false;
+            }
+            return true;
+        }
+        else if(lSpacesCount > rSpacesCount)
+        {
+            if(lSpacesCount - rSpacesCount > 1 || rSpacesCount == 0)
+                return false;
+            
+            //right argument may doesn't have name
+            while(rTokenizer.HasMoreTokens())
+            {
+                if(rTokenizer.GetNextToken() != lTokenizer.GetNextToken())
+                    return false;
+            }
+            return true;
+        }
+    }
+    
+    static bool CompareBaseArguments(const wxString& left, const wxString& right)
+    {
+        if(left == right) // No args, or exactly same names
+            return true;
+        
+        // tokenize strings without parentheses:
+        wxStringTokenizer lTokenizer(left.Mid(1, left.size()-1), _T(","));
+        wxStringTokenizer rTokenizer(right.Mid(1, right.size()-1), _T(","));
+        
+        if(lTokenizer.CountTokens() != rTokenizer.CountTokens())
+            return false;
+        
+        while(lTokenizer.HasMoreTokens())
+        {
+            wxString lTok = lTokenizer.GetNextToken();
+            wxString rTok = rTokenizer.GetNextToken();
+            if(!CompareArgumentType(lTok,rTok))
+                return false;
+        }
+        
+        return true;
+    }
+}
+
 wxMutex s_TokenTreeMutex;
 
 TokenTree::TokenTree() :
@@ -95,6 +173,8 @@
             delete token;
     }
     m_Tokens.clear();
+    
+    m_TokenDocumentationMap.clear();
 }
 
 size_t TokenTree::size()
@@ -382,7 +463,18 @@
         m_TopNameSpaces.erase(idx);
     }
 
-    // Step 6: Finally, remove it from the list.
+    // Step 6: Delete documentation associated with removed token
+    
+    int hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(oldToken->m_FileIdx, oldToken->m_Line);
+    m_TokenDocumentationMap.erase(hashedIdx);
+    if(oldToken->m_TokenKind & tkFunction)
+    {
+        // Remove implementation's documentation
+        hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(oldToken->m_ImplFileIdx, oldToken->m_ImplLine);
+        m_TokenDocumentationMap.erase(hashedIdx);
+    }
+    
+    // Step 7: Finally, remove it from the list.
 
     RemoveTokenFromList(idx);
 }
@@ -831,3 +923,99 @@
 {
     m_FileStatusMap[ InsertFileOrGetIndex(filename) ] = fpsDone;
 }
+
+void TokenTree::SetDocumentation(int fileIdx, int lineNo, const wxString& doc)
+{
+    //generate unique index:
+    int hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(fileIdx, lineNo);
+    
+    TokenIdxStringMap::iterator it = m_TokenDocumentationMap.find(hashedIdx);
+    if(it != m_TokenDocumentationMap.end())
+    {
+        it->second = doc;
+        it->second.Shrink();
+    }
+    else
+    {
+        wxString& newDoc = m_TokenDocumentationMap[hashedIdx];
+        newDoc = doc;
+        newDoc.Shrink();
+    }
+}
+
+void TokenTree::PrependDocumentation(int fileIdx, int lineNo, const wxString& doc)
+{
+    int hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(fileIdx, lineNo);
+    
+    TokenIdxStringMap::iterator it = m_TokenDocumentationMap.find(hashedIdx);
+    if(it != m_TokenDocumentationMap.end())
+    {
+        it->second.Prepend(doc);
+        it->second.Shrink();
+    }
+    else
+    {
+        wxString& newDoc = m_TokenDocumentationMap[hashedIdx];
+        newDoc = doc;
+        newDoc.Shrink();
+    }
+}
+
+void TokenTree::AppendDocumentation(int fileIdx, int lineNo, const wxString& doc)
+{
+    int hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(fileIdx, lineNo);
+    
+    TokenIdxStringMap::iterator it = m_TokenDocumentationMap.find(hashedIdx);
+    if(it != m_TokenDocumentationMap.end())
+    {
+        it->second += doc;
+        it->second.Shrink();
+    }
+    else
+    {
+        wxString& newDoc = m_TokenDocumentationMap[hashedIdx];
+        newDoc = doc;
+        newDoc.Shrink();
+    }
+}
+
+wxString TokenTree::GetDocumentation(int fileIdx, int lineNo) const
+{
+    int hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(fileIdx, lineNo);
+    TokenIdxStringMap::const_iterator it = m_TokenDocumentationMap.find(hashedIdx);
+    if(it != m_TokenDocumentationMap.end())
+    {
+        return it->second;
+    }
+    else
+    {
+        return wxString();
+    }
+}
+
+//! also returns documentation found before implementation
+wxString TokenTree::GetDocumentation(int tokenIdx) const
+{
+    const Token* token = at(tokenIdx);
+    if(!token)
+        return wxString();
+    int hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(token->m_FileIdx, token->m_Line);
+    
+    wxString out;
+    TokenIdxStringMap::const_iterator it = m_TokenDocumentationMap.find(hashedIdx);
+    if(it != m_TokenDocumentationMap.end())
+    {
+        out = it->second;
+    }
+    
+    if(token->m_TokenKind & tkAnyFunction)
+    {
+        hashedIdx = TokenTreeHelper::HashFileIdxAndLineNo(token->m_ImplFileIdx, token->m_ImplLine);
+        it = m_TokenDocumentationMap.find(hashedIdx);
+        if(it != m_TokenDocumentationMap.end())
+        {
+            out += it->second;
+        }
+    }
+    return out;
+}
Index: src/plugins/codecompletion/parser/tokentree.h
===================================================================
--- src/plugins/codecompletion/parser/tokentree.h	(wersja 8785)
+++ src/plugins/codecompletion/parser/tokentree.h	(kopia robocza)
@@ -24,6 +24,7 @@
 typedef BasicSearchTree                                          TokenFilenameMap;
 typedef std::map< size_t, TokenIdxSet,       std::less<size_t> > TokenFileMap;
 typedef std::map< size_t, FileParsingStatus, std::less<size_t> > TokenFileStatusMap;
+typedef std::map< int, wxString >                                TokenIdxStringMap;
 
 extern wxMutex s_TokenTreeMutex;
 
@@ -97,6 +98,13 @@
 
     void MarkFileTokensAsLocal(const wxString& filename, bool local = true, void* userData = 0);
     void MarkFileTokensAsLocal(size_t fileIdx, bool local = true, void* userData = 0);
+    
+    //documentation functions
+    void SetDocumentation(int fileIdx, int lineNo, const wxString& doc);
+    void PrependDocumentation(int fileIdx, int lineNo, const wxString& doc);
+    void AppendDocumentation(int fileIdx, int lineNo, const wxString& doc);
+    wxString GetDocumentation(int fileIdx, int lineNo) const;
+    wxString GetDocumentation(int tokenIdx) const;
 
     size_t        m_StructUnionUnnamedCount;
     size_t        m_EnumUnnamedCount;
@@ -121,7 +129,7 @@
       * @return if true, we can safely remove the token
       */
     bool CheckChildRemove(const Token* token, int fileIdx);
-
+    
     TokenSearchTree   m_Tree;              /** Tree containing the indexes to the tokens (the indexes will be used on m_Tokens) */
     TokenList         m_Tokens;            /** Contains the pointers to all the tokens */
     TokenIdxList      m_FreeTokens;        /** List of all the deleted (and available) tokens */
@@ -134,6 +142,8 @@
     TokenFileMap        m_FileMap;             /** Map: file indices -> sets of TokenIndexes */
     TokenFileStatusMap  m_FileStatusMap;       /** Map: file indices -> status */
     TokenFileSet        m_FilesToBeReparsed;   /** Set: file indices */
+    
+    TokenIdxStringMap   m_TokenDocumentationMap;    /** Map: hashed file and line -> documentation */
 };
 
 #endif // TOKENTREE_H
Index: src/plugins/codecompletion/resources/settings.xrc
===================================================================
--- src/plugins/codecompletion/resources/settings.xrc	(wersja 8785)
+++ src/plugins/codecompletion/resources/settings.xrc	(kopia robocza)
@@ -1,599 +1,700 @@
-<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8" ?>
 <resource xmlns="http://www.wxwidgets.org/wxxrc">
-  <object class="wxPanel" name="dlgCCSettings">
-    <object class="wxBoxSizer">
-      <orient>wxVERTICAL</orient>
-      <object class="sizeritem">
-        <object class="wxNotebook" name="nbCCSettings">
-          <object class="notebookpage">
-            <object class="wxPanel" name="tabCC">
-              <object class="wxBoxSizer">
-                <orient>wxVERTICAL</orient>
-                <object class="sizeritem">
-                  <object class="wxCheckBox" name="chkNoCC">
-                    <label>Disable code-completion</label>
-                  </object>
-                  <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <label>Options</label>
-                    <orient>wxVERTICAL</orient>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkUseSmartSense">
-                        <label>Disable SmartSense</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkWhileTyping">
-                        <label>Update parser when typing (on save otherwise)</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkCaseSensitive">
-                        <label>Case sensitive matches</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkEvalTooltip">
-                        <label>Display info when hovering mouse over a token in the editor</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkAutoSelectOne">
-                        <label>Auto-select, if only one match</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkAutoAddParentheses">
-                        <label>Add parentheses after function name auto completion</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkAddDoxgenComment">
-                        <label>Add doxgen comment, when implementing the function method</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkEnableHeaders">
-                        <label>Enable headers code-completion</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxFlexGridSizer">
-                        <cols>2</cols>
-                        <vgap>8</vgap>
-                        <hgap>8</hgap>
-                        <object class="sizeritem">
-                          <object class="wxCheckBox" name="chkAutoLaunch">
-                            <label>Automatically launch when typed # letters:</label>
-                          </object>
-                          <flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxSpinCtrl" name="spnAutoLaunchChars">
-                            <value>4</value>
-                            <min>1</min>
-                            <max>8</max>
-                          </object>
-                          <flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxStaticText" name="lblMaxMatches">
-                            <label>Maximum allowed code-completion matches:</label>
-                          </object>
-                          <flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxSpinCtrl" name="spnMaxMatches">
-                            <value>16384</value>
-                            <max>100000</max>
-                          </object>
-                          <flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxStaticText" name="lblFillupChars">
-                            <label>Fillup characters:</label>
-                          </object>
-                          <flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                          <option>1</option>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxTextCtrl" name="txtFillupChars"/>
-                          <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <option>1</option>
-                        </object>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxStaticText" name="ID_STATICTEXT1">
-                        <label>Delay for auto-kick-in when typing [. :: -&gt;]:</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxBoxSizer">
-                        <object class="sizeritem">
-                          <object class="wxStaticText" name="ID_STATICTEXT2">
-                            <label>1 ms</label>
-                          </object>
-                          <flag>wxTOP|wxLEFT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <border>5</border>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxBoxSizer">
-                            <orient>wxVERTICAL</orient>
-                            <object class="sizeritem">
-                              <object class="wxSlider" name="sldCCDelay">
-                                <value>5</value>
-                                <max>25</max>
-                                <tickfreq>5</tickfreq>
-                                <pagesize>10</pagesize>
-                                <style>wxSL_AUTOTICKS</style>
-                              </object>
-                              <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                              <border>5</border>
-                              <option>1</option>
-                            </object>
-                            <object class="sizeritem">
-                              <object class="wxStaticText" name="lblDelay">
-                                <label>500 ms</label>
-                              </object>
-                              <flag>wxALIGN_TOP|wxALIGN_CENTER_HORIZONTAL</flag>
-                            </object>
-                          </object>
-                          <flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <border>8</border>
-                          <option>1</option>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxStaticText" name="ID_STATICTEXT3">
-                            <label>2.5 sec</label>
-                          </object>
-                          <flag>wxTOP|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <border>5</border>
-                        </object>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                  </object>
-                  <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_1">
-                        <label>1</label>
-                      </object>
-                      <flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_2">
-                        <label>2</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_3">
-                        <label>3</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_4">
-                        <label>4</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_5">
-                        <label>5</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_6">
-                        <label>6</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_7">
-                        <label>7</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_8">
-                        <label>8</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkKL_9">
-                        <label>9</label>
-                      </object>
-                      <flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                      <border>8</border>
-                    </object>
-                    <label>Keyword sets to additionally include:</label>
-                    <orient>wxHORIZONTAL</orient>
-                  </object>
-                  <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-              </object>
-            </object>
-            <label>Code completion</label>
-          </object>
-          <object class="notebookpage">
-            <object class="wxPanel" name="tabParser">
-              <object class="wxBoxSizer">
-                <orient>wxVERTICAL</orient>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <label>Options</label>
-                    <orient>wxVERTICAL</orient>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkLocals">
-                        <label>Follow LOCAL includes</label>
-                      </object>
-                      <flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkGlobals">
-                        <label>Follow GLOBAL includes</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkPreprocessor">
-                        <label>Parse preprocessor directives</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkComplexMacros">
-                        <label>Parse complex macros (needs more time)</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxStaticText" name="ID_STATICTEXT7">
-                        <label>Headers to parse with high priority (i.e. initially, before project):</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxTextCtrl" name="txtPriorityHeaders">
-                        <value>&lt;cstddef&gt;, &lt;w32api.h&gt;,
-&lt;wx/defs.h&gt;, &lt;wx/dlimpexp.h&gt;, &lt;wx/toplevel.h&gt;,
-&lt;boost/config.hpp&gt;, &lt; boost/filesystem/config.hpp&gt;,
-&quot;pch.h&quot;, &quot;sdk.h&quot;, &quot;stdafx.h&quot;</value>
-                        <size>-1,50</size>
-                        <style>wxTE_MULTILINE</style>
-                      </object>
-                      <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxStaticLine" name="ID_STATICLINE1">
-                        <size>10,-1</size>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxBoxSizer">
-                        <orient>wxVERTICAL</orient>
-                        <object class="sizeritem">
-                          <object class="wxBoxSizer">
-                            <object class="sizeritem">
-                              <object class="wxStaticText" name="ID_STATICTEXT6">
-                                <label>Concurrently parsing threads:</label>
-                              </object>
-                              <flag>wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                              <border>5</border>
-                            </object>
-                            <object class="sizeritem">
-                              <object class="wxSpinCtrl" name="spnThreadsNum">
-                                <value>2</value>
-                                <min>1</min>
-                                <max>16</max>
-                                <style>wxSP_ARROW_KEYS</style>
-                              </object>
-                              <flag>wxLEFT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                              <border>8</border>
-                            </object>
-                          </object>
-                          <flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <border>5</border>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxBoxSizer">
-                            <orient>wxVERTICAL</orient>
-                            <object class="sizeritem">
-                              <object class="wxRadioButton" name="rdoOneParserPerWorkspace">
-                                <label>Use one parser for the whole workspace</label>
-                              </object>
-                              <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                              <border>5</border>
-                            </object>
-                            <object class="sizeritem">
-                              <object class="wxRadioButton" name="rdoOneParserPerProject">
-                                <label>Use one parser per project</label>
-                                <selected>1</selected>
-                              </object>
-                              <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                              <border>5</border>
-                            </object>
-                            <object class="sizeritem">
-                              <object class="wxBoxSizer">
-                                <object class="spacer">
-                                  <flag>wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                                  <border>5</border>
-                                </object>
-                                <object class="sizeritem">
-                                  <object class="wxStaticText" name="lblParsersNum">
-                                    <label>Maximum allowed parsers:</label>
-                                  </object>
-                                  <flag>wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                                  <border>5</border>
-                                </object>
-                                <object class="sizeritem">
-                                  <object class="wxSpinCtrl" name="spnParsersNum">
-                                    <value>5</value>
-                                    <min>1</min>
-                                    <max>32</max>
-                                    <style>wxSP_ARROW_KEYS</style>
-                                  </object>
-                                  <flag>wxLEFT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
-                                  <border>8</border>
-                                </object>
-                              </object>
-                              <flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                              <border>5</border>
-                            </object>
-                          </object>
-                          <flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_BOTTOM</flag>
-                          <border>5</border>
-                        </object>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                  </object>
-                  <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-              </object>
-            </object>
-            <label>C/C++ parser</label>
-          </object>
-          <object class="notebookpage">
-            <object class="wxPanel" name="tabParserAdvanced">
-              <object class="wxBoxSizer">
-                <orient>wxVERTICAL</orient>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <label>File extension handling</label>
-                    <orient>wxVERTICAL</orient>
-                    <object class="sizeritem">
-                      <object class="wxStaticText" name="ID_STATICTEXT8">
-                        <label>File extensions to parse as header files (separated by colons):</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxTextCtrl" name="txtCCFileExtHeader">
-                        <value>h,hpp,tcc,xpm</value>
-                      </object>
-                      <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkCCFileExtEmpty">
-                        <label>Include files w/o extension (i.e. C++ &lt;iostream&gt;)</label>
-                        <checked>1</checked>
-                      </object>
-                      <flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxStaticText" name="ID_STATICTEXT9">
-                        <label>File extensions to parse as source files (separated by colons):</label>
-                      </object>
-                      <flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxTextCtrl" name="txtCCFileExtSource">
-                        <value>c,cpp,cxx,cc,c++</value>
-                      </object>
-                      <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                  </object>
-                  <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <label>Replacement tokens</label>
-                    <orient>wxVERTICAL</orient>
-                    <object class="sizeritem">
-                      <object class="wxBoxSizer">
-                        <object class="sizeritem">
-                          <object class="wxListBox" name="lstRepl">
-                            <size>-1,100</size>
-                          </object>
-                          <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <option>1</option>
-                        </object>
-                        <object class="sizeritem">
-                          <object class="wxBoxSizer">
-                            <orient>wxVERTICAL</orient>
-                            <object class="sizeritem">
-                              <object class="wxButton" name="btnAddRepl">
-                                <label>&amp;Add</label>
-                              </object>
-                              <flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                            </object>
-                            <object class="sizeritem">
-                              <object class="wxButton" name="btnEditRepl">
-                                <label>&amp;Edit</label>
-                              </object>
-                              <flag>wxTOP|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                              <border>4</border>
-                            </object>
-                            <object class="sizeritem">
-                              <object class="wxButton" name="btnDelRepl">
-                                <label>&amp;Delete</label>
-                              </object>
-                              <flag>wxTOP|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                              <border>4</border>
-                            </object>
-                          </object>
-                          <flag>wxLEFT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                          <border>8</border>
-                        </object>
-                      </object>
-                      <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                      <option>1</option>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxStaticText" name="ID_STATICTEXT4">
-                        <label>The more replacement tokens you add, the slower the parser will become.</label>
-                      </object>
-                      <flag>wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxStaticText" name="ID_STATICTEXT5">
-                        <label>So try not to over-do it :).</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                  </object>
-                  <flag>wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-              
-              </object>
-            </object>
-            <label>C/C++ parser (adv.)</label>
-          </object>
-          <object class="notebookpage">
-            <object class="wxPanel" name="tabBrowser">
-              <object class="wxBoxSizer">
-                <orient>wxVERTICAL</orient>
-                <object class="sizeritem">
-                  <object class="wxCheckBox" name="chkNoSB">
-                    <label>Disable symbols browser</label>
-                  </object>
-                  <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <label>Options</label>
-                    <orient>wxVERTICAL</orient>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkInheritance">
-                        <label>Display inheritance info</label>
-                      </object>
-                      <flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkExpandNS">
-                        <label>Automatically expand namespaces</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkFloatCB">
-                        <label>Display as free floating/docking window</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                    </object>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkTreeMembers">
-                        <label>Display member list in separate tree</label>
-                      </object>
-                      <flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                      <border>5</border>
-                      <option>1</option>
-                    </object>
-                  </object>
-                  <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-                  <border>8</border>
-                </object>
-                <object class="sizeritem">
-                  <object class="wxStaticBoxSizer">
-                    <label>Toolbar</label>
-                    <orient>wxVERTICAL</orient>
-                    <object class="sizeritem">
-                      <object class="wxCheckBox" name="chkScopeFilter">
-                        <label>Use scope filtering</label>
-                      </object>
-                      <flag>wxALL|wxALIGN_LEFT|wxALIGN_BOTTOM</flag>
-                      <border>5</border>
-                      <option>1</option>
-                    </object>
-                  </object>
-                  <flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_BOTTOM</flag>
-                  <border>8</border>
-                </object>
-              </object>
-            </object>
-            <label>Symbols browser</label>
-          </object>
-        </object>
-        <flag>wxLEFT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
-        <border>8</border>
-        <option>1</option>
-      </object>
-    </object>
-  </object>
-</resource>
+	<object class="wxPanel" name="dlgCCSettings">
+		<object class="wxBoxSizer">
+			<orient>wxVERTICAL</orient>
+			<object class="sizeritem">
+				<object class="wxNotebook" name="nbCCSettings">
+					<object class="notebookpage">
+						<object class="wxPanel" name="tabCC">
+							<object class="wxBoxSizer">
+								<orient>wxVERTICAL</orient>
+								<object class="sizeritem">
+									<object class="wxCheckBox" name="chkNoCC">
+										<label>Disable code-completion</label>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Options</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkUseSmartSense">
+												<label>Disable SmartSense</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkWhileTyping">
+												<label>Update parser when typing (on save otherwise)</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkCaseSensitive">
+												<label>Case sensitive matches</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkEvalTooltip">
+												<label>Display info when hovering mouse over a token in the editor</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkAutoSelectOne">
+												<label>Auto-select, if only one match</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkAutoAddParentheses">
+												<label>Add parentheses after function name auto completion</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="spacer">
+											<flag>wxBOTTOM|wxEXPAND|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+											<border>5</border>
+											<size>581,0</size>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkDetectImpl">
+												<label>Add function arguments&apos; types and names when autocomleted outside function</label>
+											</object>
+											<flag>wxLEFT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>20</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkAddDoxgenComment">
+												<label>Add doxgen comment, when implementing the function method</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkEnableHeaders">
+												<label>Enable headers code-completion</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxFlexGridSizer">
+												<cols>2</cols>
+												<vgap>8</vgap>
+												<hgap>8</hgap>
+												<object class="sizeritem">
+													<object class="wxCheckBox" name="chkAutoLaunch">
+														<label>Automatically launch when typed # letters:</label>
+													</object>
+													<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+												</object>
+												<object class="sizeritem">
+													<object class="wxSpinCtrl" name="spnAutoLaunchChars">
+														<value>4</value>
+														<min>1</min>
+														<max>8</max>
+													</object>
+													<flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
+												</object>
+												<object class="sizeritem">
+													<object class="wxStaticText" name="lblMaxMatches">
+														<label>Maximum allowed code-completion matches:</label>
+													</object>
+													<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+												</object>
+												<object class="sizeritem">
+													<object class="wxSpinCtrl" name="spnMaxMatches">
+														<value>16384</value>
+														<max>100000</max>
+													</object>
+													<flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
+												</object>
+												<object class="sizeritem">
+													<object class="wxStaticText" name="lblFillupChars">
+														<label>Fillup characters:</label>
+													</object>
+													<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxTextCtrl" name="txtFillupChars" />
+													<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<option>1</option>
+												</object>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxStaticText" name="ID_STATICTEXT1">
+												<label>Delay for auto-kick-in when typing [. :: -&gt;]:</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxBoxSizer">
+												<object class="sizeritem">
+													<object class="wxStaticText" name="ID_STATICTEXT2">
+														<label>1 ms</label>
+													</object>
+													<flag>wxTOP|wxLEFT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<border>5</border>
+												</object>
+												<object class="sizeritem">
+													<object class="wxBoxSizer">
+														<orient>wxVERTICAL</orient>
+														<object class="sizeritem">
+															<object class="wxSlider" name="sldCCDelay">
+																<value>5</value>
+																<max>25</max>
+																<tickfreq>5</tickfreq>
+																<pagesize>10</pagesize>
+																<style>wxSL_AUTOTICKS</style>
+															</object>
+															<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+															<border>5</border>
+															<option>1</option>
+														</object>
+														<object class="sizeritem">
+															<object class="wxStaticText" name="lblDelay">
+																<label>500 ms</label>
+															</object>
+															<flag>wxALIGN_TOP|wxALIGN_CENTER_HORIZONTAL</flag>
+														</object>
+													</object>
+													<flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<border>8</border>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxStaticText" name="ID_STATICTEXT3">
+														<label>2.5 sec</label>
+													</object>
+													<flag>wxTOP|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<border>5</border>
+												</object>
+											</object>
+											<flag>wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Keyword sets to additionally include:</label>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_1">
+												<label>1</label>
+											</object>
+											<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_2">
+												<label>2</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_3">
+												<label>3</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_4">
+												<label>4</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_5">
+												<label>5</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_6">
+												<label>6</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_7">
+												<label>7</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_8">
+												<label>8</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkKL_9">
+												<label>9</label>
+											</object>
+											<flag>wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>8</border>
+										</object>
+									</object>
+									<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+							</object>
+						</object>
+						<label>Code completion</label>
+					</object>
+					<object class="notebookpage">
+						<object class="wxPanel" name="tabParser">
+							<object class="wxBoxSizer">
+								<orient>wxVERTICAL</orient>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Options</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkLocals">
+												<label>Follow LOCAL includes</label>
+											</object>
+											<flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkGlobals">
+												<label>Follow GLOBAL includes</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkPreprocessor">
+												<label>Parse preprocessor directives</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkComplexMacros">
+												<label>Parse complex macros (needs more time)</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxStaticText" name="ID_STATICTEXT7">
+												<label>Headers to parse with high priority (i.e. initially, before project):</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxTextCtrl" name="txtPriorityHeaders">
+												<value>&lt;cstddef&gt;, &lt;w32api.h&gt;,&#x0A;&lt;wx/defs.h&gt;, &lt;wx/dlimpexp.h&gt;, &lt;wx/toplevel.h&gt;,&#x0A;&lt;boost/config.hpp&gt;, &lt; boost/filesystem/config.hpp&gt;,&#x0A;&quot;pch.h&quot;, &quot;sdk.h&quot;, &quot;stdafx.h&quot;</value>
+												<size>-1,50</size>
+												<style>wxTE_MULTILINE</style>
+											</object>
+											<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxStaticLine" name="ID_STATICLINE1">
+												<size>10,-1</size>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxBoxSizer">
+												<orient>wxVERTICAL</orient>
+												<object class="sizeritem">
+													<object class="wxBoxSizer">
+														<object class="sizeritem">
+															<object class="wxStaticText" name="ID_STATICTEXT6">
+																<label>Concurrently parsing threads:</label>
+															</object>
+															<flag>wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+															<border>5</border>
+														</object>
+														<object class="sizeritem">
+															<object class="wxSpinCtrl" name="spnThreadsNum">
+																<value>2</value>
+																<min>1</min>
+																<max>16</max>
+																<style>wxSP_ARROW_KEYS</style>
+															</object>
+															<flag>wxLEFT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+															<border>8</border>
+														</object>
+													</object>
+													<flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<border>5</border>
+												</object>
+												<object class="sizeritem">
+													<object class="wxBoxSizer">
+														<orient>wxVERTICAL</orient>
+														<object class="sizeritem">
+															<object class="wxRadioButton" name="rdoOneParserPerWorkspace">
+																<label>Use one parser for the whole workspace</label>
+															</object>
+															<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+															<border>5</border>
+														</object>
+														<object class="sizeritem">
+															<object class="wxRadioButton" name="rdoOneParserPerProject">
+																<label>Use one parser per project</label>
+																<selected>1</selected>
+															</object>
+															<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+															<border>5</border>
+														</object>
+														<object class="sizeritem">
+															<object class="wxBoxSizer">
+																<object class="spacer">
+																	<flag>wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+																	<border>5</border>
+																</object>
+																<object class="sizeritem">
+																	<object class="wxStaticText" name="lblParsersNum">
+																		<label>Maximum allowed parsers:</label>
+																	</object>
+																	<flag>wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+																	<border>5</border>
+																</object>
+																<object class="sizeritem">
+																	<object class="wxSpinCtrl" name="spnParsersNum">
+																		<value>5</value>
+																		<min>1</min>
+																		<max>32</max>
+																		<style>wxSP_ARROW_KEYS</style>
+																	</object>
+																	<flag>wxLEFT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+																	<border>8</border>
+																</object>
+															</object>
+															<flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+															<border>5</border>
+														</object>
+													</object>
+													<flag>wxEXPAND|wxALIGN_LEFT|wxALIGN_BOTTOM</flag>
+													<border>5</border>
+												</object>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+									</object>
+									<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+							</object>
+						</object>
+						<label>C/C++ parser</label>
+					</object>
+					<object class="notebookpage">
+						<object class="wxPanel" name="tabParserAdvanced">
+							<object class="wxBoxSizer">
+								<orient>wxVERTICAL</orient>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>File extension handling</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxStaticText" name="ID_STATICTEXT8">
+												<label>File extensions to parse as header files (separated by colons):</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxTextCtrl" name="txtCCFileExtHeader">
+												<value>h,hpp,tcc,xpm</value>
+											</object>
+											<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkCCFileExtEmpty">
+												<label>Include files w/o extension (i.e. C++ &lt;iostream&gt;)</label>
+												<checked>1</checked>
+											</object>
+											<flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxStaticText" name="ID_STATICTEXT9">
+												<label>File extensions to parse as source files (separated by colons):</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxTextCtrl" name="txtCCFileExtSource">
+												<value>c,cpp,cxx,cc,c++</value>
+											</object>
+											<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+									</object>
+									<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Replacement tokens</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxBoxSizer">
+												<object class="sizeritem">
+													<object class="wxListBox" name="lstRepl">
+														<size>-1,100</size>
+													</object>
+													<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxBoxSizer">
+														<orient>wxVERTICAL</orient>
+														<object class="sizeritem">
+															<object class="wxButton" name="btnAddRepl">
+																<label>&amp;Add</label>
+															</object>
+															<flag>wxALL|wxALIGN_LEFT|wxALIGN_TOP</flag>
+														</object>
+														<object class="sizeritem">
+															<object class="wxButton" name="btnEditRepl">
+																<label>&amp;Edit</label>
+															</object>
+															<flag>wxTOP|wxALIGN_LEFT|wxALIGN_TOP</flag>
+															<border>4</border>
+														</object>
+														<object class="sizeritem">
+															<object class="wxButton" name="btnDelRepl">
+																<label>&amp;Delete</label>
+															</object>
+															<flag>wxTOP|wxALIGN_LEFT|wxALIGN_TOP</flag>
+															<border>4</border>
+														</object>
+													</object>
+													<flag>wxLEFT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+													<border>8</border>
+												</object>
+											</object>
+											<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+											<option>1</option>
+										</object>
+										<object class="sizeritem">
+											<object class="wxStaticText" name="ID_STATICTEXT4">
+												<label>The more replacement tokens you add, the slower the parser will become.</label>
+											</object>
+											<flag>wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxStaticText" name="ID_STATICTEXT5">
+												<label>So try not to over-do it :).</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+									</object>
+									<flag>wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+							</object>
+						</object>
+						<label>C/C++ parser (adv.)</label>
+					</object>
+					<object class="notebookpage">
+						<object class="wxPanel" name="tabBrowser">
+							<object class="wxBoxSizer">
+								<orient>wxVERTICAL</orient>
+								<object class="sizeritem">
+									<object class="wxCheckBox" name="chkNoSB">
+										<label>Disable symbols browser</label>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Options</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkInheritance">
+												<label>Display inheritance info</label>
+											</object>
+											<flag>wxALL|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkExpandNS">
+												<label>Automatically expand namespaces</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkFloatCB">
+												<label>Display as free floating/docking window</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkTreeMembers">
+												<label>Display member list in separate tree</label>
+											</object>
+											<flag>wxBOTTOM|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+											<border>5</border>
+											<option>1</option>
+										</object>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Toolbar</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkScopeFilter">
+												<label>Use scope filtering</label>
+											</object>
+											<flag>wxALL|wxALIGN_LEFT|wxALIGN_BOTTOM</flag>
+											<border>5</border>
+											<option>1</option>
+										</object>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_BOTTOM</flag>
+									<border>8</border>
+								</object>
+							</object>
+						</object>
+						<label>Symbols browser</label>
+					</object>
+					<object class="notebookpage">
+						<object class="wxPanel" name="ID_PANEL1">
+							<pos>402,16</pos>
+							<object class="wxBoxSizer">
+								<orient>wxVERTICAL</orient>
+								<object class="sizeritem">
+									<object class="wxCheckBox" name="chkDocumentation">
+										<label>Parse documentation</label>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+								<object class="sizeritem">
+									<object class="wxStaticBoxSizer">
+										<label>Options</label>
+										<orient>wxVERTICAL</orient>
+										<object class="sizeritem">
+											<object class="wxCheckBox" name="chkDocPopupAlways">
+												<label>Show token&apos;s details even if it hasn&apos;t documentation</label>
+											</object>
+											<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>5</border>
+										</object>
+										<object class="sizeritem">
+											<object class="wxFlexGridSizer">
+												<cols>2</cols>
+												<rows>3</rows>
+												<hgap>20</hgap>
+												<object class="sizeritem">
+													<object class="wxStaticText" name="ID_STATICTEXT10">
+														<label>Background color</label>
+													</object>
+													<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+													<border>5</border>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxButton" name="btnDocBgColor">
+														<size>40,18</size>
+														<bg>wxSYS_COLOUR_INFOBK</bg>
+														<style>wxBU_EXACTFIT</style>
+													</object>
+													<flag>wxTOP|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+													<border>5</border>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxStaticText" name="ID_STATICTEXT11">
+														<label>Text color</label>
+													</object>
+													<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+													<border>5</border>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxButton" name="btnDocTextColor">
+														<size>40,18</size>
+														<bg>wxSYS_COLOUR_INFOTEXT</bg>
+														<style>wxBU_EXACTFIT</style>
+													</object>
+													<flag>wxTOP|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+													<border>5</border>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxStaticText" name="ID_STATICTEXT12">
+														<label>Link color</label>
+													</object>
+													<flag>wxTOP|wxLEFT|wxRIGHT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+													<border>5</border>
+													<option>1</option>
+												</object>
+												<object class="sizeritem">
+													<object class="wxButton" name="btnDocLinkColor">
+														<size>40,18</size>
+														<bg>wxSYS_COLOUR_HIGHLIGHT</bg>
+														<style>wxBU_EXACTFIT</style>
+													</object>
+													<flag>wxTOP|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+													<border>5</border>
+													<option>1</option>
+												</object>
+											</object>
+											<flag>wxLEFT|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+											<border>5</border>
+										</object>
+									</object>
+									<flag>wxTOP|wxLEFT|wxRIGHT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+									<border>8</border>
+								</object>
+							</object>
+						</object>
+						<label>Documentation</label>
+					</object>
+				</object>
+				<flag>wxLEFT|wxEXPAND|wxALIGN_LEFT|wxALIGN_TOP</flag>
+				<border>8</border>
+				<option>1</option>
+			</object>
+		</object>
+	</object>
+</resource>
Index: src/sdk/cbeditor.cpp
===================================================================
--- src/sdk/cbeditor.cpp	(wersja 8785)
+++ src/sdk/cbeditor.cpp	(kopia robocza)
@@ -984,6 +984,7 @@
             wxEVT_SCI_AUTOCOMP_SELECTION,
     //        wxEVT_SCI_INDICATOR_CLICK,
     //        wxEVT_SCI_INDICATOR_RELEASE,
+            wxEVT_SCI_AUTOCOMP_CANCELLED,
             wxEVT_SCI_TAB,
             wxEVT_SCI_ESC,
 
