Index: src/plugins/todo/addtododlg.cpp
===================================================================
--- src/plugins/todo/addtododlg.cpp	(revision 6193)
+++ src/plugins/todo/addtododlg.cpp	(working copy)
@@ -210,7 +210,7 @@
 void AddTodoDlg::OnAddType(wxCommandEvent&)
 {
     // ask for the new type to be added to the "choice" list
-    wxTextEntryDialog dlg(this, _T("Enter the user you wish to add"), _T("Add type"), _T(""), wxOK|wxCANCEL);
+    wxTextEntryDialog dlg(this, _T("Enter the type you wish to add"), _T("Add type"), _T(""), wxOK|wxCANCEL);
     if(dlg.ShowModal() == wxID_OK)
     {
         wxString Type = dlg.GetValue();
Index: src/plugins/todo/addtododlg.h
===================================================================
--- src/plugins/todo/addtododlg.h	(revision 6193)
+++ src/plugins/todo/addtododlg.h	(working copy)
@@ -25,7 +25,9 @@
 {
     tdctCpp = 0, // C++ style,
     tdctC,       // C style
-    tdctDoxygen, // Doxygen style
+	// GJH 3/3/10 Added doxygen comment in C-style block.
+    tdctDoxygenC, // Doxygen C style
+    tdctDoxygenCPP, // Doxygen CPP style
     tdctWarning, // compiler warning
     tdctError    // compiler error
 };
Index: src/plugins/todo/resources/add_todo.xrc
===================================================================
--- src/plugins/todo/resources/add_todo.xrc	(revision 6193)
+++ src/plugins/todo/resources/add_todo.xrc	(working copy)
@@ -127,7 +127,8 @@
               <content>
                 <item>C++ style comment</item>
                 <item>C style comment</item>
-                <item>Doxygen style comment</item>
+				<item>Doxygen C style comment (in block)</item>
+				<item>Doxygen C++ style comment</item>
                 <item>Compiler warning</item>
                 <item>Compiler error</item>
               </content>
Index: src/plugins/todo/todolist.cpp
===================================================================
--- src/plugins/todo/todolist.cpp	(revision 6193)
+++ src/plugins/todo/todolist.cpp	(working copy)
@@ -66,7 +66,6 @@
 
 ToDoList::~ToDoList()
 {
-    //dtor
 }
 
 void ToDoList::OnAttach()
@@ -77,7 +76,7 @@
     titles.Add(_("Type"));
     titles.Add(_("Text"));
     titles.Add(_("User"));
-    titles.Add(_("Prio."));
+    titles.Add(_("Priority"));
     titles.Add(_("Line"));
     titles.Add(_("File"));
     widths.Add(64);
@@ -96,7 +95,7 @@
     {
         LogManager* msgMan = Manager::Get()->GetLogManager();
         m_ListPageIndex = msgMan->SetLog(m_pListLog);
-        msgMan->Slot(m_ListPageIndex).title = _("Todo");
+        msgMan->Slot(m_ListPageIndex).title = _("To Do");
 
         CodeBlocksLogEvent evt(cbEVT_ADD_LOG_WINDOW, m_pListLog, msgMan->Slot(m_ListPageIndex).title, msgMan->Slot(m_ListPageIndex).icon);
         Manager::Get()->ProcessEvent(evt);
@@ -242,6 +241,13 @@
         m_Types.Add(_T("@note"));
         m_Types.Add(_T("\\note"));
     }
+    m_pListLog->m_pAllowedTypesDlg->Clear();
+    m_pListLog->m_pAllowedTypesDlg->AddItem(m_Types);
+
+    wxArrayString selectedTypes;
+    Manager::Get()->GetConfigManager(_T("todo_list"))->Read(_T("types_selected"), &selectedTypes);
+
+    m_pListLog->m_pAllowedTypesDlg->SetChecked(selectedTypes);
     SaveTypes();
 }
 
@@ -370,7 +376,11 @@
         case tdctCpp:
             buffer << _T("// ");
             break;
-        case tdctDoxygen:
+		// GJH 3/3/10 Added doxygen comment in C-style block.
+        case tdctDoxygenC:
+            buffer << _T(" * ");
+            break;
+        case tdctDoxygenCPP:
             buffer << _T("/// ");
             break;
         case tdctWarning:
Index: src/plugins/todo/todolistview.cpp
===================================================================
--- src/plugins/todo/todolistview.cpp	(revision 6193)
+++ src/plugins/todo/todolistview.cpp	(working copy)
@@ -9,26 +9,26 @@
 
 #include "sdk.h"
 #ifndef CB_PRECOMP
-  #include <wx/arrstr.h>
-  #include <wx/button.h>
-  #include <wx/combobox.h>
-  #include <wx/event.h>
-  #include <wx/file.h>
-  #include <wx/intl.h>
-  #include <wx/listctrl.h>
-  #include <wx/sizer.h>
-  #include <wx/stattext.h>
-  #include <wx/utils.h>
+#include <wx/arrstr.h>
+#include <wx/button.h>
+#include <wx/combobox.h>
+#include <wx/event.h>
+#include <wx/file.h>
+#include <wx/intl.h>
+#include <wx/listctrl.h>
+#include <wx/sizer.h>
+#include <wx/stattext.h>
+#include <wx/utils.h>
 
-  #include "cbeditor.h"
-  #include "cbproject.h"
-  #include "editormanager.h"
-  #include "filemanager.h"
-  #include "globals.h"
-  #include "manager.h"
-  #include "projectfile.h"
-  #include "projectmanager.h"
-  //#include "logmanager.h"
+#include "cbeditor.h"
+#include "cbproject.h"
+#include "editormanager.h"
+#include "filemanager.h"
+#include "globals.h"
+#include "manager.h"
+#include "projectfile.h"
+#include "projectmanager.h"
+#include "logmanager.h"
 #endif
 
 #include <wx/progdlg.h>
@@ -40,16 +40,18 @@
 
 namespace
 {
-    int idList = wxNewId();
-    int idSource = wxNewId();
-    int idUser = wxNewId();
-    int idButtonRefresh = wxNewId();
+	int idList = wxNewId();
+	int idSource = wxNewId();
+	int idUser = wxNewId();
+	int idButtonRefresh = wxNewId();
+	int idButtonTypes = wxNewId();
 };
 
 BEGIN_EVENT_TABLE(ToDoListView, wxEvtHandler)
-    EVT_COMBOBOX(idSource, ToDoListView::OnComboChange)
-    EVT_COMBOBOX(idUser, ToDoListView::OnComboChange)
-    EVT_BUTTON(idButtonRefresh, ToDoListView::OnButtonRefresh)
+	EVT_COMBOBOX(idSource, ToDoListView::OnComboChange)
+	EVT_COMBOBOX(idUser, ToDoListView::OnComboChange)
+	EVT_BUTTON(idButtonRefresh, ToDoListView::OnButtonRefresh)
+	EVT_BUTTON(idButtonTypes, ToDoListView::OnButtonTypes)
 END_EVENT_TABLE()
 
 ToDoListView::ToDoListView(const wxArrayString& titles, const wxArrayInt& widths, const wxArrayString& m_Types) :
@@ -64,13 +66,13 @@
     m_SortAscending(false),
     m_SortColumn(-1)
 {
-    //ctor
+	//ctor
 }
 
 ToDoListView::~ToDoListView()
 {
-    //dtor
-    Manager::Get()->GetAppWindow()->RemoveEventHandler(this);
+	//dtor
+	Manager::Get()->GetAppWindow()->RemoveEventHandler(this);
 }
 
 wxWindow* ToDoListView::CreateControl(wxWindow* parent)
@@ -89,7 +91,7 @@
             (wxObjectEventFunction) (wxEventFunction) (wxListEventFunction)
             &ToDoListView::OnColClick);
 
-    Manager::Get()->GetAppWindow()->PushEventHandler(this);
+	Manager::Get()->GetAppWindow()->PushEventHandler(this);
 
     control->SetInitialSize(wxSize(342,56));
     control->SetMinSize(wxSize(342,56));
@@ -118,9 +120,15 @@
     m_pRefresh = new wxButton(m_pPanel, idButtonRefresh, _("Refresh"));
     hbs->Add(m_pRefresh, 0, wxLEFT, 4);
 
+    m_pAllowedTypes = new wxButton(m_pPanel, idButtonTypes, _("Types"));
+    hbs->Add(m_pAllowedTypes, 0, wxLEFT, 4);
+
     bs->Add(hbs, 0, wxGROW | wxALL, 4);
     m_pPanel->SetSizer(bs);
 
+    m_pPanel->SetSizer(bs);
+
+	m_pAllowedTypesDlg = new CheckListDialog(m_pPanel);
     return m_pPanel;
 }
 
@@ -209,15 +217,15 @@
 
 void ToDoListView::LoadUsers()
 {
-    wxString oldStr = m_pUser->GetStringSelection();
-    m_pUser->Clear();
-    m_pUser->Append(_("<All users>"));
+	wxString oldStr = m_pUser->GetStringSelection();
+	m_pUser->Clear();
+	m_pUser->Append(_("<All users>"));
 
-    // loop through all todos and add distinct users
+	// loop through all todos and add distinct users
 //    Manager::Get()->GetLogManager()->DebugLog(F(_T("Managing %d items."), m_Items.GetCount()));
-    for (unsigned int i = 0; i < m_Items.GetCount(); ++i)
-    {
-        wxString user = m_Items[i].user;
+	for (unsigned int i = 0; i < m_Items.GetCount(); ++i)
+	{
+		wxString user = m_Items[i].user;
 //        Manager::Get()->GetLogManager()->DebugLog(F(_T("Found user %s."), user.c_str()));
         if (!user.IsEmpty())
         {
@@ -239,7 +247,7 @@
     Clear();
     m_Items.Clear();
 
-    TodoItemsMap::iterator it;
+	TodoItemsMap::iterator it;
 
     if(m_pSource->GetSelection()==0) // Single file
     {
@@ -357,209 +365,188 @@
 
 void ToDoListView::ParseEditor(cbEditor* pEditor)
 {
-    if (pEditor)
-        ParseBuffer(pEditor->GetControl()->GetText(), pEditor->GetFilename());
+	if (pEditor)
+		ParseBuffer(pEditor->GetControl()->GetText(), pEditor->GetFilename());
 }
 
 void ToDoListView::ParseFile(const wxString& filename)
 {
-    if (!wxFileExists(filename))
-        return;
+	if (!wxFileExists(filename))
+		return;
 
-    wxString st;
-    LoaderBase* fileBuffer = Manager::Get()->GetFileManager()->Load(filename, true);
-    if (fileBuffer)
-    {
-        EncodingDetector encDetector(fileBuffer);
-        if (encDetector.IsOK())
-        {
-            st = encDetector.GetWxStr();
-            ParseBuffer(st, filename);
-        }
-    }
-    else
-    {
-        return;
-    }
+	wxString st;
+	LoaderBase* fileBuffer = Manager::Get()->GetFileManager()->Load(filename, true);
+	if (fileBuffer)
+	{
+		EncodingDetector encDetector(fileBuffer);
+		if (encDetector.IsOK())
+		{
+			st = encDetector.GetWxStr();
+			ParseBuffer(st, filename);
+		}
+	}
+	else
+	{
+		return;
+	}
 
-    delete fileBuffer;
+	delete fileBuffer;
 }
 
 void ToDoListView::ParseBuffer(const wxString& buffer, const wxString& filename)
 {
-    // this is the actual workhorse...
 
-    // ok, we look for two basic kinds of todo entries in the text
-    // our version...
-    // TODO (mandrav#0#): Implement code to do this and the other...
-    // and a generic version...
+	// this is the actual workhorse...
 
-    m_ItemsMap[filename].clear();
+	m_ItemsMap[filename].clear();
 
-    for (unsigned int i = 0; i < m_Types.GetCount(); ++i)
-    {
-//Manager::Get()->GetLogManager()->DebugLog("Looking for %s", m_Types[i].c_str());
-        int pos = buffer.find(m_Types[i], 0);
+	//initialize one Comment class and reuse it
+	Comment current;
 
-        while (pos > 0)
-        {
-            // ok, start parsing now...
-            // keep a temp copy of pos to work with
-            int idx = pos;
-            bool isValid = false; // found it in a comment?
-            bool isC = false; // C or C++ style comment?
+	wxArrayString allowedTypes;
+	int t = 0;
+	while(t< m_Types.Count())
+	{
+		if(m_pAllowedTypesDlg->IsChecked(m_Types.Item(t)))
+		{
+			allowedTypes.Add(m_Types.Item(t));
+		}
+		t++;
+	}
 
-            // first check what type of comment we have
-            wxString allowedChars = _T(" \t/*");
-            wxChar lastChar = _T('\0');
-            while (idx >= 0)
-            {
-                // Check for special cases: compiler warnings, errors
-                if      ((idx>=8) && buffer.Mid(idx-8, 8).IsSameAs(_T("#warning")))
-                {
-                    isValid = true;
-                    break;
-                }
-                else if ((idx>=6) && buffer.Mid(idx-6, 6).IsSameAs(_T("#error")))
-                {
-                    isValid = true;
-                    break;
-                }
+	//find parse for comments
+	while (FindNextComment(buffer, &current))
+	{
 
-                wxChar c = buffer.GetChar(--idx);
-                // Check for EOL's and terminate early (saving time)
-                if (c == _T('\r') || c == _T('\n'))
-                    break;
+	// ok, we look for two basic kinds of todo entries in the text
+	// our version...
+	// TODO (mandrav#0#): Implement code to do this and the other...
+	// and a generic version...
+	// TODO: Implement code to do this and the other...
 
-                if ((int)allowedChars.Index(c) != wxNOT_FOUND)
-                {
-                    if (c == _T('/') && (lastChar == _T('/') || lastChar == _T('*')))
-                    {
-                        isValid = true;
-                        isC = lastChar == _T('*');
-                        break;
-                    }
-                }
-                else
-                    break;
+		for (unsigned int i = 0; i < allowedTypes.GetCount(); ++i)
+		{
+			//Manager::Get()->GetLogManager()->DebugLog(allowedTypes.Item(i));
 
-                lastChar = c;
-            }
+			// ok, start parsing now...
+			int pos = current.m_comment.find(allowedTypes[i], 0);
+			while (pos != -1)
+			{
+				// keep a temp copy of pos to work with
+				int idx = pos;
 
-//wxString msg;
-//msg.Printf(_T("Found %s %s style %s at %d"),
-//           isValid ? _T("valid") : _T("invalid"),
-//           isC     ? _T("C")     : _T("C++"),
-//           m_Types[i].c_str(),
-//           pos);
-//Manager::Get()->GetLogManager()->DebugLog(msg);
+				//#warning TODO (mandrav#1#): Make viewtododlg understand and display todo notes that are compiler warnings/errors...
 
-            if (isValid)
-            {
-                ToDoItem item;
-                item.type = m_Types[i];
-                item.filename = filename;
 
-                idx = pos + m_Types[i].Length();
-                wxChar c = _T('\0');
+				//Manager::Get()->GetLogManager()->DebugLog("Found %s %s style %s at %d", isValid ? "valid" : "invalid", m_isC ? "C" : "C++", allowedTypes[i].c_str(), pos);
 
-//Manager::Get()->GetLogManager()->DebugLog("1");
-                // skip to next non-blank char
-                while (idx < (int)buffer.Length())
-                {
-                    c = buffer.GetChar(idx);
-                    if (c != _T(' ') && c != _T('\t'))
-                        break;
-                    ++idx;
-                }
-//Manager::Get()->GetLogManager()->DebugLog("2");
-                // is it ours or generic todo?
-                if (c == _T('('))
-                {
-                    // it's ours, find user and/or priority
-                    ++idx; // skip (
-                    while (idx < (int)buffer.Length())
-                    {
-                        wxChar c1 = buffer.GetChar(idx);
-                        if (c1 != _T('#') && c1 != _T(')'))
-                        {
-                            // a little logic doesn't hurt ;)
+				ToDoItem item;
+				item.type = allowedTypes[i];
+				item.filename = filename;
 
-                            if (c1 == _T(' ') || c1 == _T('\t') || c1 == _T('\r') || c1 == _T('\n'))
-                            {
-                                // allow one consecutive space
-                                if (item.user.Last() != _T(' '))
-                                    item.user << _T(' ');
-                            }
-                            else
-                                item.user << c1;
-                        }
-                        else if (c1 == _T('#'))
-                        {
-                            // look for priority
-                            c1 = buffer.GetChar(++idx);
-                            allowedChars = _T("0123456789");
-                            if ((int)allowedChars.Index(c1) != wxNOT_FOUND)
-                                item.priorityStr << c1;
-                            // skip to start of text
-                            while (idx < (int)buffer.Length())
-                            {
-                                wxChar c2 = buffer.GetChar(idx++);
-                                if (c2 == _T(')') || c2 == _T('\r') || c2 == _T('\n'))
-                                    break;
-                            }
-                            break;
-                        }
-                        else
-                            break;
-                        ++idx;
-                    }
-                }
-//Manager::Get()->GetLogManager()->DebugLog("3");
-                // ok, we 've reached the actual todo text :)
-                // take everything up to the end of line or end of comment (if isC)
-                wxChar lastChar = _T('\0');
-                if (buffer.GetChar(idx) == _T(':'))
-                    ++idx;
-                while (idx < (int)buffer.Length())
-                {
-                    wxChar c1 = buffer.GetChar(idx++);
-                    if (c1 == _T('\r') || c1 == _T('\n'))
-                        break;
-                    if (isC && c1 == _T('/') && lastChar == _T('*'))
-                    {
-                        // remove last char '*'
-                        item.text.RemoveLast();
-                        break;
-                    }
-                    if (c1 == _T(' ') || c1 == _T('\t'))
-                    {
-                        // allow one consecutive space
-                        if (item.text.IsEmpty() || item.text.Last() != _T(' '))
-                            item.text << _T(' ');
-                    }
-                    else
-                        item.text << c1;
-                    lastChar = c1;
-                }
-//Manager::Get()->GetLogManager()->DebugLog("4");
-                // do some clean-up
-                item.text.Trim();
-                item.text.Trim(false);
-                item.user.Trim();
-                item.user.Trim(false);
-                item.line = CalculateLineNumber(buffer, pos);
-                item.lineStr << wxString::Format(_T("%d"), item.line + 1); // 1-based line number for list
-                m_ItemsMap[filename].push_back(item);
-                // m_Items.Add(item);
-            }
-            else
-                break; // invalid style...
+				idx = pos + allowedTypes[i].Length();
 
-            pos = buffer.find(m_Types[i], idx);
-        }
-//        Manager::Get()->GetLogManager()->DebugLog("Found it at %d", pos);
-    }
+				wxString allowedChars = _T(" \t/*");
+				wxChar c = _T('\0');
+
+				//Manager::Get()->GetLogManager()->DebugLog("1");
+				// skip to next non-blank char
+				while (idx < (int)current.m_comment.Length())
+				{
+					c = current.m_comment.GetChar(idx);
+					if (c != _T(' ') && c != _T('\t') && c != _T('\n'))
+						break;
+					++idx;
+				}
+				//Manager::Get()->GetLogManager()->DebugLog("2");
+				// is it ours or generic todo?
+				if (c == _T('('))
+				{
+					// it's ours, find user and/or priority
+					++idx; // skip (
+					while (idx < (int)current.m_comment.Length())
+					{
+						wxChar c1 = current.m_comment.GetChar(idx);
+						if (c1 != _T('#') && c1 != _T(')'))
+						{
+							// a little logic doesn't hurt ;)
+
+							if (c1 == _T(' ') || c1 == _T('\t') || c1 == _T('\r') || c1 == _T('\n'))
+							{
+								// allow one consecutive space
+								if (item.user.Last() != _T(' '))
+									item.user << _T(' ');
+							}
+							else
+								item.user << c1;
+						}
+						else if (c1 == _T('#'))
+						{
+							// look for priority
+							c1 = current.m_comment.GetChar(++idx);
+							allowedChars = _T("0123456789");
+							if ((int)allowedChars.Index(c1) != wxNOT_FOUND)
+								item.priorityStr << c1;
+							// skip to start of text
+							while (idx < (int)current.m_comment.Length())
+							{
+								wxChar c2 = current.m_comment.GetChar(idx++);
+								if (c2 == _T(')') || c2 == _T('\r') || c2 == _T('\n'))
+									break;
+							}
+							break;
+						}
+						else
+							break;
+						++idx;
+					}
+				}
+				//Manager::Get()->GetLogManager()->DebugLog("3");
+				// ok, we 've reached the actual todo text :)
+				// take everything up to the end of line or end of comment (if m_isC)
+				wxChar lastChar = _T('\0');
+				if (current.m_comment.GetChar(idx) == _T(':'))
+					++idx;
+				while (idx < (int)current.m_comment.Length())
+				{
+					wxChar c1 = current.m_comment.GetChar(idx++);
+					if (c1 == _T('\r') || c1 == _T('\n'))
+						break;
+					if (current.m_isC && c1 == _T('/') && lastChar == _T('*'))
+					{
+						// remove last char '*'
+						item.text.RemoveLast();
+						break;
+					}
+					if (c1 == _T(' ') || c1 == _T('\t'))
+					{
+						// allow one consecutive space
+						if (item.text.IsEmpty() || item.text.Last() != _T(' '))
+							item.text << _T(' ');
+					}
+					else
+						item.text << c1;
+					lastChar = c1;
+				}
+				//Manager::Get()->GetLogManager()->DebugLog("4");
+				// do some clean-up
+				item.text.Trim();
+				item.text.Trim(false);
+				item.user.Trim();
+				item.user.Trim(false);
+				item.line = CalculateLineNumber(buffer, current.m_posBegin + pos);
+				item.lineStr << wxString::Format(_T("%d"), item.line + 1); // 1-based line number for list
+				m_ItemsMap[filename].push_back(item);
+				m_Items.Add(item);
+
+				pos = current.m_comment.find(allowedTypes[i], idx);
+		//        Manager::Get()->GetLogManager()->DebugLog("Found it at %d", pos);
+			}
+
+		}
+
+		//current.logFile.Write();
+	}
 }
 
 int ToDoListView::CalculateLineNumber(const wxString& buffer, int upTo)
@@ -585,40 +572,110 @@
     }
 }
 
+
+bool ToDoListView::FindNextComment(const wxString& buffer, Comment * previous)
+{
+	wxString Str;
+	bool valid = false;
+	while(!valid)
+	{
+		// find beginning of next comment, aka "/"
+		Str = _("/");
+		previous->m_posBegin = buffer.find(Str, previous->m_posEnd);
+		if (previous->m_posBegin != -1)
+		{
+			//Test for C++ style
+			Str = _("/");
+			if (buffer.GetChar(previous->m_posBegin + 1) == Str)
+			{
+				// is is Single line so find the end
+				Str = _("\n");
+				previous->m_posEnd = buffer.find(Str, previous->m_posBegin);
+				if (previous->m_posEnd == -1)
+				{
+					//file ended without newline
+					previous->m_posEnd = buffer.Len() - 2;
+				}
+				previous->m_isC = false;
+				valid = true;
+			}
+			//Test for C style
+			else
+			{
+				Str = _("*");
+				if (buffer.GetChar(previous->m_posBegin + 1) == Str)
+				{
+					// is is Multiline so find the end
+					Str = _("*/");
+					previous->m_posEnd = buffer.find(Str, previous->m_posBegin);
+					if (previous->m_posEnd == -1)
+					{
+						//comment end not found
+						return false;
+					}
+					previous->m_isC = true;
+					previous->m_posEnd = previous->m_posEnd + 1;
+					valid = true;
+				}
+				//It is not a valid comment so search some more
+				else
+				{
+					previous->m_posEnd = previous->m_posBegin + 1;
+					valid = false;
+				}
+			}
+		}
+		else
+		{
+			return false;
+		}
+
+	}
+	previous->m_comment = buffer.Mid(previous->m_posBegin, (previous->m_posEnd - previous->m_posBegin) + 1);
+	return true;
+}
+
+
+
 void ToDoListView::OnComboChange(wxCommandEvent& event)
 {
-    Manager::Get()->GetConfigManager( _T("todo_list"))->Write(_T("source"), m_pSource->GetSelection() );
-    Parse();
+	Manager::Get()->GetConfigManager(_T("todo_list"))->Write(_T("source"), m_pSource->GetSelection());
+	Parse();
 }
 
 void ToDoListView::OnListItemSelected(wxCommandEvent& event)
 {
-    long index = control->GetNextItem(-1,
-                                     wxLIST_NEXT_ALL,
-                                     wxLIST_STATE_SELECTED);
-    if (index == -1)
-        return;
-    FocusEntry(index);
+	long index = control->GetNextItem(-1,
+							    wxLIST_NEXT_ALL,
+							    wxLIST_STATE_SELECTED);
+	if (index == -1)
+		return;
+	FocusEntry(index);
 }
 
+void ToDoListView::OnButtonTypes(wxCommandEvent& event)
+{
+	m_pAllowedTypesDlg->Show(!m_pAllowedTypesDlg->IsShown());
+}
+
 void ToDoListView::OnButtonRefresh(wxCommandEvent& event)
 {
-    Parse();
+	Parse();
 }
 
-void ToDoListView::OnDoubleClick( wxCommandEvent& event )
+void ToDoListView::OnDoubleClick(wxCommandEvent& event)
 {    // pecan 1/2/2006 12PM : Switched with OnListItemSelected by Rick 20/07/2007
-    long idx = control->GetNextItem(-1,
-                                     wxLIST_NEXT_ALL,
-                                     wxLIST_STATE_SELECTED);
-    if (idx == -1)
-        return;
+	long idx = control->GetNextItem(-1,
+							  wxLIST_NEXT_ALL,
+							  wxLIST_STATE_SELECTED);
+	if (idx == -1)
+		return;
 
-    wxString file = m_Items[idx].filename;
-    long int line = m_Items[idx].line;
+	wxString file = m_Items[idx].filename;
+	long int line = m_Items[idx].line;
 
-    if (file.IsEmpty() || line < 0)
-        return;
+	if (file.IsEmpty() || line < 0)
+		return;
 
     // jump to file/line selected
     cbEditor* ed = Manager::Get()->GetEditorManager()->Open(file);
@@ -643,3 +700,70 @@
     m_SortColumn = event.GetColumn();
     FillList();
 }
+
+
+CheckListDialog::CheckListDialog( wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style ) : wxDialog( parent, id, title, pos, size, style )
+{
+	this->SetSizeHints( wxDefaultSize, wxDefaultSize );
+
+	wxBoxSizer* bSizer122;
+	bSizer122 = new wxBoxSizer( wxVERTICAL );
+
+	wxArrayString m_checkList1Choices;
+	m_checkList1 = new wxCheckListBox( this, wxID_ANY, wxDefaultPosition, wxDefaultSize, m_checkList1Choices, 0 );
+	bSizer122->Add( m_checkList1, 1, wxEXPAND, 5 );
+
+	m_okBtn = new wxButton( this, wxID_ANY, wxT("OK"), wxDefaultPosition, wxDefaultSize, 0 );
+	bSizer122->Add( m_okBtn, 0, wxALIGN_CENTER_HORIZONTAL|wxTOP|wxBOTTOM, 5 );
+
+	this->SetSizer( bSizer122 );
+	this->Layout();
+
+	// Connect Events
+	m_okBtn->Connect( wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler( CheckListDialog::OkOnButtonClick ), NULL, this );
+}
+
+CheckListDialog::~CheckListDialog()
+{
+	// Disconnect Events
+	m_okBtn->Disconnect( wxEVT_COMMAND_BUTTON_CLICKED, wxCommandEventHandler( CheckListDialog::OkOnButtonClick ), NULL, this );
+}
+
+void CheckListDialog::OkOnButtonClick(wxCommandEvent& event)
+{
+	Show(false);
+    Manager::Get()->GetConfigManager(_T("todo_list"))->Write(_T("types_selected"), GetChecked());
+}
+
+bool CheckListDialog::IsChecked(wxString item)
+{
+	return m_checkList1->IsChecked(m_checkList1->FindString(item, true));
+}
+
+wxArrayString CheckListDialog::GetChecked()
+{
+	int item = 0;
+	wxArrayString items;
+	while(item < m_checkList1->GetCount())
+	{
+		if(m_checkList1->IsChecked(item))
+		{
+			items.Add(m_checkList1->GetString(item));
+		}
+		item++;
+	}
+	return items;
+}
+
+void CheckListDialog::SetChecked(wxArrayString items)
+{
+
+	int item = 0;
+	while(item < items.GetCount())
+	{
+		m_checkList1->Check(m_checkList1->FindString(items.Item(item), true));
+		item++;
+	}
+}
+
+
Index: src/plugins/todo/todolistview.h
===================================================================
--- src/plugins/todo/todolistview.h	(revision 6193)
+++ src/plugins/todo/todolistview.h	(working copy)
@@ -10,6 +10,7 @@
 #include "loggers.h"
 #include <vector>
 #include <map>
+#include <wx/textfile.h>
 using namespace std;
 
 class cbEditor;
@@ -32,10 +33,60 @@
     int priority;
 };
 
+class Comment
+{
+	public:
+		Comment()
+		{
+			/*if(!wxFileExists(_("c:\\log.txt")))
+			{
+				logFile.Create(_("c:\\log.txt"));
+			}
+			logFile.Open(_("c:\\log.txt"));
+			*/
+			m_posBegin = 0;
+			m_posEnd = 0;
+			m_isC = false;
+		}
+		~Comment()
+		{
+			//logFile.Close();
+		}
+		wxString m_comment;
+		int m_posBegin;
+		int m_posEnd;
+		bool m_isC;
+
+		//wxTextFile logFile;
+};
+
 typedef map<wxString,vector<ToDoItem> > TodoItemsMap;
 
 WX_DECLARE_OBJARRAY(ToDoItem, ToDoItems);
 
+class CheckListDialog : public wxDialog
+{
+	private:
+
+	protected:
+		wxCheckListBox* m_checkList1;
+
+		wxButton* m_okBtn;
+
+	public:
+
+		virtual void OkOnButtonClick( wxCommandEvent& event );
+		CheckListDialog( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = wxEmptyString, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( 150,180 ), long style = 0 );
+		~CheckListDialog();
+		bool IsChecked(wxString item);
+		void AddItem(const wxArrayString& items){m_checkList1->InsertItems(items, 0); }
+		void Clear(){m_checkList1->Clear();}
+		void SetChecked(wxArrayString items);
+		wxArrayString GetChecked();
+
+};
+
+
 class ToDoListView : public ListCtrlLogger, public wxEvtHandler
 {
     public:
@@ -47,6 +98,7 @@
         void ParseCurrent(bool forced);
         wxWindow* GetWindow(){ return m_pPanel; }
 
+        CheckListDialog * m_pAllowedTypesDlg;
     private:
         void LoadUsers();
         void FillList();
@@ -56,11 +108,13 @@
         void ParseFile(const wxString& filename);
         void ParseBuffer(const wxString& buffer, const wxString& filename);
         int CalculateLineNumber(const wxString& buffer, int upTo);
+        bool FindNextComment(const wxString& buffer, Comment *previous);
         void FocusEntry(size_t index);
 
         void OnComboChange(wxCommandEvent& event);
         void OnListItemSelected(wxCommandEvent& event);
         void OnButtonRefresh(wxCommandEvent& event);
+        void OnButtonTypes(wxCommandEvent& event);
         void OnDoubleClick( wxCommandEvent& event );
         void OnColClick( wxListEvent& event );
 
@@ -70,6 +124,7 @@
         wxComboBox* m_pSource;
         wxComboBox* m_pUser;
         wxButton* m_pRefresh;
+        wxButton* m_pAllowedTypes;
         const wxArrayString& m_Types;
         wxString m_LastFile;
         bool m_Ignore;
