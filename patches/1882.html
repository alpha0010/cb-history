<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Patch 1882 - Code::Blocks History</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css">

    <link rel="stylesheet" href="../pygments.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="navbar navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://www.codeblocks.org/">Code::Blocks</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../bugs.html">Bugs</a></li>
            <li><a href="../features.html">Features</a></li>
            <li class="active"><a href="../patches.html">Patches</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container" role="main">
      <div class="row">
        <div class="col-sm-8">
          <h3>Patch #1882 <small>2007-02-11 20:20</small></h3>
          <h4>pecan</h4>
          Debugging Console for Linux 
          <dl class="dl-horizontal">
            <dt>Download</dt>
            <dd><a href="1882-Debugging_Cons.patch">1882-Debugging_Cons.patch</a> (6.8 KB)</dd>
          </dl>
        </div>
        <div class="col-sm-4">
          <dl class="dl-horizontal">
            <dt>Category</dt><dd>&nbsp;</dd>
            <dt>Status</dt><dd>Accepted</dd>
            <dt>Close date</dt><dd>2007-04-12 11:21 <a href="http://cb.biplab.in/websvn/log.php?sr=3845"><span class="glyphicon glyphicon-link"></span></a></dd>
            <dt>Assigned to</dt><dd>&nbsp;</dd>
          </dl>
        </div>
      </div>
      <div class="highlight"><pre class="pre-scrollable"><span class="gh">Index: debuggergdb.cpp</span>
<span class="gh">===================================================================</span>
<span class="gd">--- debuggergdb.cpp    (revision 3676)</span>
<span class="gi">+++ debuggergdb.cpp    (working copy)</span>
<span class="gu">@@ -233,6 +233,10 @@</span>
     {
         NotifyMissingFile(_T(&quot;debugger.zip&quot;));
     }
<span class="gi">+    // vars for Linux console //(pecan 2007/2/06)</span>
<span class="gi">+    m_bIsConsole = false;</span>
<span class="gi">+    m_nConsolePid = 0;</span>
<span class="gi">+    m_ConsoleTty = wxEmptyString;</span>
 }
 
 DebuggerGDB::~DebuggerGDB()
<span class="gu">@@ -1021,6 +1025,21 @@</span>
     m_State.GetDriver()-&gt;Prepare(target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
     m_State.ApplyBreakpoints();
 
<span class="gi">+   #ifdef __WXGTK__    //(pecan 2007/2/05)</span>
<span class="gi">+    // create xterm and issue tty &quot;/dev/pts/#&quot; to GDB where</span>
<span class="gi">+    // # is the tty for the newly created xterm</span>
<span class="gi">+    m_bIsConsole = (target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);</span>
<span class="gi">+    if (m_bIsConsole)</span>
<span class="gi">+    {</span>
<span class="gi">+        if (RunNixConsole() &gt; 0 )</span>
<span class="gi">+        {   wxString gdbTtyCmd;</span>
<span class="gi">+            gdbTtyCmd &lt;&lt; wxT(&quot;tty &quot;) &lt;&lt; m_ConsoleTty;</span>
<span class="gi">+            m_State.GetDriver()-&gt;QueueCommand(new DebuggerCmd(m_State.GetDriver(), gdbTtyCmd, true));</span>
<span class="gi">+            DebugLog(wxString::Format( _(&quot;Queued:[%s]&quot;), gdbTtyCmd.c_str()) );</span>
<span class="gi">+        }</span>
<span class="gi">+    }//if</span>
<span class="gi">+   #endif//def __WXGTK__</span>
<span class="gi">+</span>
     // Don&#39;t issue &#39;run&#39; if attaching to a process (Bug #1391904)
     if (m_PidToAttach == 0)
         m_State.GetDriver()-&gt;Start(m_BreakOnEntry);
<span class="gu">@@ -1503,12 +1522,21 @@</span>
 
 void DebuggerGDB::Stop()
 {
<span class="gi">+    // m_Process is PipedProcess I/O; m_Pid is debugger pid</span>
     if (m_pProcess &amp;&amp; m_Pid)
     {
         if (IsStopped())
         {
             RunCommand(CMD_STOP);
             m_pProcess-&gt;CloseOutput();
<span class="gi">+           #ifdef __WXGTK__</span>
<span class="gi">+            // kill any linux console //(pecan 2007/2/06)</span>
<span class="gi">+            if ( m_bIsConsole &amp;&amp; (m_nConsolePid &gt; 0) )</span>
<span class="gi">+            {</span>
<span class="gi">+                ::wxKill(m_nConsolePid);</span>
<span class="gi">+                m_nConsolePid = 0;</span>
<span class="gi">+            }</span>
<span class="gi">+           #endif</span>
         }
         else
         {
<span class="gu">@@ -2214,3 +2242,108 @@</span>
 {
     Configure();
 }
<span class="gi">+// ----------------------------------------------------------------------------</span>
<span class="gi">+int DebuggerGDB::RunNixConsole()</span>
<span class="gi">+// ----------------------------------------------------------------------------</span>
<span class="gi">+{//(pecan 2007/3/09)</span>
<span class="gi">+</span>
<span class="gi">+    // start the xterm and put the shell to sleep with -e sleep 80000</span>
<span class="gi">+    // fetch the xterm tty so we can issue to gdb a &quot;tty /dev/pts/#&quot;</span>
<span class="gi">+    // redirecting program stdin/stdout/stderr to the xterm console.</span>
<span class="gi">+</span>
<span class="gi">+  #ifndef __WXMSW__</span>
<span class="gi">+    wxString cmd;</span>
<span class="gi">+    wxString title = wxT(&quot;Program Console&quot;);</span>
<span class="gi">+    m_nConsolePid = 0;</span>
<span class="gi">+    // for non-win platforms, use m_ConsoleTerm to run the console app</span>
<span class="gi">+    wxString term = Manager::Get()-&gt;GetConfigManager(_T(&quot;app&quot;))-&gt;Read(_T(&quot;/console_terminal&quot;), DEFAULT_CONSOLE_TERM);</span>
<span class="gi">+    term.Replace(_T(&quot;$TITLE&quot;), _T(&quot;&#39;&quot;) + title + _T(&quot;&#39;&quot;));</span>
<span class="gi">+    cmd &lt;&lt; term &lt;&lt; _T(&quot; &quot;);</span>
<span class="gi">+    cmd &lt;&lt; wxT(&quot;sleep &quot;);</span>
<span class="gi">+    cmd &lt;&lt; wxString::Format(wxT(&quot;%d&quot;),80000 + ::wxGetProcessId());</span>
<span class="gi">+</span>
<span class="gi">+    Manager::Get()-&gt;GetMacrosManager()-&gt;ReplaceEnvVars(cmd);</span>
<span class="gi">+    DebugLog(wxString::Format( _(&quot;Executing: %s&quot;), cmd.c_str()) );</span>
<span class="gi">+    //start xterm -e sleep {some unique # of seconds}</span>
<span class="gi">+    m_nConsolePid = wxExecute(cmd, wxEXEC_ASYNC);</span>
<span class="gi">+    if (m_nConsolePid &lt;= 0) return -1;</span>
<span class="gi">+</span>
<span class="gi">+    // Issue the PS command to get the /dev/tty device name</span>
<span class="gi">+    // First, wait for the xterm to settle down, else PS won&#39;t see the sleep task</span>
<span class="gi">+    Manager::Yield();</span>
<span class="gi">+    ::wxSleep(1);</span>
<span class="gi">+    m_ConsoleTty = GetConsoleTty(m_nConsolePid);</span>
<span class="gi">+    if (not m_ConsoleTty.IsEmpty() )</span>
<span class="gi">+    {   // show what we found as tty</span>
<span class="gi">+        DebugLog(wxString::Format(wxT(&quot;GetConsoleTTY[%s]ConsolePid[%d]&quot;),m_ConsoleTty.c_str(),m_nConsolePid));</span>
<span class="gi">+        return m_nConsolePid;</span>
<span class="gi">+    }</span>
<span class="gi">+    // failed to find the console tty</span>
<span class="gi">+    DebugLog( wxT(&quot;Console Execution error:failed to find console tty.&quot;));</span>
<span class="gi">+    if (m_nConsolePid != 0)::wxKill(m_nConsolePid);</span>
<span class="gi">+    m_nConsolePid = 0;</span>
<span class="gi">+  #endif//ndef __WWXMSW__</span>
<span class="gi">+    return -1;</span>
<span class="gi">+}</span>
<span class="gi">+// ----------------------------------------------------------------------------</span>
<span class="gi">+wxString DebuggerGDB::GetConsoleTty(int ConsolePid)</span>
<span class="gi">+// ----------------------------------------------------------------------------</span>
<span class="gi">+{//(pecan 2007/3/09)</span>
<span class="gi">+</span>
<span class="gi">+    // execute the ps x -o command  and read PS output to get the /dev/tty field</span>
<span class="gi">+</span>
<span class="gi">+    unsigned long ConsPid = ConsolePid;</span>
<span class="gi">+    wxString psCmd;</span>
<span class="gi">+    wxArrayString psOutput;</span>
<span class="gi">+    wxArrayString psErrors;</span>
<span class="gi">+</span>
<span class="gi">+    psCmd &lt;&lt; wxT(&quot;ps x -o tty,pid,command&quot;);</span>
<span class="gi">+    DebugLog(wxString::Format( _(&quot;Executing: %s&quot;), psCmd.c_str()) );</span>
<span class="gi">+    int result = wxExecute(psCmd, psOutput, psErrors, wxEXEC_SYNC);</span>
<span class="gi">+    psCmd.Clear();</span>
<span class="gi">+    if (result != 0)</span>
<span class="gi">+    {   psCmd &lt;&lt; wxT(&quot;Result of ps x:&quot;) &lt;&lt; result;</span>
<span class="gi">+        DebugLog(wxString::Format( _(&quot;Execution Error:&quot;), psCmd.c_str()) );</span>
<span class="gi">+        return wxEmptyString;</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    wxString ConsTtyStr;</span>
<span class="gi">+    wxString ConsPidStr;</span>
<span class="gi">+    ConsPidStr &lt;&lt; ConsPid;</span>
<span class="gi">+    //find task with our unique sleep time</span>
<span class="gi">+    wxString uniqueSleepTimeStr;</span>
<span class="gi">+    uniqueSleepTimeStr &lt;&lt; wxT(&quot;sleep &quot;) &lt;&lt; wxString::Format(wxT(&quot;%d&quot;),80000 + ::wxGetProcessId());</span>
<span class="gi">+    // search the output of &quot;ps pid&quot; command</span>
<span class="gi">+    in</span>
<em><strong>file truncated...</strong></em>
</pre></div>

      <h4 class="page-header">History</h4>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-02-11 20:22</div>
        <div class="panel-body">
          <p>This patch provides a debugging console facility for Linux.</p>
          <p>The user should also apply <a href="1881.html" data-toggle="tooltip" title="Fix for Debugger termination crashes">Patch 1881</a> to avoid crashes when the program is killed with the stop button.</p>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-02-11 21:01</div>
        <div class="panel-body">
          <pre class="pre-scrollable">Corrected Patch. The previous patch had two extra lines from path 1881 in it by mistake

Index: debuggergdb.cpp
===================================================================
--- debuggergdb.cpp	(revision 3590)
+++ debuggergdb.cpp	(working copy)
@@ -233,6 +233,11 @@
     {
         NotifyMissingFile(_T("debugger.zip"));
     }
+    // vars for Linux console //(pecan 2007/2/06)
+    m_bIsConsole = false;
+    m_nConsolePid = 0;
+    m_ConsoleTty = wxEmptyString;
+
 }

 DebuggerGDB::~DebuggerGDB()
@@ -1021,6 +1026,21 @@
     m_State.GetDriver()-&gt;Prepare(target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
     m_State.ApplyBreakpoints();

+   #ifdef __WXGTK__    //(pecan 2007/2/05)
+    // create xterm and issue tty "/dev/pts/#" to GDB where
+    // # is the tty for the newly created xterm
+    m_bIsConsole = (target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
+    if (m_bIsConsole)
+    {
+        if (RunNixConsole() &gt; 0 )
+        {   wxString gdbTtyCmd;
+            gdbTtyCmd &lt;&lt; wxT("tty ") &lt;&lt; m_ConsoleTty;
+            m_State.GetDriver()-&gt;QueueCommand(new DebuggerCmd(m_State.GetDriver(), gdbTtyCmd, true));
+            DebugLog(wxString::Format( _("Queued:[%s]"), gdbTtyCmd.c_str()) );
+        }
+    }//if
+   #endif//def __WXGTK__
+
     // Don't issue 'run' if attaching to a process (Bug #1391904)
     if (m_PidToAttach == 0)
         m_State.GetDriver()-&gt;Start(m_BreakOnEntry);
@@ -1503,12 +1523,21 @@

 void DebuggerGDB::Stop()
 {
+    // m_Process is PipedProcess I/O; m_Pid is debugger pid
     if (m_pProcess &amp;&amp; m_Pid)
     {
         if (IsStopped())
         {
             RunCommand(CMD_STOP);
             m_pProcess-&gt;CloseOutput();
+           #ifdef __WXGTK__
+            // kill any linux console //(pecan 2007/2/06)
+            if ( m_bIsConsole &amp;&amp; (m_nConsolePid &gt; 0) )
+            {
+                ::wxKill(m_nConsolePid);
+                m_nConsolePid = 0;
+            }
+           #endif
         }
         else
         {
@@ -1521,7 +1550,8 @@
                     _("Debug"), wxOK | wxICON_EXCLAMATION);
             else
         #endif
-            wxKill(pid, wxSIGINT);
+            if (pid &gt; 0)
+                wxKill(pid, wxSIGINT);
         #else
             m_pProcess-&gt;CloseOutput();
             wxKillError err = m_pProcess-&gt;Kill(m_Pid, wxSIGKILL);
@@ -2198,3 +2228,95 @@
 {
     Configure();
 }
+// ----------------------------------------------------------------------------
+int DebuggerGDB::RunNixConsole()
+// ----------------------------------------------------------------------------
+{
+    // start the xterm and put the shell to sleep with -e sleep 80000
+    // fetch the xterm tty so we can issue to gdb a "tty /dev/pts/#"
+    // redirecting program stdin/stdout/stderr to the xterm console.
+
+  #ifndef __WXMSW__
+    wxString cmd;
+    wxString title = wxT("Program Console");
+    m_nConsolePid = 0;
+    // for non-win platforms, use m_ConsoleTerm to run the console app
+    wxString term = Manager::Get()-&gt;GetConfigManager(_T("app"))-&gt;Read(_T("/console_terminal"), DEFAULT_CONSOLE_TERM);
+    //term.Replace(_T("$TITLE"), _T("'") + _T("*nixConsole") + _T("'"));
+    term.Replace(_T("$TITLE"), _T("'") + title + _T("'"));
+    cmd &lt;&lt; term &lt;&lt; _T(" ");
+    cmd &lt;&lt; wxT("sleep ");
+    cmd &lt;&lt; 80000 + ::wxGetProcessId(); //make a unique sleep command
+
+    Manager::Get()-&gt;GetMacrosManager()-&gt;ReplaceEnvVars(cmd);
+    //Manager::Get()-&gt;GetMessageManager()-&gt;Log(m_PageIndex, _("Executing: %s"), cmd.c_str() );
+    DebugLog(wxString::Format( _("Executing: %s"), cmd.c_str()) );
+    //start xterm -e sleep {some unique # of seconds}
+    m_nConsolePid = wxExecute(cmd, wxEXEC_ASYNC);
+    if (m_nConsolePid &lt;= 0) return -1;
+
+    // Issue the PS command with to get the /dev/tty device name
+    // First, wait for the xterm to settle down, else PS won't see the sleep task
+    Manager::Yield();
+    ::wxSleep(1);
+    m_ConsoleTty = GetConsoleTty(m_nConsolePid);
+    if (not m_ConsoleTty.IsEmpty() )
+        return m_nConsolePid;
+    // failed to find the console tty
+    DebugLog( wxT("Console Execution error:failed to find console tty."));
+    ::wxKill(m_nConsolePid);
+    m_nConsolePid = 0;
+  #endif//ndef __WWXMSW__
+    return -1;
+}
+// ----------------------------------------------------------------------------
+wxString DebuggerGDB::GetConsoleTty(int ConsolePid)
+// ----------------------------------------------------------------------------
+{
+    // execute the ps -x command  and read PS output to get the /dev/tty field
+
+	unsigned long ConsPid = ConsolePid;
+	wxString psCmd;
+	wxArrayString psOutput;
+	wxArrayString psErrors;
+
+	psCmd &lt;&lt; wxT("ps x");
+    DebugLog(wxString::Format( _("Executing: %s"), psCmd.c_str()) );
+	int result = wxExecute(psCmd, psOutput, psErrors, wxEXEC_SYNC);
+	psCmd.Clear();
+	if (result != 0)
+	{   psCmd &lt;&lt; wxT("Result of ps x:") &lt;&lt; result;
+        DebugLog(wxString::Format( _("Execution Error:"), psCmd.c_str()) );
+        return wxEmptyString;
+	}
+
+    wxString ConsTtyStr;
+    wxString ConsPidStr;
+    ConsPidStr &lt;&lt; ConsPid;
+    //find task with our unique sleep time
+    wxString uniqueSleepTimeStr;
+    uniqueSleepTimeStr &lt;&lt; wxT("sleep ") &lt;&lt; 80000 + ::wxGetProcessId();
+    // search the output of "ps pid" command
+    int knt = psOutput.GetCount();
+    for (int i=knt-1; i&gt;-1; --i)
+    {   psCmd = psOutput.Item(i);
+        DebugLog(wxString::Format( _("PS result: %s"), psCmd.c_str()) );
+        // find the pts/# or tty/# or whatever it's called
+        // by seaching the output or out "ps x" command.
+        // The output of ps looks like:
+        //   PID TTY      STAT   TIME COMMAND
+        // 8779 pts/3    Ss+    0:00 sleep 600000
+        //if (psCmd.Contains(ConsPidStr))
+        if (psCmd.Contains(uniqueSleepTimeStr))
+        {   ConsTtyStr = psCmd.Mid( ConsPidStr.Length()+2);
+            ConsTtyStr = wxT("/dev/")+ConsTtyStr.BeforeFirst(' ');
+            DebugLog(wxString::Format( _("TTY is[%s]"), ConsTtyStr.c_str()) );
+            return ConsTtyStr;
+        }//if
+    }//for
+
+    knt = psErrors.GetCount();
+    for (int i=0; i&lt;knt; ++i)
+        DebugLog(wxString::Format( _("PS Error:%s"), psErrors.Item(i).c_str()) );
+    return wxEmptyString;
+}
Index: debuggergdb.h
===================================================================
--- debuggergdb.h	(revision 3590)
+++ debuggergdb.h	(working copy)
@@ -205,6 +205,13 @@

         int m_HookId; // project loader hook ID

+        // Linux console support
+        int      RunNixConsole();
+        wxString GetConsoleTty(int ConsolePid);
+        bool     m_bIsConsole;
+        int      m_nConsolePid;
+        wxString m_ConsoleTty;
+
 		DECLARE_EVENT_TABLE()
 };

</pre>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-03-02 18:23</div>
        <div class="panel-body">
          <pre class="pre-scrollable">Update Linux Console patch for SVN 3536

Index: debuggergdb.cpp
===================================================================
--- debuggergdb.cpp	(revision 3659)
+++ debuggergdb.cpp	(working copy)
@@ -233,6 +233,10 @@
     {
         NotifyMissingFile(_T("debugger.zip"));
     }
+    // vars for Linux console //(pecan 2007/2/06)
+    m_bIsConsole = false;
+    m_nConsolePid = 0;
+    m_ConsoleTty = wxEmptyString;
 }

 DebuggerGDB::~DebuggerGDB()
@@ -1021,6 +1025,21 @@
     m_State.GetDriver()-&gt;Prepare(target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
     m_State.ApplyBreakpoints();

+   #ifdef __WXGTK__    //(pecan 2007/2/05)
+    // create xterm and issue tty "/dev/pts/#" to GDB where
+    // # is the tty for the newly created xterm
+    m_bIsConsole = (target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
+    if (m_bIsConsole)
+    {
+        if (RunNixConsole() &gt; 0 )
+        {   wxString gdbTtyCmd;
+            gdbTtyCmd &lt;&lt; wxT("tty ") &lt;&lt; m_ConsoleTty;
+            m_State.GetDriver()-&gt;QueueCommand(new DebuggerCmd(m_State.GetDriver(), gdbTtyCmd, true));
+            DebugLog(wxString::Format( _("Queued:[%s]"), gdbTtyCmd.c_str()) );
+        }
+    }//if
+   #endif//def __WXGTK__
+
     // Don't issue 'run' if attaching to a process (Bug #1391904)
     if (m_PidToAttach == 0)
         m_State.GetDriver()-&gt;Start(m_BreakOnEntry);
@@ -1503,12 +1522,21 @@

 void DebuggerGDB::Stop()
 {
+    // m_Process is PipedProcess I/O; m_Pid is debugger pid
     if (m_pProcess &amp;&amp; m_Pid)
     {
         if (IsStopped())
         {
             RunCommand(CMD_STOP);
             m_pProcess-&gt;CloseOutput();
+           #ifdef __WXGTK__
+            // kill any linux console //(pecan 2007/2/06)
+            if ( m_bIsConsole &amp;&amp; (m_nConsolePid &gt; 0) )
+            {
+                ::wxKill(m_nConsolePid);
+                m_nConsolePid = 0;
+            }
+           #endif
         }
         else
         {
@@ -2196,3 +2224,101 @@
 {
     Configure();
 }
+// ----------------------------------------------------------------------------
+int DebuggerGDB::RunNixConsole()
+// ----------------------------------------------------------------------------
+{
+    // start the xterm and put the shell to sleep with -e sleep 80000
+    // fetch the xterm tty so we can issue to gdb a "tty /dev/pts/#"
+    // redirecting program stdin/stdout/stderr to the xterm console.
+
+  #ifndef __WXMSW__
+    wxString cmd;
+    wxString title = wxT("Program Console");
+    m_nConsolePid = 0;
+    // for non-win platforms, use m_ConsoleTerm to run the console app
+    wxString term = Manager::Get()-&gt;GetConfigManager(_T("app"))-&gt;Read(_T("/console_terminal"), DEFAULT_CONSOLE_TERM);
+    //term.Replace(_T("$TITLE"), _T("'") + _T("*nixConsole") + _T("'"));
+    term.Replace(_T("$TITLE"), _T("'") + title + _T("'"));
+    cmd &lt;&lt; term &lt;&lt; _T(" ");
+    cmd &lt;&lt; wxT("sleep ");
+    cmd &lt;&lt; 80000 + ::wxGetProcessId(); //make a unique sleep command
+
+    Manager::Get()-&gt;GetMacrosManager()-&gt;ReplaceEnvVars(cmd);
+    //Manager::Get()-&gt;GetMessageManager()-&gt;Log(m_PageIndex, _("Executing: %s"), cmd.c_str() );
+    DebugLog(wxString::Format( _("Executing: %s"), cmd.c_str()) );
+    //start xterm -e sleep {some unique # of seconds}
+    m_nConsolePid = wxExecute(cmd, wxEXEC_ASYNC);
+    if (m_nConsolePid &lt;= 0) return -1;
+
+    // Issue the PS command to get the /dev/tty device name
+    // First, wait for the xterm to settle down, else PS won't see the sleep task
+    Manager::Yield();
+    ::wxSleep(1);
+    m_ConsoleTty = GetConsoleTty(m_nConsolePid);
+    if (not m_ConsoleTty.IsEmpty() )
+        return m_nConsolePid;
+    // failed to find the console tty
+    DebugLog( wxT("Console Execution error:failed to find console tty."));
+    ::wxKill(m_nConsolePid);
+    m_nConsolePid = 0;
+  #endif//ndef __WWXMSW__
+    return -1;
+}
+// ----------------------------------------------------------------------------
+wxString DebuggerGDB::GetConsoleTty(int ConsolePid)
+// ----------------------------------------------------------------------------
+{
+    // execute the ps -xo command  and read PS output to get the /dev/tty field
+
+	unsigned long ConsPid = ConsolePid;
+	wxString psCmd;
+	wxArrayString psOutput;
+	wxArrayString psErrors;
+
+	psCmd &lt;&lt; wxT("ps x -o tty,pid,command");
+    DebugLog(wxString::Format( _("Executing: %s"), psCmd.c_str()) );
+	int result = wxExecute(psCmd, psOutput, psErrors, wxEXEC_SYNC);
+	psCmd.Clear();
+	if (result != 0)
+	{   psCmd &lt;&lt; wxT("Result of ps x:") &lt;&lt; result;
+        DebugLog(wxString::Format( _("Execution Error:"), psCmd.c_str()) );
+        return wxEmptyString;
+	}
+
+    wxString ConsTtyStr;
+    wxString ConsPidStr;
+    ConsPidStr &lt;&lt; ConsPid;
+    //find task with our unique sleep time
+    wxString uniqueSleepTimeStr;
+    uniqueSleepTimeStr &lt;&lt; wxT("sleep ") &lt;&lt; 80000 + ::wxGetProcessId();
+    // search the output of "ps pid" command
+    int knt = psOutput.GetCount();
+    for (int i=knt-1; i&gt;-1; --i)
+    {   psCmd = psOutput.Item(i);
+        DebugLog(wxString::Format( _("PS result: %s"), psCmd.c_str()) );
+        // find the pts/# or tty/# or whatever it's called
+        // by seaching the output or out "ps x" command.
+        // The output of ps looks like:
+        // TT       PID   COMMAND
+        // pts/0    13342 /bin/sh ./run.sh
+        // pts/0    13343 /home/pecan/devel/trunk/src/devel/codeblocks
+        // pts/0    13361 /usr/bin/gdb -nx -fullname -quiet -args ./conio
+        // pts/0    13362 xterm -font -*-*-*-*-*-*-20-*-*-*-*-*-*-* -T Program Console -e sleep 93343
+        // pts/2    13363 sleep 93343
+        // ?        13365 /home/pecan/proj/conio/conio
+        // pts/1    13370 ps x -o tty,pid,command
+
+        if (psCmd.Contains(uniqueSleepTimeStr))
+        {   // found sleep 93343 string, extract tty field
+            ConsTtyStr = wxT("/dev/") + psCmd.BeforeFirst(' ');
+            DebugLog(wxString::Format( _("TTY is[%s]"), ConsTtyStr.c_str()) );
+            return ConsTtyStr;
+        }//if
+    }//for
+
+    knt = psErrors.GetCount();
+    for (int i=0; i&lt;knt; ++i)
+        DebugLog(wxString::Format( _("PS Error:%s"), psErrors.Item(i).c_str()) );
+    return wxEmptyString;
+}
Index: debuggergdb.h
===================================================================
--- debuggergdb.h	(revision 3659)
+++ debuggergdb.h	(working copy)
@@ -205,6 +205,13 @@

         int m_HookId; // project loader hook ID

+        // Linux console support
+        int      RunNixConsole();
+        wxString GetConsoleTty(int ConsolePid);
+        bool     m_bIsConsole;
+        int      m_nConsolePid;
+        wxString m_ConsoleTty;
+
 		DECLARE_EVENT_TABLE()
 };

</pre>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-03-09 15:14</div>
        <div class="panel-body">
          <p>Uploaded corrections to patch, especially for SlackWare</p>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">mandrav 2007-04-12 11:21</div>
        <div class="panel-body">
          <p>Patch applied.</p>
          <p>One thing to note though: the user can manually close the terminal and the debugger plugin does not know about it. This contains the risk of killing the wrong process when the debugger ends because the terminal's PID might be used by a different process by then...</p>
        </div>
      </div>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script>
      $(document).ready(function() {
        $("body").tooltip({ selector: '[data-toggle=tooltip]' });
      });
    </script>
  </body>
</html>