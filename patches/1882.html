<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Patch 1882 - Code::Blocks History</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap-theme.min.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="navbar navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://www.codeblocks.org/">Code::Blocks</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../bugs.html">Bugs</a></li>
            <li><a href="../features.html">Features</a></li>
            <li class="active"><a href="../patches.html">Patches</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container" role="main">
      <div class="row">
        <div class="col-sm-8">
          <h3>Patch #1882 <small>2007-02-11 20:20:52</small></h3>
          <h4>pecan</h4>
          Debugging Console for Linux 
          <dl class="dl-horizontal">
            <dt>Download</dt>
            <dd><a href="1882-Debugging_Cons.patch">1882-Debugging_Cons.patch</a></dd>
          </dl>
        </div>
        <div class="col-sm-4">
          <dl class="dl-horizontal">
            <dt>Category</dt><dd>&nbsp;</dd>
            <dt>Status</dt><dd>Accepted</dd>
            <dt>Close date</dt><dd>2007-04-12 11:21:52</dd>
            <dt>Assigned to</dt><dd>&nbsp;</dd>
          </dl>
        </div>
      </div>
      <h4 class="page-header">History</h4>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-02-11 20:22:38</div>
        <div class="panel-body">
          <p>This patch provides a debugging console facility for Linux.</p>
          <p>The user should also apply <a href="1881.html" data-toggle="tooltip" title="Fix for Debugger termination crashes">Patch 1881</a> to avoid crashes when the program is killed with the stop button.</p>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-02-11 21:01:59</div>
        <div class="panel-body">
          <pre class="pre-scrollable">Corrected Patch. The previous patch had two extra lines from path 1881 in it by mistake

Index: debuggergdb.cpp
===================================================================
--- debuggergdb.cpp	(revision 3590)
+++ debuggergdb.cpp	(working copy)
@@ -233,6 +233,11 @@
     {
         NotifyMissingFile(_T("debugger.zip"));
     }
+    // vars for Linux console //(pecan 2007/2/06)
+    m_bIsConsole = false;
+    m_nConsolePid = 0;
+    m_ConsoleTty = wxEmptyString;
+
 }

 DebuggerGDB::~DebuggerGDB()
@@ -1021,6 +1026,21 @@
     m_State.GetDriver()-&gt;Prepare(target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
     m_State.ApplyBreakpoints();

+   #ifdef __WXGTK__    //(pecan 2007/2/05)
+    // create xterm and issue tty "/dev/pts/#" to GDB where
+    // # is the tty for the newly created xterm
+    m_bIsConsole = (target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
+    if (m_bIsConsole)
+    {
+        if (RunNixConsole() &gt; 0 )
+        {   wxString gdbTtyCmd;
+            gdbTtyCmd &lt;&lt; wxT("tty ") &lt;&lt; m_ConsoleTty;
+            m_State.GetDriver()-&gt;QueueCommand(new DebuggerCmd(m_State.GetDriver(), gdbTtyCmd, true));
+            DebugLog(wxString::Format( _("Queued:[%s]"), gdbTtyCmd.c_str()) );
+        }
+    }//if
+   #endif//def __WXGTK__
+
     // Don't issue 'run' if attaching to a process (Bug #1391904)
     if (m_PidToAttach == 0)
         m_State.GetDriver()-&gt;Start(m_BreakOnEntry);
@@ -1503,12 +1523,21 @@

 void DebuggerGDB::Stop()
 {
+    // m_Process is PipedProcess I/O; m_Pid is debugger pid
     if (m_pProcess &amp;&amp; m_Pid)
     {
         if (IsStopped())
         {
             RunCommand(CMD_STOP);
             m_pProcess-&gt;CloseOutput();
+           #ifdef __WXGTK__
+            // kill any linux console //(pecan 2007/2/06)
+            if ( m_bIsConsole &amp;&amp; (m_nConsolePid &gt; 0) )
+            {
+                ::wxKill(m_nConsolePid);
+                m_nConsolePid = 0;
+            }
+           #endif
         }
         else
         {
@@ -1521,7 +1550,8 @@
                     _("Debug"), wxOK | wxICON_EXCLAMATION);
             else
         #endif
-            wxKill(pid, wxSIGINT);
+            if (pid &gt; 0)
+                wxKill(pid, wxSIGINT);
         #else
             m_pProcess-&gt;CloseOutput();
             wxKillError err = m_pProcess-&gt;Kill(m_Pid, wxSIGKILL);
@@ -2198,3 +2228,95 @@
 {
     Configure();
 }
+// ----------------------------------------------------------------------------
+int DebuggerGDB::RunNixConsole()
+// ----------------------------------------------------------------------------
+{
+    // start the xterm and put the shell to sleep with -e sleep 80000
+    // fetch the xterm tty so we can issue to gdb a "tty /dev/pts/#"
+    // redirecting program stdin/stdout/stderr to the xterm console.
+
+  #ifndef __WXMSW__
+    wxString cmd;
+    wxString title = wxT("Program Console");
+    m_nConsolePid = 0;
+    // for non-win platforms, use m_ConsoleTerm to run the console app
+    wxString term = Manager::Get()-&gt;GetConfigManager(_T("app"))-&gt;Read(_T("/console_terminal"), DEFAULT_CONSOLE_TERM);
+    //term.Replace(_T("$TITLE"), _T("'") + _T("*nixConsole") + _T("'"));
+    term.Replace(_T("$TITLE"), _T("'") + title + _T("'"));
+    cmd &lt;&lt; term &lt;&lt; _T(" ");
+    cmd &lt;&lt; wxT("sleep ");
+    cmd &lt;&lt; 80000 + ::wxGetProcessId(); //make a unique sleep command
+
+    Manager::Get()-&gt;GetMacrosManager()-&gt;ReplaceEnvVars(cmd);
+    //Manager::Get()-&gt;GetMessageManager()-&gt;Log(m_PageIndex, _("Executing: %s"), cmd.c_str() );
+    DebugLog(wxString::Format( _("Executing: %s"), cmd.c_str()) );
+    //start xterm -e sleep {some unique # of seconds}
+    m_nConsolePid = wxExecute(cmd, wxEXEC_ASYNC);
+    if (m_nConsolePid &lt;= 0) return -1;
+
+    // Issue the PS command with to get the /dev/tty device name
+    // First, wait for the xterm to settle down, else PS won't see the sleep task
+    Manager::Yield();
+    ::wxSleep(1);
+    m_ConsoleTty = GetConsoleTty(m_nConsolePid);
+    if (not m_ConsoleTty.IsEmpty() )
+        return m_nConsolePid;
+    // failed to find the console tty
+    DebugLog( wxT("Console Execution error:failed to find console tty."));
+    ::wxKill(m_nConsolePid);
+    m_nConsolePid = 0;
+  #endif//ndef __WWXMSW__
+    return -1;
+}
+// ----------------------------------------------------------------------------
+wxString DebuggerGDB::GetConsoleTty(int ConsolePid)
+// ----------------------------------------------------------------------------
+{
+    // execute the ps -x command  and read PS output to get the /dev/tty field
+
+	unsigned long ConsPid = ConsolePid;
+	wxString psCmd;
+	wxArrayString psOutput;
+	wxArrayString psErrors;
+
+	psCmd &lt;&lt; wxT("ps x");
+    DebugLog(wxString::Format( _("Executing: %s"), psCmd.c_str()) );
+	int result = wxExecute(psCmd, psOutput, psErrors, wxEXEC_SYNC);
+	psCmd.Clear();
+	if (result != 0)
+	{   psCmd &lt;&lt; wxT("Result of ps x:") &lt;&lt; result;
+        DebugLog(wxString::Format( _("Execution Error:"), psCmd.c_str()) );
+        return wxEmptyString;
+	}
+
+    wxString ConsTtyStr;
+    wxString ConsPidStr;
+    ConsPidStr &lt;&lt; ConsPid;
+    //find task with our unique sleep time
+    wxString uniqueSleepTimeStr;
+    uniqueSleepTimeStr &lt;&lt; wxT("sleep ") &lt;&lt; 80000 + ::wxGetProcessId();
+    // search the output of "ps pid" command
+    int knt = psOutput.GetCount();
+    for (int i=knt-1; i&gt;-1; --i)
+    {   psCmd = psOutput.Item(i);
+        DebugLog(wxString::Format( _("PS result: %s"), psCmd.c_str()) );
+        // find the pts/# or tty/# or whatever it's called
+        // by seaching the output or out "ps x" command.
+        // The output of ps looks like:
+        //   PID TTY      STAT   TIME COMMAND
+        // 8779 pts/3    Ss+    0:00 sleep 600000
+        //if (psCmd.Contains(ConsPidStr))
+        if (psCmd.Contains(uniqueSleepTimeStr))
+        {   ConsTtyStr = psCmd.Mid( ConsPidStr.Length()+2);
+            ConsTtyStr = wxT("/dev/")+ConsTtyStr.BeforeFirst(' ');
+            DebugLog(wxString::Format( _("TTY is[%s]"), ConsTtyStr.c_str()) );
+            return ConsTtyStr;
+        }//if
+    }//for
+
+    knt = psErrors.GetCount();
+    for (int i=0; i&lt;knt; ++i)
+        DebugLog(wxString::Format( _("PS Error:%s"), psErrors.Item(i).c_str()) );
+    return wxEmptyString;
+}
Index: debuggergdb.h
===================================================================
--- debuggergdb.h	(revision 3590)
+++ debuggergdb.h	(working copy)
@@ -205,6 +205,13 @@

         int m_HookId; // project loader hook ID

+        // Linux console support
+        int      RunNixConsole();
+        wxString GetConsoleTty(int ConsolePid);
+        bool     m_bIsConsole;
+        int      m_nConsolePid;
+        wxString m_ConsoleTty;
+
 		DECLARE_EVENT_TABLE()
 };

</pre>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-03-02 18:23:29</div>
        <div class="panel-body">
          <pre class="pre-scrollable">Update Linux Console patch for SVN 3536

Index: debuggergdb.cpp
===================================================================
--- debuggergdb.cpp	(revision 3659)
+++ debuggergdb.cpp	(working copy)
@@ -233,6 +233,10 @@
     {
         NotifyMissingFile(_T("debugger.zip"));
     }
+    // vars for Linux console //(pecan 2007/2/06)
+    m_bIsConsole = false;
+    m_nConsolePid = 0;
+    m_ConsoleTty = wxEmptyString;
 }

 DebuggerGDB::~DebuggerGDB()
@@ -1021,6 +1025,21 @@
     m_State.GetDriver()-&gt;Prepare(target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
     m_State.ApplyBreakpoints();

+   #ifdef __WXGTK__    //(pecan 2007/2/05)
+    // create xterm and issue tty "/dev/pts/#" to GDB where
+    // # is the tty for the newly created xterm
+    m_bIsConsole = (target &amp;&amp; target-&gt;GetTargetType() == ttConsoleOnly);
+    if (m_bIsConsole)
+    {
+        if (RunNixConsole() &gt; 0 )
+        {   wxString gdbTtyCmd;
+            gdbTtyCmd &lt;&lt; wxT("tty ") &lt;&lt; m_ConsoleTty;
+            m_State.GetDriver()-&gt;QueueCommand(new DebuggerCmd(m_State.GetDriver(), gdbTtyCmd, true));
+            DebugLog(wxString::Format( _("Queued:[%s]"), gdbTtyCmd.c_str()) );
+        }
+    }//if
+   #endif//def __WXGTK__
+
     // Don't issue 'run' if attaching to a process (Bug #1391904)
     if (m_PidToAttach == 0)
         m_State.GetDriver()-&gt;Start(m_BreakOnEntry);
@@ -1503,12 +1522,21 @@

 void DebuggerGDB::Stop()
 {
+    // m_Process is PipedProcess I/O; m_Pid is debugger pid
     if (m_pProcess &amp;&amp; m_Pid)
     {
         if (IsStopped())
         {
             RunCommand(CMD_STOP);
             m_pProcess-&gt;CloseOutput();
+           #ifdef __WXGTK__
+            // kill any linux console //(pecan 2007/2/06)
+            if ( m_bIsConsole &amp;&amp; (m_nConsolePid &gt; 0) )
+            {
+                ::wxKill(m_nConsolePid);
+                m_nConsolePid = 0;
+            }
+           #endif
         }
         else
         {
@@ -2196,3 +2224,101 @@
 {
     Configure();
 }
+// ----------------------------------------------------------------------------
+int DebuggerGDB::RunNixConsole()
+// ----------------------------------------------------------------------------
+{
+    // start the xterm and put the shell to sleep with -e sleep 80000
+    // fetch the xterm tty so we can issue to gdb a "tty /dev/pts/#"
+    // redirecting program stdin/stdout/stderr to the xterm console.
+
+  #ifndef __WXMSW__
+    wxString cmd;
+    wxString title = wxT("Program Console");
+    m_nConsolePid = 0;
+    // for non-win platforms, use m_ConsoleTerm to run the console app
+    wxString term = Manager::Get()-&gt;GetConfigManager(_T("app"))-&gt;Read(_T("/console_terminal"), DEFAULT_CONSOLE_TERM);
+    //term.Replace(_T("$TITLE"), _T("'") + _T("*nixConsole") + _T("'"));
+    term.Replace(_T("$TITLE"), _T("'") + title + _T("'"));
+    cmd &lt;&lt; term &lt;&lt; _T(" ");
+    cmd &lt;&lt; wxT("sleep ");
+    cmd &lt;&lt; 80000 + ::wxGetProcessId(); //make a unique sleep command
+
+    Manager::Get()-&gt;GetMacrosManager()-&gt;ReplaceEnvVars(cmd);
+    //Manager::Get()-&gt;GetMessageManager()-&gt;Log(m_PageIndex, _("Executing: %s"), cmd.c_str() );
+    DebugLog(wxString::Format( _("Executing: %s"), cmd.c_str()) );
+    //start xterm -e sleep {some unique # of seconds}
+    m_nConsolePid = wxExecute(cmd, wxEXEC_ASYNC);
+    if (m_nConsolePid &lt;= 0) return -1;
+
+    // Issue the PS command to get the /dev/tty device name
+    // First, wait for the xterm to settle down, else PS won't see the sleep task
+    Manager::Yield();
+    ::wxSleep(1);
+    m_ConsoleTty = GetConsoleTty(m_nConsolePid);
+    if (not m_ConsoleTty.IsEmpty() )
+        return m_nConsolePid;
+    // failed to find the console tty
+    DebugLog( wxT("Console Execution error:failed to find console tty."));
+    ::wxKill(m_nConsolePid);
+    m_nConsolePid = 0;
+  #endif//ndef __WWXMSW__
+    return -1;
+}
+// ----------------------------------------------------------------------------
+wxString DebuggerGDB::GetConsoleTty(int ConsolePid)
+// ----------------------------------------------------------------------------
+{
+    // execute the ps -xo command  and read PS output to get the /dev/tty field
+
+	unsigned long ConsPid = ConsolePid;
+	wxString psCmd;
+	wxArrayString psOutput;
+	wxArrayString psErrors;
+
+	psCmd &lt;&lt; wxT("ps x -o tty,pid,command");
+    DebugLog(wxString::Format( _("Executing: %s"), psCmd.c_str()) );
+	int result = wxExecute(psCmd, psOutput, psErrors, wxEXEC_SYNC);
+	psCmd.Clear();
+	if (result != 0)
+	{   psCmd &lt;&lt; wxT("Result of ps x:") &lt;&lt; result;
+        DebugLog(wxString::Format( _("Execution Error:"), psCmd.c_str()) );
+        return wxEmptyString;
+	}
+
+    wxString ConsTtyStr;
+    wxString ConsPidStr;
+    ConsPidStr &lt;&lt; ConsPid;
+    //find task with our unique sleep time
+    wxString uniqueSleepTimeStr;
+    uniqueSleepTimeStr &lt;&lt; wxT("sleep ") &lt;&lt; 80000 + ::wxGetProcessId();
+    // search the output of "ps pid" command
+    int knt = psOutput.GetCount();
+    for (int i=knt-1; i&gt;-1; --i)
+    {   psCmd = psOutput.Item(i);
+        DebugLog(wxString::Format( _("PS result: %s"), psCmd.c_str()) );
+        // find the pts/# or tty/# or whatever it's called
+        // by seaching the output or out "ps x" command.
+        // The output of ps looks like:
+        // TT       PID   COMMAND
+        // pts/0    13342 /bin/sh ./run.sh
+        // pts/0    13343 /home/pecan/devel/trunk/src/devel/codeblocks
+        // pts/0    13361 /usr/bin/gdb -nx -fullname -quiet -args ./conio
+        // pts/0    13362 xterm -font -*-*-*-*-*-*-20-*-*-*-*-*-*-* -T Program Console -e sleep 93343
+        // pts/2    13363 sleep 93343
+        // ?        13365 /home/pecan/proj/conio/conio
+        // pts/1    13370 ps x -o tty,pid,command
+
+        if (psCmd.Contains(uniqueSleepTimeStr))
+        {   // found sleep 93343 string, extract tty field
+            ConsTtyStr = wxT("/dev/") + psCmd.BeforeFirst(' ');
+            DebugLog(wxString::Format( _("TTY is[%s]"), ConsTtyStr.c_str()) );
+            return ConsTtyStr;
+        }//if
+    }//for
+
+    knt = psErrors.GetCount();
+    for (int i=0; i&lt;knt; ++i)
+        DebugLog(wxString::Format( _("PS Error:%s"), psErrors.Item(i).c_str()) );
+    return wxEmptyString;
+}
Index: debuggergdb.h
===================================================================
--- debuggergdb.h	(revision 3659)
+++ debuggergdb.h	(working copy)
@@ -205,6 +205,13 @@

         int m_HookId; // project loader hook ID

+        // Linux console support
+        int      RunNixConsole();
+        wxString GetConsoleTty(int ConsolePid);
+        bool     m_bIsConsole;
+        int      m_nConsolePid;
+        wxString m_ConsoleTty;
+
 		DECLARE_EVENT_TABLE()
 };

</pre>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">pecan 2007-03-09 15:14:31</div>
        <div class="panel-body">
          <p>Uploaded corrections to patch, especially for SlackWare</p>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading">mandrav 2007-04-12 11:21:52</div>
        <div class="panel-body">
          <p>Patch applied.</p>
          <p>One thing to note though: the user can manually close the terminal and the debugger plugin does not know about it. This contains the risk of killing the wrong process when the debugger ends because the terminal's PID might be used by a different process by then...</p>
        </div>
      </div>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script>
      $(document).ready(function() {
        $("body").tooltip({ selector: '[data-toggle=tooltip]' });
      });
    </script>
  </body>
</html>