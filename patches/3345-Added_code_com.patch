Index: plugins/codecompletion/parser/parserthread.cpp
===================================================================
--- plugins/codecompletion/parser/parserthread.cpp	(revision 8431)
+++ plugins/codecompletion/parser/parserthread.cpp	(working copy)
@@ -666,7 +666,8 @@
                 if (!m_Options.useBuffer || m_Options.bufferSkipBlocks)
                     SkipToOneOfChars(ParserConsts::semicolonclbrace, true, true);
                 else
-                    m_Tokenizer.GetToken(); // skip arguments
+                    HandleConditionalArguments();
+
                 m_Str.Clear();
             }
             else
@@ -682,7 +683,8 @@
                 if (!m_Options.useBuffer || m_Options.bufferSkipBlocks)
                     SkipToOneOfChars(ParserConsts::semicolonclbrace, true, true);
                 else
-                    m_Tokenizer.GetToken(); // skip arguments
+                    HandleForLoopArguments();
+
                 m_Str.Clear();
             }
             else
@@ -727,7 +729,8 @@
                 if (!m_Options.useBuffer || m_Options.bufferSkipBlocks)
                     SkipToOneOfChars(ParserConsts::semicolonclbrace, true, true);
                 else
-                    m_Tokenizer.GetToken(); // skip arguments
+                    HandleConditionalArguments();
+
                 m_Str.Clear();
             }
             else if (token == ParserConsts::kw_const)
@@ -2070,6 +2073,188 @@
     }
 }
 
+void ParserThread::HandleConditionalArguments()
+{
+    // if these aren't empty at this point, we have a syntax error
+    if (!m_Str.empty())
+        return;
+
+    if (!m_PointerOrRef.empty())
+        return;
+
+    if (!m_TemplateArgument.empty())
+        return;
+
+    // conditional arguments can look like this:
+    // (int i = 12)
+    // (Foo *bar = getFooBar())
+    // (var <= 12 && (getType() != 23))
+    wxString args = m_Tokenizer.GetToken();
+
+    // remove braces
+    if (args.StartsWith(_T("(")))
+        args = args.Mid(1, args.length() - 1);
+
+    if (args.EndsWith(_T(")")))
+        args = args.Mid(0, args.length() - 1);
+
+    // parse small tokens inside for loop head
+    TokenTree tree;
+    wxString fileName = m_Tokenizer.GetFilename();
+    Tokenizer smallTokenizer(&tree);
+
+    smallTokenizer.InitFromBuffer(args, fileName, m_Tokenizer.GetLineNumber());
+
+    while (IS_ALIVE)
+    {
+        wxString token = smallTokenizer.GetToken();
+        if (token.empty())
+            break;
+
+        wxString peek = smallTokenizer.PeekToken();
+
+        if (peek.empty())
+        {
+            if (!m_Str.empty())
+            {
+                // remove template argument if there is one
+                wxString varType, templateArgs;
+                RemoveTemplateArgs(m_Str, varType, templateArgs);
+
+                m_Str = varType;
+                m_TemplateArgument = templateArgs;
+
+                Token *newToken = DoAddToken(tkVariable, token, smallTokenizer.GetLineNumber());
+                if (newToken && !m_TemplateArgument.IsEmpty())
+                {
+                    ResolveTemplateArgs(newToken);
+                }
+                else
+                {
+                    TRACE(_T("HandleConditionalArguments() : Unable to create/add new token: ") + token);
+                }
+            }
+
+            break;
+        }
+        else
+        {
+            if (token == ParserConsts::ref_chr || token == ParserConsts::ptr_chr)
+            {
+                m_PointerOrRef << token;
+            }
+            else
+            {
+                if (!m_Str.empty())
+                    m_Str << _T(" ");
+
+                m_Str << token;
+            }
+        }
+    }
+
+    m_Str.clear();
+    m_PointerOrRef.clear();
+    m_TemplateArgument.clear();
+}
+
+void ParserThread::HandleForLoopArguments()
+{
+    // if these aren't empty at this point, we have a syntax error
+    if (!m_Str.empty())
+        return;
+
+    if (!m_PointerOrRef.empty())
+        return;
+
+    if (!m_TemplateArgument.empty())
+        return;
+
+    // for loop heads look like this:
+    // ([init1 [, init2 ...] ] ; [cond1 [, cond2 ..]]; [mod1 [, mod2 ..]])
+    wxString args = m_Tokenizer.GetToken();
+
+    // remove braces
+    if (args.StartsWith(_T("(")))
+        args = args.Mid(1, args.length() - 1);
+    if (args.EndsWith(_T(")")))
+        args = args.Mid(0, args.length() - 1);
+
+    // parse small tokens inside for loop head
+    TokenTree tree;
+    wxString fileName = m_Tokenizer.GetFilename();
+    Tokenizer smallTokenizer(&tree);
+
+    smallTokenizer.InitFromBuffer(args, fileName, m_Tokenizer.GetLineNumber());
+
+    while (IS_ALIVE)
+    {
+        wxString token = smallTokenizer.GetToken();
+        if (token.empty())
+            break;
+
+        wxString peek = smallTokenizer.PeekToken();
+
+        bool createNewToken = false;
+        bool finished = false;
+
+        if (peek == ParserConsts::comma)
+        {
+            smallTokenizer.GetToken(); // eat comma
+            createNewToken = true;
+        }
+        else if (peek == ParserConsts::colon
+                 || peek == ParserConsts::semicolon
+                 || peek.empty())
+        {
+            createNewToken = true;
+            finished = true; // after this point there will be no further declarations
+        }
+        else
+        {
+            if (token == ParserConsts::ref_chr || token == ParserConsts::ptr_chr)
+            {
+                m_PointerOrRef << token;
+            }
+            else
+            {
+                if (!m_Str.empty())
+                    m_Str << _T(" ");
+
+                m_Str << token;
+            }
+        }
+
+        if (createNewToken && !m_Str.empty())
+        {
+            // remove template argument if there is one
+            wxString name, templateArgs;
+            RemoveTemplateArgs(m_Str, name, templateArgs);
+
+            m_Str = name;
+            m_TemplateArgument = templateArgs;
+
+            Token *newToken = DoAddToken(tkVariable, token, smallTokenizer.GetLineNumber());
+            if (newToken && !m_TemplateArgument.IsEmpty())
+            {
+                ResolveTemplateArgs(newToken);
+            }
+            else
+            {
+                TRACE(_T("HandleForLoopArguments() : Unable to create/add new token: ") + token);
+            }
+
+        }
+
+        if (finished)
+            break;
+    }
+
+    m_Str.clear();
+    m_PointerOrRef.clear();
+    m_TemplateArgument.clear();
+}
+
 void ParserThread::HandleEnum()
 {
     // enums have the following rough definition:
@@ -2910,6 +3095,60 @@
         return false;
 }
 
+void ParserThread::RemoveTemplateArgs(const wxString &exp, wxString &expNoArgs, wxString &templateArgs)
+{
+    expNoArgs.clear();
+    templateArgs.clear();
+
+    int nestLvl = 0;
+    for (unsigned int i = 0; i < exp.length(); i++)
+    {
+        wxChar c = exp[i];
+
+        if (c == ParserConsts::lt_chr)
+        {
+            nestLvl++;
+            templateArgs << c;
+            continue;
+        }
+
+        if (c == ParserConsts::gt_chr)
+        {
+            nestLvl--;
+            templateArgs << c;
+            continue;
+        }
+
+        if (nestLvl == 0)
+        {
+            expNoArgs << c;
+        }
+        else
+        {
+            bool wanted = true;
+
+            // dont add unwanted whitespaces, i.e. ws around '<' and '>'
+            if(c == ParserConsts::space)
+            {
+                wxChar last = 0;
+                wxChar next = 0;
+
+                if (i > 0) last = exp[i - 1];
+                if (i < exp.length() - 1) next = exp[i + 1];
+
+                if (last == ParserConsts::gt || last == ParserConsts::lt)
+                    wanted = false;
+
+                if (next == ParserConsts::gt || next == ParserConsts::lt)
+                    wanted = false;
+            }
+
+            if (wanted == true)
+                templateArgs << c;
+        }
+    }
+}
+
 bool ParserThread::IsStillAlive(const wxString& funcInfo)
 {
     const bool alive = !TestDestroy();
Index: plugins/codecompletion/parser/parserthread.h
===================================================================
--- plugins/codecompletion/parser/parserthread.h	(revision 8431)
+++ plugins/codecompletion/parser/parserthread.h	(working copy)
@@ -198,6 +198,16 @@
       */
     void HandleFunction(const wxString& name, bool isOperator = false);
 
+    /** parse for loop arguments:
+      * for(int X; ... ; ...)
+      */
+    void HandleForLoopArguments();
+
+    /** parse arguments like:
+      * if(int X = getNumber())
+      */
+    void HandleConditionalArguments();
+
     /** handle enum declaration */
     void HandleEnum();
 
@@ -313,6 +323,14 @@
     bool ResolveTemplateMap(const wxString& typeStr, const wxArrayString& actuals,
                             std::map<wxString, wxString>& results);
 
+    /** remove template arguments from an expression
+      * example: 'std::list<string>' will be separated into 'std::list' and '<string>'
+      * @param expr Complete expression with template arguments
+      * @param expNoArgs Returned expression without template arguments
+      * @param templateArgs The removed template arguments
+    */
+    void RemoveTemplateArgs(const wxString& expr, wxString &expNoArgs, wxString &templateArgs);
+
     /** Only for debug */
     bool IsStillAlive(const wxString& funcInfo);
 
