Index: plugins/codecompletion/parser/parserthread.h
===================================================================
--- plugins/codecompletion/parser/parserthread.h	(revision 5213)
+++ plugins/codecompletion/parser/parserthread.h	(working copy)
@@ -86,8 +86,9 @@
         void HandleIncludes();
         void HandleDefines();
         void HandlePreprocessorBlocks(const wxString& preproc);
-        void HandleNamespace();
-        void HandleClass(bool isClass = true);
+        void HandleNamespace();
+        void ReadVarNames();
+        void HandleClass(int isType = 1 /* class */);
         void HandleFunction(const wxString& name, bool isOperator = false);
         void HandleEnum();
         void HandleTypedef();
Index: plugins/codecompletion/parser/parserthread.cpp
===================================================================
--- plugins/codecompletion/parser/parserthread.cpp	(revision 5213)
+++ plugins/codecompletion/parser/parserthread.cpp	(working copy)
@@ -525,7 +525,7 @@
         {
             m_Str.Clear();
             if (m_Options.handleClasses)
-                HandleClass(false);
+                HandleClass(0 /* structure */);
             else
                 SkipToOneOfChars(ParserConsts::semicolonclbrace, true);
         }
@@ -538,7 +538,8 @@
                 SkipToOneOfChars(ParserConsts::semicolonclbrace, true);
         }
         else if (token==ParserConsts::kw_union)
-        {
+        {
+#if 0
             SkipToOneOfChars(ParserConsts::opbracesemicolon);
 //            if (m_Tokenizer.GetToken() == "{")
             {
@@ -546,7 +547,14 @@
                 DoParse();
                 m_Str.Clear();
                 m_pLastParent = oldparent;
-            }
+            }
+#endif
+
+            m_Str.Clear();
+            if (m_Options.handleClasses)
+                HandleClass(2 /* union */);
+            else
+                SkipToOneOfChars(ParserConsts::semicolonclbrace, true);
         }
 #if 1
         else if (token==ParserConsts::kw_operator)
@@ -1101,9 +1109,31 @@
             SkipToOneOfChars(ParserConsts::semicolonopbrace); // some kind of error in code ?
         }
     }
+}
+
+void ParserThread::ReadVarNames()
+{
+	while (1)
+	{
+		wxString current = m_Tokenizer.GetToken();
+
+		if (current.IsEmpty())
+			break;
+		if (current==ParserConsts::comma)
+			continue;
+		else if (current==ParserConsts::semicolon)
+			break;
+		else if (wxIsalpha(current.GetChar(0)))
+		{
+			Manager::Get()->GetLogManager()->DebugLog(F(_T("Adding variable '%s' as '%s' to '%s'"), current.c_str(), m_Str.c_str(), (m_pLastParent?m_pLastParent->m_Name.c_str():_T("<no-parent>"))));
+			DoAddToken(tkVariable, current, m_Tokenizer.GetLineNumber());
+		}
+		else // unexpected
+			break;
+	}
 }
 
-void ParserThread::HandleClass(bool isClass)
+void ParserThread::HandleClass(int isType) // 0 - structure, 1 - class, 2 - union
 {
 	// need to force the tokenizer _not_ skip anything
 	// as we 're manually parsing class decls
@@ -1188,29 +1218,40 @@
 //                Manager::Get()->GetLogManager()->DebugLog(F(_T("Ancestors: ") + ancestors));
             }
 
-            if (current==ParserConsts::opbrace) // unnamed class/struct
+            if (current==ParserConsts::opbrace) // unnamed class/struct/union
             {
                 static size_t num = 0;
                 wxString unnamedTmp;
-                unnamedTmp.Printf(_T("Unnamed-%s-%d"), isClass ? _T("Class") : _T("Struct"), num++);
+                unnamedTmp.Printf(_T("Unnamed-%s-%d"), isType == 1 ? _T("Class") : isType == 2 ? _T("Union") : _T("Struct"), num++);
 
                 Token* newToken = DoAddToken(tkClass, unnamedTmp, lineNr);
 
                 Token* lastParent = m_pLastParent;
-                TokenScope lastScope = m_LastScope;
+                TokenScope lastScope = m_LastScope;
+                bool parsingTypedef = m_ParsingTypedef;
 
                 m_pLastParent = newToken;
-                // default scope is: private for classes, public for structs
-                m_LastScope = isClass ? tsPrivate : tsPublic;
+                // default scope is: private for classes, public for structs, public for unions
+                m_LastScope = isType == 1 ? tsPrivate : tsPublic;
+                m_ParsingTypedef = false;
 
-                DoParse();
-
-                m_pLastParent = lastParent;
+                DoParse();
+
+                m_ParsingTypedef = parsingTypedef;
+                m_pLastParent = lastParent;
                 m_LastScope = lastScope;
 
-                m_LastUnnamedTokenName = unnamedTmp; // used for typedef'ing anonymous class/struct/union
+                m_LastUnnamedTokenName = unnamedTmp; // used for typedef'ing anonymous class/struct/union
 
-                // we should now be right after the closing brace: read the var name
+                // we should now be right after the closing brace
+                // no vars are defined on a typedef, only types
+                // In the former example, aa is not part of the typedef.
+                if (m_ParsingTypedef)
+					break;
+
+				m_Str = newToken->m_Name;
+				ReadVarNames();
+                m_Str.Clear();
                 break;
             }
             else if (next==ParserConsts::opbrace)
@@ -1227,16 +1268,29 @@
                 m_Tokenizer.GetToken(); // eat {
 
                 Token* lastParent = m_pLastParent;
-                TokenScope lastScope = m_LastScope;
-
-                m_pLastParent = newToken;
-                // default scope is: private for classes, public for structs
-                m_LastScope = isClass ? tsPrivate : tsPublic;
-
-                DoParse();
-
+                TokenScope lastScope = m_LastScope;
+                bool parsingTypedef = m_ParsingTypedef;
+
+                m_pLastParent = newToken;
+                // default scope is: private for classes, public for structs, public for unions
+                m_LastScope = isType == 1 ? tsPrivate : tsPublic;
+                m_ParsingTypedef = false;
+
+                DoParse();
+
+                m_ParsingTypedef = parsingTypedef;
                 m_pLastParent = lastParent;
-                m_LastScope = lastScope;
+                m_LastScope = lastScope;
+
+                // we should now be right after the closing brace
+                // no vars are defined on a typedef, only types
+                // In the former example, aa is not part of the typedef.
+                if (m_ParsingTypedef)
+					break;
+
+				m_Str = newToken->m_Name;
+				ReadVarNames();
+				m_Str.Clear();
                 break;
             }
             else if (next==ParserConsts::semicolon) // forward decl; we don't care
@@ -1245,6 +1299,42 @@
             {
                 HandleFunction(current);
                 break;
+            }
+            else if (next.GetChar(0) != '*')
+            {
+                // might be instantiation, see the following
+				/*
+				struct HiddenStruct {
+			        int val;
+                };
+
+                struct HiddenStruct yy;
+				*/
+				if (TokenExists(current, m_pLastParent, tkClass))
+				{
+					if (!TokenExists(next, m_pLastParent, tkVariable) )
+					{
+						wxString farnext;
+
+						m_Tokenizer.GetToken(); // go ahead of identifier
+						farnext = m_Tokenizer.PeekToken();
+
+						if (farnext==ParserConsts::semicolon)
+						{
+							if (m_Options.handleVars)
+							{
+								m_Str = current;
+								DoAddToken(tkVariable, next, m_Tokenizer.GetLineNumber());
+								m_Str.Clear();
+							}
+
+							m_Tokenizer.GetToken(); // eat semi-colon
+							break;
+						}
+						else
+							m_Tokenizer.UngetToken(); // restore the identifier
+					}
+				}
             }
         }
         else
@@ -1366,9 +1456,33 @@
     unsigned int level = 0;
     if (wxIsalpha(token.GetChar(0)))
     {
-        if (m_Tokenizer.PeekToken().GetChar(0) != '{')
-            return;
+        if (m_Tokenizer.PeekToken().GetChar(0) != '{')
+        {
+			if (TokenExists(token, m_pLastParent, tkEnum))
+			{
+				if (!TokenExists(m_Tokenizer.PeekToken(), m_pLastParent, tkVariable) )
+				{
+					wxString ident = m_Tokenizer.GetToken(); // go ahead of identifier
+
+					if (m_Tokenizer.PeekToken()==ParserConsts::semicolon)
+					{
+						if (m_Options.handleEnums)
+						{
+							m_Str = token;
+							DoAddToken(tkVariable, ident, m_Tokenizer.GetLineNumber());
+							m_Str.Clear();
+						}
+
+						m_Tokenizer.GetToken(); // eat semi-colon
+					}
+					else
+						m_Tokenizer.UngetToken(); // restore the identifier
+				}
+			}
 
+            return;
+        }
+
         if (isUnnamed && !m_ParsingTypedef)
         {
             // for unnamed enums, look if we already have "Unnamed", so we don't
@@ -1377,14 +1491,15 @@
         }
 
         if (!newEnum) // either named or first unnamed enum
-            newEnum = DoAddToken(tkEnum, token, lineNr);
+            newEnum = DoAddToken(tkEnum, token, lineNr);
         level = m_Tokenizer.GetNestingLevel();
         m_Tokenizer.GetToken(); // skip {
     }
     else
     {
-        if (token.GetChar(0) != '{')
-            return;
+        if (token.GetChar(0) != '{')
+            return;
+
         level = m_Tokenizer.GetNestingLevel() - 1; // we 've already entered the { block
     }
 
@@ -1460,19 +1575,22 @@
 //        Manager::Get()->GetLogManager()->DebugLog(F(_T("tdef: token=%s, peek=%s"), token.c_str(), peek.c_str()));
         if (token.IsEmpty() || token == ParserConsts::semicolon)
             break;
-
+
+#if 0
         if (token == ParserConsts::kw_union)
         {
             // "typedef union" is not supported
             SkipToOneOfChars(ParserConsts::semicolon, true);
             break;
         }
-
-        else if (token == ParserConsts::kw_class ||
-            token == ParserConsts::kw_struct)
+        else
+#endif
+		if (token == ParserConsts::kw_class ||
+            token == ParserConsts::kw_struct ||
+            token == ParserConsts::kw_union)
         {
-            // "typedef struct|class"
-            HandleClass(token == ParserConsts::kw_class);
+            // "typedef struct|class|union"
+            HandleClass(token == ParserConsts::kw_class ? 1 : token == ParserConsts::kw_union ? 2 : 0);
             token = m_LastUnnamedTokenName;
         }
         else if (token == ParserConsts::kw_enum)
