Index: src/plugins/contrib/wxSmith/wxSmith-unix.cbp
===================================================================
--- src/plugins/contrib/wxSmith/wxSmith-unix.cbp	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxSmith-unix.cbp	(working copy)
@@ -46,13 +46,12 @@
 			<Add option="-DwxPG_USE_WXMODULE=0" />
 			<Add directory="../../../include" />
 			<Add directory="../../../sdk/wxscintilla/include" />
+			<Add directory="../../../sdk/wxpropgrid/include" />
 			<Add directory="../../../include/scripting/include" />
 			<Add directory="../../../include/scripting/squirrel" />
 			<Add directory="../../../include/scripting/sqplus" />
 			<Add directory="../../../include/scripting/bindings" />
-			<Add directory="propgrid/contrib/include" />
 			<Add directory="../../../include/mozilla_chardet" />
-			<Add directory="../../../sdk/wxpropgrid/include" />
 		</Compiler>
 		<Linker>
 			<Add option="`wx-config --libs`" />
@@ -474,6 +473,18 @@
 		<Unit filename="wxwidgets/defitems/wxshyperlinkctrl.h">
 			<Option target="wxSmithLib" />
 		</Unit>
+		<Unit filename="wxwidgets/defitems/wxsimage.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/defitems/wxsimage.h">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/defitems/wxsimagelist.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/defitems/wxsimagelist.h">
+			<Option target="wxSmithLib" />
+		</Unit>
 		<Unit filename="wxwidgets/defitems/wxslistbook.cpp">
 			<Option target="wxSmithLib" />
 		</Unit>
@@ -834,6 +845,12 @@
 		<Unit filename="wxwidgets/properties/wxsdimensionproperty.h">
 			<Option target="wxSmithLib" />
 		</Unit>
+		<Unit filename="wxwidgets/properties/wxseditenumproperty.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/properties/wxseditenumproperty.h">
+			<Option target="wxSmithLib" />
+		</Unit>
 		<Unit filename="wxwidgets/properties/wxsfonteditordlg.cpp">
 			<Option target="wxSmithLib" />
 		</Unit>
@@ -852,6 +869,24 @@
 		<Unit filename="wxwidgets/properties/wxsfontproperty.h">
 			<Option target="wxSmithLib" />
 		</Unit>
+		<Unit filename="wxwidgets/properties/wxsimagelistdlg.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/properties/wxsimagelistdlg.h">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/properties/wxsimagelistproperty.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/properties/wxsimagelistproperty.h">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/properties/wxsimageproperty.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets/properties/wxsimageproperty.h">
+			<Option target="wxSmithLib" />
+		</Unit>
 		<Unit filename="wxwidgets/properties/wxspositionsizeproperty.cpp">
 			<Option target="wxSmithLib" />
 		</Unit>
Index: src/plugins/contrib/wxSmith/wxSmith.cbp
===================================================================
--- src/plugins/contrib/wxSmith/wxSmith.cbp	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxSmith.cbp	(working copy)
@@ -503,6 +503,18 @@
 		<Unit filename="wxwidgets\defitems\wxshyperlinkctrl.h">
 			<Option target="wxSmithLib" />
 		</Unit>
+		<Unit filename="wxwidgets\defitems\wxsimage.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\defitems\wxsimage.h">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\defitems\wxsimagelist.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\defitems\wxsimagelist.h">
+			<Option target="wxSmithLib" />
+		</Unit>
 		<Unit filename="wxwidgets\defitems\wxslistbook.cpp">
 			<Option target="wxSmithLib" />
 		</Unit>
@@ -863,6 +875,12 @@
 		<Unit filename="wxwidgets\properties\wxsdimensionproperty.h">
 			<Option target="wxSmithLib" />
 		</Unit>
+		<Unit filename="wxwidgets\properties\wxseditenumproperty.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\properties\wxseditenumproperty.h">
+			<Option target="wxSmithLib" />
+		</Unit>
 		<Unit filename="wxwidgets\properties\wxsfonteditordlg.cpp">
 			<Option target="wxSmithLib" />
 		</Unit>
@@ -881,6 +899,24 @@
 		<Unit filename="wxwidgets\properties\wxsfontproperty.h">
 			<Option target="wxSmithLib" />
 		</Unit>
+		<Unit filename="wxwidgets\properties\wxsimagelistdlg.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\properties\wxsimagelistdlg.h">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\properties\wxsimagelistproperty.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\properties\wxsimagelistproperty.h">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\properties\wxsimageproperty.cpp">
+			<Option target="wxSmithLib" />
+		</Unit>
+		<Unit filename="wxwidgets\properties\wxsimageproperty.h">
+			<Option target="wxSmithLib" />
+		</Unit>
 		<Unit filename="wxwidgets\properties\wxspositionsizeproperty.cpp">
 			<Option target="wxSmithLib" />
 		</Unit>
@@ -1155,6 +1191,7 @@
 					<wxScrollingDialog wxs="wxsmith/wxsFontEditorDlg.wxs" src="wxwidgets/properties/wxsfonteditordlg.cpp" hdr="wxwidgets/properties/wxsfonteditordlg.h" name="wxsFontEditorDlg" language="CPP" />
 					<wxScrollingDialog wxs="wxsmith/wxsFontFaceEditorDlg.wxs" src="wxwidgets/properties/wxsfontfaceeditordlg.cpp" hdr="wxwidgets/properties/wxsfontfaceeditordlg.h" name="wxsFontFaceEditorDlg" language="CPP" />
 					<wxScrollingDialog wxs="wxsmith/wxsSimpleFontEditorDlg.wxs" src="wxwidgets/properties/wxssimplefonteditordlg.cpp" hdr="wxwidgets/properties/wxssimplefonteditordlg.h" name="wxsSimpleFontEditorDlg" language="CPP" />
+					<wxScrollingDialog wxs="wxsmith/wxsImageListDlg.wxs" src="wxwidgets/properties/wxsimagelistdlg.cpp" hdr="wxwidgets/properties/wxsimagelistdlg.h" name="wxsImageListDlg" language="CPP" />
 					<wxPanel wxs="wxsmith/wxWidgetsGUIConfigPanel.wxs" src="wxwidgets/wxwidgetsguiconfigpanel.cpp" hdr="wxwidgets/wxwidgetsguiconfigpanel.h" name="wxWidgetsGUIConfigPanel" language="CPP" />
 					<wxPanel wxs="wxsmith/wxsSizerParentQP.wxs" src="wxwidgets/wxssizerparentqp.cpp" hdr="wxwidgets/wxssizerparentqp.h" name="wxsSizerParentQP" language="CPP" />
 					<wxPanel wxs="wxsmith/wxsNotebookParentQP.wxs" src="wxwidgets/defitems/wxsnotebook.cpp" hdr="wxwidgets/defitems/wxsnotebook.cpp" name="wxsNotebookParentQP" language="CPP" />
Index: src/plugins/contrib/wxSmith/wxsmith/wxsImageListDlg.wxs
===================================================================
--- src/plugins/contrib/wxSmith/wxsmith/wxsImageListDlg.wxs	(revision 0)
+++ src/plugins/contrib/wxSmith/wxsmith/wxsImageListDlg.wxs	(revision 0)
@@ -0,0 +1,346 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<wxsmith>
+	<object class="wxScrollingDialog" name="wxsImageListDlg">
+		<size>400,317</size>
+		<bg>wxSYS_COLOUR_BTNFACE</bg>
+		<font>
+			<size>8</size>
+			<style>normal</style>
+			<weight>normal</weight>
+			<underlined>0</underlined>
+			<family>swiss</family>
+			<face>Arial</face>
+		</font>
+		<pos_arg>1</pos_arg>
+		<size_arg>1</size_arg>
+		<object class="wxStaticBox" name="ID_STATICBOX3" variable="StaticBox3" member="yes">
+			<label>Options</label>
+			<pos>200,104</pos>
+			<size>200,160</size>
+		</object>
+		<object class="wxStaticBox" name="ID_STATICBOX2" variable="StaticBox2" member="yes">
+			<label>Import From File</label>
+			<pos>0,104</pos>
+			<size>200,160</size>
+		</object>
+		<object class="wxStaticBox" name="ID_STATICBOX1" variable="StaticBox1" member="yes">
+			<label>Image List</label>
+			<pos>0,0</pos>
+			<size>400,104</size>
+		</object>
+		<object class="wxPanel" name="ID_PANEL1" variable="Panel1" member="yes">
+			<pos>8,144</pos>
+			<size>92,92</size>
+			<bg>wxSYS_COLOUR_HOTLIGHT</bg>
+			<tooltip>Click any spot on the image to select a transparent color</tooltip>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="OnPanel1Paint" entry="EVT_PAINT" />
+			<handler function="OnPanel1LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT1" variable="StaticText1" member="yes">
+			<label>Imported Image</label>
+			<pos>8,124</pos>
+			<size>92,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxPanel" name="ID_PANEL2" variable="Panel2" member="yes">
+			<pos>40,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel2LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL3" variable="Panel3" member="yes">
+			<pos>72,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel3LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL4" variable="Panel4" member="yes">
+			<pos>104,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel4LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL5" variable="Panel5" member="yes">
+			<pos>136,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel5LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL6" variable="Panel6" member="yes">
+			<pos>200,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel6LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL7" variable="Panel7" member="yes">
+			<pos>232,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel7LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL8" variable="Panel8" member="yes">
+			<pos>168,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel8LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL9" variable="Panel9" member="yes">
+			<pos>264,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel9LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL10" variable="Panel10" member="yes">
+			<pos>296,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel10LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxPanel" name="ID_PANEL11" variable="Panel11" member="yes">
+			<pos>328,48</pos>
+			<size>32,32</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="PaintPreviewPanel" entry="EVT_PAINT" />
+			<handler function="OnPanel11LeftUp" entry="EVT_LEFT_UP" />
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON1" variable="bLeft" member="yes">
+			<bitmap stock_id="wxART_GO_BACK" />
+			<default>1</default>
+			<pos>8,52</pos>
+			<handler function="OnbLeftClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON2" variable="bRight" member="yes">
+			<bitmap stock_id="wxART_GO_FORWARD" />
+			<default>1</default>
+			<pos>368,52</pos>
+			<handler function="OnbRightClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT2" variable="StaticText2" member="yes">
+			<label>1</label>
+			<pos>40,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT3" variable="StaticText3" member="yes">
+			<label>2</label>
+			<pos>72,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT4" variable="StaticText4" member="yes">
+			<label>3</label>
+			<pos>104,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT5" variable="StaticText5" member="yes">
+			<label>4</label>
+			<pos>136,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT6" variable="StaticText6" member="yes">
+			<label>5</label>
+			<pos>168,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT7" variable="StaticText7" member="yes">
+			<label>6</label>
+			<pos>200,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT8" variable="StaticText8" member="yes">
+			<label>7</label>
+			<pos>232,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT9" variable="StaticText9" member="yes">
+			<label>8</label>
+			<pos>264,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT10" variable="StaticText10" member="yes">
+			<label>9</label>
+			<pos>296,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT12" variable="StaticText12" member="yes">
+			<label>10</label>
+			<pos>328,80</pos>
+			<size>32,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxButton" name="ID_BUTTON1" variable="bOK" member="yes">
+			<label>OK</label>
+			<default>1</default>
+			<pos>72,280</pos>
+			<handler function="OnbOKClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxButton" name="ID_BUTTON4" variable="bCancel" member="yes">
+			<label>Cancel</label>
+			<pos>256,280</pos>
+			<handler function="OnbCancelClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON3" variable="bAdd" member="yes">
+			<bitmap stock_id="wxART_ADD_BOOKMARK" />
+			<pos>104,220</pos>
+			<style>wxBU_LEFT|wxBU_AUTODRAW</style>
+			<handler function="OnbAddClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON4" variable="bDel" member="yes">
+			<bitmap stock_id="wxART_DEL_BOOKMARK" />
+			<default>1</default>
+			<pos>304,144</pos>
+			<handler function="OnbDelClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT11" variable="StaticText11" member="yes">
+			<label>Add To List</label>
+			<pos>136,224</pos>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT13" variable="StaticText13" member="yes">
+			<label>Delete Image</label>
+			<pos>336,148</pos>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT14" variable="StaticText14" member="yes">
+			<label>Name</label>
+			<pos>8,20</pos>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT15" variable="StaticText15" member="yes">
+			<label>Label</label>
+			<pos>40,20</pos>
+			<size>96,18</size>
+			<style>wxST_NO_AUTORESIZE|wxSUNKEN_BORDER</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT16" variable="StaticText16" member="yes">
+			<label>Image Count</label>
+			<pos>144,20</pos>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT17" variable="StaticText17" member="yes">
+			<label>Label</label>
+			<pos>208,20</pos>
+			<size>32,18</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE|wxSUNKEN_BORDER</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT18" variable="StaticText18" member="yes">
+			<label>Image Size</label>
+			<pos>248,20</pos>
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON5" variable="bRead" member="yes">
+			<bitmap stock_id="wxART_FILE_OPEN" />
+			<default>1</default>
+			<pos>104,144</pos>
+			<handler function="OnbReadClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT20" variable="StaticText20" member="yes">
+			<label>Read File</label>
+			<pos>136,148</pos>
+		</object>
+		<object class="wxButton" name="ID_BUTTON2" variable="bColor" member="yes">
+			<label>C</label>
+			<pos>104,192</pos>
+			<size>24,24</size>
+			<handler function="OnbColorClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT21" variable="StaticText21" member="yes">
+			<label>Mask Color</label>
+			<pos>136,200</pos>
+		</object>
+		<object class="wxPanel" name="ID_PANEL12" variable="Panel12" member="yes">
+			<pos>208,144</pos>
+			<size>92,92</size>
+			<bg>#FFFFFF</bg>
+			<style>wxDOUBLE_BORDER|wxTAB_TRAVERSAL</style>
+			<handler function="OnPanel12Paint" entry="EVT_PAINT" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT22" variable="StaticText22" member="yes">
+			<label>Selected Image</label>
+			<pos>208,124</pos>
+			<size>92,16</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT23" variable="StaticText23" member="yes">
+			<label>Label</label>
+			<pos>8,240</pos>
+			<size>92,14</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT24" variable="StaticText24" member="yes">
+			<label>Clear List</label>
+			<pos>336,178</pos>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT25" variable="StaticText25" member="yes">
+			<label>Export BMP</label>
+			<pos>336,208</pos>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT19" variable="StaticText19" member="yes">
+			<label>x</label>
+			<pos>344,20</pos>
+		</object>
+		<object class="wxCheckBox" name="ID_CHECKBOX1" variable="cxTransparent" member="yes">
+			<label>Transparent</label>
+			<pos>108,174</pos>
+			<handler function="OncxTransparentClick" entry="EVT_CHECKBOX" />
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT26" variable="StaticText26" member="yes">
+			<label>16</label>
+			<pos>304,20</pos>
+			<size>32,18</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE|wxSUNKEN_BORDER</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT27" variable="StaticText27" member="yes">
+			<label>16</label>
+			<pos>360,20</pos>
+			<size>32,18</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE|wxSUNKEN_BORDER</style>
+		</object>
+		<object class="wxStaticText" name="ID_STATICTEXT28" variable="StaticText28" member="yes">
+			<label>Label</label>
+			<pos>208,240</pos>
+			<size>88,14</size>
+			<style>wxST_NO_AUTORESIZE|wxALIGN_CENTRE</style>
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON6" variable="bClear" member="yes">
+			<bitmap stock_id="wxART_DELETE" />
+			<default>1</default>
+			<pos>304,174</pos>
+			<handler function="OnbClearClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxBitmapButton" name="ID_BITMAPBUTTON7" variable="bSave" member="yes">
+			<bitmap stock_id="wxART_FILE_SAVE" />
+			<default>1</default>
+			<pos>304,204</pos>
+			<handler function="OnbSaveClick" entry="EVT_BUTTON" />
+		</object>
+		<object class="wxColourDialog" variable="ColourDialog1" member="yes" />
+		<object class="wxFileDialog" variable="FileDialog1" member="yes">
+			<message>Select output file</message>
+			<wildcard>Bitmap Files|*.bmp|All Files|*.*</wildcard>
+			<style>wxFD_SAVE|wxFD_OVERWRITE_PROMPT</style>
+		</object>
+	</object>
+</wxsmith>
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/Makefile.am
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/Makefile.am	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/Makefile.am	(working copy)
@@ -77,6 +77,7 @@
 ./wxsglcanvas.cpp \
 ./wxshyperlinkctrl.cpp \
 ./wxsanimationctrl.cpp \
+./wxsmediactrl.cpp \
 ./wxsfindreplacedialog.cpp \
 ./wxsfontdialog.cpp \
 ./wxsmessagedialog.cpp \
@@ -99,7 +100,9 @@
 ./wxsrichtextctrl.cpp \
 ./wxssearchctrl.cpp \
 ./wxssimplehtmllistbox.cpp \
-./wxstreebook.cpp
+./wxstreebook.cpp \
+./wxsimage.cpp \
+./wxsimagelist.cpp
 
 noinst_HEADERS = \
 ./wxsgauge.h \
@@ -167,6 +170,7 @@
 ./wxsglcanvas.h \
 ./wxshyperlinkctrl.h \
 ./wxsanimationctrl.h \
+./wxsmediactrl.h \
 ./wxsfindreplacedialog.h \
 ./wxsfontdialog.h \
 ./wxsmessagedialog.h \
@@ -189,6 +193,8 @@
 ./wxsrichtextctrl.h \
 ./wxssearchctrl.h \
 ./wxssimplehtmllistbox.h \
-./wxstreebook.h
+./wxstreebook.h \
+./wxsimage.h \
+./wxsimagelist.h
 
 
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsbitmapcombobox.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsbitmapcombobox.cpp	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsbitmapcombobox.cpp	(working copy)
@@ -1,7 +1,7 @@
 /** \file wxsbitmapcombobox.cpp
 *
 * This file is part of wxSmith plugin for Code::Blocks Studio
-* Copyright (C) 2006-2010 Gary Harris
+* Copyright (C) 2010 Gary Harris
 *
 * wxSmith is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
@@ -20,11 +20,10 @@
 
 #include <wx/bmpcbox.h>
 #include "wxsbitmapcombobox.h"
+#include "wxsimagelist.h"
+#include "../properties/wxsimagelistdlg.h"
 
-#include <wx/arrimpl.cpp> // This is a magic incantation which must be done!
-WX_DEFINE_OBJARRAY(BmpComboBitmapDataArray);
 
-
 namespace
 {
     wxsRegisterItem<wxsBitmapComboBox> Reg(_T("BitmapComboBox"), wxsTWidget, _T("Standard"), 350);
@@ -56,10 +55,8 @@
         &Reg.Info,
         wxsBitmapComboBoxEvents,
         wxsBitmapComboBoxStyles),
-    m_defaultSelection(-1),
-    m_iNumImages(0)
+    m_defaultSelection(-1)
 {
-    UpdateArraySizes(m_iNumImages);
 }
 
 /*! \brief Create the initial control.
@@ -93,12 +90,38 @@
                     }
                     Codef(_T(";\n"));
                 }
-				// SetItemBitmap() uses an unsigned int.
-				for(unsigned int i = 0;i < m_arrImagePaths.GetCount();i++){
-                    Codef(_T("%ASetItemBitmap(%d, wxBitmap(%n, wxBITMAP_TYPE_ANY));\n"), i, m_arrImagePaths[i].c_str());
+
+				// Find the image list.
+				wxsImageList *imageList = (wxsImageList *) wxsImageListDlg::FindTool(this, m_sImageList);
+				int iItemcount = m_arrChoices.GetCount();
+
+				wxString vv = GetVarName();
+				if(imageList){
+					wxString tt;
+					wxString ss = imageList->GetVarName();
+					int iImgCount = imageList->GetCount();
+					if(iImgCount > 0){
+						AddEventCode(_("\n"));
+					}
+					for(int i = 0;i < iImgCount;i++){
+						// Keep within the size limits of the combo box.
+						if(i >= iItemcount){
+							break;
+						}
+#if wxCHECK_VERSION(2, 9, 0)
+						tt.Printf(_("%s->SetItemBitmap(%d, %s->GetBitmap(%d));\n"), vv.wx_str(), i, ss.wx_str(), i);
+#else
+						tt.Printf(_("%s->SetItemBitmap(%d, %s->GetBitmap(%d));\n"), vv.c_str(), i, ss.c_str(), i);
+#endif
+						// add all the bitmaps at the bottom of the code... after the wxsImage's and wxsImageList's have been coded
+						AddEventCode(tt);
+					}
+					if(iImgCount > 0){
+						AddEventCode(_("\n"));
+					}
 				}
 
-                BuildSetupWindowCode();
+               BuildSetupWindowCode();
                 return;
             }
 
@@ -119,10 +142,22 @@
 wxObject *wxsBitmapComboBox::OnBuildPreview(wxWindow *Parent, long Flags)
 {
     wxBitmapComboBox *preview = new wxBitmapComboBox(Parent, GetId(), wxEmptyString, Pos(Parent), Size(Parent), m_arrChoices, Style());
-    // SetItemBitmap() uses an unsigned int.
-    for(unsigned int i = 0;i < m_arrImagePaths.GetCount();i++){
-		preview->SetItemBitmap(i, wxBitmap(m_arrImagePaths[i], wxBITMAP_TYPE_ANY));
-    }
+
+	// Find the image list.
+	wxsImageList *imageList = (wxsImageList *) wxsImageListDlg::FindTool(this, m_sImageList);
+
+	int count = preview->GetCount();
+	if(imageList){
+		for(int i = 0;i < imageList->GetCount();i++){
+			// Keep within the size limits of the combo box.
+			if(i >= count){
+				break;
+			}
+			// SetItemBitmap() uses an unsigned int.
+			preview->SetItemBitmap((unsigned)i, imageList->GetPreview(i));
+		}
+	}
+
     if(m_defaultSelection != -1){
 		preview->SetSelection(m_defaultSelection);
     }
@@ -140,180 +175,41 @@
 {
     WXS_ARRAYSTRING(wxsBitmapComboBox, m_arrChoices, _("Choices"), _T("content"), _T("item"))
     WXS_LONG(wxsBitmapComboBox, m_defaultSelection, _("Selection"), _T("selection"), -1)
-}
 
-/*! \brief Add extra control properties.
- *
- * \param Grid wxsPropertyGridManager*	A PropertyGridManager object.
- * \return void
- *
- */
- void wxsBitmapComboBox::OnAddExtraProperties(wxsPropertyGridManager *Grid)
-{
-    const wxString sPriorTo(_("Selection"));
-    wxString sImage(_("Image"));
-    wxString sImages(_("Images"));
+	static const wxChar	*pImageNames[128];
+	static long 					iImageNames[128];
+	int									i, n, iResCount;
+	wxsItemResData         *resData;
+	wxsTool                			*tool;
+	wxString						s;
+	wxsImageList           	*imageList;
+	static const wxString	sNone(_("<none>"));
 
-#if wxCHECK_VERSION(2, 9, 0) || wxCHECK_PROPGRID_VERSION(1, 4, 0)
-    Grid->SelectPage(0);
-#else
-    Grid->SetTargetPage(0);
-#endif
-    m_idNumImages = Grid->GetGrid()->Insert(sPriorTo, NEW_IN_WXPG14X wxIntProperty(_("Number of images"), wxPG_LABEL, m_iNumImages));
+	// find available images, and pointer to current imagelist
+    imageList = NULL;
+    resData = GetResourceData();
+    n = 0;
+    m_arrImageListNames[n] = sNone;
+    pImageNames[n] = (const wxChar *) m_arrImageListNames[n];
+    n += 1;
+    iResCount = resData->GetToolsCount();
+    for(i = 0;i < iResCount;i++){
+        tool = resData->GetTool(i);
+        s = tool->GetUserClass();
 
-    if(m_iNumImages > 0) {
-        m_idImages = Grid->GetGrid()->Insert(sPriorTo, NEW_IN_WXPG14X wxParentProperty(sImages.c_str(), wxPG_LABEL));
-	}
-    for(int i = 0; i < m_iNumImages; i++) {
-        m_arrBitmapIds[i] = Grid->GetGrid()->AppendIn(m_idImages, NEW_IN_WXPG14X wxImageFileProperty(wxString::Format(wxT("%s %d"), sImage.c_str(), i + 1), wxPG_LABEL));
-		Grid->SetPropertyValue(m_arrBitmapIds[i], m_arrImagePaths[i]);
-    }
+        if((s == _T("wxImageList")) && (n < 127)){
+            s = tool->GetVarName();
+            m_arrImageListNames[n] = s;
+            pImageNames[n] = (const wxChar *) m_arrImageListNames[n];
+            iImageNames[n] = n;
+            n += 1;
 
-    wxsWidget::OnAddExtraProperties(Grid);
-}
-
-/*! \brief One of the control's extra properties changed.
- *
- * \param Grid 	wxsPropertyGridManager*	A PropertyGridManager object.
- * \param id 		wxPGId										The property's ID.
- * \return void
- *
- */
-void wxsBitmapComboBox::OnExtraPropertyChanged(wxsPropertyGridManager *Grid, wxPGId Id)
-{
-    const wxString sPriorTo(_("Selection"));
-    wxString sImage(_("Image"));
-    wxString sImages(_("Images"));
-
-    // The "Number of images" field has changed.
-    if(Id == m_idNumImages) {
-        // Number of fields is going to change...
-        int iNewFields = Grid->GetPropertyValueAsInt(Id);
-        if(iNewFields < 0) {
-            iNewFields = 0;
-            Grid->SetPropertyValue(Id, iNewFields);
-        }
-
-        // Now it's time to delete / add properties for fields
-        if(iNewFields < m_iNumImages) {
-            for(int i = iNewFields;i < m_iNumImages;i++){
-#if wxCHECK_VERSION(2, 9, 0) || wxCHECK_PROPGRID_VERSION(1, 4, 0)
-                Grid->DeleteProperty(m_arrBitmapIds[i]);
-#else
-                Grid->Delete(m_arrBitmapIds[i]);
-#endif
-			}
-            // If there are no images, delete the parent field.
-            if(iNewFields == 0) {
-#if wxCHECK_VERSION(2, 9, 0) || wxCHECK_PROPGRID_VERSION(1, 4, 0)
-                Grid->DeleteProperty(m_idImages);
-#else
-                Grid->Delete(m_idImages);
-#endif
-                m_idImages = NULL;
+            if(s == m_sImageList){
+            	imageList = (wxsImageList *) tool;
             }
         }
-        else if(iNewFields > m_iNumImages){
-            // Adding new properties
-#if wxCHECK_VERSION(2, 9, 0) || wxCHECK_PROPGRID_VERSION(1, 4, 0)
-			Grid->SelectPage(0);
-#else
-			Grid->SetTargetPage(0);
-#endif
-			UpdateArraySizes(iNewFields);
-            // If the parent field was previously deleted, recreate it.
-            if(!m_idImages) {
-                m_idImages = Grid->GetGrid()->Insert(sPriorTo, NEW_IN_WXPG14X wxParentProperty(sImages.c_str(), wxPG_LABEL));
-            }
-            for(int i = m_iNumImages; i < iNewFields; i++) {
-                m_arrBitmapIds[i] = Grid->GetGrid()->AppendIn(m_idImages, NEW_IN_WXPG14X wxImageFileProperty(wxString::Format(wxT("%s %d"), sImage.c_str(), i + 1), wxPG_LABEL));
-            }
-        }
-
-        m_iNumImages = iNewFields;
-        NotifyPropertyChange(true);
-        return;
     }
-
-    // One of the image paths has changed.
-    for(int i = 0; i < m_iNumImages; i++) {
-        if(m_arrBitmapIds[i] == Id) {
-            m_arrImagePaths[i] = Grid->GetPropertyValueAsString(Id);
-            NotifyPropertyChange(true);
-            return;
-        }
-    }
-
-    wxsWidget::OnExtraPropertyChanged(Grid,Id);
+    pImageNames[n] = NULL;
+    WXS_EDITENUM(wxsBitmapComboBox, m_sImageList, _("Image List"), _T("image_list"), pImageNames, sNone)
 }
 
-/*! \brief Read XML control data.
- *
- * \param Element 	TiXmlElement*	A pointer to the parent node of the XML block.
- * \param IsXRC 		bool						Whether this is an XRC file.
- * \param IsExtra 		bool						Whether the data is extra information not conforming to the XRC standard.
- * \return bool											Success or failure.
- *
- */
- bool wxsBitmapComboBox::OnXmlRead(TiXmlElement *Element, bool IsXRC, bool IsExtra)
-{
-    if(IsXRC)
-    {
-        TiXmlElement *FieldsCnt = Element->FirstChildElement("num_images");
-        if(!FieldsCnt){
-            m_iNumImages = 0;
-        }
-        else{
-            m_iNumImages = wxAtoi(cbC2U(FieldsCnt->GetText()));
-        }
-
-        if(m_iNumImages < 0){
-			m_iNumImages = 0;
-        }
-        UpdateArraySizes(m_iNumImages);
-
-        for(int i = 0;i < m_iNumImages;i++){
-			wxString s = wxString::Format(_T("image_%d"), i);
-			if(TiXmlElement *ImageElem = Element->FirstChildElement(cbU2C(s))){
-				m_arrImagePaths[i] = cbC2U(ImageElem->GetText());
-			}
-        }
-    }
-
-    return wxsWidget::OnXmlRead(Element, IsXRC, IsExtra);
-}
-
-/*! \brief Write XML data.
- *
- * \param Element 	TiXmlElement*	A pointer to the parent node of the XML block.
- * \param IsXRC 		bool						Whether this is an XRC file.
- * \param IsExtra 		bool						Whether the data is extra information not conforming to the XRC standard.
- * \return bool											Success or failure.
- *
- */
- bool wxsBitmapComboBox::OnXmlWrite(TiXmlElement *Element, bool IsXRC, bool IsExtra)
-{
-    if(IsXRC)
-    {
-        Element->InsertEndChild(TiXmlElement("num_images"))->InsertEndChild(TiXmlText(cbU2C(wxString::Format(_T("%d"), m_iNumImages))));
-
-        for(int i = 0;i < m_iNumImages;i++){
-			wxString s = wxString::Format(_T("image_%d"), i);
-			Element->InsertEndChild(TiXmlElement(cbU2C(s)))->InsertEndChild(TiXmlText(cbU2C(m_arrImagePaths[i])));
-        }
-    }
-
-    return wxsWidget::OnXmlWrite(Element, IsXRC, IsExtra);
-}
-
-/*! \brief Update arrays sizes to match changes in the properties.
- *
- * \param 	size 	int	The new array size.
- * \return 	void
- *
- */
-void wxsBitmapComboBox::UpdateArraySizes(int size)
-{
-    m_arrBitmapIds.SetCount(size);
-    m_arrImagePaths.SetCount(size);
-}
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsbitmapcombobox.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsbitmapcombobox.h	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsbitmapcombobox.h	(working copy)
@@ -1,7 +1,7 @@
 /** \file wxsbitmapcombobox.h
 *
 * This file is part of wxSmith plugin for Code::Blocks Studio
-* Copyright (C) 2006-2010 Gary Harris
+* Copyright (C) 2010 Gary Harris
 *
 * wxSmith is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
@@ -38,24 +38,12 @@
         virtual void OnBuildCreatingCode();
         virtual wxObject* OnBuildPreview(wxWindow* Parent,long Flags);
         virtual void OnEnumWidgetProperties(long Flags);
-        virtual void OnAddExtraProperties(wxsPropertyGridManager* Grid);
-        virtual void OnExtraPropertyChanged(wxsPropertyGridManager* Grid,wxPGId Id);
-        virtual bool OnXmlRead(TiXmlElement* Element,bool IsXRC,bool IsExtra);
-        virtual bool OnXmlWrite(TiXmlElement* Element,bool IsXRC,bool IsExtra);
 
-		void UpdateArraySizes(int size);
+        wxArrayString 	m_arrChoices;											//!< Array of entries for the choice list.
+        long 					m_defaultSelection;									//!< The item selected by default.
+		wxString    		m_sImageList;                     						//!< The selected image list .
+		wxString    		m_arrImageListNames[128];					//!< Array of image list names.
 
-        wxArrayString 									m_arrChoices;			//!< Array of entries for the choice list.
-        long 													m_defaultSelection;	//!< The item selected by default.
-		BmpComboBitmapDataArray		m_arrBmps;					//!< Array of bitmaps for entries.
-
-		WX_DEFINE_ARRAY(wxPGId, IdsArray);							//!< Define an array of property IDs.
-
-		int											m_iNumImages;						//!< The number of images.
-		wxPGId     								m_idNumImages;					//!< The ID of the field containing the number of images.
-		wxPGId     								m_idImages;							//!< The ID of the image parent field.
-		wxArrayString						m_arrImagePaths;					//!< An array of paths to images.
-		IdsArray   								m_arrBitmapIds;						//!< An array of IDs of the image path fields.
 };
 
 #endif
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimage.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimage.cpp	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimage.cpp	(revision 0)
@@ -0,0 +1,249 @@
+/** \file wxsimage.cpp
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+
+#include "wxsimage.h"
+
+namespace
+{
+    wxsRegisterItem<wxsImage> Reg(_T("Image"), wxsTTool, _T("Tools"), 73);
+}
+
+wxsImage::wxsImage(wxsItemResData *Data) :
+    wxsTool(Data, &Reg.Info, 0, 0)
+{
+    int         n;
+    wxString    ss, tt;
+    wxFileName  fn;
+
+	// nothing selected yet
+    m_IsBuilt = false;
+    m_ImageData.Clear();
+    m_Include = false;
+
+	// make the absolute directory path where we store XPM image files
+	// this directory is always a sub-dir where the source code file is stored
+    fn = Data->GetSrcFileName();
+    ss = fn.GetPath((wxPATH_GET_VOLUME + wxPATH_GET_SEPARATOR));
+    n  = ss.Len();
+    ss = ss + _("wximages") + ss[n-1];
+
+    m_IDir = ss;
+    m_RDir = _("./wximages/");
+    m_Base = fn.GetName();
+}
+
+/*! \brief Create the initial control.
+ *
+ * \return void
+ *
+ */
+void wxsImage::OnBuildCreatingCode()
+{
+    wxString    inc;
+    wxString    vname;                  // this variable name
+    wxString    bname;                  // name of the bitmap variable
+    wxString    xname;                  // XPM data block name
+    wxString    ss, tt;                 // general use
+
+    // have we already been here?
+    if(m_IsBuilt) {
+        return;
+    }
+    m_IsBuilt = true;
+
+    switch(GetLanguage())
+    {
+        case wxsCPP:
+            {
+                vname = GetVarName();
+                bname = vname + _("_BMP");
+                xname = vname + _("_XPM");
+                AddHeader(_("<wx/image.h>"), GetInfo().ClassName, 0);
+                AddHeader(_("<wx/bitmap.h>"), GetInfo().ClassName, 0);
+
+                // store the XPM data someplace
+                StoreXpmData();
+
+                // if there is no data, then just make empty image and bitmap
+                if(m_ImageData.Count() == 0) {
+                    Codef(_T("%s = new wxImage();\n"), vname.c_str());
+                    Codef(_T("%s = new wxBitmap();\n"), bname.c_str());
+                }
+                // else fill it with XPM data
+                else {
+                    Codef(_T("%s = new wxImage(%s);\n"),  vname.c_str(), xname.c_str());
+                    Codef(_T("%s = new wxBitmap(%s);\n"), bname.c_str(), xname.c_str());
+                }
+
+                BuildSetupWindowCode();
+                return;
+            }
+
+        default:
+            {
+                wxsCodeMarks::Unknown(_T("wxsImage::OnBuildCreatingCode"), GetLanguage());
+            }
+    }
+}
+
+/*! \brief Enumerate the tool's properties.
+ *
+ * \param flags long	The control flags.
+ * \return void
+ *
+ */
+void wxsImage::OnEnumToolProperties(long Flags)
+{
+	// starting a new build cycle
+    m_IsBuilt = false;
+    m_Context = GetCoderContext();
+
+	// details
+    WXS_IMAGE(wxsImage, m_ImageData, _("Image"), _T("image"));
+    WXS_ARRAYSTRING(wxsImage, m_ImageData, _("Image as Text"), _T("image_text"), _("item2"));
+    WXS_BOOL(wxsImage, m_Include, _("Use Include File"), _T("use_include"), false);
+};
+
+/*! \brief Declare the var with a bitmap.
+ *
+ * \return void
+ *
+ */
+void wxsImage::OnBuildDeclarationsCode()
+{
+    wxString    vname;
+    wxString    bname;
+
+    vname = GetVarName();
+    bname = vname + _T("_BMP");
+
+	// put in all the vars, although some might be ignored later
+    AddDeclaration(_T("wxImage               *") + vname + _T(";"));
+    AddDeclaration(_T("wxBitmap              *") + bname + _T(";"));
+}
+
+/*! \brief Save the XPM data block; may be stored as a #include file.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImage::StoreXpmData(void) {
+    int         		i, n;
+    wxString    vname;
+    wxString    xname;
+    wxString    ss, tt;
+    wxFile      	ff;
+
+	// nothing to store?
+    if(m_ImageData.Count() == 0) return;
+
+	// important names
+    vname = GetVarName();
+    xname = vname + _T("_XPM");
+
+	// make a single string with the proper name
+    tt = _T("");
+    n = m_ImageData.GetCount();
+    if(n > 5){
+        n = (n * m_ImageData.Item(n - 2).Length()) + 100;
+        tt.Alloc(n);
+    }
+
+    for(i = 0;i < (int)m_ImageData.GetCount();i++){
+        ss = m_ImageData.Item(i);
+        if(ss.Find(_T("xpm_data")) >= 0){
+        	ss.Replace(_T("xpm_data"), xname);
+        }
+
+        tt += ss;
+        tt += _T("\n");
+    }
+
+	// store as an include file
+    if(m_Include) {
+        if(! wxFileName::DirExists(m_IDir)){
+        	wxFileName::Mkdir(m_IDir);
+        }
+        ss  = m_IDir;
+        ss += m_Base;
+        ss += _T("_");
+        ss += xname;
+        ss += _T(".xpm");
+        ff.Open(ss, wxFile::write);
+        ff.Write(tt);
+        ff.Close();
+
+        ss = _T("\"");
+        ss += m_RDir;
+        ss += m_Base;
+        ss += _T("_");
+        ss += xname;
+        ss += _T(".xpm");
+        ss += _T("\"");
+
+        AddHeader(ss, GetInfo().ClassName, 0);
+    }
+	// store in-line in the main header file
+    else {
+        Codef(tt);
+    }
+}
+
+/*! \brief Get an image preview.
+ *
+ * \param void
+ * \return wxBitmap
+ *
+ */
+wxBitmap wxsImage::GetPreview(void)
+{
+    wxBitmap    bmp;
+
+    if(m_ImageData.GetCount() == 0){
+    	return wxNullBitmap;
+    }
+
+    wxsImageListDlg::ArrayToBitmap(m_ImageData, bmp);
+    return bmp;
+}
+
+/*! \brief This just exposes the "OnBuildCreatingCode()" method.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImage::DoBuild(void)
+{
+    BuildCode(m_Context);
+}
+
+
+
+
+
+
+
+
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimage.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimage.h	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimage.h	(revision 0)
@@ -0,0 +1,58 @@
+/** \file wxsimage.h
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#ifndef WXSIMAGE_H
+#define WXSIMAGE_H
+
+#include "../wxstool.h"
+#include "../wxsitemresdata.h"
+
+/*! \brief Class for the wxsImage tool.  */
+class wxsImage : public wxsTool
+{
+    public:
+
+        wxsImage(wxsItemResData* Data);
+        wxBitmap  GetPreview(void);
+        void            DoBuild(void);
+
+
+    private:
+
+        virtual void        OnBuildCreatingCode();
+        virtual void        OnEnumToolProperties(long Flags);
+        virtual void        OnBuildDeclarationsCode();
+
+		void StoreXpmData(void);
+
+        bool            				m_IsBuilt;              //!<  Only build the code once.
+        wxsCoderContext 	*m_Context;			//!< Coder context.
+        wxArrayString   		m_ImageData;     //!< The XPM data for the image.
+        bool            				m_Include;            //!< Save as #include file?
+        wxString        			m_Base;                //!< Base file name of source and include files.
+        wxString        			m_IDir;                   //!< The absolute path to the image include directory.
+        wxString        			m_RDir;                 //!< Relative directory specified for image files.
+};
+
+
+#endif      // WXSIMAGE_H
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimagelist.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimagelist.cpp	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimagelist.cpp	(revision 0)
@@ -0,0 +1,356 @@
+/** \file wxsimagelist.cpp
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#include "wxsimagelist.h"
+
+namespace
+{
+    wxsRegisterItem<wxsImageList> Reg(_T("ImageList"), wxsTTool, _T("Tools"), 72);
+}
+
+wxsImageList::wxsImageList(wxsItemResData *Data):
+    wxsTool(Data, &Reg.Info, 0, 0)
+{
+    int         n;
+    wxString    ss, tt;
+    wxFileName  fn;
+
+    m_IsBuilt = false;
+    m_ImageData.Clear();
+    m_Width   = 16;
+    m_Height  = 16;
+    m_Count   = 0;
+    m_Include = false;
+
+    // make the absolute directory path where we store XPM image files
+    // this directory is always a sub-dir where the source code file is stored
+    fn = Data->GetSrcFileName();
+    ss = fn.GetPath((wxPATH_GET_VOLUME + wxPATH_GET_SEPARATOR));
+    n  = ss.Len();
+    ss = ss + _T("wximages") + ss[n-1];
+
+    m_IDir = ss;
+    m_RDir = _T("./wximages/");
+    m_Base = fn.GetName();
+}
+
+/*! \brief Create the initial control.
+ *
+ * \return void
+ *
+ */
+void wxsImageList::OnBuildCreatingCode()
+{
+    int         i;
+    wxString    inc;
+    wxString    vname;                  // this variable name
+    wxString    bname;                  // name of the bitmap variable
+    wxString    fbase;                  // base name of XPM file without dirs or extension
+    wxString    fabs;                   // absolute name of XPM file
+    wxString    frel;                   // relative
+    wxString    dname;                  // name of XPM data array
+    wxBitmap  bmp;                    // preview bitmap saved as XPM
+    wxString    ss, tt;                 // general use
+
+    // have we already been here?
+    if(m_IsBuilt){
+        return;
+    }
+    m_IsBuilt = true;
+
+    switch(GetLanguage())
+    {
+        case wxsCPP:
+            {
+                AddHeader(_("<wx/imaglist.h>"), GetInfo().ClassName, 0);
+
+                // store the XPM data someplace
+                StoreXpmData();
+
+            	vname = GetVarName();
+                // if there is no data, then just make empty image and bitmap
+                if(m_Count == 0){
+                    Codef(_T("%s = new wxImageList(%d, %d, 1);\n"), vname.c_str(), m_Width, m_Height);
+                }
+                // else fill it with XPM data
+                else{
+                    Codef(_T("%s = new wxImageList(%d, %d, %d);\n"),  vname.c_str(), m_Width, m_Height, (m_Count + 1));
+                    for(i = 0; i < m_Count; i++) {
+                        ss.Printf(_("%s_%d_XPM"), vname.c_str(), i);
+                        Codef(_T("%s->Add(wxBitmap(%s));\n"), vname.c_str(), ss.c_str());
+                    }
+                }
+
+                BuildSetupWindowCode();
+                return;
+            }
+
+        default:
+            {
+                wxsCodeMarks::Unknown(_T("wxsImageList::OnBuildCreatingCode"), GetLanguage());
+            }
+    }
+}
+
+/*! \brief Enumerate the tool's properties.
+ *
+ * \param flags long	The control flags.
+ * \return void
+ *
+ */
+void wxsImageList::OnEnumToolProperties(long Flags)
+{
+    // starting a new build cycle
+    m_IsBuilt = false;
+    m_Context = GetCoderContext();
+
+    // details for the image list
+    WXS_IMAGELIST(wxsImageList, m_ImageData, _T("Image List"), _T("image_list"));
+    WXS_ARRAYSTRING(wxsImageList, m_ImageData, _("Images as Text"), _T("image_text"), _T("item2"));
+    WXS_LONG(wxsImageList, m_Width,   _("Image Width"),      _T("image_width"),   16);
+    WXS_LONG(wxsImageList, m_Height,  _("Image Height"),     _T("image_height"),  16);
+    WXS_LONG(wxsImageList, m_Count,   _("Image Count"),      _T("image_count"),   0);
+    WXS_BOOL(wxsImageList, m_Include, _("Use Include File"), _T("use_include"), false);
+};
+
+/*! \brief Save XPM data either in the code or in a separate header file.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImageList::StoreXpmData(void)
+{
+    int         i, n;
+    long        ll;
+    wxString    vname;
+    wxString    xname;
+    wxString    ss, tt, vv;
+    wxFile      ff;
+
+	// important names
+    vname = GetVarName();
+
+	// if no XPM images, then just store the image size
+    n = m_ImageData.GetCount();
+    if(n <= 2){
+        if(m_Width <= 0) m_Width = 16;
+        if(m_Height <= 0) m_Height = 16;
+        m_Count = 0;
+
+        m_ImageData.Clear();
+        ss.Printf(_T("%d"), m_Width);
+        m_ImageData.Add(ss);
+
+        ss.Printf(_T("%d"), m_Height);
+        m_ImageData.Add(ss);
+    }
+	// else reset the displayed size
+    else{
+        ss = m_ImageData.Item(0);
+        if(ss.ToLong(&ll)) m_Width = ll;
+
+        ss = m_ImageData.Item(1);
+        if(ss.ToLong(&ll)) m_Height = ll;
+
+        m_Count = 0;
+        for(i = 0;i < (int)m_ImageData.GetCount();i++){
+            ss = m_ImageData.Item(i);
+            if(ss.Find(_T("xpm_data")) >= 0){
+            	m_Count += 1;
+            }
+        };
+    };
+
+	// are we finished?
+    if(m_Count == 0){
+    	return;
+    }
+
+	// need to create a #include file?
+    if(m_Include){
+        if(! wxFileName::DirExists(m_IDir)) wxFileName::Mkdir(m_IDir);
+        ss  = m_IDir;
+        ss += m_Base;
+        ss += _T("_");
+        ss += vname;
+        ss += _T(".xpm");
+        ff.Open(ss, wxFile::write);
+    }
+
+	// go thru entire array, pulling out one XPM at a time into a single string
+    n = 0;
+    i = 2;
+    tt = _("");
+    while(i < (int)m_ImageData.GetCount()){
+        ss = m_ImageData.Item(i);
+        i += 1;
+
+		// the beginning of a new XPM image means the end of the previous image
+        if(ss.Find(_T("xpm_data")) >= 0){
+            vv.Printf(_T("%s_%d_XPM"), vname.c_str(), n);
+            ss.Replace(_T("xpm_data"), vv);
+            n += 1;
+
+            if(tt.Length() > 0){
+                if(m_Include){
+                	ff.Write(tt);
+                }
+                else{
+                	Codef(tt);
+                }
+            }
+
+            tt  = ss;
+            tt += _T("\n");
+        }
+		// else just another data line
+        else {
+            tt += ss;
+            tt += _T("\n");
+        }
+    }
+
+	// the left-overs
+    if(tt.Length() > 0){
+        if(m_Include){
+        	ff.Write(tt);
+        }
+        else{
+        	Codef(tt);
+        }
+    }
+
+	// include the #include file
+    if(m_Include){
+        ff.Close();
+
+        ss = _T("\"");
+        ss += m_RDir;
+        ss += m_Base;
+        ss += _T("_");
+        ss += vname;
+        ss += _T(".xpm");
+        ss += _T("\"");
+
+        AddHeader(ss, GetInfo().ClassName, 0);
+    }
+}
+
+int  wxsImageList::GetCount(void)
+{
+    return m_Count;
+}
+
+/*! \brief Get an image preview by index.
+ *
+ * \param inIndex int
+ * \return wxBitmap
+ *
+ */
+wxBitmap wxsImageList::GetPreview(int inIndex)
+{
+    int             i, j, n;
+    wxString        ss, tt;
+    wxArrayString   aa;
+    wxBitmap        bmp;
+
+	// no such image?
+    if((inIndex < 0) || (inIndex >= m_Count)){
+    	return wxNullBitmap;
+    }
+    if(m_ImageData.GetCount() == 0){
+    	return wxNullBitmap;
+    }
+
+	// count down to the start of that image data
+    n = -1;             // found index at start of data
+    j = 0;              // counter of data blocks
+    i = 0;              // index into m_ImageData
+
+    while((i < (int)m_ImageData.GetCount()) && (n < 0)){
+        ss = m_ImageData.Item(i);
+        i += 1;
+
+        if(ss.Find(_T("xpm_data")) >= 0){
+            if(j == inIndex){
+            	n = i;
+            }
+            j += 1;
+        }
+    }
+
+	// still no data block?
+    if(n < 0){
+    	return wxNullBitmap;\
+	}
+
+	// save that first line
+    aa.Clear();
+    aa.Add(ss);
+
+	// copy out the data block (until the next "xpm_data")
+    i = n;
+    n = -1;
+    while((i < (int)m_ImageData.GetCount()) && (n < 0)){
+        ss = m_ImageData.Item(i);
+        i += 1;
+
+        if(ss.Find(_T("xpm_data")) >= 0){
+        	n = i;
+        }
+        else{
+        	aa.Add(ss);
+        }
+    }
+
+	// turn that data block into a bitmap
+    wxsImageListDlg::ArrayToBitmap(aa, bmp);
+
+	// done
+    return bmp;
+}
+
+/*! \brief Get the image list.
+ *
+ * \param aImageList wxImageList&
+ * \return void
+ *
+ */
+void wxsImageList::GetImageList(wxImageList &aImageList)
+{
+    aImageList.RemoveAll();
+    wxsImageListDlg::ArrayToImageList(m_ImageData, aImageList);
+}
+
+/*! \brief This just exposes the "OnBuildCreatingCode()" method.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImageList::DoBuild(void)
+{
+    BuildCode(m_Context);
+}
+
Index: src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimagelist.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimagelist.h	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/defitems/wxsimagelist.h	(revision 0)
@@ -0,0 +1,62 @@
+/** \file wxsimagelist.h
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#ifndef wxsIMAGELIST_H
+#define wxsIMAGELIST_H
+
+#include    "../wxsitemresdata.h"
+#include "../wxstool.h"
+
+/** \brief Class for the wxsImageList widget */
+class wxsImageList : public wxsTool
+{
+    public:
+
+        wxsImageList(wxsItemResData* Data);
+
+        int             	GetCount(void);
+        wxBitmap  GetPreview(int inIndex);
+        void            GetImageList(wxImageList &aImageList);
+        void            DoBuild(void);
+
+    private:
+
+        virtual void OnBuildCreatingCode();
+        virtual void OnEnumToolProperties(long Flags);
+
+		void StoreXpmData(void);
+
+        bool            				m_IsBuilt;                 //!<  Only build the code once.
+        wxsCoderContext 	*m_Context;				//!< Coder context.
+        wxArrayString   		m_ImageData;         //!< Store all images as XPMs.
+        long            				m_Width;					//!< Image width.
+        long							m_Height;					//!< Image height.
+        long							m_Count;        			//!< Image count .
+        bool            				m_Include;                //!< Save as #include file?
+        wxString        			m_Base;                    //!< Base file name of source and include files.
+        wxString        			m_IDir;                       //!< The absolute path to the image include directory.
+        wxString        			m_RDir;                     //!< Relative directory specified for image files.
+};
+
+
+#endif      // wxsIMAGELIST_H
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/Makefile.am
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/Makefile.am	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/Makefile.am	(working copy)
@@ -24,7 +24,11 @@
 ./wxsbitmapiconeditordlg.cpp \
 ./wxsdimensionproperty.cpp \
 ./wxsbitmapiconproperty.cpp \
-./wxssimplefonteditordlg.cpp
+./wxssimplefonteditordlg.cpp \
+./wxseditenumproperty.cpp \
+./wxsimagelistdlg.cpp \
+./wxsimagelistproperty.cpp \
+./wxsimageproperty.cpp
 
 sdkdir=$(includedir)/wxsmith/wxwidgets/properties/
 
@@ -41,4 +45,9 @@
 ./wxssizerflagsproperty.h \
 ./wxsfontfaceeditordlg.h \
 ./wxsbitmapiconeditordlg.h \
-./wxssimplefonteditordlg.h
+./wxssimplefonteditordlg.h \
+./wxseditenumproperty.h \
+./wxsimagelistdlg.h \
+./wxsimagelistproperty.h \
+./wxsimageproperty.h
+
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxseditenumproperty.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxseditenumproperty.cpp	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxseditenumproperty.cpp	(revision 0)
@@ -0,0 +1,236 @@
+/** \file wxseditenumproperty.cpp
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010  Gary Harris.
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*/
+
+#include "wxseditenumproperty.h"
+
+#include <globals.h>
+
+// Helper macro for fetching variable
+#define VALUE   wxsVARIABLE(Object,Offset,wxString)
+
+wxsEditEnumProperty::wxsEditEnumProperty(const wxString &PGName,
+        const wxString &DataName,
+        long _Offset,
+        const wxChar **_Names,
+        bool _UpdateEnteries,
+        const wxString &_Default,
+        bool _XmlStoreEmpty,
+        bool _UseNamesInXml,
+        int Priority):
+    wxsProperty(PGName, DataName, Priority),
+    Offset(_Offset),
+    Default(_Default),
+    XmlStoreEmpty(_XmlStoreEmpty),
+    UpdateEnteries(_UpdateEnteries),
+    Names(_Names),
+    UseNamesInXml(_UseNamesInXml)
+{
+    int     i;
+
+	// the calling routine only needs the returned value as a string
+	// the list of long Values[] is useless to the calling routine
+	// so, let us hope that we have enough Values[] here
+
+    for(i = 0; i < 512; i++) Values[i] = i;
+}
+
+/*! \brief Register the control with a property grid.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Grid wxPropertyGridManager*
+ * \param Parent wxPGId
+ * \return void
+ *
+ */
+void wxsEditEnumProperty::PGCreate(wxsPropertyContainer *Object, wxPropertyGridManager *Grid, wxPGId Parent)
+{
+    wxPGChoices PGC(Names, Values);
+
+    PGRegister(Object, Grid, Grid->AppendIn(Parent, NEW_IN_WXPG14X wxEditEnumProperty(GetPGName(), wxPG_LABEL, PGC, VALUE)));
+}
+
+/*! \brief Read a property value.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Grid wxPropertyGridManager*
+ * \param Id wxPGId
+ * \param Index long
+ * \return bool
+ *
+ * \date 27/8/10
+ * Updated by Cryogen to use the item name rather than the enumerator value under wxPropertyGrid 1.4.
+ */
+bool wxsEditEnumProperty::PGRead(wxsPropertyContainer *Object, wxPropertyGridManager *Grid, wxPGId Id, long Index)
+{
+	VALUE = Grid->GetPropertyValueAsString(Id);
+    VALUE.Replace(_T("\\n"), _T("\n"));
+
+    return true;
+}
+
+/*! \brief Write a property value.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Grid wxPropertyGridManager*
+ * \param Id wxPGId
+ * \param Index long
+ * \return bool
+ *
+ */
+bool wxsEditEnumProperty::PGWrite(wxsPropertyContainer *Object, wxPropertyGridManager *Grid, wxPGId Id, long Index)
+{
+    wxString Fixed = VALUE;
+
+    Fixed.Replace(_T("\n"), _T("\\n"));
+   if ( UpdateEnteries )
+    {
+        #if wxCHECK_VERSION(2, 9, 0)
+        wxPGChoices choices = Grid->GetGrid()->GetSelection()->GetChoices();
+        choices.Set(Names,Values);
+        #else
+        Grid->GetPropertyChoices(Id).Set(Names,Values);
+        #endif
+    }
+    Grid->SetPropertyValue(Id, Fixed);
+    return true;
+}
+
+/*! \brief Read XML data.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Element TiXmlElement*
+ * \return bool
+ *
+ */
+bool wxsEditEnumProperty::XmlRead(wxsPropertyContainer *Object, TiXmlElement *Element)
+{
+    if(!Element)
+    {
+        VALUE.Clear();
+        return false;
+    }
+    // TODO: Use proper encoding
+    wxString Base = cbC2U(Element->GetText());
+    wxString Result;
+    for(const wxChar *Ch = Base.c_str(); *Ch; Ch++)
+    {
+        if(*Ch == _T('_'))
+        {
+            if(*++Ch == _T('_'))
+            {
+                Result << _T('_');
+            }
+            else
+            {
+                Result << _T('&') << *Ch;
+            }
+        }
+        else if(*Ch == _T('\\'))
+        {
+            switch(*++Ch)
+            {
+                case _T('n'):
+                    Result << _T('\n');
+                    break;
+                case _T('r'):
+                    Result << _T('\r');
+                    break;
+                case _T('t'):
+                    Result << _T('\t');
+                    break;
+                case _T('\\'):
+                    Result << _T('\\');
+                    break;
+                default:
+                    Result << _T('\\') << *Ch;
+                    break;
+            }
+        }
+        else
+        {
+            Result << *Ch;
+        }
+    }
+    VALUE = Result;
+    return true;
+}
+
+/*! \brief Write XML data.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Element TiXmlElement*
+ * \return bool
+ *
+ */
+bool wxsEditEnumProperty::XmlWrite(wxsPropertyContainer *Object, TiXmlElement *Element)
+{
+    if(XmlStoreEmpty || (VALUE != Default))
+    {
+        wxString Base = VALUE;
+        wxString Result;
+        for(const wxChar *Ch = Base.c_str(); *Ch; Ch++)
+        {
+            switch(*Ch)
+            {
+                case _T('_'):
+                    Result << _T("__");
+                    break;       // TODO: This is NOT compatible with xrc file when there's no version entry or version is less than 2.3.0.1
+                    //case _T('&'):  Result << _T('_');  break;     // We could leave this to be translated into &amp; but this looks nicer ;)
+                case _T('\\'):
+                    Result << _T("\\\\");
+                    break;
+                    // We could handle \n and \r here too but this is not necessary since XRC loading
+                    // routines also handle \n and \r chars
+                default:
+                    Result << *Ch;
+            }
+        }
+        // TODO: Use proper encoding
+        Element->InsertEndChild(TiXmlText(cbU2C(Result)));
+        return true;
+    }
+    return false;
+}
+
+/*! \brief Read from a property stream.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Stream wxsPropertyStream*
+ * \return bool
+ *
+ */
+bool wxsEditEnumProperty::PropStreamRead(wxsPropertyContainer *Object, wxsPropertyStream *Stream)
+{
+    return Stream->GetString(GetDataName(), VALUE, Default);
+}
+
+/*! \brief Write to a property stream.
+ *
+ * \param Object wxsPropertyContainer*
+ * \param Stream wxsPropertyStream*
+ * \return bool
+ *
+ */
+bool wxsEditEnumProperty::PropStreamWrite(wxsPropertyContainer *Object, wxsPropertyStream *Stream)
+{
+    return Stream->PutString(GetDataName(), VALUE, Default);
+}
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxseditenumproperty.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxseditenumproperty.h	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxseditenumproperty.h	(revision 0)
@@ -0,0 +1,118 @@
+/** \file wxseditenumproperty.h
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010  Gary Harris.
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*/
+
+#ifndef WXSEDITENUMPROPERTY_H
+#define WXSEDITENUMPROPERTY_H
+
+#include "../../properties/wxsproperties.h"
+#include "../wxscodercontext.h"
+
+/** \brief Property with enumerated values and editable field.
+ *
+ * Enum property works almost the same as long property but it uses
+ * predefined values from given set.
+ * Note that this class is abstract and should be used as base class for others.
+ */
+class wxsEditEnumProperty: public wxsProperty
+{
+	public:
+
+        /** \brief Ctor
+         *  \param PGName           name of property used in Property Grid
+         *  \param DataName         name of property used in data structures
+         *  \param Offset           offset of long integer holding enumerated value (taken from wxsOFFSET macro)
+         *  \param Values           array of long integer values which can be enumerated
+         *  \param Names            array of names used for items in Values array, ending with 0
+         *  \param UpdateEnteries   posting true here notifies, that arrays may change while property is shown in property grid
+         *  \param Default          defaut value applied on read errors
+         *  \param UseNamesInXml    if true, names will be stored inside xml node instead of values
+         *  \param Priority         priority of this property
+         */
+		wxsEditEnumProperty(
+            const wxString& PGName,
+            const wxString& DataName,
+            long Offset,
+            const wxChar** Names,
+            bool UpdateEnteries=false,
+            const wxString &Default=wxEmptyString,
+            bool XmlStoreEmpty=false,
+            bool UseNamesInXml=false,
+            int Priority=100);
+
+    protected:
+
+        virtual const wxString GetTypeName() { return _T(""); }
+        virtual void PGCreate(wxsPropertyContainer* Object,wxPropertyGridManager* Grid,wxPGId Parent);
+        virtual bool PGRead(wxsPropertyContainer* Object,wxPropertyGridManager* Grid, wxPGId Id, long Index);
+        virtual bool PGWrite(wxsPropertyContainer* Object,wxPropertyGridManager* Grid, wxPGId Id, long Index);
+        virtual bool XmlRead(wxsPropertyContainer* Object,TiXmlElement* Element);
+        virtual bool XmlWrite(wxsPropertyContainer* Object,TiXmlElement* Element);
+        virtual bool PropStreamRead(wxsPropertyContainer* Object,wxsPropertyStream* Stream);
+        virtual bool PropStreamWrite(wxsPropertyContainer* Object,wxsPropertyStream* Stream);
+
+	private:
+        long            		Offset;							//!< The offset of the long integer holding the enumerated value (taken from wxsOFFSET macro).
+        wxString        	Default;							//!< The defaut value applied on read errors.
+        bool            		XmlStoreEmpty;			//!< Store empty values in XML.
+        bool            		UpdateEnteries;			//!< If true, arrays may change while the property is shown in the property grid.
+        long            		Values[512];					//!< An array of long integer values which can be enumerated.
+        const wxChar  **Names;						//!< An array of names used for items in Values array, ending with 0.
+        bool            		UseNamesInXml;		//!< If true, names will be stored in XML nodes instead of values.
+};
+
+/** \addtogroup properties_macros
+ *  \{ */
+
+/** \brief Macro automatically declaring enum property
+ *  \param ClassName name of class holding this property
+ *  \param VarName name of variable of type long inside class
+ *  \param PGName name used in property grid
+ *  \param DataName name used in Xml / Data Streams
+ *  \param Names global array of names (stored as wxChar*) for enums, ended with 0 entry
+ *  \param Default value applied on read errors / validation failures
+ *
+ * \date 27/8/10
+ * Updated by Cryogen to allow the values to be updated whilst the property is displayed.
+ */
+	#define WXS_EDITENUM(ClassName,VarName,PGName,DataName,Names,Default) \
+    { static wxsEditEnumProperty _Property(PGName,DataName,wxsOFFSET(ClassName,VarName),Names,true,Default,true); \
+      Property(_Property); }
+
+/** \brief Macro automatically declaring enum property with custom priority
+ *  \param ClassName name of class holding this property
+ *  \param VarName name of variable of type long inside class
+ *  \param PGName name used in property grid
+ *  \param DataName name used in Xml / Data Streams
+ *  \param Names global array of names (stored as wxChar*) for enums, ended with 0 entry
+ *  \param Default value applied on read errors / validation failures
+ *  \param Priority priority of this property
+ *
+ * \date 27/8/10
+ * Updated by Cryogen to allow the values to be updated whilst the property is displayed.
+ */
+#define WXS_EDITENUM_P(ClassName,VarName,PGName,DataName,Names,Default,Priority) \
+    { static wxsEditEnumProperty _Property(PGName,DataName,wxsOFFSET(ClassName,VarName),Names,true,Default,true,Priority); \
+      Property(_Property); }
+
+/** \} */
+
+#endif
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistdlg.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistdlg.cpp	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistdlg.cpp	(revision 0)
@@ -0,0 +1,1461 @@
+/** \file wxsimagelistdlg.cpp
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+//(*InternalHeaders(wxsImageListDlg)
+#include <wx/artprov.h>
+#include <wx/bitmap.h>
+#include <wx/settings.h>
+#include <wx/font.h>
+#include <wx/intl.h>
+#include <wx/image.h>
+#include <wx/string.h>
+//*)
+
+#include <wx/app.h>
+#include <wx/msgdlg.h>
+#include <wx/clrpicker.h>
+#include <wx/dcmemory.h>
+#include <wx/sstream.h>
+#include <wx/tokenzr.h>
+#include "../wxsitemresdata.h"
+#include "../wxstool.h"
+
+#include "wxsimagelistdlg.h"
+#include "../wxsitem.h"
+
+
+// for the base-64 stuff
+// we copy the code into this file to avoid any conflict with the SDK routines of the same name
+const wxChar fillchar = '=';
+static wxString     cvt = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                             "abcdefghijklmnopqrstuvwxyz"
+                             "0123456789+/");
+
+
+//(*IdInit(wxsImageListDlg)
+const long wxsImageListDlg::ID_STATICBOX3 = wxNewId();
+const long wxsImageListDlg::ID_STATICBOX2 = wxNewId();
+const long wxsImageListDlg::ID_STATICBOX1 = wxNewId();
+const long wxsImageListDlg::ID_PANEL1 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT1 = wxNewId();
+const long wxsImageListDlg::ID_PANEL2 = wxNewId();
+const long wxsImageListDlg::ID_PANEL3 = wxNewId();
+const long wxsImageListDlg::ID_PANEL4 = wxNewId();
+const long wxsImageListDlg::ID_PANEL5 = wxNewId();
+const long wxsImageListDlg::ID_PANEL6 = wxNewId();
+const long wxsImageListDlg::ID_PANEL7 = wxNewId();
+const long wxsImageListDlg::ID_PANEL8 = wxNewId();
+const long wxsImageListDlg::ID_PANEL9 = wxNewId();
+const long wxsImageListDlg::ID_PANEL10 = wxNewId();
+const long wxsImageListDlg::ID_PANEL11 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON1 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON2 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT2 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT3 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT4 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT5 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT6 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT7 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT8 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT9 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT10 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT12 = wxNewId();
+const long wxsImageListDlg::ID_BUTTON1 = wxNewId();
+const long wxsImageListDlg::ID_BUTTON4 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON3 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON4 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT11 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT13 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT14 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT15 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT16 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT17 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT18 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON5 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT20 = wxNewId();
+const long wxsImageListDlg::ID_BUTTON2 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT21 = wxNewId();
+const long wxsImageListDlg::ID_PANEL12 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT22 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT23 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT24 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT25 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT19 = wxNewId();
+const long wxsImageListDlg::ID_CHECKBOX1 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT26 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT27 = wxNewId();
+const long wxsImageListDlg::ID_STATICTEXT28 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON6 = wxNewId();
+const long wxsImageListDlg::ID_BITMAPBUTTON7 = wxNewId();
+//*)
+
+BEGIN_EVENT_TABLE(wxsImageListDlg, wxDialog)
+    //(*EventTable(wxsImageListDlg)
+    //*)
+END_EVENT_TABLE()
+
+wxsImageListDlg::wxsImageListDlg(wxWindow *parent, wxWindowID id, const wxPoint &pos, const wxSize &size)
+{
+    //(*Initialize(wxsImageListDlg)
+    Create(parent, id, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE, _T("id"));
+    SetClientSize(wxSize(400,317));
+    Move(wxDefaultPosition);
+    SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE));
+    wxFont thisFont(8,wxSWISS,wxFONTSTYLE_NORMAL,wxNORMAL,false,_T("Arial"),wxFONTENCODING_DEFAULT);
+    SetFont(thisFont);
+    StaticBox3 = new wxStaticBox(this, ID_STATICBOX3, _("Options"), wxPoint(200,104), wxSize(200,160), 0, _T("ID_STATICBOX3"));
+    StaticBox2 = new wxStaticBox(this, ID_STATICBOX2, _("Import From File"), wxPoint(0,104), wxSize(200,160), 0, _T("ID_STATICBOX2"));
+    StaticBox1 = new wxStaticBox(this, ID_STATICBOX1, _("Image List"), wxPoint(0,0), wxSize(400,104), 0, _T("ID_STATICBOX1"));
+    Panel1 = new wxPanel(this, ID_PANEL1, wxPoint(8,144), wxSize(92,92), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL1"));
+    Panel1->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_HOTLIGHT));
+    Panel1->SetToolTip(_("Click any spot on the image to select a transparent color"));
+    StaticText1 = new wxStaticText(this, ID_STATICTEXT1, _("Imported Image"), wxPoint(8,124), wxSize(92,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT1"));
+    Panel2 = new wxPanel(this, ID_PANEL2, wxPoint(40,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL2"));
+    Panel2->SetBackgroundColour(wxColour(255,255,255));
+    Panel3 = new wxPanel(this, ID_PANEL3, wxPoint(72,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL3"));
+    Panel3->SetBackgroundColour(wxColour(255,255,255));
+    Panel4 = new wxPanel(this, ID_PANEL4, wxPoint(104,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL4"));
+    Panel4->SetBackgroundColour(wxColour(255,255,255));
+    Panel5 = new wxPanel(this, ID_PANEL5, wxPoint(136,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL5"));
+    Panel5->SetBackgroundColour(wxColour(255,255,255));
+    Panel6 = new wxPanel(this, ID_PANEL6, wxPoint(200,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL6"));
+    Panel6->SetBackgroundColour(wxColour(255,255,255));
+    Panel7 = new wxPanel(this, ID_PANEL7, wxPoint(232,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL7"));
+    Panel7->SetBackgroundColour(wxColour(255,255,255));
+    Panel8 = new wxPanel(this, ID_PANEL8, wxPoint(168,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL8"));
+    Panel8->SetBackgroundColour(wxColour(255,255,255));
+    Panel9 = new wxPanel(this, ID_PANEL9, wxPoint(264,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL9"));
+    Panel9->SetBackgroundColour(wxColour(255,255,255));
+    Panel10 = new wxPanel(this, ID_PANEL10, wxPoint(296,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL10"));
+    Panel10->SetBackgroundColour(wxColour(255,255,255));
+    Panel11 = new wxPanel(this, ID_PANEL11, wxPoint(328,48), wxSize(32,32), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL11"));
+    Panel11->SetBackgroundColour(wxColour(255,255,255));
+    bLeft = new wxBitmapButton(this, ID_BITMAPBUTTON1, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_GO_BACK")),wxART_BUTTON), wxPoint(8,52), wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON1"));
+    bLeft->SetDefault();
+    bRight = new wxBitmapButton(this, ID_BITMAPBUTTON2, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_GO_FORWARD")),wxART_BUTTON), wxPoint(368,52), wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON2"));
+    bRight->SetDefault();
+    StaticText2 = new wxStaticText(this, ID_STATICTEXT2, _("1"), wxPoint(40,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT2"));
+    StaticText3 = new wxStaticText(this, ID_STATICTEXT3, _("2"), wxPoint(72,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT3"));
+    StaticText4 = new wxStaticText(this, ID_STATICTEXT4, _("3"), wxPoint(104,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT4"));
+    StaticText5 = new wxStaticText(this, ID_STATICTEXT5, _("4"), wxPoint(136,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT5"));
+    StaticText6 = new wxStaticText(this, ID_STATICTEXT6, _("5"), wxPoint(168,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT6"));
+    StaticText7 = new wxStaticText(this, ID_STATICTEXT7, _("6"), wxPoint(200,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT7"));
+    StaticText8 = new wxStaticText(this, ID_STATICTEXT8, _("7"), wxPoint(232,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT8"));
+    StaticText9 = new wxStaticText(this, ID_STATICTEXT9, _("8"), wxPoint(264,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT9"));
+    StaticText10 = new wxStaticText(this, ID_STATICTEXT10, _("9"), wxPoint(296,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT10"));
+    StaticText12 = new wxStaticText(this, ID_STATICTEXT12, _("10"), wxPoint(328,80), wxSize(32,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT12"));
+    bOK = new wxButton(this, ID_BUTTON1, _("OK"), wxPoint(72,280), wxDefaultSize, 0, wxDefaultValidator, _T("ID_BUTTON1"));
+    bOK->SetDefault();
+    bCancel = new wxButton(this, ID_BUTTON4, _("Cancel"), wxPoint(256,280), wxDefaultSize, 0, wxDefaultValidator, _T("ID_BUTTON4"));
+    bAdd = new wxBitmapButton(this, ID_BITMAPBUTTON3, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_ADD_BOOKMARK")),wxART_BUTTON), wxPoint(104,220), wxDefaultSize, wxBU_LEFT|wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON3"));
+    bDel = new wxBitmapButton(this, ID_BITMAPBUTTON4, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_DEL_BOOKMARK")),wxART_BUTTON), wxPoint(304,144), wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON4"));
+    bDel->SetDefault();
+    StaticText11 = new wxStaticText(this, ID_STATICTEXT11, _("Add To List"), wxPoint(136,224), wxDefaultSize, 0, _T("ID_STATICTEXT11"));
+    StaticText13 = new wxStaticText(this, ID_STATICTEXT13, _("Delete Image"), wxPoint(336,148), wxDefaultSize, 0, _T("ID_STATICTEXT13"));
+    StaticText14 = new wxStaticText(this, ID_STATICTEXT14, _("Name"), wxPoint(8,20), wxDefaultSize, 0, _T("ID_STATICTEXT14"));
+    StaticText15 = new wxStaticText(this, ID_STATICTEXT15, _("Label"), wxPoint(40,20), wxSize(96,18), wxST_NO_AUTORESIZE|wxSUNKEN_BORDER, _T("ID_STATICTEXT15"));
+    StaticText16 = new wxStaticText(this, ID_STATICTEXT16, _("Image Count"), wxPoint(144,20), wxDefaultSize, 0, _T("ID_STATICTEXT16"));
+    StaticText17 = new wxStaticText(this, ID_STATICTEXT17, _("Label"), wxPoint(208,20), wxSize(32,18), wxST_NO_AUTORESIZE|wxALIGN_CENTRE|wxSUNKEN_BORDER, _T("ID_STATICTEXT17"));
+    StaticText18 = new wxStaticText(this, ID_STATICTEXT18, _("Image Size"), wxPoint(248,20), wxDefaultSize, 0, _T("ID_STATICTEXT18"));
+    bRead = new wxBitmapButton(this, ID_BITMAPBUTTON5, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_FILE_OPEN")),wxART_BUTTON), wxPoint(104,144), wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON5"));
+    bRead->SetDefault();
+    StaticText20 = new wxStaticText(this, ID_STATICTEXT20, _("Read File"), wxPoint(136,148), wxDefaultSize, 0, _T("ID_STATICTEXT20"));
+    bColor = new wxButton(this, ID_BUTTON2, _("C"), wxPoint(104,192), wxSize(24,24), 0, wxDefaultValidator, _T("ID_BUTTON2"));
+    StaticText21 = new wxStaticText(this, ID_STATICTEXT21, _("Mask Color"), wxPoint(136,200), wxDefaultSize, 0, _T("ID_STATICTEXT21"));
+    Panel12 = new wxPanel(this, ID_PANEL12, wxPoint(208,144), wxSize(92,92), wxDOUBLE_BORDER|wxTAB_TRAVERSAL, _T("ID_PANEL12"));
+    Panel12->SetBackgroundColour(wxColour(255,255,255));
+    StaticText22 = new wxStaticText(this, ID_STATICTEXT22, _("Selected Image"), wxPoint(208,124), wxSize(92,16), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT22"));
+    StaticText23 = new wxStaticText(this, ID_STATICTEXT23, _("Label"), wxPoint(8,240), wxSize(92,14), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT23"));
+    StaticText24 = new wxStaticText(this, ID_STATICTEXT24, _("Clear List"), wxPoint(336,178), wxDefaultSize, 0, _T("ID_STATICTEXT24"));
+    StaticText25 = new wxStaticText(this, ID_STATICTEXT25, _("Export BMP"), wxPoint(336,208), wxDefaultSize, 0, _T("ID_STATICTEXT25"));
+    StaticText19 = new wxStaticText(this, ID_STATICTEXT19, _("x"), wxPoint(344,20), wxDefaultSize, 0, _T("ID_STATICTEXT19"));
+    cxTransparent = new wxCheckBox(this, ID_CHECKBOX1, _("Transparent"), wxPoint(108,174), wxDefaultSize, 0, wxDefaultValidator, _T("ID_CHECKBOX1"));
+    cxTransparent->SetValue(false);
+    StaticText26 = new wxStaticText(this, ID_STATICTEXT26, _("16"), wxPoint(304,20), wxSize(32,18), wxST_NO_AUTORESIZE|wxALIGN_CENTRE|wxSUNKEN_BORDER, _T("ID_STATICTEXT26"));
+    StaticText27 = new wxStaticText(this, ID_STATICTEXT27, _("16"), wxPoint(360,20), wxSize(32,18), wxST_NO_AUTORESIZE|wxALIGN_CENTRE|wxSUNKEN_BORDER, _T("ID_STATICTEXT27"));
+    StaticText28 = new wxStaticText(this, ID_STATICTEXT28, _("Label"), wxPoint(208,240), wxSize(88,14), wxST_NO_AUTORESIZE|wxALIGN_CENTRE, _T("ID_STATICTEXT28"));
+    bClear = new wxBitmapButton(this, ID_BITMAPBUTTON6, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_DELETE")),wxART_BUTTON), wxPoint(304,174), wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON6"));
+    bClear->SetDefault();
+    bSave = new wxBitmapButton(this, ID_BITMAPBUTTON7, wxArtProvider::GetBitmap(wxART_MAKE_ART_ID_FROM_STR(_T("wxART_FILE_SAVE")),wxART_BUTTON), wxPoint(304,204), wxDefaultSize, wxBU_AUTODRAW, wxDefaultValidator, _T("ID_BITMAPBUTTON7"));
+    bSave->SetDefault();
+    ColourDialog1 = new wxColourDialog(this);
+    FileDialog1 = new wxFileDialog(this, _("Select output file"), wxEmptyString, wxEmptyString, _("Bitmap Files|*.bmp|All Files|*.*"), wxFD_SAVE|wxFD_OVERWRITE_PROMPT, wxDefaultPosition, wxDefaultSize, _T("wxFileDialog"));
+
+    Panel1->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::OnPanel1Paint,0,this);
+    Panel1->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel1LeftUp,0,this);
+    Panel2->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel2->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel2LeftUp,0,this);
+    Panel3->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel3->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel3LeftUp,0,this);
+    Panel4->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel4->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel4LeftUp,0,this);
+    Panel5->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel5->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel5LeftUp,0,this);
+    Panel6->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel6->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel6LeftUp,0,this);
+    Panel7->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel7->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel7LeftUp,0,this);
+    Panel8->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel8->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel8LeftUp,0,this);
+    Panel9->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel9->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel9LeftUp,0,this);
+    Panel10->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel10->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel10LeftUp,0,this);
+    Panel11->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::PaintPreviewPanel,0,this);
+    Panel11->Connect(wxEVT_LEFT_UP,(wxObjectEventFunction)&wxsImageListDlg::OnPanel11LeftUp,0,this);
+    Connect(ID_BITMAPBUTTON1,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbLeftClick);
+    Connect(ID_BITMAPBUTTON2,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbRightClick);
+    Connect(ID_BUTTON1,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbOKClick);
+    Connect(ID_BUTTON4,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbCancelClick);
+    Connect(ID_BITMAPBUTTON3,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbAddClick);
+    Connect(ID_BITMAPBUTTON4,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbDelClick);
+    Connect(ID_BITMAPBUTTON5,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbReadClick);
+    Connect(ID_BUTTON2,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbColorClick);
+    Panel12->Connect(wxEVT_PAINT,(wxObjectEventFunction)&wxsImageListDlg::OnPanel12Paint,0,this);
+    Connect(ID_CHECKBOX1,wxEVT_COMMAND_CHECKBOX_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OncxTransparentClick);
+    Connect(ID_BITMAPBUTTON6,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbClearClick);
+    Connect(ID_BITMAPBUTTON7,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&wxsImageListDlg::OnbSaveClick);
+    //*)
+
+    // reading images
+    wxInitAllImageHandlers();
+
+    // nothing yet
+    m_ImageDialog   = new wxsBitmapIconEditorDlg(0, m_ImageData, _("wxART_OTHER"));
+    m_ImportMask    = *wxWHITE;
+    m_FirstImage    = 0;
+    m_PreviewSelect = -1;
+
+    // preview panels
+    m_PreviewPanel[0] = Panel2;
+    m_PreviewLabel[0] = StaticText2;
+    m_PreviewPanel[1] = Panel3;
+    m_PreviewLabel[1] = StaticText3;
+    m_PreviewPanel[2] = Panel4;
+    m_PreviewLabel[2] = StaticText4;
+    m_PreviewPanel[3] = Panel5;
+    m_PreviewLabel[3] = StaticText5;
+    m_PreviewPanel[4] = Panel8;
+    m_PreviewLabel[4] = StaticText6;
+    m_PreviewPanel[5] = Panel6;
+    m_PreviewLabel[5] = StaticText7;
+    m_PreviewPanel[6] = Panel7;
+    m_PreviewLabel[6] = StaticText8;
+    m_PreviewPanel[7] = Panel9;
+    m_PreviewLabel[7] = StaticText9;
+    m_PreviewPanel[8] = Panel10;
+    m_PreviewLabel[8] = StaticText10;
+    m_PreviewPanel[9] = Panel11;
+    m_PreviewLabel[9] = StaticText12;
+
+    // change the cursor for the transparency preview panel
+    Panel1->SetCursor(*wxCROSS_CURSOR);
+}
+
+wxsImageListDlg::~wxsImageListDlg()
+{
+    //(*Destroy(wxsImageListDlg)
+    //*)
+
+    if(m_ImageDialog != NULL) delete m_ImageDialog;
+
+}
+
+/*! \brief Run the dialogue.
+ *
+ * \param inName wxString&
+ * \param aImageData wxArrayString&
+ * \return bool
+ *
+ */
+bool wxsImageListDlg::Execute(wxString &inName, wxArrayString &aImageData)
+{
+    int         n;
+    int         w, h;
+    wxString    ss;
+
+	// need default sizes?
+    if(aImageData.GetCount() < 2){
+        aImageData.Clear();
+        aImageData.Add(_("16"));
+        aImageData.Add(_("16"));
+    }
+
+	// read image data into list
+    ArrayToImageList(aImageData, m_ImageList);
+
+	// some presets
+    m_ImportMask    = *wxWHITE;
+    m_FirstImage    = 0;
+    m_PreviewSelect = -1;
+
+	// the name
+    StaticText15->SetLabel(inName);
+
+	// each image size
+    m_ImageList.GetSize(0, w, h);
+    ss.Printf(_T("%d"), w);
+    StaticText26->SetLabel(ss);
+    ss.Printf(_T("%d"), h);
+    StaticText27->SetLabel(ss);
+
+	// and the current count
+    n = m_ImageList.GetImageCount();
+    ss.Printf(_T("%d"), n);
+    StaticText17->SetLabel(ss);
+
+	// update buttons
+    UpdateEnabled();
+
+	// show it
+    n = ShowModal();
+
+	// save new data?
+    if(n == wxID_OK){
+    	ImageListToArray(m_ImageList, aImageData);
+    }
+
+	// done
+    return (n == wxID_OK);
+}
+
+/*! \brief Add an external file.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbAddClick(wxCommandEvent &event)
+{
+    int         n;
+    int         iw, ih;
+    int         bw, bh;
+    wxBitmap    *bmp;
+    wxString    ss;
+
+	// no image?
+    if(!m_ImportImage.IsOk()){
+    	return;
+    }
+
+	// compare sizes
+    m_ImageList.GetSize(0, iw, ih);
+    bw = m_ImportImage.GetWidth();
+    bh = m_ImportImage.GetHeight();
+
+    if((bw > iw) || (bh > ih)){
+        n = ::wxMessageBox(_("The image is larger than the size allowed for the list;\nDivide the image into multiple entries?"), _("Add Image"), wxYES_NO);
+        if(n != wxYES){
+        	return;
+        }
+    }
+
+	// add the bitmap
+    bmp = new wxBitmap(m_ImportImage);
+    if(cxTransparent->GetValue()){
+    	m_ImageList.Add(*bmp, m_ImportMask);
+    }
+    else{
+    	m_ImageList.Add(*bmp);
+    }
+    delete bmp;
+
+	// update the count
+    n = m_ImageList.GetImageCount();
+    ss.Printf(_T("%d"), n);
+    StaticText17->SetLabel(ss);
+
+	// re-draw the previews
+    PreviewList();
+    UpdateEnabled();
+}
+
+/*! \brief Add an external file.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbReadClick(wxCommandEvent &event)
+{
+    int         n;
+    wxBitmap    bmp;
+
+	// show the image select dialog
+    n = m_ImageDialog->ShowModal();
+    if(n != wxID_OK){
+    	return;
+    }
+
+	// get what the user selected
+    bmp = m_ImageData.GetPreview(wxDefaultSize);
+    m_ImportImage = bmp.ConvertToImage();
+
+	// a default mask color
+    m_ImportMask = *wxWHITE;
+
+	// show it
+    PreviewImport();
+}
+
+/*! \brief Refresh the imported image preview.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImageListDlg::PreviewImport(void)
+{
+    Panel1->Refresh();
+}
+
+/*! \brief Refresh the imported image list preview.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImageListDlg::PreviewList(void)
+{
+    int     i;
+
+    for(i = 0;i < 10;i++){
+    	m_PreviewPanel[i]->Refresh();
+    }
+}
+
+/*! \brief The OnPaint event.
+ *
+ * \param event wxPaintEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel1Paint(wxPaintEvent &event)
+{
+    int         iw, ih;
+    wxPaintDC   dc(Panel1);
+    wxString    ss;
+
+	// no image
+    if(!m_ImportImage.IsOk()){
+    	return;
+    }
+
+	// make a working copy of the original image
+    wxImage img(m_ImportImage);
+
+	// apply the mask color
+    if(cxTransparent->GetValue()){
+    	img.SetMaskColour(m_ImportMask.Red(), m_ImportMask.Green(), m_ImportMask.Blue());
+    }
+
+	// and then a bitmap to draw
+    wxBitmap bmp(img);
+
+	// image info
+    iw = bmp.GetWidth();
+    ih = bmp.GetHeight();
+    ss.Printf(_T("%d x %d"), iw, ih);
+    StaticText23->SetLabel(ss);
+
+	// draw it
+    PaintPanel(dc, Panel1, bmp);
+}
+
+/*! \brief The mask colour button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbColorClick(wxCommandEvent &event)
+{
+    int             n;
+    wxColourData    cd;
+    wxColour        cc;
+
+	// not allowed?
+    if(!cxTransparent->GetValue()){
+    	return;
+    }
+
+	// show the dialog
+    n = ColourDialog1->ShowModal();
+    if(n != wxID_OK){
+    	return;
+    }
+
+	// get color data
+    cd = ColourDialog1->GetColourData();
+    cc = cd.GetColour();
+
+	// save the mask colour
+    m_ImportMask = cc;
+
+	// show the colour on the button
+    bColor->SetBackgroundColour(cc);
+
+	// redraw the bitmap
+    Panel1->Refresh();
+}
+
+/*! \brief Set a new mask colour.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel1LeftUp(wxMouseEvent &event)
+{
+    int         mx, my;
+    wxClientDC  dc(Panel1);
+    wxColour    cc;
+
+	// not allowed?
+    if(!cxTransparent->GetValue()){
+    	return;
+    }
+
+	// where was the mouse?
+    event.GetPosition(&mx, &my);
+
+	// get the colour at that pixel
+    dc.GetPixel(mx, my, &cc);
+
+	// save it
+    m_ImportMask = cc;
+
+	// show the colour on the button
+    bColor->SetBackgroundColour(cc);
+
+	// redraw the bitmap
+    Panel1->Refresh();
+}
+
+/*! \brief Update which buttons are enabled or disabled.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImageListDlg::UpdateEnabled(void)
+{
+    int         n;
+    bool        b;
+    wxString    ss;
+
+	// can the user select a transparent color?
+    b = cxTransparent->GetValue();
+    bColor->Enable(b);
+    StaticText21->Enable(b);
+
+	// this is also a good place to update image count
+    n = m_ImageList.GetImageCount();
+    ss.Printf(_T("%d"), n);
+    StaticText17->SetLabel(ss);
+}
+
+/*! \brief The "transparent" checkbox was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OncxTransparentClick(wxCommandEvent &event)
+{
+    UpdateEnabled();
+    PreviewImport();
+}
+
+/*! \brief The "OK" button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbOKClick(wxCommandEvent &event)
+{
+    EndModal(wxID_OK);
+}
+
+/*! \brief The "Cancel" button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbCancelClick(wxCommandEvent &event)
+{
+    EndModal(wxID_CANCEL);
+}
+
+/*! \brief Paint the preview panel.
+ *
+ * \param event wxPaintEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::PaintPreviewPanel(wxPaintEvent &event)
+{
+    int         i;
+    int         ip, ix;
+    wxPanel     *pnl;
+    wxBitmap    bmp;
+    wxString    ss, tt;
+    wxPaintDC   dc((wxWindow *) event.GetEventObject());
+
+	// which panel?
+    ip = 0;
+    pnl = (wxPanel *) event.GetEventObject();
+    for(i = 0; i < 10; i++){
+        if(pnl == m_PreviewPanel[i]){
+        	ip = i;
+        }
+    };
+
+	// which bitmap from the list?
+    ix = m_FirstImage + ip;
+
+	// the bitmap
+    bmp = m_ImageList.GetBitmap(ix);
+
+	// the label
+    ss.Printf(_T("%d"), ix);
+    m_PreviewLabel[ip]->SetLabel(ss);
+
+	// draw it
+    PaintPanel(dc, pnl, bmp, (ix == m_PreviewSelect));
+}
+
+/*! \brief The left mouse button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbLeftClick(wxCommandEvent &event)
+{
+
+    m_FirstImage -= 1;
+    if(m_FirstImage < 0) m_FirstImage = 0;
+
+    PreviewList();
+}
+
+/*! \brief The right mouse button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbRightClick(wxCommandEvent &event)
+{
+    int     n;
+
+    m_FirstImage += 1;
+    n = m_ImageList.GetImageCount();
+    if(m_FirstImage >= n) m_FirstImage = n - 1;
+    if(m_FirstImage  < 0) m_FirstImage = 0;
+
+    PreviewList();
+}
+
+/*! \brief Preview panel 0 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel2LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(0);
+}
+
+/*! \brief Preview panel 1 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel3LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(1);
+}
+
+/*! \brief Preview panel 2 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel4LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(2);
+}
+
+/*! \brief Preview panel 3 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel5LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(3);
+}
+
+/*! \brief Preview panel 4 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel8LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(4);
+}
+
+/*! \brief Preview panel 5 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel6LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(5);
+}
+
+/*! \brief Preview panel 6 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel7LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(6);
+}
+
+/*! \brief Preview panel 7 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel9LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(7);
+}
+
+/*! \brief Preview panel 8 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel10LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(8);
+}
+
+/*! \brief Preview panel 9 was selected.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel11LeftUp(wxMouseEvent &event)
+{
+    SelectPreviewPanel(9);
+}
+
+/*! \brief Select a preview panel by index.
+ *
+ * \param event wxMouseEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::SelectPreviewPanel(int aIndex)
+{
+    m_PreviewSelect = aIndex + m_FirstImage;
+    PreviewList();
+    PreviewSelected();
+}
+
+/*! \brief Paint the selected image preview.
+ *
+ * \param event wxPaintEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnPanel12Paint(wxPaintEvent &event)
+{
+    wxPaintDC   dc(Panel12);
+    wxBitmap    bmp;
+    wxString    ss, tt;
+
+	// a copy of the selected bitmap
+    bmp = m_ImageList.GetBitmap(m_PreviewSelect);
+
+	// the label
+    ss.Printf(_("%d"), m_PreviewSelect);
+    StaticText28->SetLabel(ss);
+
+	// draw it
+    PaintPanel(dc, Panel12, bmp);
+}
+
+/*! \brief The selected image preview was selected.
+ *
+ * \param void
+ * \return void
+ *
+ */
+void wxsImageListDlg::PreviewSelected(void)
+{
+    Panel12->Refresh();
+}
+
+/*! \brief The "Delete Image" button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbDelClick(wxCommandEvent &event)
+{
+    int         n;
+    wxString    ss;
+
+	// anything to delete?
+    if(m_PreviewSelect < 0) return;
+
+	// are you sure?
+    ss.Printf(_("Delete Image %d; Are You Sure?"), m_PreviewSelect);
+    n = ::wxMessageBox(ss, _("Delete Image"), wxYES_NO);
+    if(n != wxYES){
+    	return;
+    }
+
+	// do it
+    m_ImageList.Remove(m_PreviewSelect);
+
+	// refresh
+    m_PreviewSelect = -1;
+    PreviewList();
+    PreviewSelected();
+    UpdateEnabled();
+}
+
+/*! \brief The "Clear List" button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbClearClick(wxCommandEvent &event)
+{
+    int         n;
+    wxString    ss;
+
+	// are you sure?
+    ss.Printf(_("Delete All Images. Are You Sure?"));
+    n = ::wxMessageBox(ss, _("Delete Image"), wxYES_NO);
+    if(n != wxYES){
+    	return;
+    }
+
+	// do it
+    m_ImageList.RemoveAll();
+
+	// refresh
+    m_PreviewSelect = -1;
+    PreviewList();
+    PreviewSelected();
+    UpdateEnabled();
+}
+
+/*! \brief The "Export BMP" button was clicked.
+ *
+ * \param event wxCommandEvent&
+ * \return void
+ *
+ */
+void wxsImageListDlg::OnbSaveClick(wxCommandEvent &event)
+{
+    int         i, n;
+    int         w, h;
+    wxMemoryDC  dc;
+    wxBitmap    *bmp;
+    wxString    ss;
+
+	// size of each image
+    m_ImageList.GetSize(0, w, h);
+    n = m_ImageList.GetImageCount();
+
+	// anything to save
+    if(n == 0){
+    	return;
+    }
+
+	// make a bitmap and a drawing context
+    bmp = new wxBitmap(n * w, h);
+    dc.SelectObject(*bmp);
+
+	// default background
+    dc.SetBackground(*wxWHITE_BRUSH);
+    dc.Clear();
+
+	// draw each object into the bitmap
+    for(i = 0; i < n; i++){
+    	m_ImageList.Draw(i, dc, i * w, 0, wxIMAGELIST_DRAW_NORMAL, true);
+    }
+
+	// save it
+    n = FileDialog1->ShowModal();
+    if(n == wxID_OK){
+        ss = FileDialog1->GetPath();
+        bmp->SaveFile(ss, wxBITMAP_TYPE_BMP);
+    }
+
+	// done
+    delete bmp;
+}
+
+/*! \brief Paint a panel.
+ *
+ * \param aDC wxPaintDC&
+ * \param aPanel wxPanel*
+ * \param aBitmap wxBitmap&
+ * \param aHot bool
+ * \return void
+ *
+ */
+void wxsImageListDlg::PaintPanel(wxPaintDC &aDC, wxPanel *aPanel, wxBitmap &aBitmap, bool aHot)
+{
+    int         iw, ih;
+    int         pw, ph;
+    double      sw, sh;
+    int         x, y;
+    wxBitmap    bmp;
+    wxString    ss, tt;
+
+	// nothing to do?
+    if(aPanel == NULL){
+    	return;
+    }
+
+	// default background
+    if(aHot){
+    	aDC.SetBackground(*wxBLUE_BRUSH);
+    }
+    else{
+    	aDC.SetBackground(*wxWHITE_BRUSH);
+    }
+
+    aDC.Clear();
+
+	// image and panel sizes
+    iw = aBitmap.GetWidth();
+    ih = aBitmap.GetHeight();
+    if((iw < 0) || (ih < 0)){
+    	return;
+    }
+
+    aPanel->GetClientSize(&pw, &ph);
+
+	// set scale to fit in panel
+    sw = 1.0;
+    sh = 1.0;
+    while(((((int)(sw * iw)) > pw) || (((int)(sh * ih)) > ph)) && (sw > 0.01) && (sh > 0.01)){
+        sw -= 0.01;
+        sh -= 0.01;
+    };
+
+    while(((int)(sw * iw)) < 8){
+    	sw += 0.01;
+    }
+    while(((int)(sh * ih)) < 8){
+    	sh += 0.01;
+    }
+
+    aDC.SetUserScale(sw, sh);
+
+	// center it in the panel and draw it
+    x = (pw - ((int)(sw * iw))) / 2;
+    y = (ph - ((int)(sh * ih))) / 2;
+
+    aDC.DrawBitmap(aBitmap, x, y, true);
+
+	// reset the scale
+    aDC.SetUserScale(1.0, 1.0);
+}
+
+/*! \brief Convert an wxImage to an XPM.
+ *
+ * \param inImage wxImage&
+ * \param outArray wxArrayString&
+ * \return void
+ *
+ */
+void wxsImageListDlg::ImageToArray(wxImage &inImage, wxArrayString &outArray)
+{
+    wxString                ss, tt;
+    wxStringOutputStream    os;
+    wxStringTokenizer       tkz;
+
+	// clear old junk
+	outArray.Clear();
+
+	// write as XPM data
+    SaveXPM(&inImage, os);
+
+    ss = os.GetString();
+
+	// convert to an array; skip empty lines and comment lines
+	// XPM images typically have a lot of black spaces, but the XML parser that
+	// stores this data in the *.wxs file compresses white space
+	// to preserve white space with a minimum of expanded data size, we convert
+	// all data lines (all except the first line of the array) to base-64
+    tkz.SetString(ss, _T("\r\n"));
+    while(tkz.HasMoreTokens()) {
+        tt = tkz.GetNextToken();
+        tt.Trim(true);
+        tt.Trim(false);
+        if(tt.Length() == 0) continue;
+        if(tt.StartsWith(_T("/*"))) continue;
+        if(tt.StartsWith(_T("//"))) continue;
+
+        outArray.Add(tt);
+    };
+}
+
+/*! \brief Convert an XPM to a wxImage.
+ *
+ * \param inArray wxArrayString&
+ * \param outImage wxImage&
+ * \return void
+ *
+ */
+void wxsImageListDlg::ArrayToImage(wxArrayString &inArray, wxImage &outImage)
+{
+    int                     i, n;
+    wxString                ss, tt;
+    wxStringInputStream     *ns;
+
+	// make an input stream
+    n = CalcArraySize(inArray);
+    tt = _("");
+    tt.Alloc(n + 64);
+
+    for(i = 0; i < (int)inArray.GetCount(); i++){
+        ss = inArray.Item(i);
+        n = ss.Length();
+
+        if(n == 0){
+        	continue;
+        }
+
+        tt += ss;
+        tt += _T("\n");
+    }
+
+    ns = new wxStringInputStream(tt);
+
+	// use it to read an image
+    outImage.LoadFile(*ns, wxBITMAP_TYPE_XPM);
+
+	// done with input
+
+    delete ns;
+}
+
+/*! \brief Convert an wxBitmap to an XPM.
+ *
+ * \param inBitmap wxBitmap&
+ * \param outArray wxArrayString&
+ * \return void
+ *
+ */
+void wxsImageListDlg::BitmapToArray(wxBitmap &inBitmap, wxArrayString &outArray)
+{
+    wxImage     img;
+
+    img = inBitmap.ConvertToImage();
+    ImageToArray(img, outArray);
+}
+
+/*! \brief Convert an XPM to a wxBitmap.
+ *
+ * \param inArray wxArrayString&
+ * \param outBitmap wxBitmap&
+ * \return void
+ *
+ */
+void wxsImageListDlg::ArrayToBitmap(wxArrayString &inArray, wxBitmap &outBitmap)
+{
+    wxImage     img;
+    wxBitmap    *bmp;
+
+    ArrayToImage(inArray, img);
+    bmp = new wxBitmap(img);
+    outBitmap = (*bmp);
+}
+
+/*! \brief Convert an image list to an array of XPMs.
+ *
+ * \param inList wxImageList&
+ * \param outArray wxArrayString&
+ * \return void
+ *
+ */
+void wxsImageListDlg::ImageListToArray(wxImageList &inList, wxArrayString &outArray)
+{
+    int             i, j, k, n;
+    wxBitmap        bmp;
+    wxArrayString   aa;
+    wxString        ss, tt;
+
+	// clear old junk
+    outArray.Clear();
+
+	// the first 2 items are the width and height
+    inList.GetSize(0, i, n);
+    ss.Printf(_T("%d"), i);
+    outArray.Add(ss);
+    ss.Printf(_T("%d"), n);
+    outArray.Add(ss);
+
+	// get each bitmap from the list and add to outArray
+    n = inList.GetImageCount();
+    for(i = 0; i < n; i++){
+        bmp = inList.GetBitmap(i);
+        BitmapToArray(bmp, aa);
+
+        k = aa.GetCount();
+        for(j = 0; j < k; j++){
+            ss = aa.Item(j);
+            outArray.Add(ss);
+        }
+    }
+}
+
+/*! \brief Convert an array of XPMs to an image list.
+ *
+ * \param inArray wxArrayString&
+ * \param outList wxImageList&
+ * \return void
+ *
+ */
+void wxsImageListDlg::ArrayToImageList(wxArrayString &inArray, wxImageList &outList)
+{
+    int             i, n;
+    int             w, h;
+    long            ll;
+    wxBitmap        bmp;
+    wxArrayString   aa;
+    wxString        ss, tt;
+    wxImageList     *list;
+
+	// get the size of the image list
+    w = 16;
+    if(inArray.GetCount() >= 1){
+        ss = inArray.Item(0);
+        if(ss.ToLong(&ll)){
+        	w = ll;
+        }
+    }
+
+    h = 16;
+    if(inArray.GetCount() >= 2){
+        ss = inArray.Item(1);
+        if(ss.ToLong(&ll)){
+        	h = ll;
+        }
+    }
+
+	// make a temp list of correct size
+    list = new wxImageList(w, h, 128);
+
+	// extract sub-arrays from the big array and make pictures out of them
+    aa.Clear();
+    i = 2;
+    while(i < (int)inArray.GetCount()){
+        ss = inArray.Item(i);
+        i += 1;
+        ss.Trim(true);
+        ss.Trim(false);
+
+        if(ss.Length() == 0){                      // empty string
+            // ignore this line
+        }
+        else if(ss.Find(_T("xpm_data")) < 0){       // not the end of previous XPM data block
+            aa.Add(ss);
+        }
+        else if(aa.GetCount() == 0){               // previous data block was empty
+            // do nothing
+        }
+        else{                                      // end of XPM data; start next block of data
+            ArrayToBitmap(aa, bmp);
+            n = list->Add(bmp);
+            aa.Clear();
+            aa.Add(ss);
+        }
+    }
+
+	// any left-over data?
+    if(aa.GetCount() > 0){
+        ArrayToBitmap(aa, bmp);
+        list->Add(bmp);
+        aa.Clear();
+    }
+
+	// return the image list, and decrement usage count for our local copy
+    outList = (*list);
+}
+
+/*! \brief Copy an image list.
+ *
+ * \param inList wxImageList&
+ * \param outList wxImageList&
+ * \return void
+ *
+ */
+void wxsImageListDlg::CopyImageList(wxImageList &inList, wxImageList &outList)
+{
+    int         i, n;
+    int         w, h;
+    wxBitmap    bmp;
+    wxImageList *list;
+
+	// size of old list
+    inList.GetSize(0, w, h);
+    n = inList.GetImageCount();
+
+	// make a new list
+    list = new wxImageList(w, h, n);
+
+	// copy it
+    for(i = 0; i < n; i++){
+        bmp = inList.GetBitmap(i);
+        list->Add(bmp);
+    }
+
+	// copy the reference back to the user
+    outList = (*list);
+}
+
+/*! \brief Find a pointer to a wxsTool given its name.
+ *
+ * \param inItem wxsItem*
+ * \param inName wxString
+ * \return wxsItem    *
+ *
+ */
+wxsItem     *wxsImageListDlg::FindTool(wxsItem *inItem, wxString inName)
+{
+    int             i, n;
+    wxsItemResData  *res;
+    wxsTool         *tool;
+    wxsTool         *found;
+    wxString        ss, tt;
+
+    static wxsItem  *last_item;
+
+	// keep track of last item used, for those cases where we cannot pass in an item
+    if(inItem != NULL){
+    	last_item = inItem;
+    }
+
+	// still nothing?
+    if(last_item == NULL){
+    	return NULL;
+    }
+
+	// nothing yet
+    found = NULL;
+
+	// pointer to resource data
+    res = last_item->GetResourceData();
+
+	// scan all the tools and check the names
+    n = res->GetToolsCount();
+    for(i = 0; i < n; i++){
+        tool = res->GetTool(i);
+        ss = tool->GetVarName();
+        if(ss == inName){
+        	found = tool;
+        }
+    }
+
+	// done
+    return found;
+}
+
+/*! \brief Estimate the amount of space is needed for a single string to hold an array.
+ *
+ * \param inArray wxArrayString&
+ * \return int
+ *
+ */
+int     wxsImageListDlg::CalcArraySize(wxArrayString &inArray)
+{
+    int     i, n;
+
+    n = 0;
+    for(i = 0; i < (int)inArray.GetCount(); i++){
+    	n += inArray.Item(i).Length() + 1;
+    }
+
+    return n;
+}
+
+/*! \brief Save a wxImage as an XPM stream.
+ *
+ * \param image wxImage*
+ * \param stream wxOutputStream&
+ * \return bool
+ *
+ * We can not use the normal XPM savefile routine in wxImage because it uses
+ * spaces " " and percents "%" as part of the encoding.
+ * Spaces are compressed by the TinyXml library (which reads and writes the
+ * wxSmith *.wxs file) and percents are used by Codef() for argument expansion
+ * otherwise, this save routine is identical to the one normally used by wxImage
+ */
+bool wxsImageListDlg::SaveXPM(wxImage *image, wxOutputStream &stream)
+{
+    // 1. count colours:
+#define MaxCixels  90
+    static const char Cixel[MaxCixels+1] =
+        "_.XoO+@#$&*=-;:>,<1234567890qwertyuipasdfghjk"
+        "lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()`'][{}|";
+    int i, j, k;
+
+    wxImageHistogram histogram;
+    int cols = int(image->ComputeHistogram(histogram));
+
+    int chars_per_pixel = 1;
+    for(k = MaxCixels; cols > k; k *= MaxCixels){
+        chars_per_pixel++;
+    }
+
+    // 2. write the header:
+    wxString sName;
+    if(image->HasOption(wxIMAGE_OPTION_FILENAME))
+    {
+        wxSplitPath(image->GetOption(wxIMAGE_OPTION_FILENAME),
+                    NULL, &sName, NULL);
+        sName << wxT("_xpm");
+    }
+
+    if(!sName.empty()){
+        sName = wxString(wxT("/* XPM */\nstatic const char *")) + sName;
+    }
+    else{
+        sName = wxT("/* XPM */\nstatic const char *xpm_data");
+    }
+    stream.Write((const char *) sName.ToAscii(), sName.Len());
+
+    char tmpbuf[200];
+    // VS: 200b is safe upper bound for anything produced by sprintf below
+    //     (<101 bytes the string, neither %i can expand into more than 10 chars)
+    sprintf(tmpbuf,
+            "[] = {\n"
+            "/* columns rows colors chars-per-pixel */\n"
+            "\"%i %i %i %i\",\n",
+            image->GetWidth(), image->GetHeight(), cols, chars_per_pixel);
+    stream.Write(tmpbuf, strlen(tmpbuf));
+
+    // 3. create color symbols table:
+    char *symbols_data = new char[cols * (chars_per_pixel+1)];
+    char **symbols = new char*[cols];
+
+    // 2a. find mask colour:
+    unsigned long mask_key = 0x1000000 /*invalid RGB value*/;
+    if(image->HasMask())
+        mask_key = (image->GetMaskRed() << 16) |
+                   (image->GetMaskGreen() << 8) | image->GetMaskBlue();
+
+    // 2b. generate colour table:
+    for(wxImageHistogram::iterator entry = histogram.begin();
+            entry != histogram.end(); ++entry)
+    {
+        unsigned long index = entry->second.index;
+        symbols[index] = symbols_data + index * (chars_per_pixel + 1);
+        char *sym = symbols[index];
+
+        for(j = 0; j < chars_per_pixel; j++)
+        {
+            sym[j] = Cixel[index % MaxCixels];
+            index /= MaxCixels;
+        }
+        sym[j] = '\0';
+
+        unsigned long key = entry->first;
+
+        if(key == 0)
+            sprintf(tmpbuf, "\"%s c Black\",\n", sym);
+        else if(key == mask_key)
+            sprintf(tmpbuf, "\"%s c None\",\n", sym);
+        else
+        {
+            wxByte r = wxByte(key >> 16);
+            wxByte g = wxByte(key >> 8);
+            wxByte b = wxByte(key);
+            sprintf(tmpbuf, "\"%s c #%02X%02X%02X\",\n", sym, r, g, b);
+        }
+        stream.Write(tmpbuf, strlen(tmpbuf));
+    }
+
+    stream.Write("/* pixels */\n", 13);
+
+    unsigned char *data = image->GetData();
+    for(j = 0; j < image->GetHeight(); j++)
+    {
+        char tmp_c;
+        tmp_c = '\"';
+        stream.Write(&tmp_c, 1);
+        for(i = 0; i < image->GetWidth(); i++, data += 3)
+        {
+            unsigned long key = (data[0] << 16) | (data[1] << 8) | (data[2]);
+            stream.Write(symbols[histogram[key].index], chars_per_pixel);
+        }
+        tmp_c = '\"';
+        stream.Write(&tmp_c, 1);
+        if(j + 1 < image->GetHeight())
+        {
+            tmp_c = ',';
+            stream.Write(&tmp_c, 1);
+        }
+        tmp_c = '\n';
+        stream.Write(&tmp_c, 1);
+    }
+    stream.Write("};\n", 3);
+
+    // Clean up:
+    delete[] symbols;
+    delete[] symbols_data;
+
+    return true;
+}
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistdlg.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistdlg.h	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistdlg.h	(revision 0)
@@ -0,0 +1,235 @@
+/** \file wxsimagelistdlg.h
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#ifndef WXSIMAGELISTDLG_H
+#define WXSIMAGELISTDLG_H
+
+
+//(*Headers(wxsImageListDlg)
+#include <wx/stattext.h>
+#include <wx/checkbox.h>
+#include <wx/statbox.h>
+#include <wx/colordlg.h>
+#include <wx/panel.h>
+#include <wx/filedlg.h>
+#include <wx/bmpbuttn.h>
+#include <wx/button.h>
+#include "scrollingdialog.h"
+//*)
+
+#include "wxsimagelistproperty.h"
+#include <wx/bitmap.h>
+#include <wx/image.h>
+#include <wx/imaglist.h>
+#include "wxsbitmapiconeditordlg.h"
+
+class wxsItem;
+
+/*! \brief Class for wxsImageListDlg. */
+class wxsImageListDlg: public wxScrollingDialog
+{
+	public:
+
+		wxsImageListDlg(wxWindow* parent,wxWindowID id=wxID_ANY,const wxPoint& pos=wxDefaultPosition,const wxSize& size=wxDefaultSize);
+		virtual ~wxsImageListDlg();
+        bool            			Execute(wxString &inName, wxArrayString &aImageData);
+		static  void            ImageToArray(wxImage &inImage, wxArrayString &outArray);
+		static  void            ArrayToImage(wxArrayString &inArray, wxImage &outImage);
+		static  void            BitmapToArray(wxBitmap &inBitmap, wxArrayString &outArray);
+		static  void            ArrayToBitmap(wxArrayString &inArray, wxBitmap &outBitmap);
+		static  void            ImageListToArray(wxImageList &inList, wxArrayString &outArray);
+		static  void            ArrayToImageList(wxArrayString &inArray, wxImageList &outList);
+		static  void            CopyImageList(wxImageList &inList, wxImageList &outList);
+		static  wxsItem     *FindTool(wxsItem *inItem, wxString inName);
+		static  int               CalcArraySize(wxArrayString &inArray);
+		static  bool            SaveXPM(wxImage * image, wxOutputStream& stream);
+
+		//(*Declarations(wxsImageListDlg)
+		wxStaticText* StaticText10;
+		wxStaticText* StaticText22;
+		wxStaticText* StaticText9;
+		wxStaticText* StaticText20;
+		wxButton* bOK;
+		wxPanel* Panel5;
+		wxBitmapButton* bRight;
+		wxStaticText* StaticText13;
+		wxButton* bCancel;
+		wxStaticText* StaticText2;
+		wxPanel* Panel4;
+		wxStaticText* StaticText14;
+		wxStaticText* StaticText26;
+		wxStaticText* StaticText6;
+		wxPanel* Panel11;
+		wxBitmapButton* bSave;
+		wxPanel* Panel9;
+		wxStaticText* StaticText19;
+		wxStaticText* StaticText8;
+		wxStaticText* StaticText11;
+		wxBitmapButton* bClear;
+		wxStaticText* StaticText18;
+		wxBitmapButton* bAdd;
+		wxPanel* Panel8;
+		wxPanel* Panel1;
+		wxColourDialog* ColourDialog1;
+		wxStaticText* StaticText1;
+		wxStaticText* StaticText27;
+		wxFileDialog* FileDialog1;
+		wxStaticText* StaticText3;
+		wxStaticBox* StaticBox1;
+		wxPanel* Panel6;
+		wxStaticText* StaticText21;
+		wxPanel* Panel3;
+		wxButton* bColor;
+		wxStaticBox* StaticBox2;
+		wxStaticText* StaticText23;
+		wxStaticText* StaticText24;
+		wxStaticText* StaticText5;
+		wxStaticText* StaticText7;
+		wxPanel* Panel7;
+		wxBitmapButton* bLeft;
+		wxCheckBox* cxTransparent;
+		wxStaticBox* StaticBox3;
+		wxStaticText* StaticText28;
+		wxStaticText* StaticText15;
+		wxStaticText* StaticText12;
+		wxPanel* Panel2;
+		wxPanel* Panel10;
+		wxStaticText* StaticText25;
+		wxBitmapButton* bDel;
+		wxStaticText* StaticText17;
+		wxStaticText* StaticText4;
+		wxPanel* Panel12;
+		wxBitmapButton* bRead;
+		wxStaticText* StaticText16;
+		//*)
+
+	protected:
+
+		//(*Identifiers(wxsImageListDlg)
+		static const long ID_STATICBOX3;
+		static const long ID_STATICBOX2;
+		static const long ID_STATICBOX1;
+		static const long ID_PANEL1;
+		static const long ID_STATICTEXT1;
+		static const long ID_PANEL2;
+		static const long ID_PANEL3;
+		static const long ID_PANEL4;
+		static const long ID_PANEL5;
+		static const long ID_PANEL6;
+		static const long ID_PANEL7;
+		static const long ID_PANEL8;
+		static const long ID_PANEL9;
+		static const long ID_PANEL10;
+		static const long ID_PANEL11;
+		static const long ID_BITMAPBUTTON1;
+		static const long ID_BITMAPBUTTON2;
+		static const long ID_STATICTEXT2;
+		static const long ID_STATICTEXT3;
+		static const long ID_STATICTEXT4;
+		static const long ID_STATICTEXT5;
+		static const long ID_STATICTEXT6;
+		static const long ID_STATICTEXT7;
+		static const long ID_STATICTEXT8;
+		static const long ID_STATICTEXT9;
+		static const long ID_STATICTEXT10;
+		static const long ID_STATICTEXT12;
+		static const long ID_BUTTON1;
+		static const long ID_BUTTON4;
+		static const long ID_BITMAPBUTTON3;
+		static const long ID_BITMAPBUTTON4;
+		static const long ID_STATICTEXT11;
+		static const long ID_STATICTEXT13;
+		static const long ID_STATICTEXT14;
+		static const long ID_STATICTEXT15;
+		static const long ID_STATICTEXT16;
+		static const long ID_STATICTEXT17;
+		static const long ID_STATICTEXT18;
+		static const long ID_BITMAPBUTTON5;
+		static const long ID_STATICTEXT20;
+		static const long ID_BUTTON2;
+		static const long ID_STATICTEXT21;
+		static const long ID_PANEL12;
+		static const long ID_STATICTEXT22;
+		static const long ID_STATICTEXT23;
+		static const long ID_STATICTEXT24;
+		static const long ID_STATICTEXT25;
+		static const long ID_STATICTEXT19;
+		static const long ID_CHECKBOX1;
+		static const long ID_STATICTEXT26;
+		static const long ID_STATICTEXT27;
+		static const long ID_STATICTEXT28;
+		static const long ID_BITMAPBUTTON6;
+		static const long ID_BITMAPBUTTON7;
+		//*)
+
+	private:
+
+		//(*Handlers(wxsImageListDlg)
+		void OnbAddClick(wxCommandEvent& event);
+		void OnbReadClick(wxCommandEvent& event);
+		void OnPanel1Paint(wxPaintEvent& event);
+		void OnbColorClick(wxCommandEvent& event);
+		void OnPanel1LeftUp(wxMouseEvent& event);
+		void OncxTransparentClick(wxCommandEvent& event);
+		void OnbOKClick(wxCommandEvent& event);
+		void OnbCancelClick(wxCommandEvent& event);
+		void OnbLeftClick(wxCommandEvent& event);
+		void OnbRightClick(wxCommandEvent& event);
+		void OnPanel2LeftUp(wxMouseEvent& event);
+		void OnPanel3LeftUp(wxMouseEvent& event);
+		void OnPanel4LeftUp(wxMouseEvent& event);
+		void OnPanel5LeftUp(wxMouseEvent& event);
+		void OnPanel8LeftUp(wxMouseEvent& event);
+		void OnPanel6LeftUp(wxMouseEvent& event);
+		void OnPanel7LeftUp(wxMouseEvent& event);
+		void OnPanel9LeftUp(wxMouseEvent& event);
+		void OnPanel10LeftUp(wxMouseEvent& event);
+		void OnPanel11LeftUp(wxMouseEvent& event);
+		void OnPanel12Paint(wxPaintEvent& event);
+		void OnbDelClick(wxCommandEvent& event);
+		void OnbClearClick(wxCommandEvent& event);
+		void OnbSaveClick(wxCommandEvent& event);
+		void PaintPreviewPanel(wxPaintEvent& event);
+		//*)
+
+        void                PreviewImport(void);
+        void                PreviewList(void);
+        void                PreviewSelected(void);
+        void                UpdateEnabled(void);
+        void                SelectPreviewPanel(int aIndex);
+        void                PaintPanel(wxPaintDC &aDC, wxPanel *aPanel, wxBitmap &aBitmap, bool aHot = false);
+
+		wxImageList             			m_ImageList;         			//!< Working copy of image list.
+		wxImage                 				m_ImportImage;    			//!< The thing that gets displayed.
+		wxColour                				m_ImportMask;      			//!< Mask color.
+		wxsBitmapIconEditorDlg 	*m_ImageDialog;			//!< Dialog to import external images.
+		wxsBitmapIconData       	m_ImageData;       			//!< Image data for the dialog.
+		int                     						m_FirstImage;        			//!< Left-most image displayed in preview.
+		wxPanel                				*m_PreviewPanel[10];  	//!< The list of preview images.
+		wxStaticText           				*m_PreviewLabel[10];  	//!< The preview list label.
+		int                     						m_PreviewSelect;         	//!< The selected preview image.
+
+		DECLARE_EVENT_TABLE()
+};
+
+#endif
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistproperty.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistproperty.cpp	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistproperty.cpp	(revision 0)
@@ -0,0 +1,130 @@
+/** \file wxsimagelistproperty.cpp
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#include "wxsimagelistproperty.h"
+#include "wxsimagelistdlg.h"
+
+#include <globals.h>
+
+// Helper macro for fetching variable
+#define VALUE   wxsVARIABLE(Object,Offset,wxArrayString)
+
+wxsImageListProperty::wxsImageListProperty(const wxString& PGName,const wxString& _DataName,const wxString& _DataSubName,long _Offset,int Priority):
+    wxsCustomEditorProperty(PGName,_DataName,Priority),
+    Offset(_Offset),
+    DataSubName(_DataSubName),
+    DataName(_DataName)
+{}
+
+bool wxsImageListProperty::ShowEditor(wxsPropertyContainer* Object)
+{
+    wxsImageListDlg Dlg(0);
+    return Dlg.Execute(DataName, VALUE);
+}
+
+bool wxsImageListProperty::XmlRead(wxsPropertyContainer* Object,TiXmlElement* Element)
+{
+    VALUE.Clear();
+
+    if ( !Element )
+    {
+        return false;
+    }
+
+    for ( TiXmlElement* Item = Element->FirstChildElement(cbU2C(DataSubName));
+          Item;
+          Item = Item->NextSiblingElement(cbU2C(DataSubName)) )
+    {
+        const char* Text = Item->GetText();
+        if ( Text )
+        {
+            VALUE.Add(cbC2U(Text));
+        }
+        else
+        {
+            VALUE.Add(wxEmptyString);
+        }
+    }
+    return true;
+}
+
+bool wxsImageListProperty::XmlWrite(wxsPropertyContainer* Object,TiXmlElement* Element)
+{
+    size_t Count = VALUE.Count();
+    for ( size_t i = 0; i < Count; i++ )
+    {
+        XmlSetString(Element,VALUE[i],DataSubName);
+    }
+    return Count != 0;
+}
+
+bool wxsImageListProperty::PropStreamRead(wxsPropertyContainer* Object,wxsPropertyStream* Stream)
+{
+    VALUE.Clear();
+    Stream->SubCategory(GetDataName());
+    for(;;)
+    {
+        wxString Item;
+        if ( !Stream->GetString(DataSubName,Item,wxEmptyString) ) break;
+        VALUE.Add(Item);
+    }
+    Stream->PopCategory();
+    return true;
+}
+
+bool wxsImageListProperty::PropStreamWrite(wxsPropertyContainer* Object,wxsPropertyStream* Stream)
+{
+    Stream->SubCategory(GetDataName());
+    size_t Count = VALUE.GetCount();
+    for ( size_t i=0; i<Count; i++ )
+    {
+        Stream->PutString(DataSubName,VALUE[i],wxEmptyString);
+    }
+    Stream->PopCategory();
+    return true;
+}
+
+wxString wxsImageListProperty::GetStr(wxsPropertyContainer* Object)
+{
+    wxString Result;
+    size_t Count = VALUE.Count();
+
+    if ( Count == 0 )
+    {
+        return _("Click to add items");
+    }
+
+    for ( size_t i=0; i<Count; i++ )
+    {
+        wxString Item = VALUE[i];
+        Item.Replace(_T("\""),_T("\\\""));
+        if ( i > 0 )
+        {
+            Result.Append(_T(' '));
+        }
+        Result.Append(_T('"'));
+        Result.Append(Item);
+        Result.Append(_T('"'));
+    }
+    return Result;
+}
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistproperty.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistproperty.h	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimagelistproperty.h	(revision 0)
@@ -0,0 +1,99 @@
+/** \file wxsimagelistproperty.h
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#ifndef WXSIMAGELISTPROPERTY_H
+#define WXSIMAGELISTPROPERTY_H
+
+#include "../../properties/wxsproperties.h"
+#include "../wxscodercontext.h"
+
+/** \brief Property for wxsImageListProperty class
+ *
+ * \note This property doesn't take any default value.
+ *       By default, the array is cleared.
+ */
+class wxsImageListProperty: public wxsCustomEditorProperty
+{
+	public:
+
+        /** \brief Ctor
+         *  \param PGName       		The name of this property in the Property Grid.
+         *  \param DataName     	The name of this property in data stuctures.
+         *  \param DataSubName  The name applied for each array element.
+         *  \param Offset       			The offset of the value (returned from wxsOFFSET macro).
+		 *  \param Priority int			The item's priority.
+         */
+		wxsImageListProperty(const wxString& PGName,const wxString& DataName,const wxString& DataSubName,long Offset,int Priority=100);
+
+		/** \brief Returning type name */
+		virtual const wxString GetTypeName() { return _T("wxArrayString"); }
+
+        /** \brief Showing editor for this property
+		 *
+		 * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+		 * \return bool	True on succes, otherwise false.
+		 *
+		 */
+        virtual bool ShowEditor(wxsPropertyContainer* Object);
+
+    protected:
+
+        virtual bool XmlRead(wxsPropertyContainer* Object,TiXmlElement* Element);
+        virtual bool XmlWrite(wxsPropertyContainer* Object,TiXmlElement* Element);
+        virtual bool PropStreamRead(wxsPropertyContainer* Object,wxsPropertyStream* Stream);
+        virtual bool PropStreamWrite(wxsPropertyContainer* Object,wxsPropertyStream* Stream);
+        virtual wxString GetStr(wxsPropertyContainer* Object);
+
+	private:
+        long Offset;
+        wxString DataSubName;
+        wxString DataName;
+};
+
+/** \addtogroup properties_macros
+ *  \{ */
+
+/** \brief Macro automatically declaring wxImageList property
+ *  \param ClassName name of class holding this property
+ *  \param VarName name of variable inside class
+ *  \param PGName name used in property grid
+ *  \param DataName name used in Xml / Data Streams
+ */
+#define WXS_IMAGELIST(ClassName,VarName,PGName,DataName) \
+    { static wxsImageListProperty _Property(PGName,DataName,_("Item"),wxsOFFSET(ClassName,VarName)); \
+      Property(_Property); }
+
+/** \brief Macro automatically declaring wxImageList property with custom priority
+ *  \param ClassName name of class holding this property
+ *  \param VarName name of variable inside class
+ *  \param PGName name used in property grid
+ *  \param DataName name used in Xml / Data Streams
+ *  \param Priority priority of property
+ */
+#define WXS_IMAGELIST_P(ClassName,VarName,PGName,DataName,Priority) \
+    { static wxsImageListProperty _Property(PGName,DataName,_("Item"),wxsOFFSET(ClassName,VarName),Priority); \
+      Property(_Property); }
+
+/** \} */
+
+#endif
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimageproperty.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimageproperty.cpp	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimageproperty.cpp	(revision 0)
@@ -0,0 +1,194 @@
+/** \file wxsimageproperty.cpp
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#include "wxsimageproperty.h"
+#include "wxsimagelistdlg.h"
+#include <globals.h>
+
+// Helper macro for fetching variable
+#define VALUE   wxsVARIABLE(Object,Offset,wxArrayString)
+
+wxsImageProperty::wxsImageProperty(const wxString &PGName, const wxString &_DataName, const wxString &_DataSubName, long _Offset, int Priority):
+    wxsCustomEditorProperty(PGName, _DataName, Priority),
+    Offset(_Offset),
+    DataSubName(_DataSubName),
+    DataName(_DataName)
+{}
+
+/*! \brief Show the image editor.
+ *
+ * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+ * \return bool	True on succes, otherwise false.
+ *
+ */
+bool wxsImageProperty::ShowEditor(wxsPropertyContainer *Object)
+{
+    int                     						n;
+    wxsBitmapIconData       	data;
+    wxsBitmapIconEditorDlg	dlg(0, data, _T("wxART_OTHER"));
+    wxBitmap                				bmp;
+    wxString                				ss;
+
+	// show the dialog, exit immediately if canceled
+    n = dlg.ShowModal();
+    if(n != wxID_OK){
+    	return false;
+    }
+
+	// no data?
+    if(data.IsEmpty()){
+        VALUE.Clear();
+    }
+
+	// get a preview image and store it as an array of XPM data
+    else{
+        bmp = data.GetPreview(wxDefaultSize);
+        wxsImageListDlg::BitmapToArray(bmp, VALUE);
+    }
+
+	// done
+    return true;
+}
+
+/*! \brief Read XML data.
+ *
+ * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+ * \param Element TiXmlElement*				A pointer to a TiXmlElement object.
+ * \return bool	True on succes, otherwise false.
+ *
+ */
+bool wxsImageProperty::XmlRead(wxsPropertyContainer *Object, TiXmlElement *Element)
+{
+    VALUE.Clear();
+
+    if(!Element)
+    {
+        return false;
+    }
+
+    for(TiXmlElement *Item = Element->FirstChildElement(cbU2C(DataSubName));
+            Item;
+            Item = Item->NextSiblingElement(cbU2C(DataSubName)))
+    {
+        const char *Text = Item->GetText();
+        if(Text)
+        {
+            VALUE.Add(cbC2U(Text));
+        }
+        else
+        {
+            VALUE.Add(wxEmptyString);
+        }
+    }
+    return true;
+}
+
+/*! \brief Write XML data.
+ *
+ * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+ * \param Element TiXmlElement*				A pointer to a TiXmlElement object.
+ * \return bool	True if count != 0, false otherwise.
+ *
+ */
+bool wxsImageProperty::XmlWrite(wxsPropertyContainer *Object, TiXmlElement *Element)
+{
+    size_t Count = VALUE.Count();
+    for(size_t i = 0; i < Count; i++)
+    {
+        XmlSetString(Element, VALUE[i], DataSubName);
+    }
+    return Count != 0;
+}
+
+/*! \brief Read from a property stream.
+ *
+ * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+ * \param Stream wxsPropertyStream*		A pointer to a wxsPropertyStream object.
+ * \return bool	Always returns true.
+ *
+ */
+bool wxsImageProperty::PropStreamRead(wxsPropertyContainer *Object, wxsPropertyStream *Stream)
+{
+    VALUE.Clear();
+    Stream->SubCategory(GetDataName());
+    for(;;)
+    {
+        wxString Item;
+        if(!Stream->GetString(DataSubName, Item, wxEmptyString)){
+        	break;
+        }
+        VALUE.Add(Item);
+    }
+    Stream->PopCategory();
+    return true;
+}
+
+/*! \brief Write to the property stream.
+ *
+ * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+ * \param Stream wxsPropertyStream*		A pointer to a wxsPropertyStream object.
+ * \return bool	Always returns true.
+ *
+ */
+bool wxsImageProperty::PropStreamWrite(wxsPropertyContainer *Object, wxsPropertyStream *Stream)
+{
+    Stream->SubCategory(GetDataName());
+    size_t Count = VALUE.GetCount();
+    for(size_t i = 0; i < Count; i++)
+    {
+        Stream->PutString(DataSubName, VALUE[i], wxEmptyString);
+    }
+    Stream->PopCategory();
+    return true;
+}
+
+/*! \brief Get the image as a string.
+ *
+ * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+ * \return wxString	The image string.
+ *
+ */
+wxString wxsImageProperty::GetStr(wxsPropertyContainer *Object)
+{
+    wxString Result;
+    size_t Count = VALUE.Count();
+
+    if(Count == 0)
+    {
+        return _("Click to add items");
+    }
+
+    for(size_t i = 0; i < Count; i++)
+    {
+        wxString Item = VALUE[i];
+        Item.Replace(_T("\""), _T("\\\""));
+        if(i > 0)
+        {
+            Result.Append(_T(' '));
+        }
+        Result.Append(_T('"'));
+        Result.Append(Item);
+        Result.Append(_T('"'));
+    }
+    return Result;
+}
Index: src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimageproperty.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimageproperty.h	(revision 0)
+++ src/plugins/contrib/wxSmith/wxwidgets/properties/wxsimageproperty.h	(revision 0)
@@ -0,0 +1,98 @@
+/** \file wxsimageproperty.h
+*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2010 Gary Harris
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+* This code was taken from the wxSmithImage plug-in, copyright Ron Collins
+* and released under the GPL.
+*
+*/
+
+#ifndef WXSIMAGEPROPERTY_H
+#define WXSIMAGEPROPERTY_H
+
+#include "wxsbitmapiconproperty.h"
+
+/** \brief Property for wxsImageProperty class
+ *
+ * \note This property doesn't take any default value.
+ *       By default, the array is cleared.
+ */
+class wxsImageProperty: public wxsCustomEditorProperty
+{
+	public:
+
+        /** \brief Ctor
+         *  \param PGName       		The name of this property in the Property Grid.
+         *  \param DataName     	The name of this property in data stuctures.
+         *  \param DataSubName  The name applied for each array element.
+         *  \param Offset       			The offset of the value (returned from wxsOFFSET macro).
+		 *  \param Priority int			The item's priority.
+         */
+		wxsImageProperty(const wxString& PGName,const wxString& DataName,const wxString& DataSubName,long Offset,int Priority=100);
+
+		/** \brief Returning type name */
+		virtual const wxString GetTypeName() { return _T("wxArrayString"); }
+
+        /** \brief Showing editor for this property
+		 *
+		 * \param Object wxsPropertyContainer*	A pointer to a wxsPropertyContainer object.
+		 * \return bool	True on succes, otherwise false.
+		 *
+		 */
+        virtual bool ShowEditor(wxsPropertyContainer* Object);
+
+    protected:
+
+        virtual bool XmlRead(wxsPropertyContainer* Object,TiXmlElement* Element);
+        virtual bool XmlWrite(wxsPropertyContainer* Object,TiXmlElement* Element);
+        virtual bool PropStreamRead(wxsPropertyContainer* Object,wxsPropertyStream* Stream);
+        virtual bool PropStreamWrite(wxsPropertyContainer* Object,wxsPropertyStream* Stream);
+        virtual wxString GetStr(wxsPropertyContainer* Object);
+
+	private:
+        long Offset;
+        wxString DataSubName;
+        wxString DataName;
+};
+
+/** \addtogroup properties_macros
+ *  \{ */
+
+/** \brief Macro automatically declaring wxImage property
+ *  \param ClassName name of class holding this property
+ *  \param VarName name of variable inside class
+ *  \param PGName name used in property grid
+ *  \param DataName name used in Xml / Data Streams
+ */
+#define WXS_IMAGE(ClassName,VarName,PGName,DataName) \
+    { static wxsImageProperty _Property(PGName,DataName,_T("Item"),wxsOFFSET(ClassName,VarName)); \
+      Property(_Property); }
+
+/** \brief Macro automatically declaring wxImage property with custom priority
+ *  \param ClassName name of class holding this property
+ *  \param VarName name of variable inside class
+ *  \param PGName name used in property grid
+ *  \param DataName name used in Xml / Data Streams
+ *  \param Priority priority of property
+ */
+#define WXS_IMAGE_P(ClassName,VarName,PGName,DataName,Priority) \
+    { static wxsImageProperty _Property(PGName,DataName,_T("Item"),wxsOFFSET(ClassName,VarName),Priority); \
+      Property(_Property); }
+
+/** \} */
+
+#endif
Index: src/plugins/contrib/wxSmith/wxwidgets/wxsexproperties.h
===================================================================
--- src/plugins/contrib/wxSmith/wxwidgets/wxsexproperties.h	(revision 6562)
+++ src/plugins/contrib/wxSmith/wxwidgets/wxsexproperties.h	(working copy)
@@ -31,5 +31,9 @@
 #include "properties/wxspositionsizeproperty.h"
 #include "properties/wxssizerflagsproperty.h"
 #include "properties/wxsstyleproperty.h"
+#include "properties/wxseditenumproperty.h"
+#include "properties/wxsimageproperty.h"
+#include "properties/wxsimagelistproperty.h"
+#include "properties/wxsimagelistdlg.h"
 
 #endif
