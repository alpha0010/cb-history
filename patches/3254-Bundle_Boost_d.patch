Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/call_traits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/call_traits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/call_traits.hpp	(working copy)
@@ -0,0 +1,24 @@
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/utility for most recent version including documentation.
+
+//  See boost/detail/call_traits.hpp and boost/detail/ob_call_traits.hpp
+//  for full copyright notices.
+
+#ifndef BOOST_CALL_TRAITS_HPP
+#define BOOST_CALL_TRAITS_HPP
+
+#ifndef BOOST_CONFIG_HPP
+#include <boost/config.hpp>
+#endif
+
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#include <boost/detail/ob_call_traits.hpp>
+#else
+#include <boost/detail/call_traits.hpp>
+#endif
+
+#endif // BOOST_CALL_TRAITS_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/assert.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/assert.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/assert.hpp	(working copy)
@@ -0,0 +1,131 @@
+//
+//  boost/assert.hpp - BOOST_ASSERT(expr)
+//                     BOOST_ASSERT_MSG(expr, msg)
+//                     BOOST_VERIFY(expr)
+//
+//  Copyright (c) 2001, 2002 Peter Dimov and Multi Media Ltd.
+//  Copyright (c) 2007 Peter Dimov
+//  Copyright (c) Beman Dawes 2011
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+//  Note: There are no include guards. This is intentional.
+//
+//  See http://www.boost.org/libs/utility/assert.html for documentation.
+//
+
+//
+// Stop inspect complaining about use of 'assert':
+//
+// boostinspect:naassert_macro
+//
+
+//--------------------------------------------------------------------------------------//
+//                                     BOOST_ASSERT                                     //
+//--------------------------------------------------------------------------------------//
+
+#undef BOOST_ASSERT
+
+#if defined(BOOST_DISABLE_ASSERTS)
+
+# define BOOST_ASSERT(expr) ((void)0)
+
+#elif defined(BOOST_ENABLE_ASSERT_HANDLER)
+
+#include <boost/current_function.hpp>
+
+namespace boost
+{
+  void assertion_failed(char const * expr,
+                        char const * function, char const * file, long line); // user defined
+} // namespace boost
+
+#define BOOST_ASSERT(expr) ((expr) \
+  ? ((void)0) \
+  : ::boost::assertion_failed(#expr, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
+
+#else
+# include <assert.h> // .h to support old libraries w/o <cassert> - effect is the same
+# define BOOST_ASSERT(expr) assert(expr)
+#endif
+
+//--------------------------------------------------------------------------------------//
+//                                   BOOST_ASSERT_MSG                                   //
+//--------------------------------------------------------------------------------------//
+
+# undef BOOST_ASSERT_MSG
+
+#if defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)
+
+  #define BOOST_ASSERT_MSG(expr, msg) ((void)0)
+
+#elif defined(BOOST_ENABLE_ASSERT_HANDLER)
+
+  #include <boost/current_function.hpp>
+
+  namespace boost
+  {
+    void assertion_failed_msg(char const * expr, char const * msg,
+                              char const * function, char const * file, long line); // user defined
+  } // namespace boost
+
+  #define BOOST_ASSERT_MSG(expr, msg) ((expr) \
+    ? ((void)0) \
+    : ::boost::assertion_failed_msg(#expr, msg, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
+
+#else
+  #ifndef BOOST_ASSERT_HPP
+    #define BOOST_ASSERT_HPP
+    #include <cstdlib>
+    #include <iostream>
+    #include <boost/current_function.hpp>
+
+    //  IDE's like Visual Studio perform better if output goes to std::cout or
+    //  some other stream, so allow user to configure output stream:
+    #ifndef BOOST_ASSERT_MSG_OSTREAM
+    # define BOOST_ASSERT_MSG_OSTREAM std::cerr
+    #endif
+
+    namespace boost
+    {
+      namespace assertion
+      {
+        namespace detail
+        {
+          inline void assertion_failed_msg(char const * expr, char const * msg, char const * function,
+            char const * file, long line)
+          {
+            BOOST_ASSERT_MSG_OSTREAM
+              << "***** Internal Program Error - assertion (" << expr << ") failed in "
+              << function << ":\n"
+              << file << '(' << line << "): " << msg << std::endl;
+            std::abort();
+          }
+        } // detail
+      } // assertion
+    } // detail
+  #endif
+
+  #define BOOST_ASSERT_MSG(expr, msg) ((expr) \
+    ? ((void)0) \
+    : ::boost::assertion::detail::assertion_failed_msg(#expr, msg, \
+          BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
+#endif
+
+//--------------------------------------------------------------------------------------//
+//                                     BOOST_VERIFY                                     //
+//--------------------------------------------------------------------------------------//
+
+#undef BOOST_VERIFY
+
+#if defined(BOOST_DISABLE_ASSERTS) || ( !defined(BOOST_ENABLE_ASSERT_HANDLER) && defined(NDEBUG) )
+
+# define BOOST_VERIFY(expr) ((void)(expr))
+
+#else
+
+# define BOOST_VERIFY(expr) BOOST_ASSERT(expr)
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/next_prior.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/next_prior.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/next_prior.hpp	(working copy)
@@ -0,0 +1,49 @@
+
+#ifndef BOOST_MPL_NEXT_PRIOR_HPP_INCLUDED
+#define BOOST_MPL_NEXT_PRIOR_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: next_prior.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/common_name_wknd.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_COMMON_NAME_WKND(next)
+BOOST_MPL_AUX_COMMON_NAME_WKND(prior)
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T)
+    >
+struct next
+{
+    typedef typename T::next type;
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,next,(T))
+};
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T)
+    >
+struct prior
+{
+    typedef typename T::prior type;
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,prior,(T))
+};
+
+BOOST_MPL_AUX_NA_SPEC(1, next)
+BOOST_MPL_AUX_NA_SPEC(1, prior)
+
+}}
+
+#endif // BOOST_MPL_NEXT_PRIOR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/int.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/int.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/int.hpp	(working copy)
@@ -0,0 +1,22 @@
+
+#ifndef BOOST_MPL_INT_HPP_INCLUDED
+#define BOOST_MPL_INT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: int.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/int_fwd.hpp>
+
+#define AUX_WRAPPER_VALUE_TYPE int
+#include <boost/mpl/aux_/integral_wrapper.hpp>
+
+#endif // BOOST_MPL_INT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/size_t.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/size_t.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/size_t.hpp	(working copy)
@@ -0,0 +1,25 @@
+
+#ifndef BOOST_MPL_SIZE_T_HPP_INCLUDED
+#define BOOST_MPL_SIZE_T_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: size_t.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/size_t_fwd.hpp>
+
+#define AUX_WRAPPER_VALUE_TYPE std::size_t
+#define AUX_WRAPPER_NAME size_t
+#define AUX_WRAPPER_PARAMS(N) std::size_t N
+
+#include <boost/mpl/aux_/integral_wrapper.hpp>
+
+#endif // BOOST_MPL_SIZE_T_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/quote.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/quote.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/quote.hpp	(working copy)
@@ -0,0 +1,151 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_QUOTE_HPP_INCLUDED
+#define BOOST_MPL_QUOTE_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2008
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: quote.hpp 49272 2008-10-11 06:50:46Z agurtovoy $
+// $Date: 2008-10-11 02:50:46 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49272 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/void.hpp>
+#   include <boost/mpl/aux_/has_type.hpp>
+#endif
+
+#include <boost/mpl/aux_/config/bcc.hpp>
+#include <boost/mpl/aux_/config/ttp.hpp>
+
+#if defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS) \
+    && !defined(BOOST_MPL_CFG_BCC590_WORKAROUNDS)
+#   define BOOST_MPL_CFG_NO_QUOTE_TEMPLATE
+#endif
+
+#if !defined(BOOST_MPL_CFG_NO_IMPLICIT_METAFUNCTIONS) \
+    && defined(BOOST_MPL_CFG_NO_HAS_XXX)
+#   define BOOST_MPL_CFG_NO_IMPLICIT_METAFUNCTIONS
+#endif
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+ && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER quote.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/mpl/aux_/config/workaround.hpp>
+
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_QUOTE_TEMPLATE)
+
+namespace boost { namespace mpl {
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template< typename T, bool has_type_ >
+struct quote_impl
+// GCC has a problem with metafunction forwarding when T is a
+// specialization of a template called 'type'.
+# if BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4)) \
+    && BOOST_WORKAROUND(__GNUC_MINOR__, BOOST_TESTED_AT(0)) \
+    && BOOST_WORKAROUND(__GNUC_PATCHLEVEL__, BOOST_TESTED_AT(2))
+{
+    typedef typename T::type type;
+};
+# else
+    : T
+{
+};
+# endif
+
+template< typename T >
+struct quote_impl<T,false>
+{
+    typedef T type;
+};
+
+#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+template< bool > struct quote_impl
+{
+    template< typename T > struct result_
+        : T
+    {
+    };
+};
+
+template<> struct quote_impl<false>
+{
+    template< typename T > struct result_
+    {
+        typedef T type;
+    };
+};
+
+#endif
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/quote.hpp>))
+#include BOOST_PP_ITERATE()
+
+}}
+
+#endif // BOOST_MPL_CFG_NO_QUOTE_TEMPLATE
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_QUOTE_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+template<
+      template< BOOST_MPL_PP_PARAMS(i_, typename P) > class F
+    , typename Tag = void_
+    >
+struct BOOST_PP_CAT(quote,i_)
+{
+    template< BOOST_MPL_PP_PARAMS(i_, typename U) > struct apply
+#if defined(BOOST_MPL_CFG_BCC590_WORKAROUNDS)
+    {
+        typedef typename quote_impl<
+              F< BOOST_MPL_PP_PARAMS(i_, U) >
+            , aux::has_type< F< BOOST_MPL_PP_PARAMS(i_, U) > >::value
+            >::type type;
+    };
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+        : quote_impl<
+              F< BOOST_MPL_PP_PARAMS(i_, U) >
+            , aux::has_type< F< BOOST_MPL_PP_PARAMS(i_, U) > >::value
+            >
+    {
+    };
+#else
+        : quote_impl< aux::has_type< F< BOOST_MPL_PP_PARAMS(i_, U) > >::value >
+            ::template result_< F< BOOST_MPL_PP_PARAMS(i_, U) > >
+    {
+    };
+#endif
+};
+
+#undef i_
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/void.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/void.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/void.hpp	(working copy)
@@ -0,0 +1,76 @@
+
+#ifndef BOOST_MPL_VOID_HPP_INCLUDED
+#define BOOST_MPL_VOID_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: void.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/void_fwd.hpp>
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+//  [JDG Feb-4-2003] made void_ a complete type to allow it to be
+//  instantiated so that it can be passed in as an object that can be
+//  used to select an overloaded function. Possible use includes signaling
+//  a zero arity functor evaluation call.
+struct void_ { typedef void_ type; };
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+namespace boost { namespace mpl {
+
+template< typename T >
+struct is_void_
+    : false_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using false_::value;
+#endif
+};
+
+template<>
+struct is_void_<void_>
+    : true_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using true_::value;
+#endif
+};
+
+template< typename T >
+struct is_not_void_
+    : true_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using true_::value;
+#endif
+};
+
+template<>
+struct is_not_void_<void_>
+    : false_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using false_::value;
+#endif
+};
+
+BOOST_MPL_AUX_NA_SPEC(1, is_void_)
+BOOST_MPL_AUX_NA_SPEC(1, is_not_void_)
+
+}}
+
+#endif // BOOST_MPL_VOID_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/assert.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/assert.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/assert.hpp	(working copy)
@@ -0,0 +1,370 @@
+
+#ifndef BOOST_MPL_ASSERT_HPP_INCLUDED
+#define BOOST_MPL_ASSERT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2006
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: assert.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/not.hpp>
+#include <boost/mpl/aux_/value_wknd.hpp>
+#include <boost/mpl/aux_/nested_type_wknd.hpp>
+#include <boost/mpl/aux_/yes_no.hpp>
+#include <boost/mpl/aux_/na.hpp>
+#include <boost/mpl/aux_/adl_barrier.hpp>
+
+#include <boost/mpl/aux_/config/nttp.hpp>
+#include <boost/mpl/aux_/config/dtp.hpp>
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/pp_counter.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#include <boost/preprocessor/cat.hpp>
+
+#include <boost/config.hpp> // make sure 'size_t' is placed into 'std'
+#include <cstddef>
+
+
+#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+    || (BOOST_MPL_CFG_GCC != 0) \
+    || BOOST_WORKAROUND(__IBMCPP__, <= 600)
+#   define BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES
+#endif
+
+#if BOOST_WORKAROUND(__MWERKS__, < 0x3202) \
+    || BOOST_WORKAROUND(__EDG_VERSION__, <= 238) \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+    || BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+#   define BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER
+#endif
+
+// agurt, 10/nov/06: use enums for Borland (which cannot cope with static constants)
+// and GCC (which issues "unused variable" warnings when static constants are used
+// at a function scope)
+#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+    || (BOOST_MPL_CFG_GCC != 0)
+#   define BOOST_MPL_AUX_ASSERT_CONSTANT(T, expr) enum { expr }
+#else
+#   define BOOST_MPL_AUX_ASSERT_CONSTANT(T, expr) BOOST_STATIC_CONSTANT(T, expr)
+#endif
+
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+struct failed {};
+
+// agurt, 24/aug/04: MSVC 7.1 workaround here and below: return/accept
+// 'assert<false>' by reference; can't apply it unconditionally -- apparently it
+// degrades the quality of GCC diagnostics
+#if BOOST_WORKAROUND(BOOST_MSVC, == 1310)
+#   define AUX778076_ASSERT_ARG(x) x&
+#else
+#   define AUX778076_ASSERT_ARG(x) x
+#endif
+
+template< bool C >  struct assert        { typedef void* type; };
+template<>          struct assert<false> { typedef AUX778076_ASSERT_ARG(assert) type; };
+
+template< bool C >
+int assertion_failed( typename assert<C>::type );
+
+template< bool C >
+struct assertion
+{
+    static int failed( assert<false> );
+};
+
+template<>
+struct assertion<true>
+{
+    static int failed( void* );
+};
+
+struct assert_
+{
+#if !defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};
+#endif
+    static assert_ const arg;
+    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
+};
+
+
+#if !defined(BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES)
+
+bool operator==( failed, failed );
+bool operator!=( failed, failed );
+bool operator>( failed, failed );
+bool operator>=( failed, failed );
+bool operator<( failed, failed );
+bool operator<=( failed, failed );
+
+#if defined(__EDG_VERSION__)
+template< bool (*)(failed, failed), long x, long y > struct assert_relation {};
+#   define BOOST_MPL_AUX_ASSERT_RELATION(x, y, r) assert_relation<r,x,y>
+#else
+template< BOOST_MPL_AUX_NTTP_DECL(long, x), BOOST_MPL_AUX_NTTP_DECL(long, y), bool (*)(failed, failed) >
+struct assert_relation {};
+#   define BOOST_MPL_AUX_ASSERT_RELATION(x, y, r) assert_relation<x,y,r>
+#endif
+
+#else // BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES
+
+boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
+boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
+boost::mpl::aux::weighted_tag<3>::type operator>(  assert_, assert_ );
+boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
+boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
+boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );
+
+template< assert_::relations r, long x, long y > struct assert_relation {};
+
+#endif
+
+
+#if !defined(BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER)
+
+template< bool > struct assert_arg_pred_impl { typedef int type; };
+template<> struct assert_arg_pred_impl<true> { typedef void* type; };
+
+template< typename P > struct assert_arg_pred
+{
+    typedef typename P::type p_type;
+    typedef typename assert_arg_pred_impl< p_type::value >::type type;
+};
+
+template< typename P > struct assert_arg_pred_not
+{
+    typedef typename P::type p_type;
+    BOOST_MPL_AUX_ASSERT_CONSTANT( bool, p = !p_type::value );
+    typedef typename assert_arg_pred_impl<p>::type type;
+};
+
+template< typename Pred >
+failed ************ (Pred::************
+      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
+    );
+
+template< typename Pred >
+failed ************ (boost::mpl::not_<Pred>::************
+      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
+    );
+
+template< typename Pred >
+AUX778076_ASSERT_ARG(assert<false>)
+assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );
+
+template< typename Pred >
+AUX778076_ASSERT_ARG(assert<false>)
+assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
+
+
+#else // BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER
+
+template< bool c, typename Pred > struct assert_arg_type_impl
+{
+    typedef failed      ************ Pred::* mwcw83_wknd;
+    typedef mwcw83_wknd ************* type;
+};
+
+template< typename Pred > struct assert_arg_type_impl<true,Pred>
+{
+    typedef AUX778076_ASSERT_ARG(assert<false>) type;
+};
+
+template< typename Pred > struct assert_arg_type
+    : assert_arg_type_impl< BOOST_MPL_AUX_VALUE_WKND(BOOST_MPL_AUX_NESTED_TYPE_WKND(Pred))::value, Pred >
+{
+};
+
+template< typename Pred >
+typename assert_arg_type<Pred>::type
+assert_arg(void (*)(Pred), int);
+
+template< typename Pred >
+typename assert_arg_type< boost::mpl::not_<Pred> >::type
+assert_not_arg(void (*)(Pred), int);
+
+#   if !defined(BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES)
+template< long x, long y, bool (*r)(failed, failed) >
+typename assert_arg_type_impl< false,BOOST_MPL_AUX_ASSERT_RELATION(x,y,r) >::type
+assert_rel_arg( BOOST_MPL_AUX_ASSERT_RELATION(x,y,r) );
+#   else
+template< assert_::relations r, long x, long y >
+typename assert_arg_type_impl< false,assert_relation<r,x,y> >::type
+assert_rel_arg( assert_relation<r,x,y> );
+#   endif
+
+#endif // BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER
+
+#undef AUX778076_ASSERT_ARG
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+
+// BOOST_MPL_ASSERT((pred<x,...>))
+
+#define BOOST_MPL_ASSERT(pred) \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( \
+          boost::mpl::assertion_failed<false>( \
+              boost::mpl::assert_arg( (void (*) pred)0, 1 ) \
+            ) \
+        ) \
+    ) \
+/**/
+
+// BOOST_MPL_ASSERT_NOT((pred<x,...>))
+
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+#   define BOOST_MPL_ASSERT_NOT(pred) \
+enum { \
+      BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( \
+          boost::mpl::assertion<false>::failed( \
+              boost::mpl::assert_not_arg( (void (*) pred)0, 1 ) \
+            ) \
+        ) \
+}\
+/**/
+#else
+#   define BOOST_MPL_ASSERT_NOT(pred) \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( \
+          boost::mpl::assertion_failed<false>( \
+              boost::mpl::assert_not_arg( (void (*) pred)0, 1 ) \
+            ) \
+        ) \
+   ) \
+/**/
+#endif
+
+// BOOST_MPL_ASSERT_RELATION(x, ==|!=|<=|<|>=|>, y)
+
+#if defined(BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES)
+
+#   if !defined(BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER)
+// agurt, 9/nov/06: 'enum' below is a workaround for gcc 4.0.4/4.1.1 bugs #29522 and #29518
+#   define BOOST_MPL_ASSERT_RELATION_IMPL(counter, x, rel, y)      \
+enum { BOOST_PP_CAT(mpl_assert_rel_value,counter) = (x rel y) }; \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,counter) = sizeof( \
+        boost::mpl::assertion_failed<BOOST_PP_CAT(mpl_assert_rel_value,counter)>( \
+            (boost::mpl::failed ************ ( boost::mpl::assert_relation< \
+                  boost::mpl::assert_::relations( sizeof( \
+                      boost::mpl::assert_::arg rel boost::mpl::assert_::arg \
+                    ) ) \
+                , x \
+                , y \
+                >::************)) 0 ) \
+        ) \
+    ) \
+/**/
+#   else
+#   define BOOST_MPL_ASSERT_RELATION_IMPL(counter, x, rel, y)    \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assert_rel,counter) = sizeof( \
+          boost::mpl::assert_::arg rel boost::mpl::assert_::arg \
+        ) \
+    ); \
+BOOST_MPL_AUX_ASSERT_CONSTANT( bool, BOOST_PP_CAT(mpl_assert_rel_value,counter) = (x rel y) ); \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,counter) = sizeof( \
+        boost::mpl::assertion_failed<BOOST_PP_CAT(mpl_assert_rel_value,counter)>( \
+              boost::mpl::assert_rel_arg( boost::mpl::assert_relation< \
+                  boost::mpl::assert_::relations(BOOST_PP_CAT(mpl_assert_rel,counter)) \
+                , x \
+                , y \
+                >() ) \
+            ) \
+        ) \
+    ) \
+/**/
+#   endif
+
+#   define BOOST_MPL_ASSERT_RELATION(x, rel, y) \
+BOOST_MPL_ASSERT_RELATION_IMPL(BOOST_MPL_AUX_PP_COUNTER(), x, rel, y) \
+/**/
+
+#else // !BOOST_MPL_CFG_ASSERT_USE_RELATION_NAMES
+
+#   if defined(BOOST_MPL_CFG_ASSERT_BROKEN_POINTER_TO_POINTER_TO_MEMBER)
+#   define BOOST_MPL_ASSERT_RELATION(x, rel, y) \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( \
+        boost::mpl::assertion_failed<(x rel y)>( boost::mpl::assert_rel_arg( \
+              boost::mpl::BOOST_MPL_AUX_ASSERT_RELATION(x,y,(&boost::mpl::operator rel))() \
+            ) ) \
+        ) \
+    ) \
+/**/
+#   else
+#   define BOOST_MPL_ASSERT_RELATION(x, rel, y) \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,BOOST_MPL_AUX_PP_COUNTER()) = sizeof( \
+        boost::mpl::assertion_failed<(x rel y)>( (boost::mpl::failed ************ ( \
+            boost::mpl::BOOST_MPL_AUX_ASSERT_RELATION(x,y,(&boost::mpl::operator rel))::************))0 ) \
+        ) \
+    ) \
+/**/
+#   endif
+
+#endif
+
+
+// BOOST_MPL_ASSERT_MSG( (pred<x,...>::value), USER_PROVIDED_MESSAGE, (types<x,...>) )
+
+#if BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3202))
+#   define BOOST_MPL_ASSERT_MSG_IMPL( counter, c, msg, types_ ) \
+struct msg; \
+typedef struct BOOST_PP_CAT(msg,counter) : boost::mpl::assert_ \
+{ \
+    using boost::mpl::assert_::types; \
+    static boost::mpl::failed ************ (msg::************ assert_arg()) types_ \
+    { return 0; } \
+} BOOST_PP_CAT(mpl_assert_arg,counter); \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,counter) = sizeof( \
+        boost::mpl::assertion<(c)>::failed( BOOST_PP_CAT(mpl_assert_arg,counter)::assert_arg() ) \
+        ) \
+    ) \
+/**/
+#else
+#   define BOOST_MPL_ASSERT_MSG_IMPL( counter, c, msg, types_ )  \
+struct msg; \
+typedef struct BOOST_PP_CAT(msg,counter) : boost::mpl::assert_ \
+{ \
+    static boost::mpl::failed ************ (msg::************ assert_arg()) types_ \
+    { return 0; } \
+} BOOST_PP_CAT(mpl_assert_arg,counter); \
+BOOST_MPL_AUX_ASSERT_CONSTANT( \
+      std::size_t \
+    , BOOST_PP_CAT(mpl_assertion_in_line_,counter) = sizeof( \
+        boost::mpl::assertion_failed<(c)>( BOOST_PP_CAT(mpl_assert_arg,counter)::assert_arg() ) \
+        ) \
+    ) \
+/**/
+#endif
+
+#define BOOST_MPL_ASSERT_MSG( c, msg, types_ ) \
+BOOST_MPL_ASSERT_MSG_IMPL( BOOST_MPL_AUX_PP_COUNTER(), c, msg, types_ ) \
+/**/
+
+#endif // BOOST_MPL_ASSERT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/placeholders.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/placeholders.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/placeholders.hpp	(working copy)
@@ -0,0 +1,100 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_PLACEHOLDERS_HPP_INCLUDED
+#define BOOST_MPL_PLACEHOLDERS_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+// Copyright Peter Dimov 2001-2003
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: placeholders.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/arg.hpp>
+#   include <boost/mpl/aux_/adl_barrier.hpp>
+
+#   if !defined(BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE)
+#       define BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(type) \
+        using ::BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::type; \
+        /**/
+#   else
+#       define BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(type) /**/
+#   endif
+
+#endif
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+ && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER placeholders.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+// watch out for GNU gettext users, who #define _(x)
+#if !defined(_) || defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<-1> _;
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_;
+}
+
+}}
+#endif
+
+/// agurt, 17/mar/02: one more placeholder for the last 'apply#'
+/// specialization
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY + 1, <boost/mpl/placeholders.hpp>))
+#include BOOST_PP_ITERATE()
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_PLACEHOLDERS_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+typedef arg<i_> BOOST_PP_CAT(_,i_);
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(BOOST_PP_CAT(_,i_))
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::BOOST_PP_CAT(_,i_);
+}
+
+}}
+
+#undef i_
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/arg_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/arg_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/arg_fwd.hpp	(working copy)
@@ -0,0 +1,28 @@
+
+#ifndef BOOST_MPL_ARG_FWD_HPP_INCLUDED
+#define BOOST_MPL_ARG_FWD_HPP_INCLUDED
+
+// Copyright Peter Dimov 2001-2002
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arg_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+#include <boost/mpl/aux_/nttp_decl.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+template< BOOST_MPL_AUX_NTTP_DECL(int, N) > struct arg;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(arg)
+
+#endif // BOOST_MPL_ARG_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bind.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bind.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bind.hpp	(working copy)
@@ -0,0 +1,551 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_BIND_HPP_INCLUDED
+#define BOOST_MPL_BIND_HPP_INCLUDED
+
+// Copyright Peter Dimov 2001
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: bind.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/bind_fwd.hpp>
+#   include <boost/mpl/placeholders.hpp>
+#   include <boost/mpl/next.hpp>
+#   include <boost/mpl/protect.hpp>
+#   include <boost/mpl/apply_wrap.hpp>
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/na.hpp>
+#   include <boost/mpl/aux_/arity_spec.hpp>
+#   include <boost/mpl/aux_/type_wrapper.hpp>
+#   include <boost/mpl/aux_/yes_no.hpp>
+#   if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+#       include <boost/type_traits/is_reference.hpp>
+#   endif
+#endif
+
+#include <boost/mpl/aux_/config/bind.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   if defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)
+#       define BOOST_MPL_PREPROCESSED_HEADER basic_bind.hpp
+#   else
+#       define BOOST_MPL_PREPROCESSED_HEADER bind.hpp
+#   endif
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/default_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/def_params_tail.hpp>
+#   include <boost/mpl/aux_/preprocessor/partial_spec_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/ext_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/repeat.hpp>
+#   include <boost/mpl/aux_/preprocessor/enum.hpp>
+#   include <boost/mpl/aux_/preprocessor/add.hpp>
+#   include <boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/mpl/aux_/config/ttp.hpp>
+#   include <boost/mpl/aux_/config/dtp.hpp>
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/cat.hpp>
+#   include <boost/preprocessor/inc.hpp>
+
+namespace boost { namespace mpl {
+
+// local macros, #undef-ined at the end of the header
+#   define AUX778076_APPLY \
+    BOOST_PP_CAT(apply_wrap,BOOST_MPL_LIMIT_METAFUNCTION_ARITY) \
+    /**/
+
+#   if defined(BOOST_MPL_CFG_DMC_AMBIGUOUS_CTPS)
+#       define AUX778076_DMC_PARAM() , int dummy_
+#   else
+#       define AUX778076_DMC_PARAM()
+#   endif
+
+#   define AUX778076_BIND_PARAMS(param) \
+    BOOST_MPL_PP_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        ) \
+    /**/
+
+#   define AUX778076_BIND_DEFAULT_PARAMS(param, value) \
+    BOOST_MPL_PP_DEFAULT_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        , value \
+        ) \
+    /**/
+
+#   define AUX778076_BIND_N_PARAMS(n, param) \
+    BOOST_PP_COMMA_IF(n) BOOST_MPL_PP_PARAMS(n, param) \
+    /**/
+
+#   define AUX778076_BIND_N_SPEC_PARAMS(n, param, def) \
+    BOOST_PP_COMMA_IF(n) \
+    BOOST_MPL_PP_PARTIAL_SPEC_PARAMS(n, param, def) \
+    /**/
+
+#if !defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#   define AUX778076_BIND_NESTED_DEFAULT_PARAMS(param, value) \
+    AUX778076_BIND_DEFAULT_PARAMS(param, value) \
+    /**/
+#else
+#   define AUX778076_BIND_NESTED_DEFAULT_PARAMS(param, value) \
+    AUX778076_BIND_PARAMS(param) \
+    /**/
+#endif
+
+namespace aux {
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template<
+      typename T, AUX778076_BIND_PARAMS(typename U)
+    >
+struct resolve_bind_arg
+{
+    typedef T type;
+};
+
+#   if !defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)
+
+template<
+      typename T
+    , typename Arg
+    >
+struct replace_unnamed_arg
+{
+    typedef Arg next;
+    typedef T type;
+};
+
+template<
+      typename Arg
+    >
+struct replace_unnamed_arg< arg<-1>,Arg >
+{
+    typedef typename Arg::next next;
+    typedef Arg type;
+};
+
+#   endif // BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT
+
+template<
+      BOOST_MPL_AUX_NTTP_DECL(int, N), AUX778076_BIND_PARAMS(typename U)
+    >
+struct resolve_bind_arg< arg<N>,AUX778076_BIND_PARAMS(U) >
+{
+    typedef typename AUX778076_APPLY<mpl::arg<N>, AUX778076_BIND_PARAMS(U)>::type type;
+};
+
+#if !defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE)
+template<
+      typename F, AUX778076_BIND_PARAMS(typename T), AUX778076_BIND_PARAMS(typename U)
+    >
+struct resolve_bind_arg< bind<F,AUX778076_BIND_PARAMS(T)>,AUX778076_BIND_PARAMS(U) >
+{
+    typedef bind<F,AUX778076_BIND_PARAMS(T)> f_;
+    typedef typename AUX778076_APPLY<f_, AUX778076_BIND_PARAMS(U)>::type type;
+};
+#endif
+
+#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+// agurt, 15/jan/02: it's not a intended to be used as a function class, and
+// MSVC6.5 has problems with 'apply' name here (the code compiles, but doesn't
+// work), so I went with the 'result_' here, and in all other similar cases
+template< bool >
+struct resolve_arg_impl
+{
+    template< typename T, AUX778076_BIND_PARAMS(typename U) > struct result_
+    {
+        typedef T type;
+    };
+};
+
+template<>
+struct resolve_arg_impl<true>
+{
+    template< typename T, AUX778076_BIND_PARAMS(typename U) > struct result_
+    {
+        typedef typename AUX778076_APPLY<
+              T
+            , AUX778076_BIND_PARAMS(U)
+            >::type type;
+    };
+};
+
+// for 'resolve_bind_arg'
+template< typename T > struct is_bind_template;
+
+template<
+      typename T, AUX778076_BIND_PARAMS(typename U)
+    >
+struct resolve_bind_arg
+    : resolve_arg_impl< is_bind_template<T>::value >
+            ::template result_< T,AUX778076_BIND_PARAMS(U) >
+{
+};
+
+#   if !defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)
+
+template< typename T >
+struct replace_unnamed_arg_impl
+{
+    template< typename Arg > struct result_
+    {
+        typedef Arg next;
+        typedef T type;
+    };
+};
+
+template<>
+struct replace_unnamed_arg_impl< arg<-1> >
+{
+    template< typename Arg > struct result_
+    {
+        typedef typename next<Arg>::type next;
+        typedef Arg type;
+    };
+};
+
+template< typename T, typename Arg >
+struct replace_unnamed_arg
+    : replace_unnamed_arg_impl<T>::template result_<Arg>
+{
+};
+
+#   endif // BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT
+
+// agurt, 10/mar/02: the forward declaration has to appear before any of
+// 'is_bind_helper' overloads, otherwise MSVC6.5 issues an ICE on it
+template< BOOST_MPL_AUX_NTTP_DECL(int, arity_) > struct bind_chooser;
+
+aux::no_tag is_bind_helper(...);
+template< typename T > aux::no_tag is_bind_helper(protect<T>*);
+
+// overload for "main" form
+// agurt, 15/mar/02: MSVC 6.5 fails to properly resolve the overload
+// in case if we use 'aux::type_wrapper< bind<...> >' here, and all
+// 'bind' instantiations form a complete type anyway
+#if !defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE)
+template<
+      typename F, AUX778076_BIND_PARAMS(typename T)
+    >
+aux::yes_tag is_bind_helper(bind<F,AUX778076_BIND_PARAMS(T)>*);
+#endif
+
+template< BOOST_MPL_AUX_NTTP_DECL(int, N) >
+aux::yes_tag is_bind_helper(arg<N>*);
+
+template< bool is_ref_ = true >
+struct is_bind_template_impl
+{
+    template< typename T > struct result_
+    {
+        BOOST_STATIC_CONSTANT(bool, value = false);
+    };
+};
+
+template<>
+struct is_bind_template_impl<false>
+{
+    template< typename T > struct result_
+    {
+        BOOST_STATIC_CONSTANT(bool, value =
+              sizeof(aux::is_bind_helper(static_cast<T*>(0)))
+                == sizeof(aux::yes_tag)
+            );
+    };
+};
+
+template< typename T > struct is_bind_template
+    : is_bind_template_impl< ::boost::detail::is_reference_impl<T>::value >
+        ::template result_<T>
+{
+};
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace aux
+
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/bind.hpp>))
+#include BOOST_PP_ITERATE()
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+    && !defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS)
+/// if_/eval_if specializations
+#   define AUX778076_SPEC_NAME if_
+#   define BOOST_PP_ITERATION_PARAMS_1 (3,(3, 3, <boost/mpl/bind.hpp>))
+#   include BOOST_PP_ITERATE()
+
+#if !defined(BOOST_MPL_CFG_DMC_AMBIGUOUS_CTPS)
+#   define AUX778076_SPEC_NAME eval_if
+#   define BOOST_PP_ITERATION_PARAMS_1 (3,(3, 3, <boost/mpl/bind.hpp>))
+#   include BOOST_PP_ITERATE()
+#endif
+#endif
+
+// real C++ version is already taken care of
+#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+    && !defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE)
+
+namespace aux {
+// apply_count_args
+#define AUX778076_COUNT_ARGS_PREFIX bind
+#define AUX778076_COUNT_ARGS_DEFAULT na
+#define AUX778076_COUNT_ARGS_ARITY BOOST_MPL_LIMIT_METAFUNCTION_ARITY
+#include <boost/mpl/aux_/count_args.hpp>
+}
+
+// bind
+template<
+      typename F, AUX778076_BIND_PARAMS(typename T) AUX778076_DMC_PARAM()
+    >
+struct bind
+    : aux::bind_chooser<
+          aux::bind_count_args<AUX778076_BIND_PARAMS(T)>::value
+        >::template result_< F,AUX778076_BIND_PARAMS(T) >::type
+{
+};
+
+BOOST_MPL_AUX_ARITY_SPEC(
+      BOOST_PP_INC(BOOST_MPL_LIMIT_METAFUNCTION_ARITY)
+    , bind
+    )
+
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(
+      BOOST_PP_INC(BOOST_MPL_LIMIT_METAFUNCTION_ARITY)
+    , bind
+    )
+
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#   undef AUX778076_BIND_NESTED_DEFAULT_PARAMS
+#   undef AUX778076_BIND_N_SPEC_PARAMS
+#   undef AUX778076_BIND_N_PARAMS
+#   undef AUX778076_BIND_DEFAULT_PARAMS
+#   undef AUX778076_BIND_PARAMS
+#   undef AUX778076_DMC_PARAM
+#   undef AUX778076_APPLY
+
+}}
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_BIND_HPP_INCLUDED
+
+///// iteration, depth == 1
+
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
+
+#   define i_ BOOST_PP_FRAME_ITERATION(1)
+
+#if defined(AUX778076_SPEC_NAME)
+
+// lazy metafunction specialization
+template< template< BOOST_MPL_PP_PARAMS(i_, typename T) > class F, typename Tag >
+struct BOOST_PP_CAT(quote,i_);
+
+template< BOOST_MPL_PP_PARAMS(i_, typename T) > struct AUX778076_SPEC_NAME;
+
+template<
+      typename Tag AUX778076_BIND_N_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(bind,i_)<
+      BOOST_PP_CAT(quote,i_)<AUX778076_SPEC_NAME,Tag>
+    AUX778076_BIND_N_PARAMS(i_,T)
+    >
+{
+    template<
+          AUX778076_BIND_NESTED_DEFAULT_PARAMS(typename U, na)
+        >
+    struct apply
+    {
+     private:
+        typedef mpl::arg<1> n1;
+#       define BOOST_PP_ITERATION_PARAMS_2 (3,(1, i_, <boost/mpl/bind.hpp>))
+#       include BOOST_PP_ITERATE()
+
+        typedef typename AUX778076_SPEC_NAME<
+              typename t1::type
+            , BOOST_MPL_PP_EXT_PARAMS(2, BOOST_PP_INC(i_), t)
+            >::type f_;
+
+     public:
+        typedef typename f_::type type;
+    };
+};
+
+#undef AUX778076_SPEC_NAME
+
+#else // AUX778076_SPEC_NAME
+
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T) AUX778076_DMC_PARAM()
+    >
+struct BOOST_PP_CAT(bind,i_)
+{
+    template<
+          AUX778076_BIND_NESTED_DEFAULT_PARAMS(typename U, na)
+        >
+    struct apply
+    {
+     private:
+#   if !defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)
+
+        typedef aux::replace_unnamed_arg< F,mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg<a0,AUX778076_BIND_PARAMS(U)>::type f_;
+        ///
+#   else
+        typedef typename aux::resolve_bind_arg<F,AUX778076_BIND_PARAMS(U)>::type f_;
+
+#   endif // BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT
+
+#   if i_ > 0
+#       define BOOST_PP_ITERATION_PARAMS_2 (3,(1, i_, <boost/mpl/bind.hpp>))
+#       include BOOST_PP_ITERATE()
+#   endif
+
+     public:
+
+#   define AUX778076_ARG(unused, i_, t) \
+    BOOST_PP_COMMA_IF(i_) \
+    typename BOOST_PP_CAT(t,BOOST_PP_INC(i_))::type \
+/**/
+
+        typedef typename BOOST_PP_CAT(apply_wrap,i_)<
+              f_
+            BOOST_PP_COMMA_IF(i_) BOOST_MPL_PP_REPEAT(i_, AUX778076_ARG, t)
+            >::type type;
+
+#   undef AUX778076_ARG
+    };
+};
+
+namespace aux {
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T), AUX778076_BIND_PARAMS(typename U)
+    >
+struct resolve_bind_arg<
+      BOOST_PP_CAT(bind,i_)<F AUX778076_BIND_N_PARAMS(i_,T)>,AUX778076_BIND_PARAMS(U)
+    >
+{
+    typedef BOOST_PP_CAT(bind,i_)<F AUX778076_BIND_N_PARAMS(i_,T)> f_;
+    typedef typename AUX778076_APPLY<f_, AUX778076_BIND_PARAMS(U)>::type type;
+};
+
+#else
+
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T)
+    >
+aux::yes_tag
+is_bind_helper(BOOST_PP_CAT(bind,i_)<F AUX778076_BIND_N_PARAMS(i_,T)>*);
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(BOOST_PP_INC(i_), BOOST_PP_CAT(bind,i_))
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(BOOST_PP_INC(i_), BOOST_PP_CAT(bind,i_))
+
+#   if !defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE)
+#   if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+#if i_ == BOOST_MPL_LIMIT_METAFUNCTION_ARITY
+/// primary template (not a specialization!)
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T) AUX778076_DMC_PARAM()
+    >
+struct bind
+    : BOOST_PP_CAT(bind,i_)<F AUX778076_BIND_N_PARAMS(i_,T) >
+{
+};
+#else
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T) AUX778076_DMC_PARAM()
+    >
+struct bind< F AUX778076_BIND_N_SPEC_PARAMS(i_, T, na) >
+    : BOOST_PP_CAT(bind,i_)<F AUX778076_BIND_N_PARAMS(i_,T) >
+{
+};
+#endif
+
+#   else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+namespace aux {
+
+template<>
+struct bind_chooser<i_>
+{
+    template<
+          typename F, AUX778076_BIND_PARAMS(typename T)
+        >
+    struct result_
+    {
+        typedef BOOST_PP_CAT(bind,i_)< F AUX778076_BIND_N_PARAMS(i_,T) > type;
+    };
+};
+
+} // namespace aux
+
+#   endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   endif // BOOST_MPL_CFG_NO_BIND_TEMPLATE
+
+#endif // AUX778076_SPEC_NAME
+
+#   undef i_
+
+///// iteration, depth == 2
+
+#elif BOOST_PP_ITERATION_DEPTH() == 2
+
+#   define j_ BOOST_PP_FRAME_ITERATION(2)
+#   if !defined(BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT)
+
+        typedef aux::replace_unnamed_arg< BOOST_PP_CAT(T,j_),BOOST_PP_CAT(n,j_) > BOOST_PP_CAT(r,j_);
+        typedef typename BOOST_PP_CAT(r,j_)::type BOOST_PP_CAT(a,j_);
+        typedef typename BOOST_PP_CAT(r,j_)::next BOOST_PP_CAT(n,BOOST_PP_INC(j_));
+        typedef aux::resolve_bind_arg<BOOST_PP_CAT(a,j_), AUX778076_BIND_PARAMS(U)> BOOST_PP_CAT(t,j_);
+        ///
+#   else
+        typedef aux::resolve_bind_arg< BOOST_PP_CAT(T,j_),AUX778076_BIND_PARAMS(U)> BOOST_PP_CAT(t,j_);
+
+#   endif
+#   undef j_
+
+#endif // BOOST_PP_ITERATION_DEPTH()
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/lambda_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/lambda_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/lambda_fwd.hpp	(working copy)
@@ -0,0 +1,57 @@
+
+#ifndef BOOST_MPL_LAMBDA_FWD_HPP_INCLUDED
+#define BOOST_MPL_LAMBDA_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: lambda_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/void_fwd.hpp>
+#include <boost/mpl/aux_/na.hpp>
+#include <boost/mpl/aux_/config/lambda.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+
+#   include <boost/mpl/int.hpp>
+#   include <boost/mpl/aux_/lambda_arity_param.hpp>
+#   include <boost/mpl/aux_/template_arity_fwd.hpp>
+
+namespace boost { namespace mpl {
+
+template<
+      typename T = na
+    , typename Tag = void_
+    BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(
+          typename Arity = int_< aux::template_arity<T>::value >
+        )
+    >
+struct lambda;
+
+}}
+
+#else // BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT
+
+#   include <boost/mpl/bool.hpp>
+
+namespace boost { namespace mpl {
+
+template<
+      typename T = na
+    , typename Tag = void_
+    , typename Protect = true_
+    >
+struct lambda;
+
+}}
+
+#endif
+
+#endif // BOOST_MPL_LAMBDA_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/protect.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/protect.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/protect.hpp	(working copy)
@@ -0,0 +1,55 @@
+
+#ifndef BOOST_MPL_PROTECT_HPP_INCLUDED
+#define BOOST_MPL_PROTECT_HPP_INCLUDED
+
+// Copyright Peter Dimov 2001
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: protect.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/arity.hpp>
+#include <boost/mpl/aux_/config/dtp.hpp>
+#include <boost/mpl/aux_/nttp_decl.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+
+namespace boost { namespace mpl {
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T)
+    , int not_le_ = 0
+    >
+struct protect : T
+{
+#if BOOST_WORKAROUND(__EDG_VERSION__, == 238)
+    typedef mpl::protect type;
+#else
+    typedef protect type;
+#endif
+};
+
+#if defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+namespace aux {
+template< BOOST_MPL_AUX_NTTP_DECL(int, N), typename T >
+struct arity< protect<T>, N >
+    : arity<T,N>
+{
+};
+} // namespace aux
+#endif
+
+BOOST_MPL_AUX_NA_SPEC_MAIN(1, protect)
+#if !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(1, 1, protect)
+#endif
+
+}}
+
+#endif // BOOST_MPL_PROTECT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/int_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/int_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/int_fwd.hpp	(working copy)
@@ -0,0 +1,27 @@
+
+#ifndef BOOST_MPL_INT_FWD_HPP_INCLUDED
+#define BOOST_MPL_INT_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: int_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+#include <boost/mpl/aux_/nttp_decl.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+template< BOOST_MPL_AUX_NTTP_DECL(int, N) > struct int_;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(int_)
+
+#endif // BOOST_MPL_INT_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/size_t_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/size_t_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/size_t_fwd.hpp	(working copy)
@@ -0,0 +1,28 @@
+
+#ifndef BOOST_MPL_SIZE_T_FWD_HPP_INCLUDED
+#define BOOST_MPL_SIZE_T_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: size_t_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+#include <boost/config.hpp> // make sure 'size_t' is placed into 'std'
+#include <cstddef>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+template< std::size_t N > struct size_t;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(size_t)
+
+#endif // BOOST_MPL_SIZE_T_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/if.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/if.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/if.hpp	(working copy)
@@ -0,0 +1,135 @@
+
+#ifndef BOOST_MPL_IF_HPP_INCLUDED
+#define BOOST_MPL_IF_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: if.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/value_wknd.hpp>
+#include <boost/mpl/aux_/static_cast.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+#include <boost/mpl/aux_/config/integral.hpp>
+#include <boost/mpl/aux_/config/ctps.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+namespace boost { namespace mpl {
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template<
+      bool C
+    , typename T1
+    , typename T2
+    >
+struct if_c
+{
+    typedef T1 type;
+};
+
+template<
+      typename T1
+    , typename T2
+    >
+struct if_c<false,T1,T2>
+{
+    typedef T2 type;
+};
+
+// agurt, 05/sep/04: nondescriptive parameter names for the sake of DigitalMars
+// (and possibly MWCW < 8.0); see http://article.gmane.org/gmane.comp.lib.boost.devel/108959
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T1)
+    , typename BOOST_MPL_AUX_NA_PARAM(T2)
+    , typename BOOST_MPL_AUX_NA_PARAM(T3)
+    >
+struct if_
+{
+ private:
+    // agurt, 02/jan/03: two-step 'type' definition for the sake of aCC
+    typedef if_c<
+#if defined(BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS)
+          BOOST_MPL_AUX_VALUE_WKND(T1)::value
+#else
+          BOOST_MPL_AUX_STATIC_CAST(bool, BOOST_MPL_AUX_VALUE_WKND(T1)::value)
+#endif
+        , T2
+        , T3
+        > almost_type_;
+
+ public:
+    typedef typename almost_type_::type type;
+
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(3,if_,(T1,T2,T3))
+};
+
+#else
+
+// no partial class template specialization
+
+namespace aux {
+
+template< bool C >
+struct if_impl
+{
+    template< typename T1, typename T2 > struct result_
+    {
+        typedef T1 type;
+    };
+};
+
+template<>
+struct if_impl<false>
+{
+    template< typename T1, typename T2 > struct result_
+    {
+        typedef T2 type;
+    };
+};
+
+} // namespace aux
+
+template<
+      bool C_
+    , typename T1
+    , typename T2
+    >
+struct if_c
+{
+    typedef typename aux::if_impl< C_ >
+        ::template result_<T1,T2>::type type;
+};
+
+// (almost) copy & paste in order to save one more
+// recursively nested template instantiation to user
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(C_)
+    , typename BOOST_MPL_AUX_NA_PARAM(T1)
+    , typename BOOST_MPL_AUX_NA_PARAM(T2)
+    >
+struct if_
+{
+    enum { msvc_wknd_ = BOOST_MPL_AUX_MSVC_VALUE_WKND(C_)::value };
+
+    typedef typename aux::if_impl< BOOST_MPL_AUX_STATIC_CAST(bool, msvc_wknd_) >
+        ::template result_<T1,T2>::type type;
+
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(3,if_,(C_,T1,T2))
+};
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+BOOST_MPL_AUX_NA_SPEC(3, if_)
+
+}}
+
+#endif // BOOST_MPL_IF_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/void_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/void_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/void_fwd.hpp	(working copy)
@@ -0,0 +1,26 @@
+
+#ifndef BOOST_MPL_VOID_FWD_HPP_INCLUDED
+#define BOOST_MPL_VOID_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: void_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+struct void_;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(void_)
+
+#endif // BOOST_MPL_VOID_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c_tag.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c_tag.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c_tag.hpp	(working copy)
@@ -0,0 +1,26 @@
+
+#ifndef BOOST_MPL_INTEGRAL_C_TAG_HPP_INCLUDED
+#define BOOST_MPL_INTEGRAL_C_TAG_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: integral_c_tag.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+struct integral_c_tag { BOOST_STATIC_CONSTANT(int, value = 0); };
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(integral_c_tag)
+
+#endif // BOOST_MPL_INTEGRAL_C_TAG_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/limits/arity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/limits/arity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/limits/arity.hpp	(working copy)
@@ -0,0 +1,21 @@
+
+#ifndef BOOST_MPL_LIMITS_ARITY_HPP_INCLUDED
+#define BOOST_MPL_LIMITS_ARITY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arity.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_LIMIT_METAFUNCTION_ARITY)
+#   define BOOST_MPL_LIMIT_METAFUNCTION_ARITY 5
+#endif
+
+#endif // BOOST_MPL_LIMITS_ARITY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bind_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bind_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bind_fwd.hpp	(working copy)
@@ -0,0 +1,99 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_BIND_FWD_HPP_INCLUDED
+#define BOOST_MPL_BIND_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: bind_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/aux_/na.hpp>
+#endif
+
+#include <boost/mpl/aux_/config/bind.hpp>
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER bind_fwd.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/default_params.hpp>
+#   include <boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp>
+
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+namespace boost { namespace mpl {
+
+// local macros, #undef-ined at the end of the header
+
+#   if defined(BOOST_MPL_CFG_DMC_AMBIGUOUS_CTPS)
+#       define AUX778076_DMC_PARAM() , int dummy_ = 0
+#   else
+#       define AUX778076_DMC_PARAM()
+#   endif
+
+#   define AUX778076_BIND_DEFAULT_PARAMS(param, value) \
+    BOOST_MPL_PP_DEFAULT_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        , value \
+        ) \
+    AUX778076_DMC_PARAM() \
+    /**/
+
+#   define AUX778076_BIND_N_PARAMS(n, param) \
+    BOOST_PP_COMMA_IF(n) BOOST_MPL_PP_PARAMS(n, param) \
+    AUX778076_DMC_PARAM() \
+    /**/
+
+#if !defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE)
+template<
+      typename F, AUX778076_BIND_DEFAULT_PARAMS(typename T, na)
+    >
+struct bind;
+#endif
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/bind_fwd.hpp>))
+#include BOOST_PP_ITERATE()
+
+#   undef AUX778076_BIND_N_PARAMS
+#   undef AUX778076_BIND_DEFAULT_PARAMS
+#   undef AUX778076_DMC_PARAM
+}}
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_BIND_FWD_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(bind,i_);
+
+#undef i_
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bool.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bool.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bool.hpp	(working copy)
@@ -0,0 +1,39 @@
+
+#ifndef BOOST_MPL_BOOL_HPP_INCLUDED
+#define BOOST_MPL_BOOL_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: bool.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/bool_fwd.hpp>
+#include <boost/mpl/integral_c_tag.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+template< bool C_ > struct bool_
+{
+    BOOST_STATIC_CONSTANT(bool, value = C_);
+    typedef integral_c_tag tag;
+    typedef bool_ type;
+    typedef bool value_type;
+    operator bool() const { return this->value; }
+};
+
+#if !defined(BOOST_NO_INCLASS_MEMBER_INITIALIZATION)
+template< bool C_ >
+bool const bool_<C_>::value;
+#endif
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+#endif // BOOST_MPL_BOOL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arg_typedef.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arg_typedef.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arg_typedef.hpp	(working copy)
@@ -0,0 +1,31 @@
+
+#ifndef BOOST_MPL_AUX_ARG_TYPEDEF_HPP_INCLUDED
+#define BOOST_MPL_AUX_ARG_TYPEDEF_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arg_typedef.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/lambda.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT) \
+    || BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+
+#   define BOOST_MPL_AUX_ARG_TYPEDEF(T, name) typedef T name;
+
+#else
+
+#   define BOOST_MPL_AUX_ARG_TYPEDEF(T, name) /**/
+
+#endif
+
+#endif // BOOST_MPL_AUX_ARG_TYPEDEF_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/yes_no.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/yes_no.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/yes_no.hpp	(working copy)
@@ -0,0 +1,58 @@
+
+#ifndef BOOST_MPL_AUX_YES_NO_HPP_INCLUDED
+#define BOOST_MPL_AUX_YES_NO_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: yes_no.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/nttp_decl.hpp>
+#include <boost/mpl/aux_/config/arrays.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+
+namespace boost { namespace mpl { namespace aux {
+
+typedef char (&no_tag)[1];
+typedef char (&yes_tag)[2];
+
+template< bool C_ > struct yes_no_tag
+{
+    typedef no_tag type;
+};
+
+template<> struct yes_no_tag<true>
+{
+    typedef yes_tag type;
+};
+
+
+template< BOOST_MPL_AUX_NTTP_DECL(long, n) > struct weighted_tag
+{
+#if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    typedef char (&type)[n];
+#else
+    char buf[n];
+    typedef weighted_tag type;
+#endif
+};
+
+#if defined(BOOST_MPL_CFG_NO_DEPENDENT_ARRAY_TYPES)
+template<> struct weighted_tag<0>
+{
+    typedef char (&type)[1];
+};
+#endif
+
+}}}
+
+#endif // BOOST_MPL_AUX_YES_NO_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na.hpp	(working copy)
@@ -0,0 +1,95 @@
+
+#ifndef BOOST_MPL_AUX_NA_HPP_INCLUDED
+#define BOOST_MPL_AUX_NA_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: na.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/aux_/na_fwd.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/ctps.hpp>
+
+namespace boost { namespace mpl {
+
+template< typename T >
+struct is_na
+    : false_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using false_::value;
+#endif
+};
+
+template<>
+struct is_na<na>
+    : true_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using true_::value;
+#endif
+};
+
+template< typename T >
+struct is_not_na
+    : true_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using true_::value;
+#endif
+};
+
+template<>
+struct is_not_na<na>
+    : false_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    using false_::value;
+#endif
+};
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+template< typename T, typename U > struct if_na
+{
+    typedef T type;
+};
+
+template< typename U > struct if_na<na,U>
+{
+    typedef U type;
+};
+#else
+template< typename T > struct if_na_impl
+{
+    template< typename U > struct apply
+    {
+        typedef T type;
+    };
+};
+
+template<> struct if_na_impl<na>
+{
+    template< typename U > struct apply
+    {
+        typedef U type;
+    };
+};
+
+template< typename T, typename U > struct if_na
+    : if_na_impl<T>::template apply<U>
+{
+};
+#endif
+
+}}
+
+#endif // BOOST_MPL_AUX_NA_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/include_preprocessed.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/include_preprocessed.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/include_preprocessed.hpp	(working copy)
@@ -0,0 +1,42 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2000-2006
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: include_preprocessed.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/compiler.hpp>
+#include <boost/mpl/aux_/config/preprocessor.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/stringize.hpp>
+
+#if !defined(BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING)
+#   define AUX778076_PREPROCESSED_HEADER \
+    BOOST_MPL_CFG_COMPILER_DIR/BOOST_MPL_PREPROCESSED_HEADER \
+/**/
+#else
+#   define AUX778076_PREPROCESSED_HEADER \
+    BOOST_PP_CAT(BOOST_MPL_CFG_COMPILER_DIR,/)##BOOST_MPL_PREPROCESSED_HEADER \
+/**/
+#endif
+
+#if BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(700))
+#   define AUX778076_INCLUDE_STRING BOOST_PP_STRINGIZE(boost/mpl/aux_/preprocessed/AUX778076_PREPROCESSED_HEADER)
+#   include AUX778076_INCLUDE_STRING
+#   undef AUX778076_INCLUDE_STRING
+#else
+#   include BOOST_PP_STRINGIZE(boost/mpl/aux_/preprocessed/AUX778076_PREPROCESSED_HEADER)
+#endif
+
+#   undef AUX778076_PREPROCESSED_HEADER
+
+#undef BOOST_MPL_PREPROCESSED_HEADER
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arity_spec.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arity_spec.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arity_spec.hpp	(working copy)
@@ -0,0 +1,67 @@
+
+#ifndef BOOST_MPL_AUX_ARITY_SPEC_HPP_INCLUDED
+#define BOOST_MPL_AUX_ARITY_SPEC_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arity_spec.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/int.hpp>
+#include <boost/mpl/limits/arity.hpp>
+#include <boost/mpl/aux_/config/dtp.hpp>
+#include <boost/mpl/aux_/preprocessor/params.hpp>
+#include <boost/mpl/aux_/arity.hpp>
+#include <boost/mpl/aux_/template_arity_fwd.hpp>
+#include <boost/mpl/aux_/config/ttp.hpp>
+#include <boost/mpl/aux_/config/lambda.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+
+#if defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#   define BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(i,type,name) \
+namespace aux { \
+template< BOOST_MPL_AUX_NTTP_DECL(int, N), BOOST_MPL_PP_PARAMS(i,type T) > \
+struct arity< \
+      name< BOOST_MPL_PP_PARAMS(i,T) > \
+    , N \
+    > \
+{ \
+    BOOST_STATIC_CONSTANT(int \
+        , value = BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        ); \
+}; \
+} \
+/**/
+#else
+#   define BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(i,type,name) /**/
+#endif
+
+#   define BOOST_MPL_AUX_ARITY_SPEC(i,name) \
+    BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(i,typename,name) \
+/**/
+
+
+#if defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING) \
+    && !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+#   define BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(i, name) \
+namespace aux { \
+template< BOOST_MPL_PP_PARAMS(i,typename T) > \
+struct template_arity< name<BOOST_MPL_PP_PARAMS(i,T)> > \
+    : int_<i> \
+{ \
+}; \
+} \
+/**/
+#else
+#   define BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(i, name) /**/
+#endif
+
+
+#endif // BOOST_MPL_AUX_ARITY_SPEC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/integral_wrapper.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/integral_wrapper.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/integral_wrapper.hpp	(working copy)
@@ -0,0 +1,93 @@
+
+// Copyright Aleksey Gurtovoy 2000-2006
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: integral_wrapper.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION!
+
+#include <boost/mpl/integral_c_tag.hpp>
+#include <boost/mpl/aux_/static_cast.hpp>
+#include <boost/mpl/aux_/nttp_decl.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#include <boost/preprocessor/cat.hpp>
+
+#if !defined(AUX_WRAPPER_NAME)
+#   define AUX_WRAPPER_NAME BOOST_PP_CAT(AUX_WRAPPER_VALUE_TYPE,_)
+#endif
+
+#if !defined(AUX_WRAPPER_PARAMS)
+#   define AUX_WRAPPER_PARAMS(N) BOOST_MPL_AUX_NTTP_DECL(AUX_WRAPPER_VALUE_TYPE, N)
+#endif
+
+#if !defined(AUX_WRAPPER_INST)
+#   if BOOST_WORKAROUND(__MWERKS__, <= 0x2407)
+#       define AUX_WRAPPER_INST(value) AUX_WRAPPER_NAME< value >
+#   else
+#       define AUX_WRAPPER_INST(value) BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::AUX_WRAPPER_NAME< value >
+#   endif
+#endif
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+template< AUX_WRAPPER_PARAMS(N) >
+struct AUX_WRAPPER_NAME
+{
+    BOOST_STATIC_CONSTANT(AUX_WRAPPER_VALUE_TYPE, value = N);
+// agurt, 08/mar/03: SGI MIPSpro C++ workaround, have to #ifdef because some
+// other compilers (e.g. MSVC) are not particulary happy about it
+#if BOOST_WORKAROUND(__EDG_VERSION__, <= 238)
+    typedef struct AUX_WRAPPER_NAME type;
+#else
+    typedef AUX_WRAPPER_NAME type;
+#endif
+    typedef AUX_WRAPPER_VALUE_TYPE value_type;
+    typedef integral_c_tag tag;
+
+// have to #ifdef here: some compilers don't like the 'N + 1' form (MSVC),
+// while some other don't like 'value + 1' (Borland), and some don't like
+// either
+#if BOOST_WORKAROUND(__EDG_VERSION__, <= 243)
+ private:
+    BOOST_STATIC_CONSTANT(AUX_WRAPPER_VALUE_TYPE, next_value = BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (N + 1)));
+    BOOST_STATIC_CONSTANT(AUX_WRAPPER_VALUE_TYPE, prior_value = BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (N - 1)));
+ public:
+    typedef AUX_WRAPPER_INST(next_value) next;
+    typedef AUX_WRAPPER_INST(prior_value) prior;
+#elif BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x561)) \
+    || BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(502)) \
+    || (BOOST_WORKAROUND(__HP_aCC, <= 53800) && (BOOST_WORKAROUND(__hpxstd98, != 1)))
+    typedef AUX_WRAPPER_INST( BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (N + 1)) ) next;
+    typedef AUX_WRAPPER_INST( BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (N - 1)) ) prior;
+#else
+    typedef AUX_WRAPPER_INST( BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (value + 1)) ) next;
+    typedef AUX_WRAPPER_INST( BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (value - 1)) ) prior;
+#endif
+
+    // enables uniform function call syntax for families of overloaded
+    // functions that return objects of both arithmetic ('int', 'long',
+    // 'double', etc.) and wrapped integral types (for an example, see
+    // "mpl/example/power.cpp")
+    operator AUX_WRAPPER_VALUE_TYPE() const { return static_cast<AUX_WRAPPER_VALUE_TYPE>(this->value); }
+};
+
+#if !defined(BOOST_NO_INCLASS_MEMBER_INITIALIZATION)
+template< AUX_WRAPPER_PARAMS(N) >
+AUX_WRAPPER_VALUE_TYPE const AUX_WRAPPER_INST(N)::value;
+#endif
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+#undef AUX_WRAPPER_NAME
+#undef AUX_WRAPPER_PARAMS
+#undef AUX_WRAPPER_INST
+#undef AUX_WRAPPER_VALUE_TYPE
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/adl_barrier.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/adl_barrier.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/adl_barrier.hpp	(working copy)
@@ -0,0 +1,48 @@
+
+#ifndef BOOST_MPL_AUX_ADL_BARRIER_HPP_INCLUDED
+#define BOOST_MPL_AUX_ADL_BARRIER_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: adl_barrier.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/adl.hpp>
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE)
+
+#   define BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE mpl_
+#   define BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN namespace mpl_ {
+#   define BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE }
+#   define BOOST_MPL_AUX_ADL_BARRIER_DECL(type) \
+    namespace boost { namespace mpl { \
+    using ::BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::type; \
+    } } \
+/**/
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+namespace BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE { namespace aux {} }
+namespace boost { namespace mpl { using namespace BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE;
+namespace aux { using namespace BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::aux; }
+}}
+#endif
+
+#else // BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE
+
+#   define BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE boost::mpl
+#   define BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN namespace boost { namespace mpl {
+#   define BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE }}
+#   define BOOST_MPL_AUX_ADL_BARRIER_DECL(type) /**/
+
+#endif
+
+#endif // BOOST_MPL_AUX_ADL_BARRIER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/quote.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/quote.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/quote.hpp	(working copy)
@@ -0,0 +1,123 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/quote.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+template< typename T, bool has_type_ >
+struct quote_impl
+{
+    typedef typename T::type type;
+};
+
+template< typename T >
+struct quote_impl< T,false >
+{
+    typedef T type;
+};
+
+template<
+      template< typename P1 > class F
+    , typename Tag = void_
+    >
+struct quote1
+{
+    template< typename U1 > struct apply
+
+        : quote_impl<
+              F<U1>
+            , aux::has_type< F<U1> >::value
+            >
+
+    {
+    };
+};
+
+template<
+      template< typename P1, typename P2 > class F
+    , typename Tag = void_
+    >
+struct quote2
+{
+    template< typename U1, typename U2 > struct apply
+
+        : quote_impl<
+              F< U1,U2 >
+            , aux::has_type< F< U1,U2 > >::value
+            >
+
+    {
+    };
+};
+
+template<
+      template< typename P1, typename P2, typename P3 > class F
+    , typename Tag = void_
+    >
+struct quote3
+{
+    template< typename U1, typename U2, typename U3 > struct apply
+
+        : quote_impl<
+              F< U1,U2,U3 >
+            , aux::has_type< F< U1,U2,U3 > >::value
+            >
+
+    {
+    };
+};
+
+template<
+      template< typename P1, typename P2, typename P3, typename P4 > class F
+    , typename Tag = void_
+    >
+struct quote4
+{
+    template<
+          typename U1, typename U2, typename U3, typename U4
+        >
+    struct apply
+
+        : quote_impl<
+              F< U1,U2,U3,U4 >
+            , aux::has_type< F< U1,U2,U3,U4 > >::value
+            >
+
+    {
+    };
+};
+
+template<
+      template<
+          typename P1, typename P2, typename P3, typename P4
+        , typename P5
+        >
+      class F
+    , typename Tag = void_
+    >
+struct quote5
+{
+    template<
+          typename U1, typename U2, typename U3, typename U4
+        , typename U5
+        >
+    struct apply
+
+        : quote_impl<
+              F< U1,U2,U3,U4,U5 >
+            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
+            >
+
+    {
+    };
+};
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp	(working copy)
@@ -0,0 +1,558 @@
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/aux_/full_lambda.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+namespace aux {
+
+template<
+      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
+    , bool C5 = false
+    >
+struct lambda_or
+    : true_
+{
+};
+
+template<>
+struct lambda_or< false,false,false,false,false >
+    : false_
+{
+};
+
+} // namespace aux
+
+template<
+      typename T
+    , typename Tag
+    , typename Arity
+    >
+struct lambda
+{
+    typedef false_ is_le;
+    typedef T result_;
+    typedef T type;
+};
+
+template<
+      typename T
+    >
+struct is_lambda_expression
+    : lambda<T>::is_le
+{
+};
+
+template< int N, typename Tag >
+struct lambda< arg<N>,Tag, int_< -1 > >
+{
+    typedef true_ is_le;
+    typedef mpl::arg<N> result_; // qualified for the sake of MIPSpro 7.41
+    typedef mpl::protect<result_> type;
+};
+
+template<
+      typename F
+    , typename Tag
+    >
+struct lambda<
+          bind0<F>
+        , Tag
+        , int_<1>
+        >
+{
+    typedef false_ is_le;
+    typedef bind0<
+          F
+        > result_;
+
+    typedef result_ type;
+};
+
+namespace aux {
+
+template<
+      typename IsLE, typename Tag
+    , template< typename P1 > class F
+    , typename L1
+    >
+struct le_result1
+{
+    typedef F<
+          typename L1::type
+        > result_;
+
+    typedef result_ type;
+};
+
+template<
+      typename Tag
+    , template< typename P1 > class F
+    , typename L1
+    >
+struct le_result1< true_,Tag,F,L1 >
+{
+    typedef bind1<
+          quote1< F,Tag >
+        , typename L1::result_
+        > result_;
+
+    typedef mpl::protect<result_> type;
+};
+
+} // namespace aux
+
+template<
+      template< typename P1 > class F
+    , typename T1
+    , typename Tag
+    >
+struct lambda<
+          F<T1>
+        , Tag
+        , int_<1>
+        >
+{
+    typedef lambda< T1,Tag > l1;
+    typedef typename l1::is_le is_le1;
+    typedef typename aux::lambda_or<
+          is_le1::value
+        >::type is_le;
+
+    typedef aux::le_result1<
+          is_le, Tag, F, l1
+        > le_result_;
+
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+template<
+      typename F, typename T1
+    , typename Tag
+    >
+struct lambda<
+          bind1< F,T1 >
+        , Tag
+        , int_<2>
+        >
+{
+    typedef false_ is_le;
+    typedef bind1<
+          F
+        , T1
+        > result_;
+
+    typedef result_ type;
+};
+
+namespace aux {
+
+template<
+      typename IsLE, typename Tag
+    , template< typename P1, typename P2 > class F
+    , typename L1, typename L2
+    >
+struct le_result2
+{
+    typedef F<
+          typename L1::type, typename L2::type
+        > result_;
+
+    typedef result_ type;
+};
+
+template<
+      typename Tag
+    , template< typename P1, typename P2 > class F
+    , typename L1, typename L2
+    >
+struct le_result2< true_,Tag,F,L1,L2 >
+{
+    typedef bind2<
+          quote2< F,Tag >
+        , typename L1::result_, typename L2::result_
+        > result_;
+
+    typedef mpl::protect<result_> type;
+};
+
+} // namespace aux
+
+template<
+      template< typename P1, typename P2 > class F
+    , typename T1, typename T2
+    , typename Tag
+    >
+struct lambda<
+          F< T1,T2 >
+        , Tag
+        , int_<2>
+        >
+{
+    typedef lambda< T1,Tag > l1;
+    typedef lambda< T2,Tag > l2;
+
+    typedef typename l1::is_le is_le1;
+    typedef typename l2::is_le is_le2;
+
+
+    typedef typename aux::lambda_or<
+          is_le1::value, is_le2::value
+        >::type is_le;
+
+    typedef aux::le_result2<
+          is_le, Tag, F, l1, l2
+        > le_result_;
+
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+template<
+      typename F, typename T1, typename T2
+    , typename Tag
+    >
+struct lambda<
+          bind2< F,T1,T2 >
+        , Tag
+        , int_<3>
+        >
+{
+    typedef false_ is_le;
+    typedef bind2<
+          F
+        , T1, T2
+        > result_;
+
+    typedef result_ type;
+};
+
+namespace aux {
+
+template<
+      typename IsLE, typename Tag
+    , template< typename P1, typename P2, typename P3 > class F
+    , typename L1, typename L2, typename L3
+    >
+struct le_result3
+{
+    typedef F<
+          typename L1::type, typename L2::type, typename L3::type
+        > result_;
+
+    typedef result_ type;
+};
+
+template<
+      typename Tag
+    , template< typename P1, typename P2, typename P3 > class F
+    , typename L1, typename L2, typename L3
+    >
+struct le_result3< true_,Tag,F,L1,L2,L3 >
+{
+    typedef bind3<
+          quote3< F,Tag >
+        , typename L1::result_, typename L2::result_, typename L3::result_
+        > result_;
+
+    typedef mpl::protect<result_> type;
+};
+
+} // namespace aux
+
+template<
+      template< typename P1, typename P2, typename P3 > class F
+    , typename T1, typename T2, typename T3
+    , typename Tag
+    >
+struct lambda<
+          F< T1,T2,T3 >
+        , Tag
+        , int_<3>
+        >
+{
+    typedef lambda< T1,Tag > l1;
+    typedef lambda< T2,Tag > l2;
+    typedef lambda< T3,Tag > l3;
+
+    typedef typename l1::is_le is_le1;
+    typedef typename l2::is_le is_le2;
+    typedef typename l3::is_le is_le3;
+
+
+    typedef typename aux::lambda_or<
+          is_le1::value, is_le2::value, is_le3::value
+        >::type is_le;
+
+    typedef aux::le_result3<
+          is_le, Tag, F, l1, l2, l3
+        > le_result_;
+
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    , typename Tag
+    >
+struct lambda<
+          bind3< F,T1,T2,T3 >
+        , Tag
+        , int_<4>
+        >
+{
+    typedef false_ is_le;
+    typedef bind3<
+          F
+        , T1, T2, T3
+        > result_;
+
+    typedef result_ type;
+};
+
+namespace aux {
+
+template<
+      typename IsLE, typename Tag
+    , template< typename P1, typename P2, typename P3, typename P4 > class F
+    , typename L1, typename L2, typename L3, typename L4
+    >
+struct le_result4
+{
+    typedef F<
+          typename L1::type, typename L2::type, typename L3::type
+        , typename L4::type
+        > result_;
+
+    typedef result_ type;
+};
+
+template<
+      typename Tag
+    , template< typename P1, typename P2, typename P3, typename P4 > class F
+    , typename L1, typename L2, typename L3, typename L4
+    >
+struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
+{
+    typedef bind4<
+          quote4< F,Tag >
+        , typename L1::result_, typename L2::result_, typename L3::result_
+        , typename L4::result_
+        > result_;
+
+    typedef mpl::protect<result_> type;
+};
+
+} // namespace aux
+
+template<
+      template< typename P1, typename P2, typename P3, typename P4 > class F
+    , typename T1, typename T2, typename T3, typename T4
+    , typename Tag
+    >
+struct lambda<
+          F< T1,T2,T3,T4 >
+        , Tag
+        , int_<4>
+        >
+{
+    typedef lambda< T1,Tag > l1;
+    typedef lambda< T2,Tag > l2;
+    typedef lambda< T3,Tag > l3;
+    typedef lambda< T4,Tag > l4;
+
+    typedef typename l1::is_le is_le1;
+    typedef typename l2::is_le is_le2;
+    typedef typename l3::is_le is_le3;
+    typedef typename l4::is_le is_le4;
+
+
+    typedef typename aux::lambda_or<
+          is_le1::value, is_le2::value, is_le3::value, is_le4::value
+        >::type is_le;
+
+    typedef aux::le_result4<
+          is_le, Tag, F, l1, l2, l3, l4
+        > le_result_;
+
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename Tag
+    >
+struct lambda<
+          bind4< F,T1,T2,T3,T4 >
+        , Tag
+        , int_<5>
+        >
+{
+    typedef false_ is_le;
+    typedef bind4<
+          F
+        , T1, T2, T3, T4
+        > result_;
+
+    typedef result_ type;
+};
+
+namespace aux {
+
+template<
+      typename IsLE, typename Tag
+    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
+    , typename L1, typename L2, typename L3, typename L4, typename L5
+    >
+struct le_result5
+{
+    typedef F<
+          typename L1::type, typename L2::type, typename L3::type
+        , typename L4::type, typename L5::type
+        > result_;
+
+    typedef result_ type;
+};
+
+template<
+      typename Tag
+    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
+    , typename L1, typename L2, typename L3, typename L4, typename L5
+    >
+struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
+{
+    typedef bind5<
+          quote5< F,Tag >
+        , typename L1::result_, typename L2::result_, typename L3::result_
+        , typename L4::result_, typename L5::result_
+        > result_;
+
+    typedef mpl::protect<result_> type;
+};
+
+} // namespace aux
+
+template<
+      template<
+          typename P1, typename P2, typename P3, typename P4
+        , typename P5
+        >
+      class F
+    , typename T1, typename T2, typename T3, typename T4, typename T5
+    , typename Tag
+    >
+struct lambda<
+          F< T1,T2,T3,T4,T5 >
+        , Tag
+        , int_<5>
+        >
+{
+    typedef lambda< T1,Tag > l1;
+    typedef lambda< T2,Tag > l2;
+    typedef lambda< T3,Tag > l3;
+    typedef lambda< T4,Tag > l4;
+    typedef lambda< T5,Tag > l5;
+
+    typedef typename l1::is_le is_le1;
+    typedef typename l2::is_le is_le2;
+    typedef typename l3::is_le is_le3;
+    typedef typename l4::is_le is_le4;
+    typedef typename l5::is_le is_le5;
+
+
+    typedef typename aux::lambda_or<
+          is_le1::value, is_le2::value, is_le3::value, is_le4::value
+        , is_le5::value
+        >::type is_le;
+
+    typedef aux::le_result5<
+          is_le, Tag, F, l1, l2, l3, l4, l5
+        > le_result_;
+
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    , typename Tag
+    >
+struct lambda<
+          bind5< F,T1,T2,T3,T4,T5 >
+        , Tag
+        , int_<6>
+        >
+{
+    typedef false_ is_le;
+    typedef bind5<
+          F
+        , T1, T2, T3, T4, T5
+        > result_;
+
+    typedef result_ type;
+};
+
+/// special case for 'protect'
+template< typename T, typename Tag >
+struct lambda< mpl::protect<T>,Tag, int_<1> >
+{
+    typedef false_ is_le;
+    typedef mpl::protect<T> result_;
+    typedef result_ type;
+};
+
+/// specializations for the main 'bind' form
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    , typename Tag
+    >
+struct lambda<
+          bind< F,T1,T2,T3,T4,T5 >
+        , Tag
+        , int_<6>
+        >
+{
+    typedef false_ is_le;
+    typedef bind< F,T1,T2,T3,T4,T5 > result_;
+    typedef result_ type;
+};
+
+template<
+      typename F
+    , typename Tag1
+    , typename Tag2
+    , typename Arity
+    >
+struct lambda<
+          lambda< F,Tag1,Arity >
+        , Tag2
+        , int_<3>
+        >
+{
+    typedef lambda< F,Tag2 > l1;
+    typedef lambda< Tag1,Tag2 > l2;
+    typedef typename l1::is_le is_le;
+    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
+    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
+    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+BOOST_MPL_AUX_NA_SPEC2(2, 3, lambda)
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/and.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/and.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/and.hpp	(working copy)
@@ -0,0 +1,69 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/and.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+namespace aux {
+
+template< bool C_, typename T1, typename T2, typename T3, typename T4 >
+struct and_impl
+    : false_
+{
+};
+
+template< typename T1, typename T2, typename T3, typename T4 >
+struct and_impl< true,T1,T2,T3,T4 >
+    : and_impl<
+          BOOST_MPL_AUX_NESTED_TYPE_WKND(T1)::value
+        , T2, T3, T4
+        , true_
+        >
+{
+};
+
+template<>
+struct and_impl<
+          true
+        , true_, true_, true_, true_
+        >
+    : true_
+{
+};
+
+} // namespace aux
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T1)
+    , typename BOOST_MPL_AUX_NA_PARAM(T2)
+    , typename T3 = true_, typename T4 = true_, typename T5 = true_
+    >
+struct and_
+
+    : aux::and_impl<
+          BOOST_MPL_AUX_NESTED_TYPE_WKND(T1)::value
+        , T2, T3, T4, T5
+        >
+
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          5
+        , and_
+        , ( T1, T2, T3, T4, T5)
+        )
+};
+
+BOOST_MPL_AUX_NA_SPEC2(
+      2
+    , 5
+    , and_
+    )
+
+}}
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp	(working copy)
@@ -0,0 +1,105 @@
+
+// Copyright Aleksey Gurtovoy 2001-2004
+// Copyright Peter Dimov 2001-2003
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/placeholders.hpp" header
+// -- DO NOT modify by hand!
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg< -1 > _;
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_;
+}
+
+}}
+
+/// agurt, 17/mar/02: one more placeholder for the last 'apply#'
+/// specialization
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<1> _1;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_1)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_1;
+}
+
+}}
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<2> _2;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_2)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_2;
+}
+
+}}
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<3> _3;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_3)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_3;
+}
+
+}}
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<4> _4;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_4)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_4;
+}
+
+}}
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<5> _5;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_5)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_5;
+}
+
+}}
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+typedef arg<6> _6;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+namespace boost { namespace mpl {
+
+BOOST_MPL_AUX_ARG_ADL_BARRIER_DECL(_6)
+
+namespace placeholders {
+using BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::_6;
+}
+
+}}
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/arg.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/arg.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/arg.hpp	(working copy)
@@ -0,0 +1,123 @@
+
+// Copyright Peter Dimov 2001-2002
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/arg.hpp" header
+// -- DO NOT modify by hand!
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+template<> struct arg< -1 >
+{
+    BOOST_STATIC_CONSTANT(int, value  = -1);
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+        typedef U1 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+template<> struct arg<1>
+{
+    BOOST_STATIC_CONSTANT(int, value  = 1);
+    typedef arg<2> next;
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+        typedef U1 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+template<> struct arg<2>
+{
+    BOOST_STATIC_CONSTANT(int, value  = 2);
+    typedef arg<3> next;
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+        typedef U2 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+template<> struct arg<3>
+{
+    BOOST_STATIC_CONSTANT(int, value  = 3);
+    typedef arg<4> next;
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+        typedef U3 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+template<> struct arg<4>
+{
+    BOOST_STATIC_CONSTANT(int, value  = 4);
+    typedef arg<5> next;
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+        typedef U4 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+template<> struct arg<5>
+{
+    BOOST_STATIC_CONSTANT(int, value  = 5);
+    typedef arg<6> next;
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+        typedef U5 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(1,int, arg)
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp	(working copy)
@@ -0,0 +1,52 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/bind_fwd.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+template<
+      typename F, typename T1 = na, typename T2 = na, typename T3 = na
+    , typename T4 = na, typename T5 = na
+    >
+struct bind;
+
+template<
+      typename F
+    >
+struct bind0;
+
+template<
+      typename F, typename T1
+    >
+struct bind1;
+
+template<
+      typename F, typename T1, typename T2
+    >
+struct bind2;
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    >
+struct bind3;
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    >
+struct bind4;
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    >
+struct bind5;
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/bind.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/bind.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/bind.hpp	(working copy)
@@ -0,0 +1,561 @@
+
+// Copyright Peter Dimov 2001
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/bind.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+namespace aux {
+
+template<
+      typename T, typename U1, typename U2, typename U3, typename U4
+    , typename U5
+    >
+struct resolve_bind_arg
+{
+    typedef T type;
+};
+
+template<
+      typename T
+    , typename Arg
+    >
+struct replace_unnamed_arg
+{
+    typedef Arg next;
+    typedef T type;
+};
+
+template<
+      typename Arg
+    >
+struct replace_unnamed_arg< arg< -1 >, Arg >
+{
+    typedef typename Arg::next next;
+    typedef Arg type;
+};
+
+template<
+      int N, typename U1, typename U2, typename U3, typename U4, typename U5
+    >
+struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
+{
+    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5, typename U1, typename U2, typename U3, typename U4
+    , typename U5
+    >
+struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
+{
+    typedef bind< F,T1,T2,T3,T4,T5 > f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+template<
+      typename F
+    >
+struct bind0
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
+        ///
+     public:
+        typedef typename apply_wrap0<
+              f_
+            >::type type;
+
+    };
+};
+
+namespace aux {
+
+template<
+      typename F, typename U1, typename U2, typename U3, typename U4
+    , typename U5
+    >
+struct resolve_bind_arg<
+      bind0<F>, U1, U2, U3, U4, U5
+    >
+{
+    typedef bind0<F> f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(1, bind0)
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(1, bind0)
+
+template<
+      typename F
+    >
+struct bind< F,na,na,na,na,na >
+    : bind0<F>
+{
+};
+
+template<
+      typename F, typename T1
+    >
+struct bind1
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
+        ///
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+     public:
+        typedef typename apply_wrap1<
+              f_
+            , typename t1::type
+            >::type type;
+
+    };
+};
+
+namespace aux {
+
+template<
+      typename F, typename T1, typename U1, typename U2, typename U3
+    , typename U4, typename U5
+    >
+struct resolve_bind_arg<
+      bind1< F,T1 >, U1, U2, U3, U4, U5
+    >
+{
+    typedef bind1< F,T1 > f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(2, bind1)
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(2, bind1)
+
+template<
+      typename F, typename T1
+    >
+struct bind< F,T1,na,na,na,na >
+    : bind1< F,T1 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2
+    >
+struct bind2
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
+        ///
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+        typedef aux::replace_unnamed_arg< T2,n2 > r2;
+        typedef typename r2::type a2;
+        typedef typename r2::next n3;
+        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
+        ///
+     public:
+        typedef typename apply_wrap2<
+              f_
+            , typename t1::type, typename t2::type
+            >::type type;
+
+    };
+};
+
+namespace aux {
+
+template<
+      typename F, typename T1, typename T2, typename U1, typename U2
+    , typename U3, typename U4, typename U5
+    >
+struct resolve_bind_arg<
+      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
+    >
+{
+    typedef bind2< F,T1,T2 > f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(3, bind2)
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(3, bind2)
+
+template<
+      typename F, typename T1, typename T2
+    >
+struct bind< F,T1,T2,na,na,na >
+    : bind2< F,T1,T2 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    >
+struct bind3
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
+        ///
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+        typedef aux::replace_unnamed_arg< T2,n2 > r2;
+        typedef typename r2::type a2;
+        typedef typename r2::next n3;
+        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
+        ///
+        typedef aux::replace_unnamed_arg< T3,n3 > r3;
+        typedef typename r3::type a3;
+        typedef typename r3::next n4;
+        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
+        ///
+     public:
+        typedef typename apply_wrap3<
+              f_
+            , typename t1::type, typename t2::type, typename t3::type
+            >::type type;
+
+    };
+};
+
+namespace aux {
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename U1
+    , typename U2, typename U3, typename U4, typename U5
+    >
+struct resolve_bind_arg<
+      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
+    >
+{
+    typedef bind3< F,T1,T2,T3 > f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(4, bind3)
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(4, bind3)
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    >
+struct bind< F,T1,T2,T3,na,na >
+    : bind3< F,T1,T2,T3 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    >
+struct bind4
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
+        ///
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+        typedef aux::replace_unnamed_arg< T2,n2 > r2;
+        typedef typename r2::type a2;
+        typedef typename r2::next n3;
+        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
+        ///
+        typedef aux::replace_unnamed_arg< T3,n3 > r3;
+        typedef typename r3::type a3;
+        typedef typename r3::next n4;
+        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
+        ///
+        typedef aux::replace_unnamed_arg< T4,n4 > r4;
+        typedef typename r4::type a4;
+        typedef typename r4::next n5;
+        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;
+        ///
+     public:
+        typedef typename apply_wrap4<
+              f_
+            , typename t1::type, typename t2::type, typename t3::type
+            , typename t4::type
+            >::type type;
+
+    };
+};
+
+namespace aux {
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename U1, typename U2, typename U3, typename U4, typename U5
+    >
+struct resolve_bind_arg<
+      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
+    >
+{
+    typedef bind4< F,T1,T2,T3,T4 > f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(5, bind4)
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(5, bind4)
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    >
+struct bind< F,T1,T2,T3,T4,na >
+    : bind4< F,T1,T2,T3,T4 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    >
+struct bind5
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
+        typedef typename r0::type a0;
+        typedef typename r0::next n1;
+        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
+        ///
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+        typedef aux::replace_unnamed_arg< T2,n2 > r2;
+        typedef typename r2::type a2;
+        typedef typename r2::next n3;
+        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
+        ///
+        typedef aux::replace_unnamed_arg< T3,n3 > r3;
+        typedef typename r3::type a3;
+        typedef typename r3::next n4;
+        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
+        ///
+        typedef aux::replace_unnamed_arg< T4,n4 > r4;
+        typedef typename r4::type a4;
+        typedef typename r4::next n5;
+        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;
+        ///
+        typedef aux::replace_unnamed_arg< T5,n5 > r5;
+        typedef typename r5::type a5;
+        typedef typename r5::next n6;
+        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;
+        ///
+     public:
+        typedef typename apply_wrap5<
+              f_
+            , typename t1::type, typename t2::type, typename t3::type
+            , typename t4::type, typename t5::type
+            >::type type;
+
+    };
+};
+
+namespace aux {
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5, typename U1, typename U2, typename U3, typename U4
+    , typename U5
+    >
+struct resolve_bind_arg<
+      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
+    >
+{
+    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
+    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
+};
+
+} // namespace aux
+
+BOOST_MPL_AUX_ARITY_SPEC(6, bind5)
+BOOST_MPL_AUX_TEMPLATE_ARITY_SPEC(6, bind5)
+
+/// primary template (not a specialization!)
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    >
+struct bind
+    : bind5< F,T1,T2,T3,T4,T5 >
+{
+};
+
+/// if_/eval_if specializations
+template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
+struct quote3;
+
+template< typename T1, typename T2, typename T3 > struct if_;
+
+template<
+      typename Tag, typename T1, typename T2, typename T3
+    >
+struct bind3<
+      quote3< if_,Tag >
+    , T1, T2, T3
+    >
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef mpl::arg<1> n1;
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+        typedef aux::replace_unnamed_arg< T2,n2 > r2;
+        typedef typename r2::type a2;
+        typedef typename r2::next n3;
+        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
+        ///
+        typedef aux::replace_unnamed_arg< T3,n3 > r3;
+        typedef typename r3::type a3;
+        typedef typename r3::next n4;
+        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
+        ///
+        typedef typename if_<
+              typename t1::type
+            , t2, t3
+            >::type f_;
+
+     public:
+        typedef typename f_::type type;
+    };
+};
+
+template<
+      template< typename T1, typename T2, typename T3 > class F, typename Tag
+    >
+struct quote3;
+
+template< typename T1, typename T2, typename T3 > struct eval_if;
+
+template<
+      typename Tag, typename T1, typename T2, typename T3
+    >
+struct bind3<
+      quote3< eval_if,Tag >
+    , T1, T2, T3
+    >
+{
+    template<
+          typename U1 = na, typename U2 = na, typename U3 = na
+        , typename U4 = na, typename U5 = na
+        >
+    struct apply
+    {
+     private:
+        typedef mpl::arg<1> n1;
+        typedef aux::replace_unnamed_arg< T1,n1 > r1;
+        typedef typename r1::type a1;
+        typedef typename r1::next n2;
+        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
+        ///
+        typedef aux::replace_unnamed_arg< T2,n2 > r2;
+        typedef typename r2::type a2;
+        typedef typename r2::next n3;
+        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
+        ///
+        typedef aux::replace_unnamed_arg< T3,n3 > r3;
+        typedef typename r3::type a3;
+        typedef typename r3::next n4;
+        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
+        ///
+        typedef typename eval_if<
+              typename t1::type
+            , t2, t3
+            >::type f_;
+
+     public:
+        typedef typename f_::type type;
+    };
+};
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp	(working copy)
@@ -0,0 +1,84 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/apply_wrap.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+template<
+      typename F
+
+    , typename has_apply_ = typename aux::has_apply<F>::type
+
+    >
+struct apply_wrap0
+
+    : F::template apply<  >
+{
+};
+
+template< typename F >
+struct apply_wrap0< F,true_ >
+    : F::apply
+{
+};
+
+template<
+      typename F, typename T1
+
+    >
+struct apply_wrap1
+
+    : F::template apply<T1>
+{
+};
+
+template<
+      typename F, typename T1, typename T2
+
+    >
+struct apply_wrap2
+
+    : F::template apply< T1,T2 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3
+
+    >
+struct apply_wrap3
+
+    : F::template apply< T1,T2,T3 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+
+    >
+struct apply_wrap4
+
+    : F::template apply< T1,T2,T3,T4 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+
+    >
+struct apply_wrap5
+
+    : F::template apply< T1,T2,T3,T4,T5 >
+{
+};
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/or.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/or.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/or.hpp	(working copy)
@@ -0,0 +1,69 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/or.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+namespace aux {
+
+template< bool C_, typename T1, typename T2, typename T3, typename T4 >
+struct or_impl
+    : true_
+{
+};
+
+template< typename T1, typename T2, typename T3, typename T4 >
+struct or_impl< false,T1,T2,T3,T4 >
+    : or_impl<
+          BOOST_MPL_AUX_NESTED_TYPE_WKND(T1)::value
+        , T2, T3, T4
+        , false_
+        >
+{
+};
+
+template<>
+struct or_impl<
+          false
+        , false_, false_, false_, false_
+        >
+    : false_
+{
+};
+
+} // namespace aux
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T1)
+    , typename BOOST_MPL_AUX_NA_PARAM(T2)
+    , typename T3 = false_, typename T4 = false_, typename T5 = false_
+    >
+struct or_
+
+    : aux::or_impl<
+          BOOST_MPL_AUX_NESTED_TYPE_WKND(T1)::value
+        , T2, T3, T4, T5
+        >
+
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          5
+        , or_
+        , ( T1, T2, T3, T4, T5)
+        )
+};
+
+BOOST_MPL_AUX_NA_SPEC2(
+      2
+    , 5
+    , or_
+    )
+
+}}
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp	(working copy)
@@ -0,0 +1,97 @@
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// *Preprocessed* version of the main "template_arity.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl { namespace aux {
+template< int N > struct arity_tag
+{
+    typedef char (&type)[N + 1];
+};
+
+template<
+      int C1, int C2, int C3, int C4, int C5, int C6
+    >
+struct max_arity
+{
+    BOOST_STATIC_CONSTANT(int, value =
+          ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) )
+        );
+};
+
+arity_tag<0>::type arity_helper(...);
+
+template<
+      template< typename P1 > class F
+    , typename T1
+    >
+typename arity_tag<1>::type
+arity_helper(type_wrapper< F<T1> >, arity_tag<1>);
+
+template<
+      template< typename P1, typename P2 > class F
+    , typename T1, typename T2
+    >
+typename arity_tag<2>::type
+arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);
+
+template<
+      template< typename P1, typename P2, typename P3 > class F
+    , typename T1, typename T2, typename T3
+    >
+typename arity_tag<3>::type
+arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);
+
+template<
+      template< typename P1, typename P2, typename P3, typename P4 > class F
+    , typename T1, typename T2, typename T3, typename T4
+    >
+typename arity_tag<4>::type
+arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);
+
+template<
+      template<
+          typename P1, typename P2, typename P3, typename P4
+        , typename P5
+        >
+      class F
+    , typename T1, typename T2, typename T3, typename T4, typename T5
+    >
+typename arity_tag<5>::type
+arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);
+
+template<
+      template<
+          typename P1, typename P2, typename P3, typename P4
+        , typename P5, typename P6
+        >
+      class F
+    , typename T1, typename T2, typename T3, typename T4, typename T5
+    , typename T6
+    >
+typename arity_tag<6>::type
+arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
+template< typename F, int N >
+struct template_arity_impl
+{
+    BOOST_STATIC_CONSTANT(int, value =
+          sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1
+        );
+};
+
+template< typename F >
+struct template_arity
+{
+    BOOST_STATIC_CONSTANT(int, value  = (
+          max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value
+        ));
+    typedef mpl::int_<value> type;
+};
+
+}}}
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp	(working copy)
@@ -0,0 +1,52 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/apply_fwd.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+template<
+      typename F, typename T1 = na, typename T2 = na, typename T3 = na
+    , typename T4 = na, typename T5 = na
+    >
+struct apply;
+
+template<
+      typename F
+    >
+struct apply0;
+
+template<
+      typename F, typename T1
+    >
+struct apply1;
+
+template<
+      typename F, typename T1, typename T2
+    >
+struct apply2;
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    >
+struct apply3;
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    >
+struct apply4;
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    >
+struct apply5;
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessed/gcc/apply.hpp	(working copy)
@@ -0,0 +1,169 @@
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// Preprocessed version of "boost/mpl/apply.hpp" header
+// -- DO NOT modify by hand!
+
+namespace boost { namespace mpl {
+
+template<
+      typename F
+    >
+struct apply0
+
+    : apply_wrap0<
+          typename lambda<F>::type
+
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          1
+        , apply0
+        , (F )
+        )
+};
+
+template<
+      typename F
+    >
+struct apply< F,na,na,na,na,na >
+    : apply0<F>
+{
+};
+
+template<
+      typename F, typename T1
+    >
+struct apply1
+
+    : apply_wrap1<
+          typename lambda<F>::type
+        , T1
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          2
+        , apply1
+        , (F, T1)
+        )
+};
+
+template<
+      typename F, typename T1
+    >
+struct apply< F,T1,na,na,na,na >
+    : apply1< F,T1 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2
+    >
+struct apply2
+
+    : apply_wrap2<
+          typename lambda<F>::type
+        , T1, T2
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          3
+        , apply2
+        , (F, T1, T2)
+        )
+};
+
+template<
+      typename F, typename T1, typename T2
+    >
+struct apply< F,T1,T2,na,na,na >
+    : apply2< F,T1,T2 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    >
+struct apply3
+
+    : apply_wrap3<
+          typename lambda<F>::type
+        , T1, T2, T3
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          4
+        , apply3
+        , (F, T1, T2, T3)
+        )
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3
+    >
+struct apply< F,T1,T2,T3,na,na >
+    : apply3< F,T1,T2,T3 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    >
+struct apply4
+
+    : apply_wrap4<
+          typename lambda<F>::type
+        , T1, T2, T3, T4
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          5
+        , apply4
+        , (F, T1, T2, T3, T4)
+        )
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    >
+struct apply< F,T1,T2,T3,T4,na >
+    : apply4< F,T1,T2,T3,T4 >
+{
+};
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    >
+struct apply5
+
+    : apply_wrap5<
+          typename lambda<F>::type
+        , T1, T2, T3, T4, T5
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          6
+        , apply5
+        , (F, T1, T2, T3, T4, T5)
+        )
+};
+
+/// primary template (not a specialization!)
+
+template<
+      typename F, typename T1, typename T2, typename T3, typename T4
+    , typename T5
+    >
+struct apply
+    : apply5< F,T1,T2,T3,T4,T5 >
+{
+};
+
+}}
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/nttp_decl.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/nttp_decl.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/nttp_decl.hpp	(working copy)
@@ -0,0 +1,35 @@
+
+#ifndef BOOST_MPL_AUX_NTTP_DECL_HPP_INCLUDED
+#define BOOST_MPL_AUX_NTTP_DECL_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: nttp_decl.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/nttp.hpp>
+
+#if defined(BOOST_MPL_CFG_NTTP_BUG)
+
+typedef bool        _mpl_nttp_bool;
+typedef int         _mpl_nttp_int;
+typedef unsigned    _mpl_nttp_unsigned;
+typedef long        _mpl_nttp_long;
+
+#   include <boost/preprocessor/cat.hpp>
+#   define BOOST_MPL_AUX_NTTP_DECL(T, x) BOOST_PP_CAT(_mpl_nttp_,T) x /**/
+
+#else
+
+#   define BOOST_MPL_AUX_NTTP_DECL(T, x) T x /**/
+
+#endif
+
+#endif // BOOST_MPL_AUX_NTTP_DECL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_assert.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_assert.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_assert.hpp	(working copy)
@@ -0,0 +1,34 @@
+
+#ifndef BOOST_MPL_AUX_NA_ASSERT_HPP_INCLUDED
+#define BOOST_MPL_AUX_NA_ASSERT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: na_assert.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/na.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if !BOOST_WORKAROUND(_MSC_FULL_VER, <= 140050601)    \
+    && !BOOST_WORKAROUND(__EDG_VERSION__, <= 243)
+#   include <boost/mpl/assert.hpp>
+#   define BOOST_MPL_AUX_ASSERT_NOT_NA(x) \
+    BOOST_MPL_ASSERT_NOT((boost::mpl::is_na<type>)) \
+/**/
+#else
+#   include <boost/static_assert.hpp>
+#   define BOOST_MPL_AUX_ASSERT_NOT_NA(x) \
+    BOOST_STATIC_ASSERT(!boost::mpl::is_na<x>::value) \
+/**/
+#endif
+
+#endif // BOOST_MPL_AUX_NA_ASSERT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/type_wrapper.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/type_wrapper.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/type_wrapper.hpp	(working copy)
@@ -0,0 +1,47 @@
+
+#ifndef BOOST_MPL_AUX_TYPE_WRAPPER_HPP_INCLUDED
+#define BOOST_MPL_AUX_TYPE_WRAPPER_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+// Copyright Peter Dimov 2000-2003
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: type_wrapper.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/ctps.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+
+template< typename T > struct type_wrapper
+{
+    typedef T type;
+};
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+// agurt 08/may/03: a complicated way to extract the wrapped type; need it
+// mostly for the sake of GCC (3.2.x), which ICEs if you try to extract the
+// nested 'type' from 'type_wrapper<T>' when the latter was the result of a
+// 'typeof' expression
+template< typename T > struct wrapped_type;
+
+template< typename T > struct wrapped_type< type_wrapper<T> >
+{
+    typedef T type;
+};
+#else
+template< typename W > struct wrapped_type
+{
+    typedef typename W::type type;
+};
+#endif
+
+}}}
+
+#endif // BOOST_MPL_AUX_TYPE_WRAPPER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/template_arity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/template_arity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/template_arity.hpp	(working copy)
@@ -0,0 +1,189 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_AUX_TEMPLATE_ARITY_HPP_INCLUDED
+#define BOOST_MPL_AUX_TEMPLATE_ARITY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: template_arity.hpp 61584 2010-04-26 18:48:26Z agurtovoy $
+// $Date: 2010-04-26 14:48:26 -0400 (Mon, 26 Apr 2010) $
+// $Revision: 61584 $
+
+#include <boost/mpl/aux_/config/ttp.hpp>
+#include <boost/mpl/aux_/config/lambda.hpp>
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/aux_/template_arity_fwd.hpp>
+#   include <boost/mpl/int.hpp>
+#   if !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+#   if defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)
+#       include <boost/mpl/aux_/type_wrapper.hpp>
+#   endif
+#   else
+#       include <boost/mpl/aux_/has_rebind.hpp>
+#   endif
+#endif
+
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER template_arity.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   if !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+#   if defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/range.hpp>
+#   include <boost/mpl/aux_/preprocessor/repeat.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+
+#   include <boost/preprocessor/seq/fold_left.hpp>
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+#   define AUX778076_ARITY BOOST_PP_INC(BOOST_MPL_LIMIT_METAFUNCTION_ARITY)
+
+namespace boost { namespace mpl { namespace aux {
+
+template< BOOST_MPL_AUX_NTTP_DECL(int, N) > struct arity_tag
+{
+    typedef char (&type)[N + 1];
+};
+
+#   define AUX778076_MAX_ARITY_OP(unused, state, i_) \
+    ( BOOST_PP_CAT(C,i_) > 0 ? BOOST_PP_CAT(C,i_) : state ) \
+/**/
+
+template<
+      BOOST_MPL_PP_PARAMS(AUX778076_ARITY, BOOST_MPL_AUX_NTTP_DECL(int, C))
+    >
+struct max_arity
+{
+    BOOST_STATIC_CONSTANT(int, value =
+          BOOST_PP_SEQ_FOLD_LEFT(
+              AUX778076_MAX_ARITY_OP
+            , -1
+            , BOOST_MPL_PP_RANGE(1, AUX778076_ARITY)
+            )
+        );
+};
+
+#   undef AUX778076_MAX_ARITY_OP
+
+arity_tag<0>::type arity_helper(...);
+
+#   define BOOST_PP_ITERATION_LIMITS (1, AUX778076_ARITY)
+#   define BOOST_PP_FILENAME_1 <boost/mpl/aux_/template_arity.hpp>
+#   include BOOST_PP_ITERATE()
+
+template< typename F, BOOST_MPL_AUX_NTTP_DECL(int, N) >
+struct template_arity_impl
+{
+    BOOST_STATIC_CONSTANT(int, value =
+          sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(),arity_tag<N>())) - 1
+        );
+};
+
+#   define AUX778076_TEMPLATE_ARITY_IMPL_INVOCATION(unused, i_, F) \
+    BOOST_PP_COMMA_IF(i_) template_arity_impl<F,BOOST_PP_INC(i_)>::value \
+/**/
+
+template< typename F >
+struct template_arity
+{
+    BOOST_STATIC_CONSTANT(int, value = (
+          max_arity< BOOST_MPL_PP_REPEAT(
+              AUX778076_ARITY
+            , AUX778076_TEMPLATE_ARITY_IMPL_INVOCATION
+            , F
+            ) >::value
+        ));
+
+    typedef mpl::int_<value> type;
+};
+
+#   undef AUX778076_TEMPLATE_ARITY_IMPL_INVOCATION
+
+#   undef AUX778076_ARITY
+
+}}}
+
+#   endif // BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING
+#   else // BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT
+
+#   include <boost/mpl/aux_/config/eti.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+
+template< bool >
+struct template_arity_impl
+{
+    template< typename F > struct result_
+        : mpl::int_<-1>
+    {
+    };
+};
+
+template<>
+struct template_arity_impl<true>
+{
+    template< typename F > struct result_
+        : F::arity
+    {
+    };
+};
+
+template< typename F >
+struct template_arity
+    : template_arity_impl< ::boost::mpl::aux::has_rebind<F>::value >
+        ::template result_<F>
+{
+};
+
+#if defined(BOOST_MPL_CFG_MSVC_ETI_BUG)
+template<>
+struct template_arity<int>
+    : mpl::int_<-1>
+{
+};
+#endif
+
+}}}
+
+#   endif // BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_AUX_TEMPLATE_ARITY_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+template<
+      template< BOOST_MPL_PP_PARAMS(i_, typename P) > class F
+    , BOOST_MPL_PP_PARAMS(i_, typename T)
+    >
+typename arity_tag<i_>::type
+arity_helper(type_wrapper< F<BOOST_MPL_PP_PARAMS(i_, T)> >, arity_tag<i_>);
+
+#undef i_
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/arity.hpp	(working copy)
@@ -0,0 +1,39 @@
+
+#ifndef BOOST_MPL_AUX_ARITY_HPP_INCLUDED
+#define BOOST_MPL_AUX_ARITY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arity.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/dtp.hpp>
+
+#if defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+#   include <boost/mpl/aux_/config/static_constant.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+
+// agurt, 15/mar/02: it's possible to implement the template so that it will
+// "just work" and do not require any specialization, but not on the compilers
+// that require the arity workaround in the first place
+template< typename F, BOOST_MPL_AUX_NTTP_DECL(int, N) >
+struct arity
+{
+    BOOST_STATIC_CONSTANT(int, value = N);
+};
+
+}}}
+
+#endif // BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES
+
+#endif // BOOST_MPL_AUX_ARITY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_fwd.hpp	(working copy)
@@ -0,0 +1,31 @@
+
+#ifndef BOOST_MPL_AUX_NA_FWD_HPP_INCLUDED
+#define BOOST_MPL_AUX_NA_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: na_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+// n.a. == not available
+struct na
+{
+    typedef na type;
+    enum { value = 0 };
+};
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(na)
+
+#endif // BOOST_MPL_AUX_NA_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/value_wknd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/value_wknd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/value_wknd.hpp	(working copy)
@@ -0,0 +1,89 @@
+
+#ifndef BOOST_MPL_AUX_VALUE_WKND_HPP_INCLUDED
+#define BOOST_MPL_AUX_VALUE_WKND_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: value_wknd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/static_cast.hpp>
+#include <boost/mpl/aux_/config/integral.hpp>
+#include <boost/mpl/aux_/config/eti.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if defined(BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS) \
+    || defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG)
+
+#   include <boost/mpl/int.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+template< typename C_ > struct value_wknd
+    : C_
+{
+};
+
+#if defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG)
+template<> struct value_wknd<int>
+    : int_<1>
+{
+    using int_<1>::value;
+};
+#endif
+}}}
+
+
+#if !defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG)
+#   define BOOST_MPL_AUX_VALUE_WKND(C) \
+    ::BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::aux::value_wknd< C > \
+/**/
+#    define BOOST_MPL_AUX_MSVC_VALUE_WKND(C) BOOST_MPL_AUX_VALUE_WKND(C)
+#else
+#   define BOOST_MPL_AUX_VALUE_WKND(C) C
+#   define BOOST_MPL_AUX_MSVC_VALUE_WKND(C) \
+    ::boost::mpl::aux::value_wknd< C > \
+/**/
+#endif
+
+#else // BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS
+
+#   define BOOST_MPL_AUX_VALUE_WKND(C) C
+#   define BOOST_MPL_AUX_MSVC_VALUE_WKND(C) C
+
+#endif
+
+#if BOOST_WORKAROUND(__EDG_VERSION__, <= 238)
+#   define BOOST_MPL_AUX_NESTED_VALUE_WKND(T, C) \
+    BOOST_MPL_AUX_STATIC_CAST(T, C::value) \
+/**/
+#else
+#   define BOOST_MPL_AUX_NESTED_VALUE_WKND(T, C) \
+    BOOST_MPL_AUX_VALUE_WKND(C)::value \
+/**/
+#endif
+
+
+namespace boost { namespace mpl { namespace aux {
+
+template< typename T > struct value_type_wknd
+{
+    typedef typename T::value_type type;
+};
+
+#if defined(BOOST_MPL_CFG_MSVC_ETI_BUG)
+template<> struct value_type_wknd<int>
+{
+    typedef int type;
+};
+#endif
+
+}}}
+
+#endif // BOOST_MPL_AUX_VALUE_WKND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/def_params_tail.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/def_params_tail.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/def_params_tail.hpp	(working copy)
@@ -0,0 +1,105 @@
+
+#ifndef BOOST_MPL_AUX_PREPROCESSOR_DEF_PARAMS_TAIL_HPP_INCLUDED
+#define BOOST_MPL_AUX_PREPROCESSOR_DEF_PARAMS_TAIL_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: def_params_tail.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/limits/arity.hpp>
+#include <boost/mpl/aux_/config/dtp.hpp>
+#include <boost/mpl/aux_/config/preprocessor.hpp>
+
+#include <boost/preprocessor/comma_if.hpp>
+#include <boost/preprocessor/logical/and.hpp>
+#include <boost/preprocessor/identity.hpp>
+#include <boost/preprocessor/empty.hpp>
+
+// BOOST_MPL_PP_DEF_PARAMS_TAIL(1,T,value): , T1 = value, .., Tn = value
+// BOOST_MPL_PP_DEF_PARAMS_TAIL(2,T,value): , T2 = value, .., Tn = value
+// BOOST_MPL_PP_DEF_PARAMS_TAIL(n,T,value): <nothing>
+
+#if !defined(BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES)
+
+#   include <boost/mpl/aux_/preprocessor/filter_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/sub.hpp>
+
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i, param, value_func) \
+    BOOST_MPL_PP_DEF_PARAMS_TAIL_DELAY_1( \
+          i \
+        , BOOST_MPL_PP_SUB(BOOST_MPL_LIMIT_METAFUNCTION_ARITY,i) \
+        , param \
+        , value_func \
+        ) \
+    /**/
+
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_DELAY_1(i, n, param, value_func) \
+    BOOST_MPL_PP_DEF_PARAMS_TAIL_DELAY_2(i,n,param,value_func) \
+    /**/
+
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_DELAY_2(i, n, param, value_func) \
+    BOOST_PP_COMMA_IF(BOOST_PP_AND(i,n)) \
+    BOOST_MPL_PP_DEF_PARAMS_TAIL_##i(n,param,value_func) \
+    /**/
+
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_0(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##1 v(),p##2 v(),p##3 v(),p##4 v(),p##5 v(),p##6 v(),p##7 v(),p##8 v(),p##9 v())
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_1(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##2 v(),p##3 v(),p##4 v(),p##5 v(),p##6 v(),p##7 v(),p##8 v(),p##9 v(),p1)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_2(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##3 v(),p##4 v(),p##5 v(),p##6 v(),p##7 v(),p##8 v(),p##9 v(),p1,p2)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_3(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##4 v(),p##5 v(),p##6 v(),p##7 v(),p##8 v(),p##9 v(),p1,p2,p3)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_4(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##5 v(),p##6 v(),p##7 v(),p##8 v(),p##9 v(),p1,p2,p3,p4)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_5(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##6 v(),p##7 v(),p##8 v(),p##9 v(),p1,p2,p3,p4,p5)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_6(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##7 v(),p##8 v(),p##9 v(),p1,p2,p3,p4,p5,p6)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_7(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##8 v(),p##9 v(),p1,p2,p3,p4,p5,p6,p7)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_8(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p##9 v(),p1,p2,p3,p4,p5,p6,p7,p8)
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_9(i,p,v) BOOST_MPL_PP_FILTER_PARAMS_##i(p1,p2,p3,p4,p5,p6,p7,p8,p9)
+
+#else
+
+#   include <boost/preprocessor/arithmetic/add.hpp>
+#   include <boost/preprocessor/arithmetic/sub.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/tuple/elem.hpp>
+#   include <boost/preprocessor/repeat.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+#   define BOOST_MPL_PP_AUX_TAIL_PARAM_FUNC(unused, i, op) \
+    , BOOST_PP_CAT( \
+          BOOST_PP_TUPLE_ELEM(3, 1, op) \
+        , BOOST_PP_ADD_D(1, i, BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(3, 0, op))) \
+        ) BOOST_PP_TUPLE_ELEM(3, 2, op)() \
+    /**/
+
+#   define BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i, param, value_func) \
+    BOOST_PP_REPEAT( \
+          BOOST_PP_SUB_D(1, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, i) \
+        , BOOST_MPL_PP_AUX_TAIL_PARAM_FUNC \
+        , (i, param, value_func) \
+        ) \
+    /**/
+
+
+#endif // BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES
+
+#define BOOST_MPL_PP_DEF_PARAMS_TAIL(i, param, value) \
+    BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i, param, BOOST_PP_IDENTITY(=value)) \
+    /**/
+
+#if !defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#   define BOOST_MPL_PP_NESTED_DEF_PARAMS_TAIL(i, param, value) \
+    BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i, param, BOOST_PP_IDENTITY(=value)) \
+    /**/
+#else
+#   define BOOST_MPL_PP_NESTED_DEF_PARAMS_TAIL(i, param, value) \
+    BOOST_MPL_PP_DEF_PARAMS_TAIL_IMPL(i, param, BOOST_PP_EMPTY) \
+    /**/
+#endif
+
+#endif // BOOST_MPL_AUX_PREPROCESSOR_DEF_PARAMS_TAIL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/params.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/params.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/params.hpp	(working copy)
@@ -0,0 +1,65 @@
+
+#ifndef BOOST_MPL_AUX_PREPROCESSOR_PARAMS_HPP_INCLUDED
+#define BOOST_MPL_AUX_PREPROCESSOR_PARAMS_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: params.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/preprocessor.hpp>
+
+// BOOST_MPL_PP_PARAMS(0,T): <nothing>
+// BOOST_MPL_PP_PARAMS(1,T): T1
+// BOOST_MPL_PP_PARAMS(2,T): T1, T2
+// BOOST_MPL_PP_PARAMS(n,T): T1, T2, .., Tn
+
+#if !defined(BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES)
+
+#   include <boost/preprocessor/cat.hpp>
+
+#   define BOOST_MPL_PP_PARAMS(n,p) \
+    BOOST_PP_CAT(BOOST_MPL_PP_PARAMS_,n)(p) \
+    /**/
+
+#   define BOOST_MPL_PP_PARAMS_0(p)
+#   define BOOST_MPL_PP_PARAMS_1(p) p##1
+#   define BOOST_MPL_PP_PARAMS_2(p) p##1,p##2
+#   define BOOST_MPL_PP_PARAMS_3(p) p##1,p##2,p##3
+#   define BOOST_MPL_PP_PARAMS_4(p) p##1,p##2,p##3,p##4
+#   define BOOST_MPL_PP_PARAMS_5(p) p##1,p##2,p##3,p##4,p##5
+#   define BOOST_MPL_PP_PARAMS_6(p) p##1,p##2,p##3,p##4,p##5,p##6
+#   define BOOST_MPL_PP_PARAMS_7(p) p##1,p##2,p##3,p##4,p##5,p##6,p##7
+#   define BOOST_MPL_PP_PARAMS_8(p) p##1,p##2,p##3,p##4,p##5,p##6,p##7,p##8
+#   define BOOST_MPL_PP_PARAMS_9(p) p##1,p##2,p##3,p##4,p##5,p##6,p##7,p##8,p##9
+
+#else
+
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/repeat.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+#   define BOOST_MPL_PP_AUX_PARAM_FUNC(unused, i, param) \
+    BOOST_PP_COMMA_IF(i) \
+    BOOST_PP_CAT(param, BOOST_PP_INC(i)) \
+    /**/
+
+#   define BOOST_MPL_PP_PARAMS(n, param) \
+    BOOST_PP_REPEAT( \
+          n \
+        , BOOST_MPL_PP_AUX_PARAM_FUNC \
+        , param \
+        ) \
+    /**/
+
+#endif
+
+#endif // BOOST_MPL_AUX_PREPROCESSOR_PARAMS_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/enum.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/enum.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/preprocessor/enum.hpp	(working copy)
@@ -0,0 +1,62 @@
+
+#ifndef BOOST_MPL_AUX_PREPROCESSOR_ENUM_HPP_INCLUDED
+#define BOOST_MPL_AUX_PREPROCESSOR_ENUM_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: enum.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/preprocessor.hpp>
+
+// BOOST_MPL_PP_ENUM(0,int): <nothing>
+// BOOST_MPL_PP_ENUM(1,int): int
+// BOOST_MPL_PP_ENUM(2,int): int, int
+// BOOST_MPL_PP_ENUM(n,int): int, int, .., int
+
+#if !defined(BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES)
+
+#   include <boost/preprocessor/cat.hpp>
+
+#   define BOOST_MPL_PP_ENUM(n, param) \
+    BOOST_PP_CAT(BOOST_MPL_PP_ENUM_,n)(param) \
+    /**/
+
+#   define BOOST_MPL_PP_ENUM_0(p)
+#   define BOOST_MPL_PP_ENUM_1(p) p
+#   define BOOST_MPL_PP_ENUM_2(p) p,p
+#   define BOOST_MPL_PP_ENUM_3(p) p,p,p
+#   define BOOST_MPL_PP_ENUM_4(p) p,p,p,p
+#   define BOOST_MPL_PP_ENUM_5(p) p,p,p,p,p
+#   define BOOST_MPL_PP_ENUM_6(p) p,p,p,p,p,p
+#   define BOOST_MPL_PP_ENUM_7(p) p,p,p,p,p,p,p
+#   define BOOST_MPL_PP_ENUM_8(p) p,p,p,p,p,p,p,p
+#   define BOOST_MPL_PP_ENUM_9(p) p,p,p,p,p,p,p,p,p
+
+#else
+
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/repeat.hpp>
+
+#   define BOOST_MPL_PP_AUX_ENUM_FUNC(unused, i, param) \
+    BOOST_PP_COMMA_IF(i) param \
+    /**/
+
+#   define BOOST_MPL_PP_ENUM(n, param) \
+    BOOST_PP_REPEAT( \
+          n \
+        , BOOST_MPL_PP_AUX_ENUM_FUNC \
+        , param \
+        ) \
+    /**/
+
+#endif
+
+#endif // BOOST_MPL_AUX_PREPROCESSOR_ENUM_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/static_cast.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/static_cast.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/static_cast.hpp	(working copy)
@@ -0,0 +1,27 @@
+
+#ifndef BOOST_MPL_AUX_STATIC_CAST_HPP_INCLUDED
+#define BOOST_MPL_AUX_STATIC_CAST_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: static_cast.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x561)) \
+ || BOOST_WORKAROUND(__GNUC__, < 3) \
+ || BOOST_WORKAROUND(__MWERKS__, <= 0x3001)
+#   define BOOST_MPL_AUX_STATIC_CAST(T, expr) (T)(expr)
+#else
+#   define BOOST_MPL_AUX_STATIC_CAST(T, expr) static_cast<T>(expr)
+#endif
+
+#endif // BOOST_MPL_AUX_STATIC_CAST_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/full_lambda.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/full_lambda.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/full_lambda.hpp	(working copy)
@@ -0,0 +1,354 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_AUX_FULL_LAMBDA_HPP_INCLUDED
+#define BOOST_MPL_AUX_FULL_LAMBDA_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: full_lambda.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/lambda_fwd.hpp>
+#   include <boost/mpl/bind_fwd.hpp>
+#   include <boost/mpl/protect.hpp>
+#   include <boost/mpl/quote.hpp>
+#   include <boost/mpl/arg.hpp>
+#   include <boost/mpl/bool.hpp>
+#   include <boost/mpl/int_fwd.hpp>
+#   include <boost/mpl/aux_/template_arity.hpp>
+#   include <boost/mpl/aux_/na_spec.hpp>
+#   include <boost/mpl/aux_/config/ttp.hpp>
+#   if defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)
+#       include <boost/mpl/if.hpp>
+#   endif
+#endif
+
+#include <boost/mpl/aux_/lambda_arity_param.hpp>
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER full_lambda.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/default_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/enum.hpp>
+#   include <boost/mpl/aux_/preprocessor/repeat.hpp>
+#   include <boost/mpl/aux_/config/dmc_ambiguous_ctps.hpp>
+
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+namespace boost { namespace mpl {
+
+// local macros, #undef-ined at the end of the header
+#   define AUX778076_LAMBDA_PARAMS(i_, param) \
+    BOOST_MPL_PP_PARAMS(i_, param) \
+    /**/
+
+#   define AUX778076_BIND_PARAMS(param) \
+    BOOST_MPL_PP_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        ) \
+    /**/
+
+#   define AUX778076_BIND_N_PARAMS(i_, param) \
+    BOOST_PP_COMMA_IF(i_) \
+    BOOST_MPL_PP_PARAMS(i_, param) \
+    /**/
+
+#   define AUX778076_ARITY_PARAM(param) \
+    BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(param) \
+    /**/
+
+
+#define n_ BOOST_MPL_LIMIT_METAFUNCTION_ARITY
+namespace aux {
+
+template<
+      BOOST_MPL_PP_DEFAULT_PARAMS(n_,bool C,false)
+    >
+struct lambda_or
+    : true_
+{
+};
+
+template<>
+struct lambda_or< BOOST_MPL_PP_ENUM(n_,false) >
+    : false_
+{
+};
+
+} // namespace aux
+#undef n_
+
+template<
+      typename T
+    , typename Tag
+    AUX778076_ARITY_PARAM(typename Arity)
+    >
+struct lambda
+{
+    typedef false_ is_le;
+    typedef T result_;
+    typedef T type;
+};
+
+template<
+      typename T
+    >
+struct is_lambda_expression
+    : lambda<T>::is_le
+{
+};
+
+
+template< int N, typename Tag >
+struct lambda< arg<N>,Tag AUX778076_ARITY_PARAM(int_<-1>) >
+{
+    typedef true_ is_le;
+    typedef mpl::arg<N> result_; // qualified for the sake of MIPSpro 7.41
+    typedef mpl::protect<result_> type;
+};
+
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/aux_/full_lambda.hpp>))
+#include BOOST_PP_ITERATE()
+
+/// special case for 'protect'
+template< typename T, typename Tag >
+struct lambda< mpl::protect<T>,Tag AUX778076_ARITY_PARAM(int_<1>) >
+{
+    typedef false_ is_le;
+    typedef mpl::protect<T> result_;
+    typedef result_ type;
+};
+
+/// specializations for the main 'bind' form
+template<
+      typename F, AUX778076_BIND_PARAMS(typename T)
+    , typename Tag
+    >
+struct lambda<
+          bind<F,AUX778076_BIND_PARAMS(T)>
+        , Tag
+        AUX778076_ARITY_PARAM(int_<BOOST_PP_INC(BOOST_MPL_LIMIT_METAFUNCTION_ARITY)>)
+        >
+{
+    typedef false_ is_le;
+    typedef bind<F, AUX778076_BIND_PARAMS(T)> result_;
+    typedef result_ type;
+};
+
+
+#if defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)
+
+template<
+      typename F
+    , typename Tag1
+    , typename Tag2
+    , typename Arity
+    >
+struct lambda<
+          lambda<F,Tag1,Arity>
+        , Tag2
+        , int_<3>
+        >
+{
+    typedef lambda< F,Tag2 > l1;
+    typedef lambda< Tag1,Tag2 > l2;
+
+    typedef typename l1::is_le is_le;
+    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
+    typedef lambda< typename if_<is_le,arity_,Arity>::type,Tag2 > l3;
+
+    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+#elif !defined(BOOST_MPL_CFG_DMC_AMBIGUOUS_CTPS)
+
+/// workaround for MWCW 8.3+/EDG < 303, leads to ambiguity on Digital Mars
+template<
+      typename F, typename Tag1, typename Tag2
+    >
+struct lambda<
+          lambda< F,Tag1 >
+        , Tag2
+        >
+{
+    typedef lambda< F,Tag2 > l1;
+    typedef lambda< Tag1,Tag2 > l2;
+
+    typedef typename l1::is_le is_le;
+    typedef aux::le_result2<is_le, Tag2, mpl::lambda, l1, l2> le_result_;
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+#endif
+
+#   undef AUX778076_ARITY_PARAM
+#   undef AUX778076_BIND_N_PARAMS
+#   undef AUX778076_BIND_PARAMS
+#   undef AUX778076_LAMBDA_PARAMS
+
+#if !defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)
+BOOST_MPL_AUX_NA_SPEC(2, lambda)
+#else
+BOOST_MPL_AUX_NA_SPEC2(2, 3, lambda)
+#endif
+
+}}
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_AUX_FULL_LAMBDA_HPP_INCLUDED
+
+///// iteration, depth == 1
+
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+#if i_ > 0
+
+namespace aux {
+
+#   define AUX778076_RESULT(unused, i_, T) \
+    BOOST_PP_COMMA_IF(i_) \
+    typename BOOST_PP_CAT(T, BOOST_PP_INC(i_))::result_ \
+    /**/
+
+#   define AUX778076_TYPE(unused, i_, T) \
+    BOOST_PP_COMMA_IF(i_) \
+    typename BOOST_PP_CAT(T, BOOST_PP_INC(i_))::type \
+    /**/
+
+template<
+      typename IsLE, typename Tag
+    , template< AUX778076_LAMBDA_PARAMS(i_, typename P) > class F
+    , AUX778076_LAMBDA_PARAMS(i_, typename L)
+    >
+struct BOOST_PP_CAT(le_result,i_)
+{
+    typedef F<
+          BOOST_MPL_PP_REPEAT(i_, AUX778076_TYPE, L)
+        > result_;
+
+    typedef result_ type;
+};
+
+template<
+      typename Tag
+    , template< AUX778076_LAMBDA_PARAMS(i_, typename P) > class F
+    , AUX778076_LAMBDA_PARAMS(i_, typename L)
+    >
+struct BOOST_PP_CAT(le_result,i_)< true_,Tag,F,AUX778076_LAMBDA_PARAMS(i_, L) >
+{
+    typedef BOOST_PP_CAT(bind,i_)<
+          BOOST_PP_CAT(quote,i_)<F,Tag>
+        , BOOST_MPL_PP_REPEAT(i_, AUX778076_RESULT, L)
+        > result_;
+
+    typedef mpl::protect<result_> type;
+};
+
+#   undef AUX778076_TYPE
+#   undef AUX778076_RESULT
+
+} // namespace aux
+
+
+#   define AUX778076_LAMBDA_TYPEDEF(unused, i_, T) \
+    typedef lambda< BOOST_PP_CAT(T, BOOST_PP_INC(i_)), Tag > \
+        BOOST_PP_CAT(l,BOOST_PP_INC(i_)); \
+/**/
+
+#   define AUX778076_IS_LE_TYPEDEF(unused, i_, unused2) \
+    typedef typename BOOST_PP_CAT(l,BOOST_PP_INC(i_))::is_le \
+        BOOST_PP_CAT(is_le,BOOST_PP_INC(i_)); \
+/**/
+
+#   define AUX778076_IS_LAMBDA_EXPR(unused, i_, unused2) \
+    BOOST_PP_COMMA_IF(i_) \
+    BOOST_PP_CAT(is_le,BOOST_PP_INC(i_))::value \
+/**/
+
+template<
+      template< AUX778076_LAMBDA_PARAMS(i_, typename P) > class F
+    , AUX778076_LAMBDA_PARAMS(i_, typename T)
+    , typename Tag
+    >
+struct lambda<
+          F<AUX778076_LAMBDA_PARAMS(i_, T)>
+        , Tag
+        AUX778076_ARITY_PARAM(int_<i_>)
+        >
+{
+    BOOST_MPL_PP_REPEAT(i_, AUX778076_LAMBDA_TYPEDEF, T)
+    BOOST_MPL_PP_REPEAT(i_, AUX778076_IS_LE_TYPEDEF, unused)
+
+    typedef typename aux::lambda_or<
+          BOOST_MPL_PP_REPEAT(i_, AUX778076_IS_LAMBDA_EXPR, unused)
+        >::type is_le;
+
+    typedef aux::BOOST_PP_CAT(le_result,i_)<
+          is_le, Tag, F, AUX778076_LAMBDA_PARAMS(i_, l)
+        > le_result_;
+
+    typedef typename le_result_::result_ result_;
+    typedef typename le_result_::type type;
+};
+
+
+#   undef AUX778076_IS_LAMBDA_EXPR
+#   undef AUX778076_IS_LE_TYPEDEF
+#   undef AUX778076_LAMBDA_TYPEDEF
+
+#endif // i_ > 0
+
+template<
+      typename F AUX778076_BIND_N_PARAMS(i_, typename T)
+    , typename Tag
+    >
+struct lambda<
+          BOOST_PP_CAT(bind,i_)<F AUX778076_BIND_N_PARAMS(i_, T)>
+        , Tag
+        AUX778076_ARITY_PARAM(int_<BOOST_PP_INC(i_)>)
+        >
+{
+    typedef false_ is_le;
+    typedef BOOST_PP_CAT(bind,i_)<
+          F
+        AUX778076_BIND_N_PARAMS(i_, T)
+        > result_;
+
+    typedef result_ type;
+};
+
+#undef i_
+#endif // BOOST_PP_ITERATION_DEPTH()
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/nested_type_wknd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/nested_type_wknd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/nested_type_wknd.hpp	(working copy)
@@ -0,0 +1,48 @@
+
+#ifndef BOOST_MPL_AUX_NESTED_TYPE_WKND_HPP_INCLUDED
+#define BOOST_MPL_AUX_NESTED_TYPE_WKND_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: nested_type_wknd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0302)) \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x561)) \
+    || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x530)) \
+    || BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+
+namespace boost { namespace mpl { namespace aux {
+template< typename T > struct nested_type_wknd
+    : T::type
+{
+};
+}}}
+
+#if BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+#   define BOOST_MPL_AUX_NESTED_TYPE_WKND(T) \
+    aux::nested_type_wknd<T> \
+/**/
+#else
+#   define BOOST_MPL_AUX_NESTED_TYPE_WKND(T) \
+    ::boost::mpl::aux::nested_type_wknd<T> \
+/**/
+#endif
+
+#else // !BOOST_MPL_CFG_GCC et al.
+
+#   define BOOST_MPL_AUX_NESTED_TYPE_WKND(T) T::type
+
+#endif
+
+#endif // BOOST_MPL_AUX_NESTED_TYPE_WKND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/msvc_never_true.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/msvc_never_true.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/msvc_never_true.hpp	(working copy)
@@ -0,0 +1,34 @@
+
+#ifndef BOOST_MPL_AUX_MSVC_NEVER_TRUE_HPP_INCLUDED
+#define BOOST_MPL_AUX_MSVC_NEVER_TRUE_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: msvc_never_true.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+
+namespace boost { namespace mpl { namespace aux {
+
+template< typename T >
+struct msvc_never_true
+{
+    enum { value = false };
+};
+
+}}}
+
+#endif // BOOST_MSVC
+
+#endif // BOOST_MPL_AUX_MSVC_NEVER_TRUE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_spec.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_spec.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/na_spec.hpp	(working copy)
@@ -0,0 +1,175 @@
+
+#ifndef BOOST_MPL_AUX_NA_SPEC_HPP_INCLUDED
+#define BOOST_MPL_AUX_NA_SPEC_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: na_spec.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/lambda_fwd.hpp>
+#   include <boost/mpl/int.hpp>
+#   include <boost/mpl/bool.hpp>
+#   include <boost/mpl/aux_/na.hpp>
+#   include <boost/mpl/aux_/arity.hpp>
+#   include <boost/mpl/aux_/template_arity_fwd.hpp>
+#endif
+
+#include <boost/mpl/aux_/preprocessor/params.hpp>
+#include <boost/mpl/aux_/preprocessor/enum.hpp>
+#include <boost/mpl/aux_/preprocessor/def_params_tail.hpp>
+#include <boost/mpl/aux_/lambda_arity_param.hpp>
+#include <boost/mpl/aux_/config/dtp.hpp>
+#include <boost/mpl/aux_/config/eti.hpp>
+#include <boost/mpl/aux_/nttp_decl.hpp>
+#include <boost/mpl/aux_/config/ttp.hpp>
+#include <boost/mpl/aux_/config/lambda.hpp>
+#include <boost/mpl/aux_/config/overload_resolution.hpp>
+
+
+#define BOOST_MPL_AUX_NA_PARAMS(i) \
+    BOOST_MPL_PP_ENUM(i, na) \
+/**/
+
+#if defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#   define BOOST_MPL_AUX_NA_SPEC_ARITY(i, name) \
+namespace aux { \
+template< BOOST_MPL_AUX_NTTP_DECL(int, N) > \
+struct arity< \
+          name< BOOST_MPL_AUX_NA_PARAMS(i) > \
+        , N \
+        > \
+    : int_< BOOST_MPL_LIMIT_METAFUNCTION_ARITY > \
+{ \
+}; \
+} \
+/**/
+#else
+#   define BOOST_MPL_AUX_NA_SPEC_ARITY(i, name) /**/
+#endif
+
+#define BOOST_MPL_AUX_NA_SPEC_MAIN(i, name) \
+template<> \
+struct name< BOOST_MPL_AUX_NA_PARAMS(i) > \
+{ \
+    template< \
+          BOOST_MPL_PP_PARAMS(i, typename T) \
+        BOOST_MPL_PP_NESTED_DEF_PARAMS_TAIL(i, typename T, na) \
+        > \
+    struct apply \
+        : name< BOOST_MPL_PP_PARAMS(i, T) > \
+    { \
+    }; \
+}; \
+/**/
+
+#if defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+#   define BOOST_MPL_AUX_NA_SPEC_LAMBDA(i, name) \
+template<> \
+struct lambda< \
+      name< BOOST_MPL_AUX_NA_PARAMS(i) > \
+    , void_ \
+    , true_ \
+    > \
+{ \
+    typedef false_ is_le; \
+    typedef name< BOOST_MPL_AUX_NA_PARAMS(i) > type; \
+}; \
+template<> \
+struct lambda< \
+      name< BOOST_MPL_AUX_NA_PARAMS(i) > \
+    , void_ \
+    , false_ \
+    > \
+{ \
+    typedef false_ is_le; \
+    typedef name< BOOST_MPL_AUX_NA_PARAMS(i) > type; \
+}; \
+/**/
+#else
+#   define BOOST_MPL_AUX_NA_SPEC_LAMBDA(i, name) \
+template< typename Tag > \
+struct lambda< \
+      name< BOOST_MPL_AUX_NA_PARAMS(i) > \
+    , Tag \
+    BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(int_<-1>) \
+    > \
+{ \
+    typedef false_ is_le; \
+    typedef name< BOOST_MPL_AUX_NA_PARAMS(i) > result_; \
+    typedef name< BOOST_MPL_AUX_NA_PARAMS(i) > type; \
+}; \
+/**/
+#endif
+
+#if defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING) \
+    || defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT) \
+        && defined(BOOST_MPL_CFG_BROKEN_OVERLOAD_RESOLUTION)
+#   define BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i, j, name) \
+namespace aux { \
+template< BOOST_MPL_PP_PARAMS(j, typename T) > \
+struct template_arity< \
+          name< BOOST_MPL_PP_PARAMS(j, T) > \
+        > \
+    : int_<j> \
+{ \
+}; \
+\
+template<> \
+struct template_arity< \
+          name< BOOST_MPL_PP_ENUM(i, na) > \
+        > \
+    : int_<-1> \
+{ \
+}; \
+} \
+/**/
+#else
+#   define BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i, j, name) /**/
+#endif
+
+#if defined(BOOST_MPL_CFG_MSVC_ETI_BUG)
+#   define BOOST_MPL_AUX_NA_SPEC_ETI(i, name) \
+template<> \
+struct name< BOOST_MPL_PP_ENUM(i, int) > \
+{ \
+    typedef int type; \
+    enum { value = 0 }; \
+}; \
+/**/
+#else
+#   define BOOST_MPL_AUX_NA_SPEC_ETI(i, name) /**/
+#endif
+
+#define BOOST_MPL_AUX_NA_PARAM(param) param = na
+
+#define BOOST_MPL_AUX_NA_SPEC_NO_ETI(i, name) \
+BOOST_MPL_AUX_NA_SPEC_MAIN(i, name) \
+BOOST_MPL_AUX_NA_SPEC_LAMBDA(i, name) \
+BOOST_MPL_AUX_NA_SPEC_ARITY(i, name) \
+BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i, i, name) \
+/**/
+
+#define BOOST_MPL_AUX_NA_SPEC(i, name) \
+BOOST_MPL_AUX_NA_SPEC_NO_ETI(i, name) \
+BOOST_MPL_AUX_NA_SPEC_ETI(i, name) \
+/**/
+
+#define BOOST_MPL_AUX_NA_SPEC2(i, j, name) \
+BOOST_MPL_AUX_NA_SPEC_MAIN(i, name) \
+BOOST_MPL_AUX_NA_SPEC_ETI(i, name) \
+BOOST_MPL_AUX_NA_SPEC_LAMBDA(i, name) \
+BOOST_MPL_AUX_NA_SPEC_ARITY(i, name) \
+BOOST_MPL_AUX_NA_SPEC_TEMPLATE_ARITY(i, j, name) \
+/**/
+
+
+#endif // BOOST_MPL_AUX_NA_SPEC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/lambda_arity_param.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/lambda_arity_param.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/lambda_arity_param.hpp	(working copy)
@@ -0,0 +1,25 @@
+
+#ifndef BOOST_MPL_AUX_LAMBDA_ARITY_PARAM_HPP_INCLUDED
+#define BOOST_MPL_AUX_LAMBDA_ARITY_PARAM_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: lambda_arity_param.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/ttp.hpp>
+
+#if !defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING)
+#   define BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(param)
+#else
+#   define BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(param) , param
+#endif
+
+#endif // BOOST_MPL_AUX_LAMBDA_ARITY_PARAM_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/common_name_wknd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/common_name_wknd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/common_name_wknd.hpp	(working copy)
@@ -0,0 +1,34 @@
+
+#ifndef BOOST_MPL_AUX_COMMON_NAME_WKND_HPP_INCLUDED
+#define BOOST_MPL_AUX_COMMON_NAME_WKND_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: common_name_wknd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if BOOST_WORKAROUND(__BORLANDC__, < 0x561)
+// agurt, 12/nov/02: to suppress the bogus "Cannot have both a template class
+// and function named 'xxx'" diagnostic
+#   define BOOST_MPL_AUX_COMMON_NAME_WKND(name) \
+namespace name_##wknd { \
+template< typename > void name(); \
+} \
+/**/
+
+#else
+
+#   define BOOST_MPL_AUX_COMMON_NAME_WKND(name) /**/
+
+#endif // __BORLANDC__
+
+#endif // BOOST_MPL_AUX_COMMON_NAME_WKND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/has_type.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/has_type.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/has_type.hpp	(working copy)
@@ -0,0 +1,23 @@
+
+#ifndef BOOST_MPL_AUX_HAS_TYPE_HPP_INCLUDED
+#define BOOST_MPL_AUX_HAS_TYPE_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: has_type.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/has_xxx.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(has_type, type, true)
+}}}
+
+#endif // BOOST_MPL_AUX_HAS_TYPE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/lambda_support.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/lambda_support.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/lambda_support.hpp	(working copy)
@@ -0,0 +1,169 @@
+
+#ifndef BOOST_MPL_AUX_LAMBDA_SUPPORT_HPP_INCLUDED
+#define BOOST_MPL_AUX_LAMBDA_SUPPORT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: lambda_support.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/lambda.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) /**/
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT(i,name,params) /**/
+
+#else
+
+#   include <boost/mpl/int_fwd.hpp>
+#   include <boost/mpl/aux_/yes_no.hpp>
+#   include <boost/mpl/aux_/na_fwd.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/enum.hpp>
+#   include <boost/mpl/aux_/config/msvc.hpp>
+#   include <boost/mpl/aux_/config/workaround.hpp>
+
+#   include <boost/preprocessor/tuple/to_list.hpp>
+#   include <boost/preprocessor/list/for_each_i.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_ARG_TYPEDEF_FUNC(R,typedef_,i,param) \
+    typedef_ param BOOST_PP_CAT(arg,BOOST_PP_INC(i)); \
+    /**/
+
+// agurt, 07/mar/03: restore an old revision for the sake of SGI MIPSpro C++
+#if BOOST_WORKAROUND(__EDG_VERSION__, <= 238)
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT(i, name, params) \
+    typedef BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::int_<i> arity; \
+    BOOST_PP_LIST_FOR_EACH_I_R( \
+          1 \
+        , BOOST_MPL_AUX_LAMBDA_SUPPORT_ARG_TYPEDEF_FUNC \
+        , typedef \
+        , BOOST_PP_TUPLE_TO_LIST(i,params) \
+        ) \
+    struct rebind \
+    { \
+        template< BOOST_MPL_PP_PARAMS(i,typename U) > struct apply \
+            : name< BOOST_MPL_PP_PARAMS(i,U) > \
+        { \
+        }; \
+    }; \
+    /**/
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(i, name, params) \
+    /**/
+
+#elif BOOST_WORKAROUND(__EDG_VERSION__, <= 244) && !defined(BOOST_INTEL_CXX_VERSION)
+// agurt, 18/jan/03: old EDG-based compilers actually enforce 11.4 para 9
+// (in strict mode), so we have to provide an alternative to the
+// MSVC-optimized implementation
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) \
+    typedef BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::int_<i> arity; \
+    BOOST_PP_LIST_FOR_EACH_I_R( \
+          1 \
+        , BOOST_MPL_AUX_LAMBDA_SUPPORT_ARG_TYPEDEF_FUNC \
+        , typedef \
+        , BOOST_PP_TUPLE_TO_LIST(i,params) \
+        ) \
+    struct rebind; \
+/**/
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT(i, name, params) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) \
+}; \
+template< BOOST_MPL_PP_PARAMS(i,typename T) > \
+struct name<BOOST_MPL_PP_PARAMS(i,T)>::rebind \
+{ \
+    template< BOOST_MPL_PP_PARAMS(i,typename U) > struct apply \
+        : name< BOOST_MPL_PP_PARAMS(i,U) > \
+    { \
+    }; \
+/**/
+
+#else // __EDG_VERSION__
+
+namespace boost { namespace mpl { namespace aux {
+template< typename T > struct has_rebind_tag;
+}}}
+
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) \
+    typedef BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE::int_<i> arity; \
+    BOOST_PP_LIST_FOR_EACH_I_R( \
+          1 \
+        , BOOST_MPL_AUX_LAMBDA_SUPPORT_ARG_TYPEDEF_FUNC \
+        , typedef \
+        , BOOST_PP_TUPLE_TO_LIST(i,params) \
+        ) \
+    friend class BOOST_PP_CAT(name,_rebind); \
+    typedef BOOST_PP_CAT(name,_rebind) rebind; \
+/**/
+
+#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610))
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_HAS_REBIND(i, name, params) \
+template< BOOST_MPL_PP_PARAMS(i,typename T) > \
+::boost::mpl::aux::yes_tag operator|( \
+      ::boost::mpl::aux::has_rebind_tag<int> \
+    , name<BOOST_MPL_PP_PARAMS(i,T)>* \
+    ); \
+::boost::mpl::aux::no_tag operator|( \
+      ::boost::mpl::aux::has_rebind_tag<int> \
+    , name< BOOST_MPL_PP_ENUM(i,::boost::mpl::na) >* \
+    ); \
+/**/
+#elif !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_HAS_REBIND(i, name, params) \
+template< BOOST_MPL_PP_PARAMS(i,typename T) > \
+::boost::mpl::aux::yes_tag operator|( \
+      ::boost::mpl::aux::has_rebind_tag<int> \
+    , ::boost::mpl::aux::has_rebind_tag< name<BOOST_MPL_PP_PARAMS(i,T)> >* \
+    ); \
+/**/
+#else
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT_HAS_REBIND(i, name, params) /**/
+#endif
+
+#   if !defined(__BORLANDC__)
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT(i, name, params) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) \
+}; \
+BOOST_MPL_AUX_LAMBDA_SUPPORT_HAS_REBIND(i, name, params) \
+class BOOST_PP_CAT(name,_rebind) \
+{ \
+ public: \
+    template< BOOST_MPL_PP_PARAMS(i,typename U) > struct apply \
+        : name< BOOST_MPL_PP_PARAMS(i,U) > \
+    { \
+    }; \
+/**/
+#   else
+#   define BOOST_MPL_AUX_LAMBDA_SUPPORT(i, name, params) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(i, name, params) \
+}; \
+BOOST_MPL_AUX_LAMBDA_SUPPORT_HAS_REBIND(i, name, params) \
+class BOOST_PP_CAT(name,_rebind) \
+{ \
+ public: \
+    template< BOOST_MPL_PP_PARAMS(i,typename U) > struct apply \
+    { \
+        typedef typename name< BOOST_MPL_PP_PARAMS(i,U) >::type type; \
+    }; \
+/**/
+#   endif // __BORLANDC__
+
+#endif // __EDG_VERSION__
+
+#endif // BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT
+
+#endif // BOOST_MPL_AUX_LAMBDA_SUPPORT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/gcc.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/gcc.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/gcc.hpp	(working copy)
@@ -0,0 +1,23 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_GCC_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_GCC_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: gcc.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if defined(__GNUC__) && !defined(__EDG_VERSION__)
+#   define BOOST_MPL_CFG_GCC ((__GNUC__ << 8) | __GNUC_MINOR__)
+#else
+#   define BOOST_MPL_CFG_GCC 0
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_GCC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/static_constant.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/static_constant.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/static_constant.hpp	(working copy)
@@ -0,0 +1,25 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_STATIC_CONSTANT_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_STATIC_CONSTANT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: static_constant.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+// BOOST_STATIC_CONSTANT is defined here:
+#   include <boost/config.hpp>
+#else
+// undef the macro for the preprocessing mode
+#   undef BOOST_STATIC_CONSTANT
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_STATIC_CONSTANT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/arrays.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/arrays.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/arrays.hpp	(working copy)
@@ -0,0 +1,30 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_ARRAYS_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_ARRAYS_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2003-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arrays.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if    !defined(BOOST_MPL_CFG_NO_DEPENDENT_ARRAY_TYPES) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && ( BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+        || BOOST_WORKAROUND(BOOST_MSVC, <= 1300) \
+        )
+
+#   define BOOST_MPL_CFG_NO_DEPENDENT_ARRAY_TYPES
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_ARRAYS_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/ttp.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/ttp.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/ttp.hpp	(working copy)
@@ -0,0 +1,41 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_TTP_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_TTP_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: ttp.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS) \
+    && ( defined(BOOST_NO_TEMPLATE_TEMPLATES) \
+      || BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT( 0x590) ) \
+       )
+
+#   define BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS
+
+#endif
+
+
+#if    !defined(BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && (   BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0302)) \
+        || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+        )
+
+#   define BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_TTP_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/msvc.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/msvc.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/msvc.hpp	(working copy)
@@ -0,0 +1,21 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_MSVC_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_MSVC_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: msvc.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+
+// BOOST_MSVC is defined here:
+#include <boost/config.hpp>
+
+#endif // BOOST_MPL_AUX_CONFIG_MSVC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/ctps.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/ctps.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/ctps.hpp	(working copy)
@@ -0,0 +1,30 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_CTPS_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_CTPS_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: ctps.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+#include <boost/config.hpp>
+
+#if    !defined(BOOST_MPL_CFG_NO_NONTYPE_TEMPLATE_PARTIAL_SPEC) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(__BORLANDC__, < 0x582)
+
+#   define BOOST_MPL_CFG_NO_NONTYPE_TEMPLATE_PARTIAL_SPEC
+
+#endif
+
+// BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION is defined in <boost/config.hpp>
+
+#endif // BOOST_MPL_AUX_CONFIG_CTPS_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/compiler.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/compiler.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/compiler.hpp	(working copy)
@@ -0,0 +1,66 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_COMPILER_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_COMPILER_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2008
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: compiler.hpp 53189 2009-05-22 20:07:55Z hkaiser $
+// $Date: 2009-05-22 16:07:55 -0400 (Fri, 22 May 2009) $
+// $Revision: 53189 $
+
+#if !defined(BOOST_MPL_CFG_COMPILER_DIR)
+
+#   include <boost/mpl/aux_/config/dtp.hpp>
+#   include <boost/mpl/aux_/config/ttp.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/mpl/aux_/config/msvc.hpp>
+#   include <boost/mpl/aux_/config/gcc.hpp>
+#   include <boost/mpl/aux_/config/workaround.hpp>
+
+#   if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+#       define BOOST_MPL_CFG_COMPILER_DIR msvc60
+
+#   elif BOOST_WORKAROUND(BOOST_MSVC, == 1300)
+#       define BOOST_MPL_CFG_COMPILER_DIR msvc70
+
+#   elif BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0304))
+#       define BOOST_MPL_CFG_COMPILER_DIR gcc
+
+#   elif BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610))
+#       if !defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#           define BOOST_MPL_CFG_COMPILER_DIR bcc551
+#       elif BOOST_WORKAROUND(__BORLANDC__, >= 0x590)
+#           define BOOST_MPL_CFG_COMPILER_DIR bcc
+#       else
+#           define BOOST_MPL_CFG_COMPILER_DIR bcc_pre590
+#       endif
+
+#   elif BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+#       define BOOST_MPL_CFG_COMPILER_DIR dmc
+
+#   elif defined(__MWERKS__)
+#       if defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#           define BOOST_MPL_CFG_COMPILER_DIR mwcw
+#       else
+#           define BOOST_MPL_CFG_COMPILER_DIR plain
+#       endif
+
+#   elif defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+#       define BOOST_MPL_CFG_COMPILER_DIR no_ctps
+
+#   elif defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS)
+#       define BOOST_MPL_CFG_COMPILER_DIR no_ttp
+
+#   else
+#       define BOOST_MPL_CFG_COMPILER_DIR plain
+#   endif
+
+#endif // BOOST_MPL_CFG_COMPILER_DIR
+
+#endif // BOOST_MPL_AUX_CONFIG_COMPILER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/msvc_typename.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/msvc_typename.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/msvc_typename.hpp	(working copy)
@@ -0,0 +1,26 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_MSVC_TYPENAME_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_MSVC_TYPENAME_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: msvc_typename.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+#   define BOOST_MSVC_TYPENAME
+#else
+#   define BOOST_MSVC_TYPENAME typename
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_MSVC_TYPENAME_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/bind.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/bind.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/bind.hpp	(working copy)
@@ -0,0 +1,33 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_BIND_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_BIND_HPP_INCLUDED
+
+// Copyright David Abrahams 2002
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: bind.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if    !defined(BOOST_MPL_CFG_NO_BIND_TEMPLATE) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && (   BOOST_WORKAROUND(BOOST_MSVC, <= 1300) \
+        || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+        )
+
+#   define BOOST_MPL_CFG_NO_BIND_TEMPLATE
+
+#endif
+
+//#define BOOST_MPL_CFG_NO_UNNAMED_PLACEHOLDER_SUPPORT
+
+#endif // BOOST_MPL_AUX_CONFIG_BIND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/pp_counter.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/pp_counter.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/pp_counter.hpp	(working copy)
@@ -0,0 +1,26 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_PP_COUNTER_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_PP_COUNTER_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2006
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: pp_counter.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_AUX_PP_COUNTER)
+#   include <boost/mpl/aux_/config/msvc.hpp>
+#   if BOOST_WORKAROUND(BOOST_MSVC, >= 1300)
+#       define BOOST_MPL_AUX_PP_COUNTER() __COUNTER__
+#   else
+#       define BOOST_MPL_AUX_PP_COUNTER() __LINE__
+#   endif
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_PP_COUNTER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/preprocessor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/preprocessor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/preprocessor.hpp	(working copy)
@@ -0,0 +1,39 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_PREPROCESSOR_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_PREPROCESSOR_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: preprocessor.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if !defined(BOOST_MPL_CFG_BROKEN_PP_MACRO_EXPANSION) \
+    && (   BOOST_WORKAROUND(__MWERKS__, <= 0x3003) \
+        || BOOST_WORKAROUND(__BORLANDC__, < 0x582) \
+        || BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(502)) \
+        )
+
+#   define BOOST_MPL_CFG_BROKEN_PP_MACRO_EXPANSION
+
+#endif
+
+#if !defined(BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES)
+#   define BOOST_MPL_CFG_NO_OWN_PP_PRIMITIVES
+#endif
+
+#if !defined(BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING) \
+    && BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+#   define BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING
+#endif
+
+
+#endif // BOOST_MPL_AUX_CONFIG_PREPROCESSOR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/workaround.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/workaround.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/workaround.hpp	(working copy)
@@ -0,0 +1,19 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_WORKAROUND_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_WORKAROUND_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: workaround.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/detail/workaround.hpp>
+
+#endif // BOOST_MPL_AUX_CONFIG_WORKAROUND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/overload_resolution.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/overload_resolution.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/overload_resolution.hpp	(working copy)
@@ -0,0 +1,29 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_OVERLOAD_RESOLUTION_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_OVERLOAD_RESOLUTION_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: overload_resolution.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if    !defined(BOOST_MPL_CFG_BROKEN_OVERLOAD_RESOLUTION) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && (   BOOST_WORKAROUND(__BORLANDC__, < 0x590) \
+        || BOOST_WORKAROUND(__MWERKS__, < 0x3001) \
+        )
+
+#   define BOOST_MPL_CFG_BROKEN_OVERLOAD_RESOLUTION
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_OVERLOAD_RESOLUTION_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/adl.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/adl.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/adl.hpp	(working copy)
@@ -0,0 +1,40 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_ADL_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_ADL_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: adl.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/intel.hpp>
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+// agurt, 25/apr/04: technically, the ADL workaround is only needed for GCC,
+// but putting everything expect public, user-specializable metafunctions into
+// a separate global namespace has a nice side effect of reducing the length
+// of template instantiation symbols, so we apply the workaround on all
+// platforms that can handle it
+
+#if !defined(BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE) \
+    && (   BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1400)) \
+        || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+        || BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840)) \
+        || BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3202)) \
+        || BOOST_WORKAROUND(BOOST_INTEL_CXX_VERSION, BOOST_TESTED_AT(810)) \
+        )
+
+#   define BOOST_MPL_CFG_NO_ADL_BARRIER_NAMESPACE
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_ADL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/integral.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/integral.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/integral.hpp	(working copy)
@@ -0,0 +1,38 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_INTEGRAL_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_INTEGRAL_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: integral.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if    !defined(BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610))
+
+#   define BOOST_MPL_CFG_BCC_INTEGRAL_CONSTANTS
+
+#endif
+
+#if    !defined(BOOST_MPL_CFG_NO_NESTED_VALUE_ARITHMETIC) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && ( BOOST_WORKAROUND(BOOST_MSVC, <= 1300) \
+        || BOOST_WORKAROUND(__EDG_VERSION__, <= 238) \
+        )
+
+#   define BOOST_MPL_CFG_NO_NESTED_VALUE_ARITHMETIC
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_INTEGRAL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/use_preprocessed.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/use_preprocessed.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/use_preprocessed.hpp	(working copy)
@@ -0,0 +1,19 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_USE_PREPROCESSED_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_USE_PREPROCESSED_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: use_preprocessed.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+// #define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+
+#endif // BOOST_MPL_AUX_CONFIG_USE_PREPROCESSED_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/intel.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/intel.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/intel.hpp	(working copy)
@@ -0,0 +1,21 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_INTEL_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_INTEL_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: intel.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+
+// BOOST_INTEL_CXX_VERSION is defined here:
+#include <boost/config.hpp>
+
+#endif // BOOST_MPL_AUX_CONFIG_INTEL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/has_apply.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/has_apply.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/has_apply.hpp	(working copy)
@@ -0,0 +1,32 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_HAS_APPLY_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_HAS_APPLY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: has_apply.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/has_xxx.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_HAS_APPLY) \
+    && (   defined(BOOST_MPL_CFG_NO_HAS_XXX) \
+        || BOOST_WORKAROUND(__EDG_VERSION__, < 300) \
+        || BOOST_WORKAROUND(BOOST_MSVC, <= 1300) \
+        || BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3202)) \
+        )
+
+#   define BOOST_MPL_CFG_NO_HAS_APPLY
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_HAS_APPLY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/lambda.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/lambda.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/lambda.hpp	(working copy)
@@ -0,0 +1,32 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_LAMBDA_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_LAMBDA_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: lambda.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/ttp.hpp>
+#include <boost/mpl/aux_/config/ctps.hpp>
+
+// agurt, 15/jan/02: full-fledged implementation requires both
+// template template parameters _and_ partial specialization
+
+#if    !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT) \
+    && (   defined(BOOST_MPL_CFG_NO_TEMPLATE_TEMPLATE_PARAMETERS) \
+        || defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+        )
+
+#   define BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_LAMBDA_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/eti.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/eti.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/eti.hpp	(working copy)
@@ -0,0 +1,47 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_ETI_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_ETI_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: eti.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+// flags for MSVC 6.5's so-called "early template instantiation bug"
+#if    !defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+#   define BOOST_MPL_CFG_MSVC_60_ETI_BUG
+
+#endif
+
+#if    !defined(BOOST_MPL_CFG_MSVC_70_ETI_BUG) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(BOOST_MSVC, == 1300)
+
+#   define BOOST_MPL_CFG_MSVC_70_ETI_BUG
+
+#endif
+
+#if    !defined(BOOST_MPL_CFG_MSVC_ETI_BUG) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && ( defined(BOOST_MPL_CFG_MSVC_60_ETI_BUG) \
+        || defined(BOOST_MPL_CFG_MSVC_70_ETI_BUG) \
+        )
+
+#   define BOOST_MPL_CFG_MSVC_ETI_BUG
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_ETI_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/has_xxx.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/has_xxx.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/has_xxx.hpp	(working copy)
@@ -0,0 +1,34 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_HAS_XXX_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_HAS_XXX_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2004
+// Copyright David Abrahams 2002-2003
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: has_xxx.hpp 63518 2010-07-02 08:32:03Z agurtovoy $
+// $Date: 2010-07-02 04:32:03 -0400 (Fri, 02 Jul 2010) $
+// $Revision: 63518 $
+
+#include <boost/mpl/aux_/config/overload_resolution.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+// agurt, 11/jan/03: signals a stub-only 'has_xxx' implementation
+
+#if !defined(BOOST_MPL_CFG_NO_HAS_XXX) \
+    && (   defined(BOOST_MPL_CFG_BROKEN_OVERLOAD_RESOLUTION) \
+        || BOOST_WORKAROUND(__GNUC__, <= 2) \
+        || BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840)) \
+        )
+
+#   define BOOST_MPL_CFG_NO_HAS_XXX
+#   define BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_HAS_XXX_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/nttp.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/nttp.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/nttp.hpp	(working copy)
@@ -0,0 +1,41 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_NTTP_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_NTTP_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: nttp.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+// MSVC 6.5 ICE-s on the code as simple as this (see "aux_/nttp_decl.hpp"
+// for a workaround):
+//
+//    namespace std {
+//    template< typename Char > struct string;
+//    }
+//
+//    void foo(std::string<char>);
+//
+//    namespace boost { namespace mpl {
+//    template< int > struct arg;
+//    }}
+
+#if    !defined(BOOST_MPL_CFG_NTTP_BUG) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+#   define BOOST_MPL_CFG_NTTP_BUG
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_NTTP_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/bcc.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/bcc.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/bcc.hpp	(working copy)
@@ -0,0 +1,28 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_BCC_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_BCC_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2008
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: bcc.hpp 49272 2008-10-11 06:50:46Z agurtovoy $
+// $Date: 2004-09-02 10:41:37 -0500 (Thu, 02 Sep 2004) $
+// $Revision: 24874 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if    !defined(BOOST_MPL_CFG_BCC590_WORKAROUNDS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(__BORLANDC__, >= 0x590) \
+    && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610))
+
+#   define BOOST_MPL_CFG_BCC590_WORKAROUNDS
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_BCC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/dtp.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/dtp.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/config/dtp.hpp	(working copy)
@@ -0,0 +1,46 @@
+
+#ifndef BOOST_MPL_AUX_CONFIG_DTP_HPP_INCLUDED
+#define BOOST_MPL_AUX_CONFIG_DTP_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: dtp.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+// MWCW 7.x-8.0 "losts" default template parameters of nested class
+// templates when their owner classes are passed as arguments to other
+// templates; Borland 5.5.1 "forgets" them from the very beginning (if
+// the owner class is a class template), and Borland 5.6 isn't even
+// able to compile a definition of nested class template with DTP
+
+#if    !defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && BOOST_WORKAROUND(__BORLANDC__, >= 0x560) \
+    && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610))
+
+#   define BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES
+
+#endif
+
+
+#if    !defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE) \
+    && (   BOOST_WORKAROUND(__MWERKS__, <= 0x3001) \
+        || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x610)) \
+        || defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES) \
+        )
+
+#   define BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES
+
+#endif
+
+#endif // BOOST_MPL_AUX_CONFIG_DTP_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/has_apply.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/has_apply.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/has_apply.hpp	(working copy)
@@ -0,0 +1,32 @@
+
+#ifndef BOOST_MPL_AUX_HAS_APPLY_HPP_INCLUDED
+#define BOOST_MPL_AUX_HAS_APPLY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: has_apply.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/has_xxx.hpp>
+#include <boost/mpl/aux_/config/has_apply.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+#if !defined(BOOST_MPL_CFG_NO_HAS_APPLY)
+BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(has_apply, apply, false)
+#else
+template< typename T, typename fallback_ = false_ >
+struct has_apply
+    : fallback_
+{
+};
+#endif
+}}}
+
+#endif // BOOST_MPL_AUX_HAS_APPLY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/template_arity_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/template_arity_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/aux_/template_arity_fwd.hpp	(working copy)
@@ -0,0 +1,23 @@
+
+#ifndef BOOST_MPL_AUX_TEMPLATE_ARITY_FWD_HPP_INCLUDED
+#define BOOST_MPL_AUX_TEMPLATE_ARITY_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: template_arity_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+namespace boost { namespace mpl { namespace aux {
+
+template< typename F > struct template_arity;
+
+}}}
+
+#endif // BOOST_MPL_AUX_TEMPLATE_ARITY_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c.hpp	(working copy)
@@ -0,0 +1,51 @@
+
+#ifndef BOOST_MPL_INTEGRAL_C_HPP_INCLUDED
+#define BOOST_MPL_INTEGRAL_C_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2006
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: integral_c.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/integral_c_fwd.hpp>
+#include <boost/mpl/aux_/config/ctps.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#if BOOST_WORKAROUND(__HP_aCC, <= 53800)
+// the type of non-type template arguments may not depend on template arguments
+#   define AUX_WRAPPER_PARAMS(N) typename T, long N
+#else
+#   define AUX_WRAPPER_PARAMS(N) typename T, T N
+#endif
+
+#define AUX_WRAPPER_NAME integral_c
+#define AUX_WRAPPER_VALUE_TYPE T
+#define AUX_WRAPPER_INST(value) AUX_WRAPPER_NAME< T, value >
+#include <boost/mpl/aux_/integral_wrapper.hpp>
+
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+ && !BOOST_WORKAROUND(__BORLANDC__, <= 0x551)
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+// 'bool' constant doesn't have 'next'/'prior' members
+template< bool C >
+struct integral_c<bool, C>
+{
+    BOOST_STATIC_CONSTANT(bool, value = C);
+    typedef integral_c_tag tag;
+    typedef integral_c type;
+    typedef bool value_type;
+    operator bool() const { return this->value; }
+};
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+#endif
+
+#endif // BOOST_MPL_INTEGRAL_C_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply.hpp	(working copy)
@@ -0,0 +1,229 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_APPLY_HPP_INCLUDED
+#define BOOST_MPL_APPLY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: apply.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/apply_fwd.hpp>
+#   include <boost/mpl/apply_wrap.hpp>
+#   include <boost/mpl/placeholders.hpp>
+#   include <boost/mpl/lambda.hpp>
+#   include <boost/mpl/aux_/na.hpp>
+#   include <boost/mpl/aux_/lambda_support.hpp>
+#endif
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER apply.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/default_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/partial_spec_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/enum.hpp>
+#   include <boost/mpl/aux_/config/lambda.hpp>
+#   include <boost/mpl/aux_/config/dtp.hpp>
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+#   include <boost/mpl/aux_/config/eti.hpp>
+#   include <boost/mpl/aux_/config/msvc.hpp>
+#   include <boost/mpl/aux_/config/workaround.hpp>
+
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+namespace boost { namespace mpl {
+
+// local macros, #undef-ined at the end of the header
+#   define AUX778076_APPLY_PARAMS(param) \
+    BOOST_MPL_PP_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        ) \
+    /**/
+
+#   define AUX778076_APPLY_DEF_PARAMS(param, value) \
+    BOOST_MPL_PP_DEFAULT_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        , value \
+        ) \
+    /**/
+
+#   define AUX778076_APPLY_N_PARAMS(n, param) \
+    BOOST_MPL_PP_PARAMS(n, param) \
+    /**/
+
+#   define AUX778076_APPLY_N_COMMA_PARAMS(n, param) \
+    BOOST_PP_COMMA_IF(n) \
+    BOOST_MPL_PP_PARAMS(n, param) \
+    /**/
+
+#   define AUX778076_APPLY_N_PARTIAL_SPEC_PARAMS(n, param, def) \
+    BOOST_PP_COMMA_IF(n) \
+    BOOST_MPL_PP_PARTIAL_SPEC_PARAMS(n, param, def) \
+    /**/
+
+#   define AUX778076_APPLY_N_SPEC_PARAMS(n, param) \
+    BOOST_MPL_PP_ENUM(BOOST_PP_INC(n), param) \
+    /**/
+
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/apply.hpp>))
+#include BOOST_PP_ITERATE()
+
+#   if !defined(BOOST_MPL_CFG_NO_APPLY_TEMPLATE)
+// real C++ version is already taken care of
+#   if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+namespace aux {
+// apply_count_args
+#define AUX778076_COUNT_ARGS_PREFIX apply
+#define AUX778076_COUNT_ARGS_DEFAULT na
+#define AUX778076_COUNT_ARGS_ARITY BOOST_MPL_LIMIT_METAFUNCTION_ARITY
+#include <boost/mpl/aux_/count_args.hpp>
+}
+
+
+template<
+      typename F, AUX778076_APPLY_DEF_PARAMS(typename T, na)
+    >
+struct apply
+    : aux::apply_chooser<
+          aux::apply_count_args< AUX778076_APPLY_PARAMS(T) >::value
+        >::template result_< F, AUX778076_APPLY_PARAMS(T) >::type
+{
+};
+
+#   endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   endif // BOOST_MPL_CFG_NO_APPLY_TEMPLATE
+
+#   undef AUX778076_APPLY_N_SPEC_PARAMS
+#   undef AUX778076_APPLY_N_PARTIAL_SPEC_PARAMS
+#   undef AUX778076_APPLY_N_COMMA_PARAMS
+#   undef AUX778076_APPLY_N_PARAMS
+#   undef AUX778076_APPLY_DEF_PARAMS
+#   undef AUX778076_APPLY_PARAMS
+
+}}
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_APPLY_HPP_INCLUDED
+
+///// iteration, depth == 1
+
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
+
+#   define i_ BOOST_PP_FRAME_ITERATION(1)
+
+template<
+      typename F AUX778076_APPLY_N_COMMA_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply,i_)
+#if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    : BOOST_PP_CAT(apply_wrap,i_)<
+          typename lambda<F>::type
+        AUX778076_APPLY_N_COMMA_PARAMS(i_, T)
+        >
+{
+#else
+{
+    typedef typename BOOST_PP_CAT(apply_wrap,i_)<
+          typename lambda<F>::type
+        AUX778076_APPLY_N_COMMA_PARAMS(i_, T)
+        >::type type;
+#endif
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(
+          BOOST_PP_INC(i_)
+        , BOOST_PP_CAT(apply,i_)
+        , (F AUX778076_APPLY_N_COMMA_PARAMS(i_,T))
+        )
+};
+
+
+#if defined(BOOST_MPL_CFG_MSVC_ETI_BUG)
+/// workaround for ETI bug
+template<>
+struct BOOST_PP_CAT(apply,i_)<AUX778076_APPLY_N_SPEC_PARAMS(i_, int)>
+{
+    typedef int type;
+};
+#endif
+
+#   if !defined(BOOST_MPL_CFG_NO_APPLY_TEMPLATE)
+#   if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+#if i_ == BOOST_MPL_LIMIT_METAFUNCTION_ARITY
+/// primary template (not a specialization!)
+template<
+      typename F AUX778076_APPLY_N_COMMA_PARAMS(i_, typename T)
+    >
+struct apply
+    : BOOST_PP_CAT(apply,i_)< F AUX778076_APPLY_N_COMMA_PARAMS(i_, T) >
+{
+};
+#else
+template<
+      typename F AUX778076_APPLY_N_COMMA_PARAMS(i_, typename T)
+    >
+struct apply< F AUX778076_APPLY_N_PARTIAL_SPEC_PARAMS(i_, T, na) >
+    : BOOST_PP_CAT(apply,i_)< F AUX778076_APPLY_N_COMMA_PARAMS(i_, T) >
+{
+};
+#endif
+
+#   else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#if !defined(BOOST_MPL_CFG_NO_APPLY_TEMPLATE)
+namespace aux {
+
+template<>
+struct apply_chooser<i_>
+{
+    template<
+          typename F, AUX778076_APPLY_PARAMS(typename T)
+        >
+    struct result_
+    {
+        typedef BOOST_PP_CAT(apply,i_)<
+              F AUX778076_APPLY_N_COMMA_PARAMS(i_, T)
+            > type;
+    };
+};
+
+} // namespace aux
+#endif
+
+#   endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   endif // BOOST_MPL_CFG_NO_APPLY_TEMPLATE
+
+#   undef i_
+
+#endif // BOOST_PP_ITERATION_DEPTH()
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/identity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/identity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/identity.hpp	(working copy)
@@ -0,0 +1,45 @@
+
+#ifndef BOOST_MPL_IDENTITY_HPP_INCLUDED
+#define BOOST_MPL_IDENTITY_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: identity.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+
+namespace boost { namespace mpl {
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T)
+    >
+struct identity
+{
+    typedef T type;
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1, identity, (T))
+};
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T)
+    >
+struct make_identity
+{
+    typedef identity<T> type;
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1, make_identity, (T))
+};
+
+BOOST_MPL_AUX_NA_SPEC_NO_ETI(1, identity)
+BOOST_MPL_AUX_NA_SPEC_NO_ETI(1, make_identity)
+
+}}
+
+#endif // BOOST_MPL_IDENTITY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bool_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bool_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/bool_fwd.hpp	(working copy)
@@ -0,0 +1,33 @@
+
+#ifndef BOOST_MPL_BOOL_FWD_HPP_INCLUDED
+#define BOOST_MPL_BOOL_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: bool_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/adl_barrier.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+template< bool C_ > struct bool_;
+
+// shorcuts
+typedef bool_<true> true_;
+typedef bool_<false> false_;
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+BOOST_MPL_AUX_ADL_BARRIER_DECL(bool_)
+BOOST_MPL_AUX_ADL_BARRIER_DECL(true_)
+BOOST_MPL_AUX_ADL_BARRIER_DECL(false_)
+
+#endif // BOOST_MPL_BOOL_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/always.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/always.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/always.hpp	(working copy)
@@ -0,0 +1,39 @@
+
+#ifndef BOOST_MPL_ALWAYS_HPP_INCLUDED
+#define BOOST_MPL_ALWAYS_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: always.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/preprocessor/def_params_tail.hpp>
+#include <boost/mpl/aux_/na.hpp>
+#include <boost/mpl/aux_/arity_spec.hpp>
+
+namespace boost { namespace mpl {
+
+template< typename Value > struct always
+{
+    template<
+          typename T
+        BOOST_MPL_PP_NESTED_DEF_PARAMS_TAIL(1, typename T, na)
+        >
+    struct apply
+    {
+        typedef Value type;
+    };
+};
+
+BOOST_MPL_AUX_ARITY_SPEC(1, always)
+
+}}
+
+#endif // BOOST_MPL_ALWAYS_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/not.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/not.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/not.hpp	(working copy)
@@ -0,0 +1,51 @@
+
+#ifndef BOOST_MPL_NOT_HPP_INCLUDED
+#define BOOST_MPL_NOT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: not.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/aux_/nttp_decl.hpp>
+#include <boost/mpl/aux_/nested_type_wknd.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+
+namespace boost { namespace mpl {
+
+namespace aux {
+
+template< BOOST_MPL_AUX_NTTP_DECL(long, C_) > // 'long' is intentional here
+struct not_impl
+    : bool_<!C_>
+{
+};
+
+} // namespace aux
+
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(T)
+    >
+struct not_
+    : aux::not_impl<
+          BOOST_MPL_AUX_NESTED_TYPE_WKND(T)::value
+        >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,not_,(T))
+};
+
+BOOST_MPL_AUX_NA_SPEC(1,not_)
+
+}}
+
+#endif // BOOST_MPL_NOT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/and.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/and.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/and.hpp	(working copy)
@@ -0,0 +1,60 @@
+
+#ifndef BOOST_MPL_AND_HPP_INCLUDED
+#define BOOST_MPL_AND_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: and.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   include <boost/mpl/bool.hpp>
+#   include <boost/mpl/aux_/nested_type_wknd.hpp>
+#   include <boost/mpl/aux_/na_spec.hpp>
+#   include <boost/mpl/aux_/lambda_support.hpp>
+
+// agurt, 19/may/04: workaround a conflict with <iso646.h> header's
+// 'or' and 'and' macros, see http://tinyurl.com/3et69; 'defined(and)'
+// has to be checked in a separate condition, otherwise GCC complains
+// about 'and' being an alternative token
+#if defined(_MSC_VER)
+#ifndef __GCCXML__
+#if defined(and)
+#   pragma push_macro("and")
+#   undef and
+#   define and(x)
+#endif
+#endif
+#endif
+
+#   define BOOST_MPL_PREPROCESSED_HEADER and.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#if defined(_MSC_VER)
+#ifndef __GCCXML__
+#if defined(and)
+#   pragma pop_macro("and")
+#endif
+#endif
+#endif
+
+#else
+
+#   define AUX778076_OP_NAME and_
+#   define AUX778076_OP_VALUE1 false
+#   define AUX778076_OP_VALUE2 true
+#   include <boost/mpl/aux_/logical_op.hpp>
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_AND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/eval_if.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/eval_if.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/eval_if.hpp	(working copy)
@@ -0,0 +1,71 @@
+
+#ifndef BOOST_MPL_EVAL_IF_HPP_INCLUDED
+#define BOOST_MPL_EVAL_IF_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: eval_if.hpp 61921 2010-05-11 21:33:24Z neilgroves $
+// $Date: 2010-05-11 17:33:24 -0400 (Tue, 11 May 2010) $
+// $Revision: 61921 $
+
+#include <boost/mpl/if.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+namespace boost { namespace mpl {
+
+template<
+      typename BOOST_MPL_AUX_NA_PARAM(C)
+    , typename BOOST_MPL_AUX_NA_PARAM(F1)
+    , typename BOOST_MPL_AUX_NA_PARAM(F2)
+    >
+struct eval_if
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300) \
+     || ( BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, >= 0x0300) \
+        && BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0304)) \
+        )
+{
+    typedef typename if_<C,F1,F2>::type f_;
+    typedef typename f_::type type;
+#else
+    : if_<C,F1,F2>::type
+{
+#endif
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(3,eval_if,(C,F1,F2))
+};
+
+// (almost) copy & paste in order to save one more
+// recursively nested template instantiation to user
+template<
+      bool C
+    , typename F1
+    , typename F2
+    >
+struct eval_if_c
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300) \
+     || ( BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, >= 0x0300) \
+        && BOOST_WORKAROUND(BOOST_MPL_CFG_GCC, BOOST_TESTED_AT(0x0304)) \
+        )
+{
+    typedef typename if_c<C,F1,F2>::type f_;
+    typedef typename f_::type type;
+#else
+    : if_c<C,F1,F2>::type
+{
+#endif
+};
+
+BOOST_MPL_AUX_NA_SPEC(3, eval_if)
+
+}}
+
+#endif // BOOST_MPL_EVAL_IF_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/integral_c_fwd.hpp	(working copy)
@@ -0,0 +1,32 @@
+
+#ifndef BOOST_MPL_INTEGRAL_C_FWD_HPP_INCLUDED
+#define BOOST_MPL_INTEGRAL_C_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2006
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: integral_c_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/workaround.hpp>
+#include <boost/mpl/aux_/adl_barrier.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+#if BOOST_WORKAROUND(__HP_aCC, <= 53800)
+// the type of non-type template arguments may not depend on template arguments
+template< typename T, long N > struct integral_c;
+#else
+template< typename T, T N > struct integral_c;
+#endif
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+BOOST_MPL_AUX_ADL_BARRIER_DECL(integral_c)
+
+#endif // BOOST_MPL_INTEGRAL_C_FWD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/arg.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/arg.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/arg.hpp	(working copy)
@@ -0,0 +1,131 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_ARG_HPP_INCLUDED
+#define BOOST_MPL_ARG_HPP_INCLUDED
+
+// Copyright Peter Dimov 2001-2002
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: arg.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/arg_fwd.hpp>
+#   include <boost/mpl/aux_/na.hpp>
+#   include <boost/mpl/aux_/na_assert.hpp>
+#   include <boost/mpl/aux_/arity_spec.hpp>
+#   include <boost/mpl/aux_/arg_typedef.hpp>
+#endif
+
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER arg.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/default_params.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/config/lambda.hpp>
+#   include <boost/mpl/aux_/config/dtp.hpp>
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_OPEN
+
+// local macro, #undef-ined at the end of the header
+#if !defined(BOOST_MPL_CFG_NO_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+#   define AUX778076_ARG_N_DEFAULT_PARAMS(param,value) \
+    BOOST_MPL_PP_DEFAULT_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        , value \
+        ) \
+    /**/
+#else
+#   define AUX778076_ARG_N_DEFAULT_PARAMS(param,value) \
+    BOOST_MPL_PP_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        ) \
+    /**/
+#endif
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/arg.hpp>))
+#include BOOST_PP_ITERATE()
+
+
+#   undef AUX778076_ARG_N_DEFAULT_PARAMS
+
+BOOST_MPL_AUX_NONTYPE_ARITY_SPEC(1,int,arg)
+
+BOOST_MPL_AUX_ADL_BARRIER_NAMESPACE_CLOSE
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_ARG_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+#if i_ > 0
+
+template<> struct arg<i_>
+{
+    BOOST_STATIC_CONSTANT(int, value = i_);
+    typedef arg<BOOST_PP_INC(i_)> next;
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          AUX778076_ARG_N_DEFAULT_PARAMS(typename U, na)
+        >
+    struct apply
+    {
+        typedef BOOST_PP_CAT(U,i_) type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+#else
+
+template<> struct arg<-1>
+{
+    BOOST_STATIC_CONSTANT(int, value = -1);
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, tag)
+    BOOST_MPL_AUX_ARG_TYPEDEF(na, type)
+
+    template<
+          AUX778076_ARG_N_DEFAULT_PARAMS(typename U, na)
+        >
+    struct apply
+    {
+        typedef U1 type;
+        BOOST_MPL_AUX_ASSERT_NOT_NA(type);
+    };
+};
+
+#endif // i_ > 0
+
+#undef i_
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply_wrap.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply_wrap.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply_wrap.hpp	(working copy)
@@ -0,0 +1,234 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_APPLY_WRAP_HPP_INCLUDED
+#define BOOST_MPL_APPLY_WRAP_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2008
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: apply_wrap.hpp 49272 2008-10-11 06:50:46Z agurtovoy $
+// $Date: 2008-10-11 02:50:46 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49272 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/aux_/arity.hpp>
+#   include <boost/mpl/aux_/has_apply.hpp>
+#   include <boost/mpl/aux_/na.hpp>
+#   include <boost/mpl/aux_/msvc_never_true.hpp>
+#endif
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER apply_wrap.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/enum.hpp>
+#   include <boost/mpl/aux_/preprocessor/add.hpp>
+#   include <boost/mpl/aux_/config/bcc.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/mpl/aux_/config/dtp.hpp>
+#   include <boost/mpl/aux_/config/eti.hpp>
+#   include <boost/mpl/aux_/config/msvc.hpp>
+#   include <boost/mpl/aux_/config/workaround.hpp>
+
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/logical/and.hpp>
+#   include <boost/preprocessor/inc.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+
+
+namespace boost { namespace mpl {
+
+// local macros, #undef-ined at the end of the header
+#   define AUX778076_APPLY_WRAP_PARAMS(n, param) \
+    BOOST_MPL_PP_PARAMS(n, param) \
+    /**/
+
+#   define AUX778076_APPLY_WRAP_SPEC_PARAMS(n, param) \
+    BOOST_MPL_PP_ENUM(BOOST_PP_INC(n), param) \
+    /**/
+
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/apply_wrap.hpp>))
+#include BOOST_PP_ITERATE()
+
+
+#   undef AUX778076_APPLY_WRAP_SPEC_PARAMS
+#   undef AUX778076_APPLY_WRAP_PARAMS
+
+}}
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_APPLY_WRAP_HPP_INCLUDED
+
+///// iteration, depth == 1
+
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
+
+#   define i_ BOOST_PP_FRAME_ITERATION(1)
+
+#   if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+// MSVC version
+
+#define AUX778076_MSVC_DTW_NAME BOOST_PP_CAT(msvc_apply,i_)
+#define AUX778076_MSVC_DTW_ORIGINAL_NAME apply
+#define AUX778076_MSVC_DTW_ARITY i_
+#include <boost/mpl/aux_/msvc_dtw.hpp>
+
+template<
+      typename F BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply_wrap,i_)
+{
+    // Metafunction forwarding confuses vc6
+    typedef typename BOOST_PP_CAT(msvc_apply,i_)<F>::template result_<
+          AUX778076_APPLY_WRAP_PARAMS(i_, T)
+        >::type type;
+};
+
+#   elif defined(BOOST_MPL_CFG_BROKEN_DEFAULT_PARAMETERS_IN_NESTED_TEMPLATES)
+// MWCW/Borland version
+
+template<
+      int N, typename F BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply_wrap_impl,i_);
+
+#define BOOST_PP_ITERATION_PARAMS_2 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY - i_, <boost/mpl/apply_wrap.hpp>))
+#include BOOST_PP_ITERATE()
+
+template<
+      typename F BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply_wrap,i_)
+    : BOOST_PP_CAT(apply_wrap_impl,i_)<
+          ::boost::mpl::aux::arity<F,i_>::value
+        , F
+        BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, T)
+        >::type
+{
+};
+
+#   else
+// ISO98 C++, with minor concession to vc7
+
+template<
+      typename F BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, typename T)
+#if i_ == 0
+    , typename has_apply_ = typename aux::has_apply<F>::type
+#endif
+    >
+struct BOOST_PP_CAT(apply_wrap,i_)
+// metafunction forwarding confuses MSVC 7.0
+#if !BOOST_WORKAROUND(BOOST_MSVC, == 1300)
+    : F::template apply< AUX778076_APPLY_WRAP_PARAMS(i_, T) >
+{
+#else
+{
+    typedef typename F::template apply<
+         AUX778076_APPLY_WRAP_PARAMS(i_, T)
+        >::type type;
+#endif
+};
+
+#if i_ == 0 && !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+template< typename F >
+struct BOOST_PP_CAT(apply_wrap,i_)<F,true_>
+    : F::apply
+{
+};
+#endif
+
+#   endif // workarounds
+
+#if defined(BOOST_MPL_CFG_MSVC_ETI_BUG)
+/// workaround for ETI bug
+template<>
+struct BOOST_PP_CAT(apply_wrap,i_)<AUX778076_APPLY_WRAP_SPEC_PARAMS(i_, int)>
+{
+    typedef int type;
+};
+#endif
+
+#   undef i_
+
+///// iteration, depth == 2
+
+#elif BOOST_PP_ITERATION_DEPTH() == 2
+
+#   define j_ BOOST_PP_FRAME_ITERATION(2)
+
+#if i_ == 0 && j_ == 0 \
+    && defined(BOOST_MPL_CFG_BCC590_WORKAROUNDS) \
+    && !defined(BOOST_MPL_CFG_NO_HAS_APPLY)
+
+template< typename F, bool F_has_apply >
+struct apply_wrap_impl0_bcb {
+    typedef typename F::template apply< na > type;
+};
+
+template< typename F >
+struct apply_wrap_impl0_bcb< F, true > {
+    typedef typename F::apply type;
+};
+
+template<
+      typename F BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply_wrap_impl,i_)<
+          BOOST_MPL_PP_ADD(i_, j_)
+        , F
+        BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, T)
+        >
+{
+    typedef apply_wrap_impl0_bcb< F, aux::has_apply< F >::value >::type type;
+};
+#else
+
+template<
+      typename F BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply_wrap_impl,i_)<
+          BOOST_MPL_PP_ADD(i_, j_)
+        , F
+        BOOST_PP_COMMA_IF(i_) AUX778076_APPLY_WRAP_PARAMS(i_, T)
+        >
+{
+    typedef typename F::template apply<
+          AUX778076_APPLY_WRAP_PARAMS(i_, T)
+#if i_ == 0 && j_ == 0
+/// since the defaults are "lost", we have to pass *something* even for nullary
+/// metafunction classes
+        na
+#else
+        BOOST_PP_COMMA_IF(BOOST_PP_AND(i_, j_)) BOOST_MPL_PP_ENUM(j_, na)
+#endif
+        > type;
+};
+
+#endif
+
+#   undef j_
+
+#endif // BOOST_PP_ITERATION_DEPTH()
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/next.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/next.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/next.hpp	(working copy)
@@ -0,0 +1,19 @@
+
+#ifndef BOOST_MPL_NEXT_HPP_INCLUDED
+#define BOOST_MPL_NEXT_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: next.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/next_prior.hpp>
+
+#endif // BOOST_MPL_NEXT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/lambda.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/lambda.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/lambda.hpp	(working copy)
@@ -0,0 +1,29 @@
+
+#ifndef BOOST_MPL_LAMBDA_HPP_INCLUDED
+#define BOOST_MPL_LAMBDA_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2001-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: lambda.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/lambda_fwd.hpp>
+#include <boost/mpl/bind.hpp>
+#include <boost/mpl/aux_/config/lambda.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT)
+#   include <boost/mpl/aux_/full_lambda.hpp>
+#else
+#   include <boost/mpl/aux_/lambda_no_ctps.hpp>
+#   include <boost/mpl/aux_/lambda_support.hpp>
+#   define BOOST_MPL_CFG_NO_IMPLICIT_METAFUNCTIONS
+#endif
+
+#endif // BOOST_MPL_LAMBDA_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/or.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/or.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/or.hpp	(working copy)
@@ -0,0 +1,61 @@
+
+#ifndef BOOST_MPL_OR_HPP_INCLUDED
+#define BOOST_MPL_OR_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: or.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   include <boost/mpl/bool.hpp>
+#   include <boost/mpl/aux_/nested_type_wknd.hpp>
+#   include <boost/mpl/aux_/na_spec.hpp>
+#   include <boost/mpl/aux_/lambda_support.hpp>
+#   include <boost/mpl/aux_/config/msvc.hpp>
+
+// agurt, 19/may/04: workaround a conflict with <iso646.h> header's
+// 'or' and 'and' macros, see http://tinyurl.com/3et69; 'defined(or)'
+// has to be checked in a separate condition, otherwise GCC complains
+// about 'or' being an alternative token
+#if defined(_MSC_VER)
+#ifndef __GCCXML__
+#if defined(or)
+#   pragma push_macro("or")
+#   undef or
+#   define or(x)
+#endif
+#endif
+#endif
+
+#   define BOOST_MPL_PREPROCESSED_HEADER or.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#if defined(_MSC_VER)
+#ifndef __GCCXML__
+#if defined(or)
+#   pragma pop_macro("or")
+#endif
+#endif
+#endif
+
+#else
+
+#   define AUX778076_OP_NAME or_
+#   define AUX778076_OP_VALUE1 true
+#   define AUX778076_OP_VALUE2 false
+#   include <boost/mpl/aux_/logical_op.hpp>
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_OR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/has_xxx.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/has_xxx.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/has_xxx.hpp	(working copy)
@@ -0,0 +1,640 @@
+
+#ifndef BOOST_MPL_HAS_XXX_HPP_INCLUDED
+#define BOOST_MPL_HAS_XXX_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2002-2006
+// Copyright David Abrahams 2002-2003
+// Copyright Daniel Walker 2007
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: has_xxx.hpp 64146 2010-07-19 00:46:31Z djwalker $
+// $Date: 2010-07-18 20:46:31 -0400 (Sun, 18 Jul 2010) $
+// $Revision: 64146 $
+
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/aux_/na_spec.hpp>
+#include <boost/mpl/aux_/type_wrapper.hpp>
+#include <boost/mpl/aux_/yes_no.hpp>
+#include <boost/mpl/aux_/config/gcc.hpp>
+#include <boost/mpl/aux_/config/has_xxx.hpp>
+#include <boost/mpl/aux_/config/msvc_typename.hpp>
+#include <boost/mpl/aux_/config/msvc.hpp>
+#include <boost/mpl/aux_/config/static_constant.hpp>
+#include <boost/mpl/aux_/config/workaround.hpp>
+
+#include <boost/preprocessor/array/elem.hpp>
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/control/if.hpp>
+#include <boost/preprocessor/repetition/enum_params.hpp>
+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>
+
+#if BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x590) )
+# include <boost/type_traits/is_class.hpp>
+#endif
+
+#if !defined(BOOST_MPL_CFG_NO_HAS_XXX)
+
+#   if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+
+// agurt, 11/sep/02: MSVC-specific version (< 7.1), based on a USENET
+// newsgroup's posting by John Madsen (comp.lang.c++.moderated,
+// 1999-11-12 19:17:06 GMT); the code is _not_ standard-conforming, but
+// it works way more reliably than the SFINAE-based implementation
+
+// Modified dwa 8/Oct/02 to handle reference types.
+
+#   include <boost/mpl/if.hpp>
+#   include <boost/mpl/bool.hpp>
+
+namespace boost { namespace mpl { namespace aux {
+
+struct has_xxx_tag;
+
+#if BOOST_WORKAROUND(BOOST_MSVC, == 1300)
+template< typename U > struct msvc_incomplete_array
+{
+    typedef char (&type)[sizeof(U) + 1];
+};
+#endif
+
+template< typename T >
+struct msvc_is_incomplete
+{
+    // MSVC is capable of some kinds of SFINAE.  If U is an incomplete
+    // type, it won't pick the second overload
+    static char tester(...);
+
+#if BOOST_WORKAROUND(BOOST_MSVC, == 1300)
+    template< typename U >
+    static typename msvc_incomplete_array<U>::type tester(type_wrapper<U>);
+#else
+    template< typename U >
+    static char (& tester(type_wrapper<U>) )[sizeof(U)+1];
+#endif
+
+    BOOST_STATIC_CONSTANT(bool, value =
+          sizeof(tester(type_wrapper<T>())) == 1
+        );
+};
+
+template<>
+struct msvc_is_incomplete<int>
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+}}}
+
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF_(trait, name, default_) \
+template< typename T, typename name = ::boost::mpl::aux::has_xxx_tag > \
+struct BOOST_PP_CAT(trait,_impl) : T \
+{ \
+    static boost::mpl::aux::no_tag \
+    test(void(*)(::boost::mpl::aux::has_xxx_tag)); \
+    \
+    static boost::mpl::aux::yes_tag test(...); \
+    \
+    BOOST_STATIC_CONSTANT(bool, value = \
+          sizeof(test(static_cast<void(*)(name)>(0))) \
+            != sizeof(boost::mpl::aux::no_tag) \
+        ); \
+    typedef boost::mpl::bool_<value> type; \
+}; \
+\
+template< typename T, typename fallback_ = boost::mpl::bool_<default_> > \
+struct trait \
+    : boost::mpl::if_c< \
+          boost::mpl::aux::msvc_is_incomplete<T>::value \
+        , boost::mpl::bool_<false> \
+        , BOOST_PP_CAT(trait,_impl)<T> \
+        >::type \
+{ \
+}; \
+\
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, void) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, bool) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, char) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, signed char) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, unsigned char) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, signed short) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, unsigned short) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, signed int) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, unsigned int) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, signed long) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, unsigned long) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, float) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, double) \
+BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, long double) \
+/**/
+
+#   define BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, T) \
+template<> struct trait<T> \
+{ \
+    BOOST_STATIC_CONSTANT(bool, value = false); \
+    typedef boost::mpl::bool_<false> type; \
+}; \
+/**/
+
+#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait, name, unused) \
+    BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF_(trait, name, unused) \
+    BOOST_MPL_AUX_HAS_XXX_TRAIT_SPEC(trait, wchar_t) \
+/**/
+#else
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait, name, unused) \
+    BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF_(trait, name, unused) \
+/**/
+#endif
+
+
+// SFINAE-based implementations below are derived from a USENET newsgroup's
+// posting by Rani Sharoni (comp.lang.c++.moderated, 2002-03-17 07:45:09 PST)
+
+#   elif BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1400)) \
+      || BOOST_WORKAROUND(__IBMCPP__, <= 700)
+
+// MSVC 7.1+ & VACPP
+
+// agurt, 15/jun/05: replace overload-based SFINAE implementation with SFINAE
+// applied to partial specialization to fix some apparently random failures
+// (thanks to Daniel Wallin for researching this!)
+
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait, name, default_) \
+template< typename T > \
+struct BOOST_PP_CAT(trait, _msvc_sfinae_helper) \
+{ \
+    typedef void type; \
+};\
+\
+template< typename T, typename U = void > \
+struct BOOST_PP_CAT(trait,_impl_) \
+{ \
+    BOOST_STATIC_CONSTANT(bool, value = false); \
+    typedef boost::mpl::bool_<value> type; \
+}; \
+\
+template< typename T > \
+struct BOOST_PP_CAT(trait,_impl_)< \
+      T \
+    , typename BOOST_PP_CAT(trait, _msvc_sfinae_helper)< typename T::name >::type \
+    > \
+{ \
+    BOOST_STATIC_CONSTANT(bool, value = true); \
+    typedef boost::mpl::bool_<value> type; \
+}; \
+\
+template< typename T, typename fallback_ = boost::mpl::bool_<default_> > \
+struct trait \
+    : BOOST_PP_CAT(trait,_impl_)<T> \
+{ \
+}; \
+/**/
+
+#   elif BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x590) )
+
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_BCB_DEF(trait, trait_tester, name, default_) \
+template< typename T, bool IS_CLASS > \
+struct trait_tester \
+{ \
+    BOOST_STATIC_CONSTANT( bool,  value = false ); \
+}; \
+template< typename T > \
+struct trait_tester< T, true > \
+{ \
+    struct trait_tester_impl \
+    { \
+        template < class U > \
+        static int  resolve( boost::mpl::aux::type_wrapper<U> const volatile * \
+                           , boost::mpl::aux::type_wrapper<typename U::name >* = 0 ); \
+        static char resolve( ... ); \
+    }; \
+    typedef boost::mpl::aux::type_wrapper<T> t_; \
+    BOOST_STATIC_CONSTANT( bool, value = ( sizeof( trait_tester_impl::resolve( static_cast< t_ * >(0) ) ) == sizeof(int) ) ); \
+}; \
+template< typename T, typename fallback_ = boost::mpl::bool_<default_> > \
+struct trait           \
+{                      \
+    BOOST_STATIC_CONSTANT( bool, value = (trait_tester< T, boost::is_class< T >::value >::value) );     \
+    typedef boost::mpl::bool_< trait< T, fallback_ >::value > type; \
+};
+
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait, name, default_) \
+    BOOST_MPL_HAS_XXX_TRAIT_NAMED_BCB_DEF( trait \
+                                         , BOOST_PP_CAT(trait,_tester)      \
+                                         , name       \
+                                         , default_ ) \
+/**/
+
+#   else // other SFINAE-capable compilers
+
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait, name, default_) \
+template< typename T, typename fallback_ = boost::mpl::bool_<default_> > \
+struct trait \
+{ \
+    struct gcc_3_2_wknd \
+    { \
+        template< typename U > \
+        static boost::mpl::aux::yes_tag test( \
+              boost::mpl::aux::type_wrapper<U> const volatile* \
+            , boost::mpl::aux::type_wrapper<BOOST_MSVC_TYPENAME U::name>* = 0 \
+            ); \
+    \
+        static boost::mpl::aux::no_tag test(...); \
+    }; \
+    \
+    typedef boost::mpl::aux::type_wrapper<T> t_; \
+    BOOST_STATIC_CONSTANT(bool, value = \
+          sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) \
+            == sizeof(boost::mpl::aux::yes_tag) \
+        ); \
+    typedef boost::mpl::bool_<value> type; \
+}; \
+/**/
+
+#   endif // BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+
+
+#else // BOOST_MPL_CFG_NO_HAS_XXX
+
+// placeholder implementation
+
+#   define BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(trait, name, default_) \
+template< typename T, typename fallback_ = boost::mpl::bool_<default_> > \
+struct trait \
+{ \
+    BOOST_STATIC_CONSTANT(bool, value = fallback_::value); \
+    typedef fallback_ type; \
+}; \
+/**/
+
+#endif
+
+#define BOOST_MPL_HAS_XXX_TRAIT_DEF(name) \
+    BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(BOOST_PP_CAT(has_,name), name, false) \
+/**/
+
+
+#if !defined(BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE)
+
+// Create a boolean Metafunction to detect a nested template
+// member. This implementation is based on a USENET newsgroup's
+// posting by Aleksey Gurtovoy (comp.lang.c++.moderated, 2002-03-19),
+// Rani Sharoni's USENET posting cited above, the non-template has_xxx
+// implementations above, and discussion on the Boost mailing list.
+
+#   if !defined(BOOST_MPL_HAS_XXX_NO_WRAPPED_TYPES)
+#     if BOOST_WORKAROUND(BOOST_MSVC, <= 1400)
+#       define BOOST_MPL_HAS_XXX_NO_WRAPPED_TYPES 1
+#     endif
+#   endif
+
+#   if !defined(BOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTION)
+#     if (defined(BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS))
+#       define BOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTION 1
+#     endif
+#   endif
+
+#   if !defined(BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAE)
+#     if BOOST_WORKAROUND(BOOST_MSVC, <= 1400)
+#       define BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAE 1
+#     endif
+#   endif
+
+// NOTE: Many internal implementation macros take a Boost.Preprocessor
+// array argument called args which is of the following form.
+//           ( 4, ( trait, name, max_arity, default_ ) )
+
+#   define BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args) \
+      BOOST_PP_CAT(BOOST_PP_ARRAY_ELEM(0, args) , _introspect) \
+    /**/
+
+#   define BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) \
+      BOOST_PP_CAT(BOOST_PP_CAT(BOOST_PP_ARRAY_ELEM(0, args) , _substitute), n) \
+    /**/
+
+#   define BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args) \
+      BOOST_PP_CAT(BOOST_PP_ARRAY_ELEM(0, args) , _test) \
+    /**/
+
+// Thanks to Guillaume Melquiond for pointing out the need for the
+// "substitute" template as an argument to the overloaded test
+// functions to get SFINAE to work for member templates with the
+// correct name but different number of arguments.
+#   define BOOST_MPL_HAS_MEMBER_MULTI_SUBSTITUTE(z, n, args) \
+      template< \
+          template< BOOST_PP_ENUM_PARAMS(BOOST_PP_INC(n), typename V) > class V \
+       > \
+      struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) { \
+      }; \
+    /**/
+
+#   define BOOST_MPL_HAS_MEMBER_SUBSTITUTE(args, substitute_macro) \
+      BOOST_PP_REPEAT( \
+          BOOST_PP_ARRAY_ELEM(2, args) \
+        , BOOST_MPL_HAS_MEMBER_MULTI_SUBSTITUTE \
+        , args \
+      ) \
+    /**/
+
+#   if !BOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTION
+#     define BOOST_MPL_HAS_MEMBER_REJECT(args, member_macro) \
+        template< typename V > \
+        static boost::mpl::aux::no_tag \
+        BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)(...); \
+      /**/
+#   else
+#     define BOOST_MPL_HAS_MEMBER_REJECT(args, member_macro) \
+        static boost::mpl::aux::no_tag \
+        BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)(...); \
+      /**/
+#   endif
+
+#   if !BOOST_MPL_HAS_XXX_NO_WRAPPED_TYPES
+#     define BOOST_MPL_HAS_MEMBER_MULTI_ACCEPT(z, n, args) \
+        template< typename V > \
+        static boost::mpl::aux::yes_tag \
+        BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)( \
+            boost::mpl::aux::type_wrapper< V > const volatile* \
+          , BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) < \
+                V::template BOOST_PP_ARRAY_ELEM(1, args) \
+            >* = 0 \
+        ); \
+      /**/
+#     define BOOST_MPL_HAS_MEMBER_ACCEPT(args, member_macro) \
+        BOOST_PP_REPEAT( \
+            BOOST_PP_ARRAY_ELEM(2, args) \
+          , BOOST_MPL_HAS_MEMBER_MULTI_ACCEPT \
+          , args \
+        ) \
+      /**/
+#   else
+#     define BOOST_MPL_HAS_MEMBER_ACCEPT(args, member_macro) \
+        template< typename V > \
+        static boost::mpl::aux::yes_tag \
+        BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)( \
+            V const volatile* \
+          , member_macro(args, V, T)* = 0 \
+        ); \
+      /**/
+#   endif
+
+#   if !BOOST_MPL_HAS_XXX_NO_EXPLICIT_TEST_FUNCTION
+#     define BOOST_MPL_HAS_MEMBER_TEST(args) \
+          sizeof(BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)< U >(0)) \
+              == sizeof(boost::mpl::aux::yes_tag) \
+      /**/
+#   else
+#     if !BOOST_MPL_HAS_XXX_NO_WRAPPED_TYPES
+#       define BOOST_MPL_HAS_MEMBER_TEST(args) \
+          sizeof( \
+              BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)( \
+                  static_cast< boost::mpl::aux::type_wrapper< U >* >(0) \
+              ) \
+          ) == sizeof(boost::mpl::aux::yes_tag) \
+        /**/
+#     else
+#       define BOOST_MPL_HAS_MEMBER_TEST(args) \
+          sizeof( \
+              BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)( \
+                  static_cast< U* >(0) \
+              ) \
+          ) == sizeof(boost::mpl::aux::yes_tag) \
+        /**/
+#     endif
+#   endif
+
+#   define BOOST_MPL_HAS_MEMBER_INTROSPECT( \
+               args, substitute_macro, member_macro \
+           ) \
+      template< typename U > \
+      struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args) { \
+          BOOST_MPL_HAS_MEMBER_SUBSTITUTE(args, substitute_macro) \
+          BOOST_MPL_HAS_MEMBER_REJECT(args, member_macro) \
+          BOOST_MPL_HAS_MEMBER_ACCEPT(args, member_macro) \
+          BOOST_STATIC_CONSTANT( \
+              bool, value = BOOST_MPL_HAS_MEMBER_TEST(args) \
+          ); \
+          typedef boost::mpl::bool_< value > type; \
+      }; \
+    /**/
+
+#   define BOOST_MPL_HAS_MEMBER_IMPLEMENTATION( \
+               args, introspect_macro, substitute_macro, member_macro \
+           ) \
+      template< \
+          typename T \
+        , typename fallback_ \
+              = boost::mpl::bool_< BOOST_PP_ARRAY_ELEM(3, args) > \
+      > \
+      class BOOST_PP_ARRAY_ELEM(0, args) { \
+          introspect_macro(args, substitute_macro, member_macro) \
+      public: \
+          static const bool value \
+              = BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args)< T >::value; \
+          typedef typename BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args)< \
+              T \
+          >::type type; \
+      }; \
+    /**/
+
+// BOOST_MPL_HAS_MEMBER_WITH_FUNCTION_SFINAE expands to the full
+// implementation of the function-based metafunction. Compile with -E
+// to see the preprocessor output for this macro.
+#   define BOOST_MPL_HAS_MEMBER_WITH_FUNCTION_SFINAE( \
+               args, substitute_macro, member_macro \
+           ) \
+      BOOST_MPL_HAS_MEMBER_IMPLEMENTATION( \
+          args \
+        , BOOST_MPL_HAS_MEMBER_INTROSPECT \
+        , substitute_macro \
+        , member_macro \
+      ) \
+    /**/
+
+#   if BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAE
+
+#     if !defined(BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE)
+#       if BOOST_WORKAROUND(BOOST_MSVC, <= 1400)
+#         define BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE 1
+#       endif
+#     endif
+
+#     if !BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE
+#       define BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME_WITH_TEMPLATE_SFINAE( \
+                   args, n \
+               ) \
+          BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) \
+        /**/
+#     else
+#       define BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME_WITH_TEMPLATE_SFINAE( \
+                   args, n \
+               ) \
+          BOOST_PP_CAT( \
+              boost_mpl_has_xxx_ \
+            , BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME(args, n) \
+          ) \
+        /**/
+#     endif
+
+#     define BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_TAG_NAME( \
+                 args \
+             ) \
+        BOOST_PP_CAT( \
+            BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME_WITH_TEMPLATE_SFINAE( \
+                args, 0 \
+            ) \
+          , _tag \
+        ) \
+      /**/
+
+#     define BOOST_MPL_HAS_MEMBER_MULTI_SUBSTITUTE_WITH_TEMPLATE_SFINAE( \
+                 z, n, args \
+             ) \
+        template< \
+             template< BOOST_PP_ENUM_PARAMS(BOOST_PP_INC(n), typename U) > class U \
+        > \
+        struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME_WITH_TEMPLATE_SFINAE( \
+                args, n \
+               ) { \
+            typedef \
+                BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_TAG_NAME(args) \
+                type; \
+        }; \
+      /**/
+
+#     define BOOST_MPL_HAS_MEMBER_SUBSTITUTE_WITH_TEMPLATE_SFINAE( \
+                 args, substitute_macro \
+             ) \
+        typedef void \
+            BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_TAG_NAME(args); \
+        BOOST_PP_REPEAT( \
+            BOOST_PP_ARRAY_ELEM(2, args) \
+          , BOOST_MPL_HAS_MEMBER_MULTI_SUBSTITUTE_WITH_TEMPLATE_SFINAE \
+          , args \
+        ) \
+      /**/
+
+#     define BOOST_MPL_HAS_MEMBER_REJECT_WITH_TEMPLATE_SFINAE( \
+                 args, member_macro \
+             ) \
+        template< \
+            typename U \
+          , typename V \
+                = BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_TAG_NAME(args) \
+        > \
+        struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args) { \
+            BOOST_STATIC_CONSTANT(bool, value = false); \
+            typedef boost::mpl::bool_< value > type; \
+        }; \
+      /**/
+
+#     define BOOST_MPL_HAS_MEMBER_MULTI_ACCEPT_WITH_TEMPLATE_SFINAE( \
+                 z, n, args \
+             ) \
+        template< typename U > \
+        struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)< \
+            U \
+          , typename \
+                BOOST_MPL_HAS_MEMBER_INTROSPECTION_SUBSTITUTE_NAME_WITH_TEMPLATE_SFINAE( \
+                    args, n \
+                )< \
+                    BOOST_MSVC_TYPENAME U::BOOST_PP_ARRAY_ELEM(1, args)< > \
+                >::type \
+        > { \
+            BOOST_STATIC_CONSTANT(bool, value = true); \
+            typedef boost::mpl::bool_< value > type; \
+        }; \
+      /**/
+
+#     define BOOST_MPL_HAS_MEMBER_ACCEPT_WITH_TEMPLATE_SFINAE( \
+                 args, member_macro \
+             ) \
+        BOOST_PP_REPEAT( \
+            BOOST_PP_ARRAY_ELEM(2, args) \
+          , BOOST_MPL_HAS_MEMBER_MULTI_ACCEPT_WITH_TEMPLATE_SFINAE \
+          , args \
+        ) \
+      /**/
+
+#     define BOOST_MPL_HAS_MEMBER_INTROSPECT_WITH_TEMPLATE_SFINAE( \
+                 args, substitute_macro, member_macro \
+             ) \
+        BOOST_MPL_HAS_MEMBER_REJECT_WITH_TEMPLATE_SFINAE(args, member_macro) \
+        BOOST_MPL_HAS_MEMBER_ACCEPT_WITH_TEMPLATE_SFINAE(args, member_macro) \
+        template< typename U > \
+        struct BOOST_MPL_HAS_MEMBER_INTROSPECTION_NAME(args) \
+            : BOOST_MPL_HAS_MEMBER_INTROSPECTION_TEST_NAME(args)< U > { \
+        }; \
+      /**/
+
+// BOOST_MPL_HAS_MEMBER_WITH_TEMPLATE_SFINAE expands to the full
+// implementation of the template-based metafunction. Compile with -E
+// to see the preprocessor output for this macro.
+//
+// Note that if BOOST_MPL_HAS_XXX_NEEDS_NAMESPACE_LEVEL_SUBSTITUTE is
+// defined BOOST_MPL_HAS_MEMBER_SUBSTITUTE_WITH_TEMPLATE_SFINAE needs
+// to be expanded at namespace level before
+// BOOST_MPL_HAS_MEMBER_WITH_TEMPLATE_SFINAE can be used.
+#     define BOOST_MPL_HAS_MEMBER_WITH_TEMPLATE_SFINAE( \
+                 args, substitute_macro, member_macro \
+             ) \
+        BOOST_MPL_HAS_MEMBER_SUBSTITUTE_WITH_TEMPLATE_SFINAE( \
+            args, substitute_macro \
+        ) \
+        BOOST_MPL_HAS_MEMBER_IMPLEMENTATION( \
+            args \
+          , BOOST_MPL_HAS_MEMBER_INTROSPECT_WITH_TEMPLATE_SFINAE \
+          , substitute_macro \
+          , member_macro \
+        ) \
+      /**/
+
+#   endif // BOOST_MPL_HAS_XXX_NEEDS_TEMPLATE_SFINAE
+
+// Note: In the current implementation the parameter and access macros
+// are no longer expanded.
+#   if !BOOST_WORKAROUND(BOOST_MSVC, <= 1400)
+#     define BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(trait, name, default_) \
+        BOOST_MPL_HAS_MEMBER_WITH_FUNCTION_SFINAE( \
+            ( 4, ( trait, name, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, default_ ) ) \
+          , BOOST_MPL_HAS_MEMBER_TEMPLATE_SUBSTITUTE_PARAMETER \
+          , BOOST_MPL_HAS_MEMBER_TEMPLATE_ACCESS \
+        ) \
+      /**/
+#   else
+#     define BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(trait, name, default_) \
+        BOOST_MPL_HAS_MEMBER_WITH_TEMPLATE_SFINAE( \
+            ( 4, ( trait, name, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, default_ ) ) \
+          , BOOST_MPL_HAS_MEMBER_TEMPLATE_SUBSTITUTE_PARAMETER \
+          , BOOST_MPL_HAS_MEMBER_TEMPLATE_ACCESS \
+        ) \
+      /**/
+#   endif
+
+#else // BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE
+
+// placeholder implementation
+
+#   define BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF(trait, name, default_) \
+      template< typename T \
+              , typename fallback_ = boost::mpl::bool_< default_ > > \
+      struct trait { \
+          BOOST_STATIC_CONSTANT(bool, value = fallback_::value); \
+          typedef fallback_ type; \
+      }; \
+    /**/
+
+#endif // BOOST_MPL_CFG_NO_HAS_XXX_TEMPLATE
+
+#   define BOOST_MPL_HAS_XXX_TEMPLATE_DEF(name) \
+      BOOST_MPL_HAS_XXX_TEMPLATE_NAMED_DEF( \
+          BOOST_PP_CAT(has_, name), name, false \
+      ) \
+    /**/
+
+#endif // BOOST_MPL_HAS_XXX_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/mpl/apply_fwd.hpp	(working copy)
@@ -0,0 +1,107 @@
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_MPL_APPLY_FWD_HPP_INCLUDED
+#define BOOST_MPL_APPLY_FWD_HPP_INCLUDED
+
+// Copyright Aleksey Gurtovoy 2000-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/mpl for documentation.
+
+// $Id: apply_fwd.hpp 49267 2008-10-11 06:19:02Z agurtovoy $
+// $Date: 2008-10-11 02:19:02 -0400 (Sat, 11 Oct 2008) $
+// $Revision: 49267 $
+
+#if !defined(BOOST_MPL_PREPROCESSING_MODE)
+#   include <boost/mpl/aux_/na.hpp>
+#endif
+
+#include <boost/mpl/aux_/config/use_preprocessed.hpp>
+
+#if !defined(BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS) \
+    && !defined(BOOST_MPL_PREPROCESSING_MODE)
+
+#   define BOOST_MPL_PREPROCESSED_HEADER apply_fwd.hpp
+#   include <boost/mpl/aux_/include_preprocessed.hpp>
+
+#else
+
+#   include <boost/mpl/limits/arity.hpp>
+#   include <boost/mpl/aux_/preprocessor/params.hpp>
+#   include <boost/mpl/aux_/preprocessor/default_params.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/mpl/aux_/nttp_decl.hpp>
+
+#   include <boost/preprocessor/comma_if.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/cat.hpp>
+
+// agurt, 15/jan/02: top-level 'apply' template gives an ICE on MSVC
+// (for known reasons)
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+#   define BOOST_MPL_CFG_NO_APPLY_TEMPLATE
+#endif
+
+namespace boost { namespace mpl {
+
+// local macro, #undef-ined at the end of the header
+#   define AUX778076_APPLY_DEF_PARAMS(param, value) \
+    BOOST_MPL_PP_DEFAULT_PARAMS( \
+          BOOST_MPL_LIMIT_METAFUNCTION_ARITY \
+        , param \
+        , value \
+        ) \
+    /**/
+
+#   define AUX778076_APPLY_N_COMMA_PARAMS(n, param) \
+    BOOST_PP_COMMA_IF(n) \
+    BOOST_MPL_PP_PARAMS(n, param) \
+    /**/
+
+#   if !defined(BOOST_MPL_CFG_NO_APPLY_TEMPLATE)
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+// forward declaration
+template<
+      typename F, AUX778076_APPLY_DEF_PARAMS(typename T, na)
+    >
+struct apply;
+#else
+namespace aux {
+template< BOOST_AUX_NTTP_DECL(int, arity_) > struct apply_chooser;
+}
+#endif
+
+#   endif // BOOST_MPL_CFG_NO_APPLY_TEMPLATE
+
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(0, BOOST_MPL_LIMIT_METAFUNCTION_ARITY, <boost/mpl/apply_fwd.hpp>))
+#include BOOST_PP_ITERATE()
+
+
+#   undef AUX778076_APPLY_N_COMMA_PARAMS
+#   undef AUX778076_APPLY_DEF_PARAMS
+
+}}
+
+#endif // BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
+#endif // BOOST_MPL_APPLY_FWD_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define i_ BOOST_PP_FRAME_ITERATION(1)
+
+template<
+      typename F AUX778076_APPLY_N_COMMA_PARAMS(i_, typename T)
+    >
+struct BOOST_PP_CAT(apply,i_);
+
+#undef i_
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/static_assert.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/static_assert.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/static_assert.hpp	(working copy)
@@ -0,0 +1,138 @@
+//  (C) Copyright John Maddock 2000.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/static_assert for documentation.
+
+/*
+ Revision history:
+   02 August 2000
+      Initial version.
+*/
+
+#ifndef BOOST_STATIC_ASSERT_HPP
+#define BOOST_STATIC_ASSERT_HPP
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#ifndef BOOST_NO_STATIC_ASSERT
+#  define BOOST_STATIC_ASSERT_MSG( B, Msg ) static_assert(B, Msg)
+#else
+#  define BOOST_STATIC_ASSERT_MSG( B, Msg ) BOOST_STATIC_ASSERT( B )
+#endif
+
+#ifdef __BORLANDC__
+//
+// workaround for buggy integral-constant expression support:
+#define BOOST_BUGGY_INTEGRAL_CONSTANT_EXPRESSIONS
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ == 3) && ((__GNUC_MINOR__ == 3) || (__GNUC_MINOR__ == 4))
+// gcc 3.3 and 3.4 don't produce good error messages with the default version:
+#  define BOOST_SA_GCC_WORKAROUND
+#endif
+
+//
+// If the compiler issues warnings about old C style casts,
+// then enable this:
+//
+#if defined(__GNUC__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4)))
+#  define BOOST_STATIC_ASSERT_BOOL_CAST( x ) ((x) == 0 ? false : true)
+#else
+#  define BOOST_STATIC_ASSERT_BOOL_CAST(x) (bool)(x)
+#endif
+
+#ifndef BOOST_NO_STATIC_ASSERT
+#  define BOOST_STATIC_ASSERT( B ) static_assert(B, #B)
+#else
+
+namespace boost{
+
+// HP aCC cannot deal with missing names for template value parameters
+template <bool x> struct STATIC_ASSERTION_FAILURE;
+
+template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };
+
+// HP aCC cannot deal with missing names for template value parameters
+template<int x> struct static_assert_test{};
+
+}
+
+//
+// Implicit instantiation requires that all member declarations be
+// instantiated, but that the definitions are *not* instantiated.
+//
+// It's not particularly clear how this applies to enum's or typedefs;
+// both are described as declarations [7.1.3] and [7.2] in the standard,
+// however some compilers use "delayed evaluation" of one or more of
+// these when implicitly instantiating templates.  We use typedef declarations
+// by default, but try defining BOOST_USE_ENUM_STATIC_ASSERT if the enum
+// version gets better results from your compiler...
+//
+// Implementation:
+// Both of these versions rely on sizeof(incomplete_type) generating an error
+// message containing the name of the incomplete type.  We use
+// "STATIC_ASSERTION_FAILURE" as the type name here to generate
+// an eye catching error message.  The result of the sizeof expression is either
+// used as an enum initialiser, or as a template argument depending which version
+// is in use...
+// Note that the argument to the assert is explicitly cast to bool using old-
+// style casts: too many compilers currently have problems with static_cast
+// when used inside integral constant expressions.
+//
+#if !defined(BOOST_BUGGY_INTEGRAL_CONSTANT_EXPRESSIONS)
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC < 1300)
+// __LINE__ macro broken when -ZI is used see Q199057
+// fortunately MSVC ignores duplicate typedef's.
+#define BOOST_STATIC_ASSERT( B ) \
+   typedef ::boost::static_assert_test<\
+      sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( B ) >)\
+      > boost_static_assert_typedef_
+#elif defined(BOOST_MSVC)
+#define BOOST_STATIC_ASSERT( B ) \
+   typedef ::boost::static_assert_test<\
+      sizeof(::boost::STATIC_ASSERTION_FAILURE< BOOST_STATIC_ASSERT_BOOL_CAST ( B ) >)>\
+         BOOST_JOIN(boost_static_assert_typedef_, __COUNTER__)
+#elif defined(BOOST_INTEL_CXX_VERSION) || defined(BOOST_SA_GCC_WORKAROUND)
+// agurt 15/sep/02: a special care is needed to force Intel C++ issue an error
+// instead of warning in case of failure
+# define BOOST_STATIC_ASSERT( B ) \
+    typedef char BOOST_JOIN(boost_static_assert_typedef_, __LINE__) \
+        [ ::boost::STATIC_ASSERTION_FAILURE< BOOST_STATIC_ASSERT_BOOL_CAST( B ) >::value ]
+#elif defined(__sgi)
+// special version for SGI MIPSpro compiler
+#define BOOST_STATIC_ASSERT( B ) \
+   BOOST_STATIC_CONSTANT(bool, \
+     BOOST_JOIN(boost_static_assert_test_, __LINE__) = ( B )); \
+   typedef ::boost::static_assert_test<\
+     sizeof(::boost::STATIC_ASSERTION_FAILURE< \
+       BOOST_JOIN(boost_static_assert_test_, __LINE__) >)>\
+         BOOST_JOIN(boost_static_assert_typedef_, __LINE__)
+#elif BOOST_WORKAROUND(__MWERKS__, <= 0x3003)
+// special version for CodeWarrior <= 8.x
+#define BOOST_STATIC_ASSERT( B ) \
+   BOOST_STATIC_CONSTANT(int, \
+     BOOST_JOIN(boost_static_assert_test_, __LINE__) = \
+       sizeof(::boost::STATIC_ASSERTION_FAILURE< BOOST_STATIC_ASSERT_BOOL_CAST( B ) >) )
+#else
+// generic version
+#define BOOST_STATIC_ASSERT( B ) \
+   typedef ::boost::static_assert_test<\
+      sizeof(::boost::STATIC_ASSERTION_FAILURE< BOOST_STATIC_ASSERT_BOOL_CAST( B ) >)>\
+         BOOST_JOIN(boost_static_assert_typedef_, __LINE__)
+#endif
+
+#else
+// alternative enum based implementation:
+#define BOOST_STATIC_ASSERT( B ) \
+   enum { BOOST_JOIN(boost_static_assert_enum_, __LINE__) \
+      = sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)( B ) >) }
+#endif
+#endif // defined(BOOST_NO_STATIC_ASSERT)
+
+#endif // BOOST_STATIC_ASSERT_HPP
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/ref.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/ref.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/ref.hpp	(working copy)
@@ -0,0 +1,189 @@
+#ifndef BOOST_REF_HPP_INCLUDED
+#define BOOST_REF_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+#include <boost/config.hpp>
+#include <boost/utility/addressof.hpp>
+#include <boost/mpl/bool.hpp>
+#include <boost/detail/workaround.hpp>
+
+//
+//  ref.hpp - ref/cref, useful helper functions
+//
+//  Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)
+//  Copyright (C) 2001, 2002 Peter Dimov
+//  Copyright (C) 2002 David Abrahams
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+//  See http://www.boost.org/libs/bind/ref.html for documentation.
+//
+
+namespace boost
+{
+
+template<class T> class reference_wrapper
+{
+public:
+    typedef T type;
+
+#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, < 1300 )
+
+    explicit reference_wrapper(T& t): t_(&t) {}
+
+#else
+
+    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}
+
+#endif
+
+    operator T& () const { return *t_; }
+
+    T& get() const { return *t_; }
+
+    T* get_pointer() const { return t_; }
+
+private:
+
+    T* t_;
+};
+
+# if defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x581) )
+#  define BOOST_REF_CONST
+# else
+#  define BOOST_REF_CONST const
+# endif
+
+template<class T> inline reference_wrapper<T> BOOST_REF_CONST ref(T & t)
+{
+    return reference_wrapper<T>(t);
+}
+
+template<class T> inline reference_wrapper<T const> BOOST_REF_CONST cref(T const & t)
+{
+    return reference_wrapper<T const>(t);
+}
+
+# undef BOOST_REF_CONST
+
+# ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+template<typename T>
+class is_reference_wrapper
+    : public mpl::false_
+{
+};
+
+template<typename T>
+class unwrap_reference
+{
+ public:
+    typedef T type;
+};
+
+#  define AUX_REFERENCE_WRAPPER_METAFUNCTIONS_DEF(X) \
+template<typename T> \
+class is_reference_wrapper< X > \
+    : public mpl::true_ \
+{ \
+}; \
+\
+template<typename T> \
+class unwrap_reference< X > \
+{ \
+ public: \
+    typedef T type; \
+}; \
+/**/
+
+AUX_REFERENCE_WRAPPER_METAFUNCTIONS_DEF(reference_wrapper<T>)
+#if !defined(BOOST_NO_CV_SPECIALIZATIONS)
+AUX_REFERENCE_WRAPPER_METAFUNCTIONS_DEF(reference_wrapper<T> const)
+AUX_REFERENCE_WRAPPER_METAFUNCTIONS_DEF(reference_wrapper<T> volatile)
+AUX_REFERENCE_WRAPPER_METAFUNCTIONS_DEF(reference_wrapper<T> const volatile)
+#endif
+
+#  undef AUX_REFERENCE_WRAPPER_METAFUNCTIONS_DEF
+
+# else // no partial specialization
+
+} // namespace boost
+
+#include <boost/type.hpp>
+
+namespace boost
+{
+
+namespace detail
+{
+  typedef char (&yes_reference_wrapper_t)[1];
+  typedef char (&no_reference_wrapper_t)[2];
+
+  no_reference_wrapper_t is_reference_wrapper_test(...);
+
+  template<typename T>
+  yes_reference_wrapper_t is_reference_wrapper_test(type< reference_wrapper<T> >);
+
+  template<bool wrapped>
+  struct reference_unwrapper
+  {
+      template <class T>
+      struct apply
+      {
+          typedef T type;
+      };
+  };
+
+  template<>
+  struct reference_unwrapper<true>
+  {
+      template <class T>
+      struct apply
+      {
+          typedef typename T::type type;
+      };
+  };
+}
+
+template<typename T>
+class is_reference_wrapper
+{
+ public:
+    BOOST_STATIC_CONSTANT(
+        bool, value = (
+             sizeof(detail::is_reference_wrapper_test(type<T>()))
+            == sizeof(detail::yes_reference_wrapper_t)));
+
+    typedef ::boost::mpl::bool_<value> type;
+};
+
+template <typename T>
+class unwrap_reference
+    : public detail::reference_unwrapper<
+        is_reference_wrapper<T>::value
+      >::template apply<T>
+{};
+
+# endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+template <class T> inline typename unwrap_reference<T>::type&
+unwrap_ref(T& t)
+{
+    return t;
+}
+
+template<class T> inline T* get_pointer( reference_wrapper<T> const & r )
+{
+    return r.get_pointer();
+}
+
+} // namespace boost
+
+#endif // #ifndef BOOST_REF_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/swap.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/swap.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/swap.hpp	(working copy)
@@ -0,0 +1,55 @@
+// Copyright (C) 2007, 2008 Steven Watanabe, Joseph Gauterin, Niels Dekker
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+// For more information, see http://www.boost.org
+
+
+#ifndef BOOST_UTILITY_SWAP_HPP
+#define BOOST_UTILITY_SWAP_HPP
+
+// Note: the implementation of this utility contains various workarounds:
+// - swap_impl is put outside the boost namespace, to avoid infinite
+// recursion (causing stack overflow) when swapping objects of a primitive
+// type.
+// - swap_impl has a using-directive, rather than a using-declaration,
+// because some compilers (including MSVC 7.1, Borland 5.9.3, and
+// Intel 8.1) don't do argument-dependent lookup when it has a
+// using-declaration instead.
+// - boost::swap has two template arguments, instead of one, to
+// avoid ambiguity when swapping objects of a Boost type that does
+// not have its own boost::swap overload.
+
+#include <algorithm> //for std::swap
+#include <cstddef> //for std::size_t
+
+namespace boost_swap_impl
+{
+  template<class T>
+  void swap_impl(T& left, T& right)
+  {
+    using namespace std;//use std::swap if argument dependent lookup fails
+    swap(left,right);
+  }
+
+  template<class T, std::size_t N>
+  void swap_impl(T (& left)[N], T (& right)[N])
+  {
+    for (std::size_t i = 0; i < N; ++i)
+    {
+      ::boost_swap_impl::swap_impl(left[i], right[i]);
+    }
+  }
+}
+
+namespace boost
+{
+  template<class T1, class T2>
+  void swap(T1& left, T2& right)
+  {
+    ::boost_swap_impl::swap_impl(left, right);
+  }
+}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/addressof.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/addressof.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/addressof.hpp	(working copy)
@@ -0,0 +1,102 @@
+// Copyright (C) 2002 Brad King (brad.king@kitware.com)
+//                    Douglas Gregor (gregod@cs.rpi.edu)
+//
+// Copyright (C) 2002, 2008 Peter Dimov
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// For more information, see http://www.boost.org
+
+#ifndef BOOST_UTILITY_ADDRESSOF_HPP
+# define BOOST_UTILITY_ADDRESSOF_HPP
+
+# include <boost/config.hpp>
+# include <boost/detail/workaround.hpp>
+
+namespace boost
+{
+
+namespace detail
+{
+
+template<class T> struct addr_impl_ref
+{
+    T & v_;
+
+    inline addr_impl_ref( T & v ): v_( v ) {}
+    inline operator T& () const { return v_; }
+
+private:
+    addr_impl_ref & operator=(const addr_impl_ref &);
+};
+
+template<class T> struct addressof_impl
+{
+    static inline T * f( T & v, long )
+    {
+        return reinterpret_cast<T*>(
+            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
+    }
+
+    static inline T * f( T * v, int )
+    {
+        return v;
+    }
+};
+
+} // namespace detail
+
+template<class T> T * addressof( T & v )
+{
+#if defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT( 0x610 ) )
+
+    return boost::detail::addressof_impl<T>::f( v, 0 );
+
+#else
+
+    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );
+
+#endif
+}
+
+#if defined( __SUNPRO_CC ) && BOOST_WORKAROUND( __SUNPRO_CC, BOOST_TESTED_AT( 0x590 ) )
+
+namespace detail
+{
+
+template<class T> struct addressof_addp
+{
+    typedef T * type;
+};
+
+} // namespace detail
+
+template< class T, std::size_t N >
+typename detail::addressof_addp< T[N] >::type addressof( T (&t)[N] )
+{
+    return &t;
+}
+
+#endif
+
+// Borland doesn't like casting an array reference to a char reference
+// but these overloads work around the problem.
+#if defined( __BORLANDC__ ) && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
+template<typename T,std::size_t N>
+T (*addressof(T (&t)[N]))[N]
+{
+   return reinterpret_cast<T(*)[N]>(&t);
+}
+
+template<typename T,std::size_t N>
+const T (*addressof(const T (&t)[N]))[N]
+{
+   return reinterpret_cast<const T(*)[N]>(&t);
+}
+#endif
+
+} // namespace boost
+
+#endif // BOOST_UTILITY_ADDRESSOF_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/detail/in_place_factory_prefix.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/detail/in_place_factory_prefix.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/detail/in_place_factory_prefix.hpp	(working copy)
@@ -0,0 +1,36 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+// Copyright (C) 2007, Tobias Schwinger.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_UTILITY_DETAIL_INPLACE_FACTORY_PREFIX_04APR2007_HPP
+#define BOOST_UTILITY_DETAIL_INPLACE_FACTORY_PREFIX_04APR2007_HPP
+
+#include <new>
+#include <cstddef>
+#include <boost/config.hpp>
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/punctuation/paren.hpp>
+#include <boost/preprocessor/iteration/iterate.hpp>
+#include <boost/preprocessor/repetition/repeat.hpp>
+#include <boost/preprocessor/repetition/enum.hpp>
+#include <boost/preprocessor/repetition/enum_params.hpp>
+#include <boost/preprocessor/repetition/enum_binary_params.hpp>
+#include <boost/preprocessor/repetition/enum_trailing_params.hpp>
+
+#define BOOST_DEFINE_INPLACE_FACTORY_CLASS_MEMBER_INIT(z,n,_) BOOST_PP_CAT(m_a,n) BOOST_PP_LPAREN() BOOST_PP_CAT(a,n) BOOST_PP_RPAREN()
+#define BOOST_DEFINE_INPLACE_FACTORY_CLASS_MEMBER_DECL(z,n,_) BOOST_PP_CAT(A,n) const& BOOST_PP_CAT(m_a,n);
+
+#define BOOST_MAX_INPLACE_FACTORY_ARITY 10
+
+#undef BOOST_UTILITY_DETAIL_INPLACE_FACTORY_SUFFIX_04APR2007_HPP
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/detail/in_place_factory_suffix.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/detail/in_place_factory_suffix.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/detail/in_place_factory_suffix.hpp	(working copy)
@@ -0,0 +1,23 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+// Copyright (C) 2007, Tobias Schwinger.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_UTILITY_DETAIL_INPLACE_FACTORY_SUFFIX_04APR2007_HPP
+#define BOOST_UTILITY_DETAIL_INPLACE_FACTORY_SUFFIX_04APR2007_HPP
+
+#undef BOOST_DEFINE_INPLACE_FACTORY_CLASS_MEMBER_INIT
+#undef BOOST_DEFINE_INPLACE_FACTORY_CLASS_MEMBER_DECL
+#undef BOOST_MAX_INPLACE_FACTORY_ARITY
+
+#undef BOOST_UTILITY_DETAIL_INPLACE_FACTORY_PREFIX_04APR2007_HPP
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/compare_pointees.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/compare_pointees.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/compare_pointees.hpp	(working copy)
@@ -0,0 +1,68 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_UTILITY_COMPARE_POINTEES_25AGO2003_HPP
+#define BOOST_UTILITY_COMPARE_POINTEES_25AGO2003_HPP
+
+#include<functional>
+
+namespace boost {
+
+// template<class OP> bool equal_pointees(OP const& x, OP const& y);
+// template<class OP> struct equal_pointees_t;
+//
+// Being OP a model of OptionalPointee (either a pointer or an optional):
+//
+// If both x and y have valid pointees, returns the result of (*x == *y)
+// If only one has a valid pointee, returns false.
+// If none have valid pointees, returns true.
+// No-throw
+template<class OptionalPointee>
+inline
+bool equal_pointees ( OptionalPointee const& x, OptionalPointee const& y )
+{
+  return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;
+}
+
+template<class OptionalPointee>
+struct equal_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
+{
+  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
+    { return equal_pointees(x,y) ; }
+} ;
+
+// template<class OP> bool less_pointees(OP const& x, OP const& y);
+// template<class OP> struct less_pointees_t;
+//
+// Being OP a model of OptionalPointee (either a pointer or an optional):
+//
+// If y has not a valid pointee, returns false.
+// ElseIf x has not a valid pointee, returns true.
+// ElseIf both x and y have valid pointees, returns the result of (*x < *y)
+// No-throw
+template<class OptionalPointee>
+inline
+bool less_pointees ( OptionalPointee const& x, OptionalPointee const& y )
+{
+  return !y ? false : ( !x ? true : (*x) < (*y) ) ;
+}
+
+template<class OptionalPointee>
+struct less_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
+{
+  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
+    { return less_pointees(x,y) ; }
+} ;
+
+} // namespace boost
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/in_place_factory.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/in_place_factory.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/utility/in_place_factory.hpp	(working copy)
@@ -0,0 +1,88 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+// Copyright (C) 2007, Tobias Schwinger.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_UTILITY_INPLACE_FACTORY_04APR2007_HPP
+#ifndef BOOST_PP_IS_ITERATING
+
+#include <boost/utility/detail/in_place_factory_prefix.hpp>
+
+namespace boost {
+
+class in_place_factory_base {} ;
+
+#define  BOOST_PP_ITERATION_LIMITS (0, BOOST_MAX_INPLACE_FACTORY_ARITY)
+#define  BOOST_PP_FILENAME_1 <boost/utility/in_place_factory.hpp>
+#include BOOST_PP_ITERATE()
+
+} // namespace boost
+
+#include <boost/utility/detail/in_place_factory_suffix.hpp>
+
+#define BOOST_UTILITY_INPLACE_FACTORY_04APR2007_HPP
+#else
+#define N BOOST_PP_ITERATION()
+
+#if N
+template< BOOST_PP_ENUM_PARAMS(N, class A) >
+#endif
+class BOOST_PP_CAT(in_place_factory,N)
+  :
+  public in_place_factory_base
+{
+public:
+
+  explicit BOOST_PP_CAT(in_place_factory,N)
+      ( BOOST_PP_ENUM_BINARY_PARAMS(N,A,const& a) )
+#if N > 0
+    : BOOST_PP_ENUM(N, BOOST_DEFINE_INPLACE_FACTORY_CLASS_MEMBER_INIT, _)
+#endif
+  {}
+
+  template<class T>
+  void* apply(void* address
+      BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(T)) const
+  {
+    return new(address) T( BOOST_PP_ENUM_PARAMS(N, m_a) );
+  }
+
+  template<class T>
+  void* apply(void* address, std::size_t n
+      BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(T)) const
+  {
+    for(char* next = address = this->BOOST_NESTED_TEMPLATE apply<T>(address);
+        !! --n;)
+      this->BOOST_NESTED_TEMPLATE apply<T>(next = next+sizeof(T));
+    return address;
+  }
+
+  BOOST_PP_REPEAT(N, BOOST_DEFINE_INPLACE_FACTORY_CLASS_MEMBER_DECL, _)
+};
+
+#if N > 0
+template< BOOST_PP_ENUM_PARAMS(N, class A) >
+inline BOOST_PP_CAT(in_place_factory,N)< BOOST_PP_ENUM_PARAMS(N, A) >
+in_place( BOOST_PP_ENUM_BINARY_PARAMS(N, A, const& a) )
+{
+  return BOOST_PP_CAT(in_place_factory,N)< BOOST_PP_ENUM_PARAMS(N, A) >
+      ( BOOST_PP_ENUM_PARAMS(N, a) );
+}
+#else
+inline in_place_factory0 in_place()
+{
+  return in_place_factory0();
+}
+#endif
+
+#undef N
+#endif
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_empty.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_empty.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_empty.hpp	(working copy)
@@ -0,0 +1,229 @@
+
+// (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_EMPTY_HPP_INCLUDED
+#define BOOST_TT_IS_EMPTY_HPP_INCLUDED
+
+#include <boost/type_traits/is_convertible.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/intrinsics.hpp>
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/type_traits/remove_cv.hpp>
+#   include <boost/type_traits/is_class.hpp>
+#   include <boost/type_traits/add_reference.hpp>
+#else
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_pointer.hpp>
+#   include <boost/type_traits/is_member_pointer.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/is_void.hpp>
+#   include <boost/type_traits/detail/ice_and.hpp>
+#   include <boost/type_traits/detail/ice_not.hpp>
+#endif
+
+// should be always the last #include directive
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+#ifndef BOOST_INTERNAL_IS_EMPTY
+#define BOOST_INTERNAL_IS_EMPTY(T) false
+#else
+#define BOOST_INTERNAL_IS_EMPTY(T) BOOST_IS_EMPTY(T)
+#endif
+
+namespace boost {
+
+namespace detail {
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#ifdef BOOST_MSVC
+#pragma warning(push)
+#pragma warning(disable:4624) // destructor could not be generated
+#endif
+
+template <typename T>
+struct empty_helper_t1 : public T
+{
+    empty_helper_t1();  // hh compiler bug workaround
+    int i[256];
+private:
+   // suppress compiler warnings:
+   empty_helper_t1(const empty_helper_t1&);
+   empty_helper_t1& operator=(const empty_helper_t1&);
+};
+
+#ifdef BOOST_MSVC
+#pragma warning(pop)
+#endif
+
+struct empty_helper_t2 { int i[256]; };
+
+#if !BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+
+template <typename T, bool is_a_class = false>
+struct empty_helper
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+template <typename T>
+struct empty_helper<T, true>
+{
+    BOOST_STATIC_CONSTANT(
+        bool, value = (sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2))
+        );
+};
+
+template <typename T>
+struct is_empty_impl
+{
+    typedef typename remove_cv<T>::type cvt;
+    BOOST_STATIC_CONSTANT(
+        bool, value = (
+            ::boost::type_traits::ice_or<
+              ::boost::detail::empty_helper<cvt,::boost::is_class<T>::value>::value
+              , BOOST_INTERNAL_IS_EMPTY(cvt)
+            >::value
+            ));
+};
+
+#else // __BORLANDC__
+
+template <typename T, bool is_a_class, bool convertible_to_int>
+struct empty_helper
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+template <typename T>
+struct empty_helper<T, true, false>
+{
+    BOOST_STATIC_CONSTANT(bool, value = (
+        sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2)
+        ));
+};
+
+template <typename T>
+struct is_empty_impl
+{
+   typedef typename remove_cv<T>::type cvt;
+   typedef typename add_reference<T>::type r_type;
+
+   BOOST_STATIC_CONSTANT(
+       bool, value = (
+           ::boost::type_traits::ice_or<
+              ::boost::detail::empty_helper<
+                  cvt
+                , ::boost::is_class<T>::value
+                , ::boost::is_convertible< r_type,int>::value
+              >::value
+              , BOOST_INTERNAL_IS_EMPTY(cvt)
+           >::value));
+};
+
+#endif // __BORLANDC__
+
+#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#ifdef BOOST_MSVC6_MEMBER_TEMPLATES
+
+template <typename T>
+struct empty_helper_t1 : public T
+{
+   empty_helper_t1();
+   int i[256];
+};
+
+struct empty_helper_t2 { int i[256]; };
+
+template <typename T>
+struct empty_helper_base
+{
+   enum { value = (sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2)) };
+};
+
+template <typename T>
+struct empty_helper_nonbase
+{
+   enum { value = false };
+};
+
+template <bool base>
+struct empty_helper_chooser
+{
+   template <typename T> struct result_
+   {
+      typedef empty_helper_nonbase<T> type;
+   };
+};
+
+template <>
+struct empty_helper_chooser<true>
+{
+   template <typename T> struct result_
+   {
+      typedef empty_helper_base<T> type;
+   };
+};
+
+template <typename T>
+struct is_empty_impl
+{
+   typedef ::boost::detail::empty_helper_chooser<
+      ::boost::type_traits::ice_and<
+         ::boost::type_traits::ice_not< ::boost::is_reference<T>::value >::value,
+         ::boost::type_traits::ice_not< ::boost::is_convertible<T,double>::value >::value,
+         ::boost::type_traits::ice_not< ::boost::is_pointer<T>::value >::value,
+         ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value,
+         ::boost::type_traits::ice_not< ::boost::is_array<T>::value >::value,
+         ::boost::type_traits::ice_not< ::boost::is_void<T>::value >::value,
+         ::boost::type_traits::ice_not<
+            ::boost::is_convertible<T,void const volatile*>::value
+            >::value
+      >::value > chooser;
+
+   typedef typename chooser::template result_<T> result;
+   typedef typename result::type eh_type;
+
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_or<eh_type::value, BOOST_INTERNAL_IS_EMPTY(T)>::value));
+};
+
+#else
+
+template <typename T> struct is_empty_impl
+{
+    BOOST_STATIC_CONSTANT(bool, value = BOOST_INTERNAL_IS_EMPTY(T));
+};
+
+#endif  // BOOST_MSVC6_MEMBER_TEMPLATES
+
+#endif  // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+// these help when the compiler has no partial specialization support:
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_empty,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_empty,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_empty,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_empty,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_empty,T,::boost::detail::is_empty_impl<T>::value)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#undef BOOST_INTERNAL_IS_EMPTY
+
+#endif // BOOST_TT_IS_EMPTY_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_abstract.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_abstract.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_abstract.hpp	(working copy)
@@ -0,0 +1,153 @@
+#ifndef BOOST_TT_IS_ABSTRACT_CLASS_HPP
+#define BOOST_TT_IS_ABSTRACT_CLASS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+/////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
+// is_abstract_class.hpp:
+//
+//  (C) Copyright 2002 Rani Sharoni (rani_sharoni@hotmail.com) and Robert Ramey
+//  Use, modification and distribution is subject to the Boost Software
+//  License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  See http://www.boost.org for updates, documentation, and revision history.
+//
+
+// Compile type discovery whether given type is abstract class or not.
+//
+//   Requires DR 337 to be supported by compiler
+//   (http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/cwg_active.html#337).
+//
+//
+// Believed (Jan 2004) to work on:
+//  - GCC 3.4
+//  - VC++ 7.1
+//  - compilers with new EDG frontend (Intel C++ 7, Comeau 4.3.2)
+//
+// Doesn't work on:
+//  - VC++6, VC++7.0 and less
+//  - GCC 3.3.X and less
+//  - Borland C++ 6 and less
+//
+//
+// History:
+//  - Originally written by Rani Sharoni, see
+//    http://groups.google.com/groups?selm=df893da6.0207110613.75b2fe90%40posting.google.com
+//    At this time supported by EDG (Intel C++ 7, Comeau 4.3.2) and VC7.1.
+//  - Adapted and added into Boost.Serialization library by Robert Ramey
+//    (starting with submission #10).
+//  - Jan 2004: GCC 3.4 fixed to suport DR337 (Giovanni Bajo).
+//  - Jan 2004: modified to be part of Boost.TypeTraits (Pavel Vozenilek).
+//  - Nov 2004: Christoph Ludwig found that the implementation did not work with
+//              template types and gcc-3.4 or VC7.1, fix due to Christoph Ludwig
+//              and John Maddock.
+//  - Dec 2004: Added new config macro BOOST_NO_IS_ABSTRACT which causes the template
+//              to degrade gracefully, rather than trash the compiler (John Maddock).
+//
+
+#include <boost/type_traits/intrinsics.hpp>
+#ifndef BOOST_IS_ABSTRACT
+#include <boost/static_assert.hpp>
+#include <boost/type_traits/detail/yes_no_type.hpp>
+#include <boost/type_traits/is_class.hpp>
+#include <boost/type_traits/detail/ice_and.hpp>
+#ifdef BOOST_NO_IS_ABSTRACT
+#include <boost/type_traits/is_polymorphic.hpp>
+#endif
+#endif
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+
+namespace boost {
+namespace detail{
+
+#ifdef BOOST_IS_ABSTRACT
+template <class T>
+struct is_abstract_imp
+{
+   BOOST_STATIC_CONSTANT(bool, value = BOOST_IS_ABSTRACT(T));
+};
+#elif !defined(BOOST_NO_IS_ABSTRACT)
+template<class T>
+struct is_abstract_imp2
+{
+   // Deduction fails if T is void, function type,
+   // reference type (14.8.2/2)or an abstract class type
+   // according to review status issue #337
+   //
+   template<class U>
+   static type_traits::no_type check_sig(U (*)[1]);
+   template<class U>
+   static type_traits::yes_type check_sig(...);
+   //
+   // T must be a complete type, further if T is a template then
+   // it must be instantiated in order for us to get the right answer:
+   //
+   BOOST_STATIC_ASSERT(sizeof(T) != 0);
+
+   // GCC2 won't even parse this template if we embed the computation
+   // of s1 in the computation of value.
+#ifdef __GNUC__
+   BOOST_STATIC_CONSTANT(std::size_t, s1 = sizeof(is_abstract_imp2<T>::template check_sig<T>(0)));
+#else
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(push)
+#pragma warning(disable:6334)
+#endif
+   BOOST_STATIC_CONSTANT(std::size_t, s1 = sizeof(check_sig<T>(0)));
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(pop)
+#endif
+#endif
+
+   BOOST_STATIC_CONSTANT(bool, value =
+      (s1 == sizeof(type_traits::yes_type)));
+};
+
+template <bool v>
+struct is_abstract_select
+{
+   template <class T>
+   struct rebind
+   {
+      typedef is_abstract_imp2<T> type;
+   };
+};
+template <>
+struct is_abstract_select<false>
+{
+   template <class T>
+   struct rebind
+   {
+      typedef false_type type;
+   };
+};
+
+template <class T>
+struct is_abstract_imp
+{
+   typedef is_abstract_select< ::boost::is_class<T>::value> selector;
+   typedef typename selector::template rebind<T> binder;
+   typedef typename binder::type type;
+
+   BOOST_STATIC_CONSTANT(bool, value = type::value);
+};
+
+#endif
+}
+
+#ifndef BOOST_NO_IS_ABSTRACT
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_abstract,T,::boost::detail::is_abstract_imp<T>::value)
+#else
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_abstract,T,::boost::detail::is_polymorphic_imp<T>::value)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif //BOOST_TT_IS_ABSTRACT_CLASS_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/ice.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/ice.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/ice.hpp	(working copy)
@@ -0,0 +1,20 @@
+
+//  (C) Copyright John Maddock and Steve Cleary 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+//
+//  macros and helpers for working with integral-constant-expressions.
+
+#ifndef BOOST_TT_ICE_HPP_INCLUDED
+#define BOOST_TT_ICE_HPP_INCLUDED
+
+#include <boost/type_traits/detail/yes_no_type.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+#include <boost/type_traits/detail/ice_and.hpp>
+#include <boost/type_traits/detail/ice_not.hpp>
+#include <boost/type_traits/detail/ice_eq.hpp>
+
+#endif // BOOST_TT_ICE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_integral.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_integral.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_integral.hpp	(working copy)
@@ -0,0 +1,78 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_INTEGRAL_HPP_INCLUDED
+#define BOOST_TT_IS_INTEGRAL_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)
+// as an extention we include long long, as this is likely to be added to the
+// standard at a later date
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_integral,T,__is_integral(T))
+#else
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_integral,T,false)
+
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned char,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned short,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned int,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned long,true)
+
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,signed char,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,signed short,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,signed int,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,signed long,true)
+
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,bool,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,char,true)
+
+#ifndef BOOST_NO_INTRINSIC_WCHAR_T
+// If the following line fails to compile and you're using the Intel
+// compiler, see http://lists.boost.org/MailArchives/boost-users/msg06567.php,
+// and define BOOST_NO_INTRINSIC_WCHAR_T on the command line.
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,wchar_t,true)
+#endif
+
+// Same set of integral types as in boost/type_traits/integral_promotion.hpp.
+// Please, keep in sync. -- Alexander Nasonov
+#if (defined(BOOST_MSVC) && (BOOST_MSVC < 1300)) \
+    || (defined(BOOST_INTEL_CXX_VERSION) && defined(_MSC_VER) && (BOOST_INTEL_CXX_VERSION <= 600)) \
+    || (defined(__BORLANDC__) && (__BORLANDC__ == 0x600) && (_MSC_VER < 1300))
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned __int8,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,__int8,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned __int16,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,__int16,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned __int32,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,__int32,true)
+#ifdef __BORLANDC__
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned __int64,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,__int64,true)
+#endif
+#endif
+
+# if defined(BOOST_HAS_LONG_LONG)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral, ::boost::ulong_long_type,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral, ::boost::long_long_type,true)
+#elif defined(BOOST_HAS_MS_INT64)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,unsigned __int64,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_integral,__int64,true)
+#endif
+
+#endif  // non-CodeGear implementation
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_INTEGRAL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_lvalue_reference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_lvalue_reference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_lvalue_reference.hpp	(working copy)
@@ -0,0 +1,118 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+//    Fixed is_pointer, is_lvalue_reference, is_const, is_volatile, is_same,
+//    is_member_pointer based on the Simulated Partial Specialization work
+//    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or
+//    http://groups.yahoo.com/group/boost/message/5441
+//    Some workarounds in here use ideas suggested from "Generic<Programming>:
+//    Mappings between Types and Values"
+//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).
+
+
+#ifndef BOOST_TT_IS_LVALUE_REFERENCE_HPP_INCLUDED
+#define BOOST_TT_IS_LVALUE_REFERENCE_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#   include <boost/type_traits/detail/wrap.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_lvalue_reference,T,__is_reference(T))
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_lvalue_reference,T,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T&,true)
+
+#if  defined(BOOST_ILLEGAL_CV_REFERENCES)
+// these are illegal specialisations; cv-qualifies applied to
+// references have no effect according to [8.3.2p1],
+// C++ Builder requires them though as it treats cv-qualified
+// references as distinct types...
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T& const,true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T& volatile,true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T& const volatile,true)
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ < 3)
+// these allow us to work around illegally cv-qualified reference
+// types.
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T const ,::boost::is_lvalue_reference<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T volatile ,::boost::is_lvalue_reference<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_lvalue_reference,T const volatile ,::boost::is_lvalue_reference<T>::value)
+// However, the above specializations confuse gcc 2.96 unless we also
+// supply these specializations for array types
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,unsigned long N,is_lvalue_reference,T[N],false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,unsigned long N,is_lvalue_reference,const T[N],false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,unsigned long N,is_lvalue_reference,volatile T[N],false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,unsigned long N,is_lvalue_reference,const volatile T[N],false)
+#endif
+
+#else
+
+#ifdef BOOST_MSVC
+#   pragma warning(push)
+#   pragma warning(disable: 4181 4097)
+#endif
+
+namespace detail {
+
+using ::boost::type_traits::yes_type;
+using ::boost::type_traits::no_type;
+using ::boost::type_traits::wrap;
+
+template <class T> T&(* is_lvalue_reference_helper1(wrap<T>) )(wrap<T>);
+char is_lvalue_reference_helper1(...);
+
+template <class T> no_type is_lvalue_reference_helper2(T&(*)(wrap<T>));
+yes_type is_lvalue_reference_helper2(...);
+
+template <typename T>
+struct is_lvalue_reference_impl
+{
+    BOOST_STATIC_CONSTANT(
+        bool, value = sizeof(
+            ::boost::detail::is_lvalue_reference_helper2(
+                ::boost::detail::is_lvalue_reference_helper1(::boost::type_traits::wrap<T>()))) == 1
+        );
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_lvalue_reference,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_lvalue_reference,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_lvalue_reference,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_lvalue_reference,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_lvalue_reference,T,::boost::detail::is_lvalue_reference_impl<T>::value)
+
+#ifdef BOOST_MSVC
+#   pragma warning(pop)
+#endif
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_REFERENCE_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_reference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_reference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_reference.hpp	(working copy)
@@ -0,0 +1,107 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_ADD_REFERENCE_HPP_INCLUDED
+#define BOOST_TT_ADD_REFERENCE_HPP_INCLUDED
+
+#include <boost/type_traits/is_reference.hpp>
+#include <boost/detail/workaround.hpp>
+#include <boost/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+template <bool x>
+struct reference_adder
+{
+    template <typename T> struct result_
+    {
+        typedef T& type;
+    };
+};
+
+template <>
+struct reference_adder<true>
+{
+    template <typename T> struct result_
+    {
+        typedef T type;
+    };
+};
+
+template <typename T>
+struct add_reference_impl
+{
+    typedef typename reference_adder<
+          ::boost::is_reference<T>::value
+        >::template result_<T> result;
+
+    typedef typename result::type type;
+};
+
+#else
+//
+// We can't filter out rvalue_references at the same level as
+// references or we get ambiguities from msvc:
+//
+
+template <typename T>
+struct add_reference_rvalue_layer
+{
+    typedef T& type;
+};
+
+#ifndef BOOST_NO_RVALUE_REFERENCES
+template <typename T>
+struct add_reference_rvalue_layer<T&&>
+{
+    typedef T&& type;
+};
+#endif
+
+template <typename T>
+struct add_reference_impl
+{
+    typedef typename add_reference_rvalue_layer<T>::type type;
+};
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+BOOST_TT_AUX_TYPE_TRAIT_IMPL_PARTIAL_SPEC1_1(typename T,add_reference,T&,T&)
+#endif
+
+#endif
+
+// these full specialisations are always required:
+BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1(add_reference,void,void)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1(add_reference,void const,void const)
+BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1(add_reference,void volatile,void volatile)
+BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1(add_reference,void const volatile,void const volatile)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(add_reference,T,typename boost::detail::add_reference_impl<T>::type)
+
+// agurt, 07/mar/03: workaround Borland's ill-formed sensitivity to an additional
+// level of indirection, here
+#if BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,add_reference,T&,T&)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_ADD_REFERENCE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_convertible.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_convertible.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_convertible.hpp	(working copy)
@@ -0,0 +1,431 @@
+
+// Copyright 2000 John Maddock (john@johnmaddock.co.uk)
+// Copyright 2000 Jeremy Siek (jsiek@lsc.nd.edu)
+// Copyright 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)
+//
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_CONVERTIBLE_HPP_INCLUDED
+#define BOOST_TT_IS_CONVERTIBLE_HPP_INCLUDED
+
+#include <boost/type_traits/intrinsics.hpp>
+#ifndef BOOST_IS_CONVERTIBLE
+#include <boost/type_traits/detail/yes_no_type.hpp>
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/is_array.hpp>
+#include <boost/type_traits/add_reference.hpp>
+#include <boost/type_traits/ice.hpp>
+#include <boost/type_traits/is_arithmetic.hpp>
+#include <boost/type_traits/is_void.hpp>
+#ifndef BOOST_NO_IS_ABSTRACT
+#include <boost/type_traits/is_abstract.hpp>
+#endif
+#include <boost/type_traits/add_rvalue_reference.hpp>
+
+#if defined(__MWERKS__)
+#include <boost/type_traits/is_function.hpp>
+#include <boost/type_traits/remove_reference.hpp>
+#endif
+
+#endif // BOOST_IS_CONVERTIBLE
+
+// should be always the last #include directive
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#ifndef BOOST_IS_CONVERTIBLE
+
+// is one type convertable to another?
+//
+// there are multiple versions of the is_convertible
+// template, almost every compiler seems to require its
+// own version.
+//
+// Thanks to Andrei Alexandrescu for the original version of the
+// conversion detection technique!
+//
+
+namespace detail {
+
+// MS specific version:
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+
+// This workaround is necessary to handle when From is void
+// which is normally taken care of by the partial specialization
+// of the is_convertible typename.
+using ::boost::type_traits::yes_type;
+using ::boost::type_traits::no_type;
+
+template< typename From >
+struct does_conversion_exist
+{
+    template< typename To > struct result_
+    {
+        static no_type BOOST_TT_DECL _m_check(...);
+        static yes_type BOOST_TT_DECL _m_check(To);
+        static typename add_rvalue_reference<From>::type  _m_from;
+        enum { value = sizeof( _m_check(_m_from) ) == sizeof(yes_type) };
+    };
+};
+
+template<>
+struct does_conversion_exist<void>
+{
+    template< typename To > struct result_
+    {
+        enum { value = ::boost::is_void<To>::value };
+    };
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl
+    : public does_conversion_exist<From>::template result_<To>
+{
+};
+
+#elif defined(__BORLANDC__) && (__BORLANDC__ < 0x560)
+//
+// special version for Borland compilers
+// this version breaks when used for some
+// UDT conversions:
+//
+template <typename From, typename To>
+struct is_convertible_impl
+{
+#pragma option push -w-8074
+    // This workaround for Borland breaks the EDG C++ frontend,
+    // so we only use it for Borland.
+    template <typename T> struct checker
+    {
+        static ::boost::type_traits::no_type BOOST_TT_DECL _m_check(...);
+        static ::boost::type_traits::yes_type BOOST_TT_DECL _m_check(T);
+    };
+
+    static typename add_rvalue_reference<From>::type  _m_from;
+    static bool const value = sizeof( checker<To>::_m_check(_m_from) )
+        == sizeof(::boost::type_traits::yes_type);
+#pragma option pop
+};
+
+#elif defined(__GNUC__) || defined(__BORLANDC__) && (__BORLANDC__ < 0x600)
+// special version for gcc compiler + recent Borland versions
+// note that this does not pass UDT's through (...)
+
+struct any_conversion
+{
+    template <typename T> any_conversion(const volatile T&);
+    template <typename T> any_conversion(T&);
+};
+
+template <typename T> struct checker
+{
+    static boost::type_traits::no_type _m_check(any_conversion ...);
+    static boost::type_traits::yes_type _m_check(T, int);
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl
+{
+    static typename add_rvalue_reference<From>::type  _m_from;
+    static bool const value = sizeof( boost::detail::checker<To>::_m_check(_m_from, 0) )
+        == sizeof(::boost::type_traits::yes_type);
+};
+
+#elif (defined(__EDG_VERSION__) && (__EDG_VERSION__ >= 245) && !defined(__ICL)) \
+      || defined(__IBMCPP__) || defined(__HP_aCC)
+//
+// This is *almost* an ideal world implementation as it doesn't rely
+// on undefined behaviour by passing UDT's through (...).
+// Unfortunately it doesn't quite pass all the tests for most compilers (sigh...)
+// Enable this for your compiler if is_convertible_test.cpp will compile it...
+//
+// Note we do not enable this for VC7.1, because even though it passes all the
+// type_traits tests it is known to cause problems when instantiation occurs
+// deep within the instantiation tree :-(
+//
+struct any_conversion
+{
+    template <typename T> any_conversion(const volatile T&);
+    // we need this constructor to catch references to functions
+    // (which can not be cv-qualified):
+    template <typename T> any_conversion(T&);
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl
+{
+    static ::boost::type_traits::no_type BOOST_TT_DECL _m_check(any_conversion ...);
+    static ::boost::type_traits::yes_type BOOST_TT_DECL _m_check(To, int);
+    static typename add_rvalue_reference<From>::type  _m_from;
+
+    BOOST_STATIC_CONSTANT(bool, value =
+        sizeof( _m_check(_m_from, 0) ) == sizeof(::boost::type_traits::yes_type)
+        );
+};
+
+#elif defined(__DMC__)
+
+struct any_conversion
+{
+    template <typename T> any_conversion(const volatile T&);
+    // we need this constructor to catch references to functions
+    // (which can not be cv-qualified):
+    template <typename T> any_conversion(T&);
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl
+{
+    // Using '...' doesn't always work on Digital Mars. This version seems to.
+    template <class T>
+    static ::boost::type_traits::no_type BOOST_TT_DECL _m_check(any_conversion,  float, T);
+    static ::boost::type_traits::yes_type BOOST_TT_DECL _m_check(To, int, int);
+    static typename add_rvalue_reference<From>::type  _m_from;
+
+    // Static constants sometime cause the conversion of _m_from to To to be
+    // called. This doesn't happen with an enum.
+    enum { value =
+        sizeof( _m_check(_m_from, 0, 0) ) == sizeof(::boost::type_traits::yes_type)
+        };
+};
+
+#elif defined(__MWERKS__)
+//
+// CW works with the technique implemented above for EDG, except when From
+// is a function type (or a reference to such a type), in which case
+// any_conversion won't be accepted as a valid conversion. We detect this
+// exceptional situation and channel it through an alternative algorithm.
+//
+
+template <typename From, typename To,bool FromIsFunctionRef>
+struct is_convertible_basic_impl_aux;
+
+struct any_conversion
+{
+    template <typename T> any_conversion(const volatile T&);
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl_aux<From,To,false /*FromIsFunctionRef*/>
+{
+    static ::boost::type_traits::no_type BOOST_TT_DECL _m_check(any_conversion ...);
+    static ::boost::type_traits::yes_type BOOST_TT_DECL _m_check(To, int);
+    static typename add_rvalue_reference<From>::type  _m_from;
+
+    BOOST_STATIC_CONSTANT(bool, value =
+        sizeof( _m_check(_m_from, 0) ) == sizeof(::boost::type_traits::yes_type)
+        );
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl_aux<From,To,true /*FromIsFunctionRef*/>
+{
+    static ::boost::type_traits::no_type BOOST_TT_DECL _m_check(...);
+    static ::boost::type_traits::yes_type BOOST_TT_DECL _m_check(To);
+    static typename add_rvalue_reference<From>::type  _m_from;
+    BOOST_STATIC_CONSTANT(bool, value =
+        sizeof( _m_check(_m_from) ) == sizeof(::boost::type_traits::yes_type)
+        );
+};
+
+template <typename From, typename To>
+struct is_convertible_basic_impl:
+  is_convertible_basic_impl_aux<
+    From,To,
+    ::boost::is_function<typename ::boost::remove_reference<From>::type>::value
+  >
+{};
+
+#else
+
+//
+// This version seems to work pretty well for a wide spectrum of compilers,
+// however it does rely on undefined behaviour by passing UDT's through (...).
+//
+template <typename From, typename To>
+struct is_convertible_basic_impl
+{
+    static ::boost::type_traits::no_type BOOST_TT_DECL _m_check(...);
+    static ::boost::type_traits::yes_type BOOST_TT_DECL _m_check(To);
+    static typename add_rvalue_reference<From>::type  _m_from;
+#ifdef BOOST_MSVC
+#pragma warning(push)
+#pragma warning(disable:4244)
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(disable:6334)
+#endif
+#endif
+    BOOST_STATIC_CONSTANT(bool, value =
+        sizeof( _m_check(_m_from) ) == sizeof(::boost::type_traits::yes_type)
+        );
+#ifdef BOOST_MSVC
+#pragma warning(pop)
+#endif
+};
+
+#endif // is_convertible_impl
+
+#if defined(__DMC__)
+// As before, a static constant sometimes causes errors on Digital Mars.
+template <typename From, typename To>
+struct is_convertible_impl
+{
+    typedef typename add_reference<From>::type ref_type;
+    enum { value =
+        (::boost::type_traits::ice_and<
+            ::boost::type_traits::ice_or<
+               ::boost::detail::is_convertible_basic_impl<ref_type,To>::value,
+               ::boost::is_void<To>::value
+            >::value,
+            ::boost::type_traits::ice_not<
+               ::boost::is_array<To>::value
+            >::value
+        >::value) };
+};
+#elif !defined(__BORLANDC__) || __BORLANDC__ > 0x551
+template <typename From, typename To>
+struct is_convertible_impl
+{
+    typedef typename add_reference<From>::type ref_type;
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::type_traits::ice_and<
+            ::boost::type_traits::ice_or<
+               ::boost::detail::is_convertible_basic_impl<ref_type,To>::value,
+               ::boost::is_void<To>::value
+            >::value,
+            ::boost::type_traits::ice_not<
+               ::boost::is_array<To>::value
+            >::value
+        >::value)
+        );
+};
+#endif
+
+template <bool trivial1, bool trivial2, bool abstract_target>
+struct is_convertible_impl_select
+{
+   template <class From, class To>
+   struct rebind
+   {
+      typedef is_convertible_impl<From, To> type;
+   };
+};
+
+template <>
+struct is_convertible_impl_select<true, true, false>
+{
+   template <class From, class To>
+   struct rebind
+   {
+      typedef true_type type;
+   };
+};
+
+template <>
+struct is_convertible_impl_select<false, false, true>
+{
+   template <class From, class To>
+   struct rebind
+   {
+      typedef false_type type;
+   };
+};
+
+template <>
+struct is_convertible_impl_select<true, false, true>
+{
+   template <class From, class To>
+   struct rebind
+   {
+      typedef false_type type;
+   };
+};
+
+template <typename From, typename To>
+struct is_convertible_impl_dispatch_base
+{
+#if !BOOST_WORKAROUND(__HP_aCC, < 60700)
+   typedef is_convertible_impl_select<
+      ::boost::is_arithmetic<From>::value,
+      ::boost::is_arithmetic<To>::value,
+#ifndef BOOST_NO_IS_ABSTRACT
+      ::boost::is_abstract<To>::value
+#else
+      false
+#endif
+   > selector;
+#else
+   typedef is_convertible_impl_select<false, false, false> selector;
+#endif
+   typedef typename selector::template rebind<From, To> isc_binder;
+   typedef typename isc_binder::type type;
+};
+
+template <typename From, typename To>
+struct is_convertible_impl_dispatch
+   : public is_convertible_impl_dispatch_base<From, To>::type
+{};
+
+//
+// Now add the full and partial specialisations
+// for void types, these are common to all the
+// implementation above:
+//
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+#   define TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2_PART1(trait,spec1,spec2,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2(trait,spec1,spec2,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2(trait,spec1,spec2 const,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2(trait,spec1,spec2 volatile,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2(trait,spec1,spec2 const volatile,value) \
+    /**/
+
+#   define TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2(trait,spec1,spec2,value) \
+    TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2_PART1(trait,spec1,spec2,value) \
+    TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2_PART1(trait,spec1 const,spec2,value) \
+    TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2_PART1(trait,spec1 volatile,spec2,value) \
+    TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2_PART1(trait,spec1 const volatile,spec2,value) \
+    /**/
+
+    TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2(is_convertible,void,void,true)
+
+#   undef TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2
+#   undef TT_AUX_BOOL_CV_VOID_TRAIT_SPEC2_PART1
+
+#else
+    BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2(is_convertible,void,void,true)
+#endif // BOOST_NO_CV_VOID_SPECIALIZATIONS
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename To,is_convertible,void,To,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename From,is_convertible,From,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename To,is_convertible,void const,To,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename To,is_convertible,void volatile,To,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename To,is_convertible,void const volatile,To,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename From,is_convertible,From,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename From,is_convertible,From,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(typename From,is_convertible,From,void const volatile,false)
+#endif
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF2(is_convertible,From,To,(::boost::detail::is_convertible_impl_dispatch<From,To>::value))
+
+#else
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF2(is_convertible,From,To,BOOST_IS_CONVERTIBLE(From,To))
+
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_CONVERTIBLE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_reference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_reference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_reference.hpp	(working copy)
@@ -0,0 +1,70 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_REMOVE_REFERENCE_HPP_INCLUDED
+#define BOOST_TT_REMOVE_REFERENCE_HPP_INCLUDED
+
+#include <boost/type_traits/broken_compiler_spec.hpp>
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#if BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+#include <boost/type_traits/msvc/remove_reference.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+namespace detail{
+//
+// We can't filter out rvalue_references at the same level as
+// references or we get ambiguities from msvc:
+//
+template <class T>
+struct remove_rvalue_ref
+{
+   typedef T type;
+};
+#ifndef BOOST_NO_RVALUE_REFERENCES
+template <class T>
+struct remove_rvalue_ref<T&&>
+{
+   typedef T type;
+};
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_reference,T,typename boost::detail::remove_rvalue_ref<T>::type)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_reference,T&,T)
+
+#if defined(BOOST_ILLEGAL_CV_REFERENCES)
+// these are illegal specialisations; cv-qualifies applied to
+// references have no effect according to [8.3.2p1],
+// C++ Builder requires them though as it treats cv-qualified
+// references as distinct types...
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_reference,T& const,T)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_reference,T& volatile,T)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_reference,T& const volatile,T)
+#endif
+
+#elif !BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_reference,T,typename boost::detail::remove_reference_impl<T>::type)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_REMOVE_REFERENCE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/conversion_traits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/conversion_traits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/conversion_traits.hpp	(working copy)
@@ -0,0 +1,17 @@
+
+// Copyright 2000 John Maddock (john@johnmaddock.co.uk)
+// Copyright 2000 Jeremy Siek (jsiek@lsc.nd.edu)
+// Copyright 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)
+//
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_CONVERSION_TRAITS_HPP_INCLUDED
+#define BOOST_TT_CONVERSION_TRAITS_HPP_INCLUDED
+
+#include <boost/type_traits/is_convertible.hpp>
+
+#endif // BOOST_TT_CONVERSION_TRAITS_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_const.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_const.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_const.hpp	(working copy)
@@ -0,0 +1,165 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+//    Fixed is_pointer, is_reference, is_const, is_volatile, is_same,
+//    is_member_pointer based on the Simulated Partial Specialization work
+//    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or
+//    http://groups.yahoo.com/group/boost/message/5441
+//    Some workarounds in here use ideas suggested from "Generic<Programming>:
+//    Mappings between Types and Values"
+//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).
+
+
+#ifndef BOOST_TT_IS_CONST_HPP_INCLUDED
+#define BOOST_TT_IS_CONST_HPP_INCLUDED
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/type_traits/detail/cv_traits_impl.hpp>
+#   ifdef __GNUC__
+#       include <boost/type_traits/is_reference.hpp>
+#   endif
+#   if BOOST_WORKAROUND(BOOST_MSVC, < 1400)
+#       include <boost/type_traits/remove_bounds.hpp>
+#   endif
+#else
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#   include <boost/type_traits/detail/false_result.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if defined( __CODEGEARC__ )
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_const,T,__is_const(T))
+
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+namespace detail{
+//
+// We can't filter out rvalue_references at the same level as
+// references or we get ambiguities from msvc:
+//
+template <class T>
+struct is_const_rvalue_filter
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1400)
+   BOOST_STATIC_CONSTANT(bool, value = ::boost::detail::cv_traits_imp<typename boost::remove_bounds<T>::type*>::is_const);
+#else
+   BOOST_STATIC_CONSTANT(bool, value = ::boost::detail::cv_traits_imp<T*>::is_const);
+#endif
+};
+#ifndef BOOST_NO_RVALUE_REFERENCES
+template <class T>
+struct is_const_rvalue_filter<T&&>
+{
+   BOOST_STATIC_CONSTANT(bool, value = false);
+};
+#endif
+}
+
+//* is a type T  declared const - is_const<T>
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_const,T,::boost::detail::is_const_rvalue_filter<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_const,T&,false)
+
+#if  defined(BOOST_ILLEGAL_CV_REFERENCES)
+// these are illegal specialisations; cv-qualifies applied to
+// references have no effect according to [8.3.2p1],
+// C++ Builder requires them though as it treats cv-qualified
+// references as distinct types...
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_const,T& const,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_const,T& volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_const,T& const volatile,false)
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ < 3)
+// special case for gcc where illegally cv-qualified reference types can be
+// generated in some corner cases:
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_const,T const,!(::boost::is_reference<T>::value))
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_const,T volatile const,!(::boost::is_reference<T>::value))
+#endif
+
+#else
+
+namespace detail {
+
+using ::boost::type_traits::yes_type;
+using ::boost::type_traits::no_type;
+
+yes_type is_const_tester(const volatile void*);
+no_type is_const_tester(volatile void *);
+
+template <bool is_ref, bool array>
+struct is_const_helper
+    : public ::boost::type_traits::false_result
+{
+};
+
+template <>
+struct is_const_helper<false,false>
+{
+    template <typename T> struct result_
+    {
+        static T* t;
+        BOOST_STATIC_CONSTANT(bool, value = (
+            sizeof(boost::detail::yes_type) == sizeof(boost::detail::is_const_tester(t))
+            ));
+    };
+};
+
+template <>
+struct is_const_helper<false,true>
+{
+    template <typename T> struct result_
+    {
+        static T t;
+        BOOST_STATIC_CONSTANT(bool, value = (
+            sizeof(boost::detail::yes_type) == sizeof(boost::detail::is_const_tester(&t))
+            ));
+    };
+};
+
+template <typename T>
+struct is_const_impl
+    : public is_const_helper<
+          is_reference<T>::value
+        , is_array<T>::value
+        >::template result_<T>
+{
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_const,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_const,void const,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_const,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_const,void const volatile,true)
+#endif
+
+} // namespace detail
+
+//* is a type T  declared const - is_const<T>
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_const,T,::boost::detail::is_const_impl<T>::value)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_CONST_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_pointer.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_pointer.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_pointer.hpp	(working copy)
@@ -0,0 +1,92 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_REMOVE_POINTER_HPP_INCLUDED
+#define BOOST_TT_REMOVE_POINTER_HPP_INCLUDED
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#include <boost/type_traits/broken_compiler_spec.hpp>
+#endif
+
+#if BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+#include <boost/type_traits/msvc/remove_pointer.hpp>
+#elif defined(BOOST_MSVC)
+#include <boost/type_traits/remove_cv.hpp>
+#include <boost/type_traits/is_pointer.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+#ifdef BOOST_MSVC
+
+namespace detail{
+
+   //
+   // We need all this crazy indirection because a type such as:
+   //
+   // T (*const)(U)
+   //
+   // Does not bind to a <T*> or <T*const> partial specialization with VC10 and earlier
+   //
+   template <class T>
+   struct remove_pointer_imp
+   {
+      typedef T type;
+   };
+
+   template <class T>
+   struct remove_pointer_imp<T*>
+   {
+      typedef T type;
+   };
+
+   template <class T, bool b>
+   struct remove_pointer_imp3
+   {
+      typedef typename remove_pointer_imp<typename boost::remove_cv<T>::type>::type type;
+   };
+
+   template <class T>
+   struct remove_pointer_imp3<T, false>
+   {
+      typedef T type;
+   };
+
+   template <class T>
+   struct remove_pointer_imp2
+   {
+      typedef typename remove_pointer_imp3<T, ::boost::is_pointer<T>::value>::type type;
+   };
+}
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_pointer,T,typename boost::detail::remove_pointer_imp2<T>::type)
+
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_pointer,T,T)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_pointer,T*,T)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_pointer,T* const,T)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_pointer,T* volatile,T)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_pointer,T* const volatile,T)
+
+#elif !BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_pointer,T,typename boost::detail::remove_pointer_impl<T>::type)
+
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_REMOVE_POINTER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_trivial_copy.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_trivial_copy.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_trivial_copy.hpp	(working copy)
@@ -0,0 +1,64 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_HAS_TRIVIAL_COPY_HPP_INCLUDED
+#define BOOST_TT_HAS_TRIVIAL_COPY_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/intrinsics.hpp>
+#include <boost/type_traits/is_volatile.hpp>
+#include <boost/type_traits/is_pod.hpp>
+#include <boost/type_traits/detail/ice_and.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+#include <boost/type_traits/detail/ice_not.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+template <typename T>
+struct has_trivial_copy_impl
+{
+#ifdef BOOST_HAS_TRIVIAL_COPY
+   BOOST_STATIC_CONSTANT(bool, value = BOOST_HAS_TRIVIAL_COPY(T));
+#else
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_and<
+         ::boost::is_pod<T>::value,
+         ::boost::type_traits::ice_not< ::boost::is_volatile<T>::value >::value
+      >::value));
+#endif
+};
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_trivial_copy,T,::boost::detail::has_trivial_copy_impl<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_trivial_copy_constructor,T,::boost::detail::has_trivial_copy_impl<T>::value)
+
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy,void const volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy,void volatile,false)
+#endif
+
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy_constructor,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy_constructor,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy_constructor,void const volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_trivial_copy_constructor,void volatile,false)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_HAS_TRIVIAL_COPY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_scalar.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_scalar.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_scalar.hpp	(working copy)
@@ -0,0 +1,55 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_SCALAR_HPP_INCLUDED
+#define BOOST_TT_IS_SCALAR_HPP_INCLUDED
+
+#include <boost/type_traits/is_arithmetic.hpp>
+#include <boost/type_traits/is_enum.hpp>
+#include <boost/type_traits/is_pointer.hpp>
+#include <boost/type_traits/is_member_pointer.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+#include <boost/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+template <typename T>
+struct is_scalar_impl
+{
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_or<
+         ::boost::is_arithmetic<T>::value,
+         ::boost::is_enum<T>::value,
+         ::boost::is_pointer<T>::value,
+         ::boost::is_member_pointer<T>::value
+      >::value));
+};
+
+// these specializations are only really needed for compilers
+// without partial specialization support:
+template <> struct is_scalar_impl<void>{ BOOST_STATIC_CONSTANT(bool, value = false ); };
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+template <> struct is_scalar_impl<void const>{ BOOST_STATIC_CONSTANT(bool, value = false ); };
+template <> struct is_scalar_impl<void volatile>{ BOOST_STATIC_CONSTANT(bool, value = false ); };
+template <> struct is_scalar_impl<void const volatile>{ BOOST_STATIC_CONSTANT(bool, value = false ); };
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_scalar,T,::boost::detail::is_scalar_impl<T>::value)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_SCALAR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_nothrow_constructor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_nothrow_constructor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_nothrow_constructor.hpp	(working copy)
@@ -0,0 +1,53 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_HAS_NOTHROW_CONSTRUCTOR_HPP_INCLUDED
+#define BOOST_TT_HAS_NOTHROW_CONSTRUCTOR_HPP_INCLUDED
+
+#include <boost/type_traits/has_trivial_constructor.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail{
+
+template <class T>
+struct has_nothrow_constructor_imp{
+#ifdef BOOST_HAS_NOTHROW_CONSTRUCTOR
+   BOOST_STATIC_CONSTANT(bool, value = BOOST_HAS_NOTHROW_CONSTRUCTOR(T));
+#else
+   BOOST_STATIC_CONSTANT(bool, value = ::boost::has_trivial_constructor<T>::value);
+#endif
+};
+
+}
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_nothrow_constructor,T,::boost::detail::has_nothrow_constructor_imp<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_nothrow_default_constructor,T,::boost::detail::has_nothrow_constructor_imp<T>::value)
+
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_constructor,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_constructor,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_constructor,void const volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_constructor,void volatile,false)
+#endif
+
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_default_constructor,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_default_constructor,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_default_constructor,void const volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_default_constructor,void volatile,false)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_HAS_NOTHROW_CONSTRUCTOR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_class.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_class.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_class.hpp	(working copy)
@@ -0,0 +1,140 @@
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000-2003.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_IS_CLASS_HPP_INCLUDED
+#define BOOST_TT_IS_CLASS_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/intrinsics.hpp>
+#ifndef BOOST_IS_CLASS
+#   include <boost/type_traits/is_union.hpp>
+#   include <boost/type_traits/detail/ice_and.hpp>
+#   include <boost/type_traits/detail/ice_not.hpp>
+
+#ifdef BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#else
+#   include <boost/type_traits/is_scalar.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_void.hpp>
+#   include <boost/type_traits/is_function.hpp>
+#endif
+
+#endif // BOOST_IS_CLASS
+
+#ifdef __EDG_VERSION__
+#   include <boost/type_traits/remove_cv.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+#ifndef BOOST_IS_CLASS
+#ifdef BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION
+
+// This is actually the conforming implementation which works with
+// abstract classes.  However, enough compilers have trouble with
+// it that most will use the one in
+// boost/type_traits/object_traits.hpp. This implementation
+// actually works with VC7.0, but other interactions seem to fail
+// when we use it.
+
+// is_class<> metafunction due to Paul Mensonides
+// (leavings@attbi.com). For more details:
+// http://groups.google.com/groups?hl=en&selm=000001c1cc83%24e154d5e0%247772e50c%40c161550a&rnum=1
+#if defined(__GNUC__)  && !defined(__EDG_VERSION__)
+
+template <class U> ::boost::type_traits::yes_type is_class_tester(void(U::*)(void));
+template <class U> ::boost::type_traits::no_type is_class_tester(...);
+
+template <typename T>
+struct is_class_impl
+{
+
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::type_traits::ice_and<
+            sizeof(is_class_tester<T>(0)) == sizeof(::boost::type_traits::yes_type),
+            ::boost::type_traits::ice_not< ::boost::is_union<T>::value >::value
+        >::value)
+        );
+};
+
+#else
+
+template <typename T>
+struct is_class_impl
+{
+    template <class U> static ::boost::type_traits::yes_type is_class_tester(void(U::*)(void));
+    template <class U> static ::boost::type_traits::no_type is_class_tester(...);
+
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::type_traits::ice_and<
+            sizeof(is_class_tester<T>(0)) == sizeof(::boost::type_traits::yes_type),
+            ::boost::type_traits::ice_not< ::boost::is_union<T>::value >::value
+        >::value)
+        );
+};
+
+#endif
+
+#else
+
+template <typename T>
+struct is_class_impl
+{
+#   ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+    BOOST_STATIC_CONSTANT(bool, value =
+    (::boost::type_traits::ice_and<
+        ::boost::type_traits::ice_not< ::boost::is_union<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_scalar<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_array<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_reference<T>::value>::value,
+        ::boost::type_traits::ice_not< ::boost::is_void<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_function<T>::value >::value
+        >::value));
+#   else
+    BOOST_STATIC_CONSTANT(bool, value =
+    (::boost::type_traits::ice_and<
+        ::boost::type_traits::ice_not< ::boost::is_union<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_scalar<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_array<T>::value >::value,
+        ::boost::type_traits::ice_not< ::boost::is_reference<T>::value>::value,
+        ::boost::type_traits::ice_not< ::boost::is_void<T>::value >::value
+        >::value));
+#   endif
+};
+
+# endif // BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION
+# else // BOOST_IS_CLASS
+template <typename T>
+struct is_class_impl
+{
+    BOOST_STATIC_CONSTANT(bool, value = BOOST_IS_CLASS(T));
+};
+# endif // BOOST_IS_CLASS
+
+} // namespace detail
+
+# ifdef __EDG_VERSION__
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(
+   is_class,T, boost::detail::is_class_impl<typename boost::remove_cv<T>::type>::value)
+# else
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_class,T,::boost::detail::is_class_impl<T>::value)
+# endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_CLASS_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_member_pointer.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_member_pointer.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_member_pointer.hpp	(working copy)
@@ -0,0 +1,116 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+//    Fixed is_pointer, is_reference, is_const, is_volatile, is_same,
+//    is_member_pointer based on the Simulated Partial Specialization work
+//    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or
+//    http://groups.yahoo.com/group/boost/message/5441
+//    Some workarounds in here use ideas suggested from "Generic<Programming>:
+//    Mappings between Types and Values"
+//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).
+
+
+#ifndef BOOST_TT_IS_MEMBER_POINTER_HPP_INCLUDED
+#define BOOST_TT_IS_MEMBER_POINTER_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+#   include <boost/type_traits/is_member_function_pointer.hpp>
+#else
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/detail/is_mem_fun_pointer_tester.hpp>
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#   include <boost/type_traits/detail/false_result.hpp>
+#   include <boost/type_traits/detail/ice_or.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_member_pointer,T,__is_member_pointer(T))
+#elif BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_member_pointer,T,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,typename U,is_member_pointer,U T::*,true)
+
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_member_pointer,T,::boost::is_member_function_pointer<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,typename U,is_member_pointer,U T::*,true)
+
+#if !BOOST_WORKAROUND(__MWERKS__,<=0x3003) && !BOOST_WORKAROUND(__IBMCPP__, <=600)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,typename U,is_member_pointer,U T::*const,true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,typename U,is_member_pointer,U T::*volatile,true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,typename U,is_member_pointer,U T::*const volatile,true)
+#endif
+
+#else // no partial template specialization
+
+namespace detail {
+
+template <typename R, typename T>
+::boost::type_traits::yes_type BOOST_TT_DECL is_member_pointer_tester(R T::*const volatile*);
+::boost::type_traits::no_type BOOST_TT_DECL is_member_pointer_tester(...);
+
+template <bool>
+struct is_member_pointer_select
+    : public ::boost::type_traits::false_result
+{
+};
+
+template <>
+struct is_member_pointer_select<false>
+{
+    template <typename T> struct result_
+    {
+        static T* make_t();
+        BOOST_STATIC_CONSTANT(
+            bool, value =
+            (::boost::type_traits::ice_or<
+                (1 == sizeof(::boost::type_traits::is_mem_fun_pointer_tester(make_t()))),
+                (1 == sizeof(is_member_pointer_tester(make_t())))
+            >::value) );
+    };
+};
+
+template <typename T>
+struct is_member_pointer_impl
+    : public is_member_pointer_select<
+          ::boost::type_traits::ice_or<
+              ::boost::is_reference<T>::value
+            , ::boost::is_array<T>::value
+            >::value
+        >::template result_<T>
+{
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_pointer,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_pointer,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_pointer,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_pointer,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_member_pointer,T,::boost::detail::is_member_pointer_impl<T>::value)
+
+#endif // __BORLANDC__
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_MEMBER_POINTER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_member_function_pointer.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_member_function_pointer.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_member_function_pointer.hpp	(working copy)
@@ -0,0 +1,136 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_IS_MEMBER_FUNCTION_POINTER_HPP_INCLUDED
+#define BOOST_TT_IS_MEMBER_FUNCTION_POINTER_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+   && !BOOST_WORKAROUND(__BORLANDC__, < 0x600) && !defined(BOOST_TT_TEST_MS_FUNC_SIGS)
+   //
+   // Note: we use the "workaround" version for MSVC because it works for
+   // __stdcall etc function types, where as the partial specialisation
+   // version does not do so.
+   //
+#   include <boost/type_traits/detail/is_mem_fun_pointer_impl.hpp>
+#   include <boost/type_traits/remove_cv.hpp>
+#else
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#   include <boost/type_traits/detail/false_result.hpp>
+#   include <boost/type_traits/detail/ice_or.hpp>
+#   include <boost/type_traits/detail/is_mem_fun_pointer_tester.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_member_function_pointer,T,__is_member_function_pointer( T ))
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !BOOST_WORKAROUND(__BORLANDC__, < 0x600) && !defined(BOOST_TT_TEST_MS_FUNC_SIGS)
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(
+      is_member_function_pointer
+    , T
+    , ::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value
+    )
+
+#else
+
+namespace detail {
+
+#ifndef __BORLANDC__
+
+template <bool>
+struct is_mem_fun_pointer_select
+    : public ::boost::type_traits::false_result
+{
+};
+
+template <>
+struct is_mem_fun_pointer_select<false>
+{
+    template <typename T> struct result_
+    {
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(push)
+#pragma warning(disable:6334)
+#endif
+        static T* make_t;
+        typedef result_<T> self_type;
+
+        BOOST_STATIC_CONSTANT(
+            bool, value = (
+                1 == sizeof(::boost::type_traits::is_mem_fun_pointer_tester(self_type::make_t))
+            ));
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(pop)
+#endif
+    };
+};
+
+template <typename T>
+struct is_member_function_pointer_impl
+    : public is_mem_fun_pointer_select<
+          ::boost::type_traits::ice_or<
+              ::boost::is_reference<T>::value
+            , ::boost::is_array<T>::value
+            >::value
+        >::template result_<T>
+{
+};
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+template <typename T>
+struct is_member_function_pointer_impl<T&> : public false_type{};
+#endif
+
+#else // Borland C++
+
+template <typename T>
+struct is_member_function_pointer_impl
+{
+   static T* m_t;
+   BOOST_STATIC_CONSTANT(
+              bool, value =
+               (1 == sizeof(type_traits::is_mem_fun_pointer_tester(m_t))) );
+};
+
+template <typename T>
+struct is_member_function_pointer_impl<T&>
+{
+   BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+#endif
+
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_function_pointer,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_function_pointer,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_function_pointer,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_member_function_pointer,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_member_function_pointer,T,::boost::detail::is_member_function_pointer_impl<T>::value)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_MEMBER_FUNCTION_POINTER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/type_with_alignment.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/type_with_alignment.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/type_with_alignment.hpp	(working copy)
@@ -0,0 +1,393 @@
+//  (C) Copyright John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_TYPE_WITH_ALIGNMENT_INCLUDED
+#define BOOST_TT_TYPE_WITH_ALIGNMENT_INCLUDED
+
+#include <boost/mpl/if.hpp>
+#include <boost/preprocessor/list/for_each_i.hpp>
+#include <boost/preprocessor/tuple/to_list.hpp>
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/list/transform.hpp>
+#include <boost/preprocessor/list/append.hpp>
+#include <boost/type_traits/alignment_of.hpp>
+#include <boost/type_traits/is_pod.hpp>
+#include <boost/static_assert.hpp>
+#include <boost/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+#include <cstddef>
+
+#ifdef BOOST_MSVC
+#   pragma warning(push)
+#   pragma warning(disable: 4121) // alignment is sensitive to packing
+#endif
+
+namespace boost {
+
+#ifndef __BORLANDC__
+
+namespace detail {
+
+class alignment_dummy;
+typedef void (*function_ptr)();
+typedef int (alignment_dummy::*member_ptr);
+typedef int (alignment_dummy::*member_function_ptr)();
+
+#ifdef BOOST_HAS_LONG_LONG
+#define BOOST_TT_ALIGNMENT_BASE_TYPES BOOST_PP_TUPLE_TO_LIST( \
+        12, ( \
+        char, short, int, long,  ::boost::long_long_type, float, double, long double \
+        , void*, function_ptr, member_ptr, member_function_ptr))
+#else
+#define BOOST_TT_ALIGNMENT_BASE_TYPES BOOST_PP_TUPLE_TO_LIST( \
+        11, ( \
+        char, short, int, long, float, double, long double \
+        , void*, function_ptr, member_ptr, member_function_ptr))
+#endif
+
+#define BOOST_TT_HAS_ONE_T(D,Data,T) boost::detail::has_one_T< T >
+
+#define BOOST_TT_ALIGNMENT_STRUCT_TYPES                         \
+        BOOST_PP_LIST_TRANSFORM(BOOST_TT_HAS_ONE_T,             \
+                                X,                              \
+                                BOOST_TT_ALIGNMENT_BASE_TYPES)
+
+#define BOOST_TT_ALIGNMENT_TYPES                                \
+        BOOST_PP_LIST_APPEND(BOOST_TT_ALIGNMENT_BASE_TYPES,     \
+                             BOOST_TT_ALIGNMENT_STRUCT_TYPES)
+
+//
+// lower_alignment_helper --
+//
+// This template gets instantiated a lot, so use partial
+// specialization when available to reduce the compiler burden.
+//
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+template <bool found = true>
+struct lower_alignment_helper_impl
+{
+    template <std::size_t, class>
+    struct apply
+    {
+        typedef char type;
+        enum { value = true };
+    };
+};
+
+template <>
+struct lower_alignment_helper_impl<false>
+{
+    template <std::size_t target, class TestType>
+    struct apply
+      : public mpl::if_c<(alignment_of<TestType>::value == target), TestType, char>
+    {
+        enum { value = (alignment_of<TestType>::value == target) };
+    };
+};
+
+template <bool found, std::size_t target, class TestType>
+struct lower_alignment_helper
+  : public lower_alignment_helper_impl<found>::template apply<target,TestType>
+{
+};
+#else
+template <bool found, std::size_t target, class TestType>
+struct lower_alignment_helper
+{
+    typedef char type;
+    enum { value = true };
+};
+
+template <std::size_t target, class TestType>
+struct lower_alignment_helper<false,target,TestType>
+{
+    enum { value = (alignment_of<TestType>::value == target) };
+    typedef typename mpl::if_c<value, TestType, char>::type type;
+};
+#endif
+
+#define BOOST_TT_CHOOSE_MIN_ALIGNMENT(R,P,I,T)                                  \
+        typename lower_alignment_helper<                                        \
+          BOOST_PP_CAT(found,I),target,T                                        \
+        >::type BOOST_PP_CAT(t,I);                                              \
+        enum {                                                                  \
+            BOOST_PP_CAT(found,BOOST_PP_INC(I))                                 \
+              = lower_alignment_helper<BOOST_PP_CAT(found,I),target,T >::value  \
+        };
+
+#define BOOST_TT_CHOOSE_T(R,P,I,T) T BOOST_PP_CAT(t,I);
+
+template <typename T>
+struct has_one_T
+{
+  T data;
+};
+
+template <std::size_t target>
+union lower_alignment
+{
+    enum { found0 = false };
+
+    BOOST_PP_LIST_FOR_EACH_I(
+          BOOST_TT_CHOOSE_MIN_ALIGNMENT
+        , ignored
+        , BOOST_TT_ALIGNMENT_TYPES
+        )
+};
+
+union max_align
+{
+    BOOST_PP_LIST_FOR_EACH_I(
+          BOOST_TT_CHOOSE_T
+        , ignored
+        , BOOST_TT_ALIGNMENT_TYPES
+        )
+};
+
+#undef BOOST_TT_ALIGNMENT_BASE_TYPES
+#undef BOOST_TT_HAS_ONE_T
+#undef BOOST_TT_ALIGNMENT_STRUCT_TYPES
+#undef BOOST_TT_ALIGNMENT_TYPES
+#undef BOOST_TT_CHOOSE_MIN_ALIGNMENT
+#undef BOOST_TT_CHOOSE_T
+
+template<std::size_t TAlign, std::size_t Align>
+struct is_aligned
+{
+    BOOST_STATIC_CONSTANT(bool,
+        value = (TAlign >= Align) & (TAlign % Align == 0)
+        );
+};
+
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::max_align,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<1> ,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<2> ,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<4> ,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<8> ,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<10> ,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<16> ,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::detail::lower_alignment<32> ,true)
+#endif
+
+} // namespace detail
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+template<std::size_t Align>
+struct is_pod< ::boost::detail::lower_alignment<Align> >
+{
+        BOOST_STATIC_CONSTANT(std::size_t, value = true);
+};
+#endif
+
+// This alignment method originally due to Brian Parker, implemented by David
+// Abrahams, and then ported here by Doug Gregor.
+namespace detail{
+
+template <std::size_t Align>
+class type_with_alignment_imp
+{
+    typedef ::boost::detail::lower_alignment<Align> t1;
+    typedef typename mpl::if_c<
+          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
+        , t1
+        , ::boost::detail::max_align
+        >::type align_t;
+
+    BOOST_STATIC_CONSTANT(std::size_t, found = alignment_of<align_t>::value);
+
+    BOOST_STATIC_ASSERT(found >= Align);
+    BOOST_STATIC_ASSERT(found % Align == 0);
+
+ public:
+    typedef align_t type;
+};
+
+}
+
+template <std::size_t Align>
+class type_with_alignment
+  : public ::boost::detail::type_with_alignment_imp<Align>
+{
+};
+
+#if defined(__GNUC__)
+namespace align {
+struct __attribute__((__aligned__(2))) a2 {};
+struct __attribute__((__aligned__(4))) a4 {};
+struct __attribute__((__aligned__(8))) a8 {};
+struct __attribute__((__aligned__(16))) a16 {};
+struct __attribute__((__aligned__(32))) a32 {};
+}
+
+template<> class type_with_alignment<1>  { public: typedef char type; };
+template<> class type_with_alignment<2>  { public: typedef align::a2 type; };
+template<> class type_with_alignment<4>  { public: typedef align::a4 type; };
+template<> class type_with_alignment<8>  { public: typedef align::a8 type; };
+template<> class type_with_alignment<16> { public: typedef align::a16 type; };
+template<> class type_with_alignment<32> { public: typedef align::a32 type; };
+
+namespace detail {
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a2,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a4,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a8,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a16,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a32,true)
+}
+#endif
+#if (defined(BOOST_MSVC) || (defined(BOOST_INTEL) && defined(_MSC_VER))) && _MSC_VER >= 1300
+//
+// MSVC supports types which have alignments greater than the normal
+// maximum: these are used for example in the types __m64 and __m128
+// to provide types with alignment requirements which match the SSE
+// registers.  Therefore we extend type_with_alignment<> to support
+// such types, however, we have to be careful to use a builtin type
+// whenever possible otherwise we break previously working code:
+// see http://article.gmane.org/gmane.comp.lib.boost.devel/173011
+// for an example and test case.  Thus types like a8 below will
+// be used *only* if the existing implementation can't provide a type
+// with suitable alignment.  This does mean however, that type_with_alignment<>
+// may return a type which cannot be passed through a function call
+// by value (and neither can any type containing such a type like
+// Boost.Optional).  However, this only happens when we have no choice
+// in the matter because no other "ordinary" type is available.
+//
+namespace align {
+struct __declspec(align(8)) a8 {
+   char m[8];
+   typedef a8 type;
+};
+struct __declspec(align(16)) a16 {
+   char m[16];
+   typedef a16 type;
+};
+struct __declspec(align(32)) a32 {
+   char m[32];
+   typedef a32 type;
+};
+struct __declspec(align(64)) a64
+{
+   char m[64];
+   typedef a64 type;
+};
+struct __declspec(align(128)) a128 {
+   char m[128];
+   typedef a128 type;
+};
+}
+
+template<> class type_with_alignment<8>
+{
+   typedef mpl::if_c<
+      ::boost::alignment_of<boost::detail::max_align>::value < 8,
+      align::a8,
+      boost::detail::type_with_alignment_imp<8> >::type t1;
+public:
+   typedef t1::type type;
+};
+template<> class type_with_alignment<16>
+{
+   typedef mpl::if_c<
+      ::boost::alignment_of<boost::detail::max_align>::value < 16,
+      align::a16,
+      boost::detail::type_with_alignment_imp<16> >::type t1;
+public:
+   typedef t1::type type;
+};
+template<> class type_with_alignment<32>
+{
+   typedef mpl::if_c<
+      ::boost::alignment_of<boost::detail::max_align>::value < 32,
+      align::a32,
+      boost::detail::type_with_alignment_imp<32> >::type t1;
+public:
+   typedef t1::type type;
+};
+template<> class type_with_alignment<64> {
+   typedef mpl::if_c<
+      ::boost::alignment_of<boost::detail::max_align>::value < 64,
+      align::a64,
+      boost::detail::type_with_alignment_imp<64> >::type t1;
+public:
+   typedef t1::type type;
+};
+template<> class type_with_alignment<128> {
+   typedef mpl::if_c<
+      ::boost::alignment_of<boost::detail::max_align>::value < 128,
+      align::a128,
+      boost::detail::type_with_alignment_imp<128> >::type t1;
+public:
+   typedef t1::type type;
+};
+
+namespace detail {
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a8,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a16,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a32,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a64,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a128,true)
+}
+#endif
+
+#else
+
+//
+// Borland specific version, we have this for two reasons:
+// 1) The version above doesn't always compile (with the new test cases for example)
+// 2) Because of Borlands #pragma option we can create types with alignments that are
+//    greater that the largest aligned builtin type.
+
+namespace align{
+#pragma option push -a16
+struct a2{ short s; };
+struct a4{ int s; };
+struct a8{ double s; };
+struct a16{ long double s; };
+#pragma option pop
+}
+
+namespace detail {
+
+typedef ::boost::align::a16 max_align;
+
+//#if ! BOOST_WORKAROUND(__CODEGEARC__, BOOST_TESTED_AT(0x610))
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a2,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a4,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a8,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,::boost::align::a16,true)
+//#endif
+}
+
+template <std::size_t N> struct type_with_alignment
+{
+   // We should never get to here, but if we do use the maximally
+   // aligned type:
+   // BOOST_STATIC_ASSERT(0);
+   typedef align::a16 type;
+};
+template <> struct type_with_alignment<1>{ typedef char type; };
+template <> struct type_with_alignment<2>{ typedef align::a2 type; };
+template <> struct type_with_alignment<4>{ typedef align::a4 type; };
+template <> struct type_with_alignment<8>{ typedef align::a8 type; };
+template <> struct type_with_alignment<16>{ typedef align::a16 type; };
+
+#endif
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+#   pragma warning(pop)
+#endif
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_TYPE_WITH_ALIGNMENT_INCLUDED
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_volatile.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_volatile.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_volatile.hpp	(working copy)
@@ -0,0 +1,152 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+//    Fixed is_pointer, is_reference, is_const, is_volatile, is_same,
+//    is_member_pointer based on the Simulated Partial Specialization work
+//    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or
+//    http://groups.yahoo.com/group/boost/message/5441
+//    Some workarounds in here use ideas suggested from "Generic<Programming>:
+//    Mappings between Types and Values"
+//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).
+
+
+#ifndef BOOST_TT_IS_VOLATILE_HPP_INCLUDED
+#define BOOST_TT_IS_VOLATILE_HPP_INCLUDED
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/type_traits/detail/cv_traits_impl.hpp>
+#   if BOOST_WORKAROUND(BOOST_MSVC, < 1400)
+#       include <boost/type_traits/remove_bounds.hpp>
+#   endif
+#else
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#   include <boost/type_traits/detail/false_result.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail{
+template <class T>
+struct is_volatile_rval_filter
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1400)
+   BOOST_STATIC_CONSTANT(bool, value = ::boost::detail::cv_traits_imp<typename boost::remove_bounds<T>::type*>::is_volatile);
+#else
+   BOOST_STATIC_CONSTANT(bool, value = ::boost::detail::cv_traits_imp<T*>::is_volatile);
+#endif
+};
+#ifndef BOOST_NO_RVALUE_REFERENCES
+//
+// We can't filter out rvalue_references at the same level as
+// references or we get ambiguities from msvc:
+//
+template <class T>
+struct is_volatile_rval_filter<T&&>
+{
+   BOOST_STATIC_CONSTANT(bool, value = false);
+};
+#endif
+}
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_volatile,T,__is_volatile(T))
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+//* is a type T declared volatile - is_volatile<T>
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_volatile,T,::boost::detail::is_volatile_rval_filter<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_volatile,T&,false)
+
+#if  defined(BOOST_ILLEGAL_CV_REFERENCES)
+// these are illegal specialisations; cv-qualifies applied to
+// references have no effect according to [8.3.2p1],
+// C++ Builder requires them though as it treats cv-qualified
+// references as distinct types...
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_volatile,T& const,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_volatile,T& volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_volatile,T& const volatile,false)
+#endif
+
+#else
+
+namespace detail {
+
+using ::boost::type_traits::yes_type;
+using ::boost::type_traits::no_type;
+
+yes_type is_volatile_tester(void const volatile*);
+no_type is_volatile_tester(void const*);
+
+template <bool is_ref, bool array>
+struct is_volatile_helper
+    : public ::boost::type_traits::false_result
+{
+};
+
+template <>
+struct is_volatile_helper<false,false>
+{
+    template <typename T> struct result_
+    {
+        static T* t;
+        BOOST_STATIC_CONSTANT(bool, value = (
+            sizeof(boost::detail::yes_type) == sizeof(boost::detail::is_volatile_tester(t))
+            ));
+    };
+};
+
+template <>
+struct is_volatile_helper<false,true>
+{
+    template <typename T> struct result_
+    {
+        static T t;
+        BOOST_STATIC_CONSTANT(bool, value = (
+            sizeof(boost::detail::yes_type) == sizeof(boost::detail::is_volatile_tester(&t))
+            ));
+    };
+};
+
+template <typename T>
+struct is_volatile_impl
+    : public is_volatile_helper<
+          is_reference<T>::value
+        , is_array<T>::value
+        >::template result_<T>
+{
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_volatile,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_volatile,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_volatile,void volatile,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_volatile,void const volatile,true)
+#endif
+
+} // namespace detail
+
+//* is a type T declared volatile - is_volatile<T>
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_volatile,T,::boost::detail::is_volatile_impl<T>::value)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_VOLATILE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_trivial_constructor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_trivial_constructor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_trivial_constructor.hpp	(working copy)
@@ -0,0 +1,51 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_HAS_TRIVIAL_CONSTRUCTOR_HPP_INCLUDED
+#define BOOST_TT_HAS_TRIVIAL_CONSTRUCTOR_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/intrinsics.hpp>
+#include <boost/type_traits/is_pod.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+template <typename T>
+struct has_trivial_ctor_impl
+{
+#ifdef BOOST_HAS_TRIVIAL_CONSTRUCTOR
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_or<
+         ::boost::is_pod<T>::value,
+         BOOST_HAS_TRIVIAL_CONSTRUCTOR(T)
+      >::value));
+#else
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_or<
+         ::boost::is_pod<T>::value,
+         false
+      >::value));
+#endif
+};
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_trivial_constructor,T,::boost::detail::has_trivial_ctor_impl<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_trivial_default_constructor,T,::boost::detail::has_trivial_ctor_impl<T>::value)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_HAS_TRIVIAL_CONSTRUCTOR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_same.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_same.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_same.hpp	(working copy)
@@ -0,0 +1,103 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+//    Fixed is_pointer, is_reference, is_const, is_volatile, is_same,
+//    is_member_pointer based on the Simulated Partial Specialization work
+//    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or
+//    http://groups.yahoo.com/group/boost/message/5441
+//    Some workarounds in here use ideas suggested from "Generic<Programming>:
+//    Mappings between Types and Values"
+//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).
+
+
+#ifndef BOOST_TT_IS_SAME_HPP_INCLUDED
+#define BOOST_TT_IS_SAME_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#include <boost/type_traits/detail/yes_no_type.hpp>
+#include <boost/type_traits/detail/ice_and.hpp>
+#include <boost/type_traits/is_reference.hpp>
+#endif
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF2(is_same,T,U,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_1(typename T,is_same,T,T,true)
+#if BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+// without this, Borland's compiler gives the wrong answer for
+// references to arrays:
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_1(typename T,is_same,T&,T&,true)
+#endif
+
+#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+namespace detail {
+
+#ifdef BOOST_MSVC
+// the following VC6 specific implementation is *NOT* legal
+// C++, but has the advantage that it works for incomplete
+// types.
+
+template< typename T1 >
+struct is_same_part_1
+{
+    template<typename T2>  struct part_2     { enum { value = false }; };
+    template<>             struct part_2<T1> { enum { value = true }; };
+};
+
+template< typename T1, typename T2 >
+struct is_same_impl
+{
+    enum { value = boost::detail::is_same_part_1<T1>::template part_2<T2>::value };
+};
+
+#else // generic "no-partial-specialization" version
+
+template <typename T>
+::boost::type_traits::yes_type
+BOOST_TT_DECL is_same_tester(T*, T*);
+
+::boost::type_traits::no_type
+BOOST_TT_DECL is_same_tester(...);
+
+template <typename T, typename U>
+struct is_same_impl
+{
+   static T t;
+   static U u;
+
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_and<
+         (sizeof(type_traits::yes_type) == sizeof(boost::detail::is_same_tester(&t,&u))),
+         (::boost::is_reference<T>::value == ::boost::is_reference<U>::value),
+         (sizeof(T) == sizeof(U))
+        >::value));
+};
+
+#endif // BOOST_MSVC
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF2(is_same,T,U,(::boost::detail::is_same_impl<T,U>::value))
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif  // BOOST_TT_IS_SAME_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_base_and_derived.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_base_and_derived.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_base_and_derived.hpp	(working copy)
@@ -0,0 +1,254 @@
+
+//  (C) Copyright Rani Sharoni 2003.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_BASE_AND_DERIVED_HPP_INCLUDED
+#define BOOST_TT_IS_BASE_AND_DERIVED_HPP_INCLUDED
+
+#include <boost/type_traits/intrinsics.hpp>
+#ifndef BOOST_IS_BASE_OF
+#include <boost/type_traits/is_class.hpp>
+#include <boost/type_traits/is_same.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+#include <boost/type_traits/detail/ice_and.hpp>
+#include <boost/config.hpp>
+#include <boost/static_assert.hpp>
+#endif
+#include <boost/type_traits/remove_cv.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+#ifndef BOOST_IS_BASE_OF
+#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x581)) \
+ && !BOOST_WORKAROUND(__SUNPRO_CC , <= 0x540) \
+ && !BOOST_WORKAROUND(__EDG_VERSION__, <= 243) \
+ && !BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+
+                             // The EDG version number is a lower estimate.
+                             // It is not currently known which EDG version
+                             // exactly fixes the problem.
+
+/*************************************************************************
+
+This version detects ambiguous base classes and private base classes
+correctly, and was devised by Rani Sharoni.
+
+Explanation by Terje Slettebo and Rani Sharoni.
+
+Let's take the multiple base class below as an example, and the following
+will also show why there's not a problem with private or ambiguous base
+class:
+
+struct B {};
+struct B1 : B {};
+struct B2 : B {};
+struct D : private B1, private B2 {};
+
+is_base_and_derived<B, D>::value;
+
+First, some terminology:
+
+SC  - Standard conversion
+UDC - User-defined conversion
+
+A user-defined conversion sequence consists of an SC, followed by an UDC,
+followed by another SC. Either SC may be the identity conversion.
+
+When passing the default-constructed Host object to the overloaded check_sig()
+functions (initialization 8.5/14/4/3), we have several viable implicit
+conversion sequences:
+
+For "static no_type check_sig(B const volatile *, int)" we have the conversion
+sequences:
+
+C -> C const (SC - Qualification Adjustment) -> B const volatile* (UDC)
+C -> D const volatile* (UDC) -> B1 const volatile* / B2 const volatile* ->
+     B const volatile* (SC - Conversion)
+
+For "static yes_type check_sig(D const volatile *, T)" we have the conversion
+sequence:
+
+C -> D const volatile* (UDC)
+
+According to 13.3.3.1/4, in context of user-defined conversion only the
+standard conversion sequence is considered when selecting the best viable
+function, so it only considers up to the user-defined conversion. For the
+first function this means choosing between C -> C const and C -> C, and it
+chooses the latter, because it's a proper subset (13.3.3.2/3/2) of the
+former. Therefore, we have:
+
+C -> D const volatile* (UDC) -> B1 const volatile* / B2 const volatile* ->
+     B const volatile* (SC - Conversion)
+C -> D const volatile* (UDC)
+
+Here, the principle of the "shortest subsequence" applies again, and it
+chooses C -> D const volatile*. This shows that it doesn't even need to
+consider the multiple paths to B, or accessibility, as that possibility is
+eliminated before it could possibly cause ambiguity or access violation.
+
+If D is not derived from B, it has to choose between C -> C const -> B const
+volatile* for the first function, and C -> D const volatile* for the second
+function, which are just as good (both requires a UDC, 13.3.3.2), had it not
+been for the fact that "static no_type check_sig(B const volatile *, int)" is
+not templated, which makes C -> C const -> B const volatile* the best choice
+(13.3.3/1/4), resulting in "no".
+
+Also, if Host::operator B const volatile* hadn't been const, the two
+conversion sequences for "static no_type check_sig(B const volatile *, int)", in
+the case where D is derived from B, would have been ambiguous.
+
+See also
+http://groups.google.com/groups?selm=df893da6.0301280859.522081f7%40posting.
+google.com and links therein.
+
+*************************************************************************/
+
+template <typename B, typename D>
+struct bd_helper
+{
+   //
+   // This VC7.1 specific workaround stops the compiler from generating
+   // an internal compiler error when compiling with /vmg (thanks to
+   // Aleksey Gurtovoy for figuring out the workaround).
+   //
+#if !BOOST_WORKAROUND(BOOST_MSVC, == 1310)
+    template <typename T>
+    static type_traits::yes_type check_sig(D const volatile *, T);
+    static type_traits::no_type  check_sig(B const volatile *, int);
+#else
+    static type_traits::yes_type check_sig(D const volatile *, long);
+    static type_traits::no_type  check_sig(B const volatile * const&, int);
+#endif
+};
+
+template<typename B, typename D>
+struct is_base_and_derived_impl2
+{
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(push)
+#pragma warning(disable:6334)
+#endif
+    //
+    // May silently do the wrong thing with incomplete types
+    // unless we trap them here:
+    //
+    BOOST_STATIC_ASSERT(sizeof(B) != 0);
+    BOOST_STATIC_ASSERT(sizeof(D) != 0);
+
+    struct Host
+    {
+#if !BOOST_WORKAROUND(BOOST_MSVC, == 1310)
+        operator B const volatile *() const;
+#else
+        operator B const volatile * const&() const;
+#endif
+        operator D const volatile *();
+    };
+
+    BOOST_STATIC_CONSTANT(bool, value =
+        sizeof(bd_helper<B,D>::check_sig(Host(), 0)) == sizeof(type_traits::yes_type));
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(pop)
+#endif
+};
+
+#else
+
+//
+// broken version:
+//
+template<typename B, typename D>
+struct is_base_and_derived_impl2
+{
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::is_convertible<D*,B*>::value));
+};
+
+#define BOOST_BROKEN_IS_BASE_AND_DERIVED
+
+#endif
+
+template <typename B, typename D>
+struct is_base_and_derived_impl3
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+template <bool ic1, bool ic2, bool iss>
+struct is_base_and_derived_select
+{
+   template <class T, class U>
+   struct rebind
+   {
+      typedef is_base_and_derived_impl3<T,U> type;
+   };
+};
+
+template <>
+struct is_base_and_derived_select<true,true,false>
+{
+   template <class T, class U>
+   struct rebind
+   {
+      typedef is_base_and_derived_impl2<T,U> type;
+   };
+};
+
+template <typename B, typename D>
+struct is_base_and_derived_impl
+{
+    typedef typename remove_cv<B>::type ncvB;
+    typedef typename remove_cv<D>::type ncvD;
+
+    typedef is_base_and_derived_select<
+       ::boost::is_class<B>::value,
+       ::boost::is_class<D>::value,
+       ::boost::is_same<ncvB,ncvD>::value> selector;
+    typedef typename selector::template rebind<ncvB,ncvD> binder;
+    typedef typename binder::type bound_type;
+
+    BOOST_STATIC_CONSTANT(bool, value = bound_type::value);
+};
+#else
+template <typename B, typename D>
+struct is_base_and_derived_impl
+{
+    typedef typename remove_cv<B>::type ncvB;
+    typedef typename remove_cv<D>::type ncvD;
+
+    BOOST_STATIC_CONSTANT(bool, value = (BOOST_IS_BASE_OF(B,D) && ! ::boost::is_same<ncvB,ncvD>::value));
+};
+#endif
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF2(
+      is_base_and_derived
+    , Base
+    , Derived
+    , (::boost::detail::is_base_and_derived_impl<Base,Derived>::value)
+    )
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_2(typename Base,typename Derived,is_base_and_derived,Base&,Derived,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_2(typename Base,typename Derived,is_base_and_derived,Base,Derived&,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_2(typename Base,typename Derived,is_base_and_derived,Base&,Derived&,false)
+#endif
+
+#if BOOST_WORKAROUND(__CODEGEARC__, BOOST_TESTED_AT(0x610))
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_1(typename Base,is_base_and_derived,Base,Base,false)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_BASE_AND_DERIVED_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_const.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_const.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_const.hpp	(working copy)
@@ -0,0 +1,47 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_ADD_CONST_HPP_INCLUDED
+#define BOOST_TT_ADD_CONST_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+// * convert a type T to const type - add_const<T>
+// this is not required since the result is always
+// the same as "T const", but it does suppress warnings
+// from some compilers:
+
+#if defined(BOOST_MSVC)
+// This bogus warning will appear when add_const is applied to a
+// const volatile reference because we can't detect const volatile
+// references with MSVC6.
+#   pragma warning(push)
+#   pragma warning(disable:4181) // warning C4181: qualifier applied to reference type ignored
+#endif
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(add_const,T,T const)
+
+#if defined(BOOST_MSVC)
+#   pragma warning(pop)
+#endif
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,add_const,T&,T&)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_ADD_CONST_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_enum.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_enum.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_enum.hpp	(working copy)
@@ -0,0 +1,189 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_IS_ENUM_HPP_INCLUDED
+#define BOOST_TT_IS_ENUM_HPP_INCLUDED
+
+#include <boost/type_traits/intrinsics.hpp>
+#ifndef BOOST_IS_ENUM
+#include <boost/type_traits/add_reference.hpp>
+#include <boost/type_traits/is_arithmetic.hpp>
+#include <boost/type_traits/is_reference.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+#include <boost/type_traits/is_array.hpp>
+#ifdef __GNUC__
+#include <boost/type_traits/is_function.hpp>
+#endif
+#include <boost/type_traits/config.hpp>
+#if defined(BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION)
+#  include <boost/type_traits/is_class.hpp>
+#  include <boost/type_traits/is_union.hpp>
+#endif
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#ifndef BOOST_IS_ENUM
+#if !(defined(__BORLANDC__) && (__BORLANDC__ <= 0x551))
+
+namespace detail {
+
+#if defined(BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION)
+
+template <typename T>
+struct is_class_or_union
+{
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_or<
+           ::boost::is_class<T>::value
+         , ::boost::is_union<T>::value
+      >::value));
+};
+
+#else
+
+template <typename T>
+struct is_class_or_union
+{
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300) || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x581))// we simply can't detect it this way.
+    BOOST_STATIC_CONSTANT(bool, value = false);
+# else
+    template <class U> static ::boost::type_traits::yes_type is_class_or_union_tester(void(U::*)(void));
+
+#  if BOOST_WORKAROUND(BOOST_MSVC, == 1300)                 \
+    || BOOST_WORKAROUND(__MWERKS__, <= 0x3000) // no SFINAE
+    static ::boost::type_traits::no_type is_class_or_union_tester(...);
+    BOOST_STATIC_CONSTANT(
+        bool, value = sizeof(is_class_or_union_tester(0)) == sizeof(::boost::type_traits::yes_type));
+#  else
+    template <class U>
+    static ::boost::type_traits::no_type is_class_or_union_tester(...);
+    BOOST_STATIC_CONSTANT(
+        bool, value = sizeof(is_class_or_union_tester<T>(0)) == sizeof(::boost::type_traits::yes_type));
+#  endif
+# endif
+};
+#endif
+
+struct int_convertible
+{
+    int_convertible(int);
+};
+
+// Don't evaluate convertibility to int_convertible unless the type
+// is non-arithmetic. This suppresses warnings with GCC.
+template <bool is_typename_arithmetic_or_reference = true>
+struct is_enum_helper
+{
+    template <typename T> struct type
+    {
+        BOOST_STATIC_CONSTANT(bool, value = false);
+    };
+};
+
+template <>
+struct is_enum_helper<false>
+{
+    template <typename T> struct type
+       : public ::boost::is_convertible<typename boost::add_reference<T>::type,::boost::detail::int_convertible>
+    {
+    };
+};
+
+template <typename T> struct is_enum_impl
+{
+   //typedef ::boost::add_reference<T> ar_t;
+   //typedef typename ar_t::type r_type;
+
+#if defined(__GNUC__)
+
+#ifdef BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION
+
+   // We MUST check for is_class_or_union on conforming compilers in
+   // order to correctly deduce that noncopyable types are not enums
+   // (dwa 2002/04/15)...
+   BOOST_STATIC_CONSTANT(bool, selector =
+      (::boost::type_traits::ice_or<
+           ::boost::is_arithmetic<T>::value
+         , ::boost::is_reference<T>::value
+         , ::boost::is_function<T>::value
+         , is_class_or_union<T>::value
+         , is_array<T>::value
+      >::value));
+#else
+   // ...however, not checking is_class_or_union on non-conforming
+   // compilers prevents a dependency recursion.
+   BOOST_STATIC_CONSTANT(bool, selector =
+      (::boost::type_traits::ice_or<
+           ::boost::is_arithmetic<T>::value
+         , ::boost::is_reference<T>::value
+         , ::boost::is_function<T>::value
+         , is_array<T>::value
+      >::value));
+#endif // BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION
+
+#else // !defined(__GNUC__):
+
+   BOOST_STATIC_CONSTANT(bool, selector =
+      (::boost::type_traits::ice_or<
+           ::boost::is_arithmetic<T>::value
+         , ::boost::is_reference<T>::value
+         , is_class_or_union<T>::value
+         , is_array<T>::value
+      >::value));
+
+#endif
+
+#if BOOST_WORKAROUND(__BORLANDC__, < 0x600)
+    typedef ::boost::detail::is_enum_helper<
+          ::boost::detail::is_enum_impl<T>::selector
+        > se_t;
+#else
+    typedef ::boost::detail::is_enum_helper<selector> se_t;
+#endif
+
+    typedef typename se_t::template type<T> helper;
+    BOOST_STATIC_CONSTANT(bool, value = helper::value);
+};
+
+// these help on compilers with no partial specialization support:
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_enum,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_enum,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_enum,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_enum,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_enum,T,::boost::detail::is_enum_impl<T>::value)
+
+#else // __BORLANDC__
+//
+// buggy is_convertible prevents working
+// implementation of is_enum:
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_enum,T,false)
+
+#endif
+
+#else // BOOST_IS_ENUM
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_enum,T,BOOST_IS_ENUM(T))
+
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_ENUM_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_const.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_const.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_const.hpp	(working copy)
@@ -0,0 +1,90 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_REMOVE_CONST_HPP_INCLUDED
+#define BOOST_TT_REMOVE_CONST_HPP_INCLUDED
+
+#include <boost/type_traits/is_volatile.hpp>
+#include <boost/type_traits/broken_compiler_spec.hpp>
+#include <boost/type_traits/detail/cv_traits_impl.hpp>
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#include <cstddef>
+
+#if BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+#include <boost/type_traits/msvc/remove_const.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+namespace detail {
+
+template <typename T, bool is_vol>
+struct remove_const_helper
+{
+    typedef T type;
+};
+
+template <typename T>
+struct remove_const_helper<T, true>
+{
+    typedef T volatile type;
+};
+
+
+template <typename T>
+struct remove_const_impl
+{
+    typedef typename remove_const_helper<
+          typename cv_traits_imp<T*>::unqualified_type
+        , ::boost::is_volatile<T>::value
+        >::type type;
+};
+
+#ifndef BOOST_NO_RVALUE_REFERENCES
+//
+// We can't filter out rvalue_references at the same level as
+// references or we get ambiguities from msvc:
+//
+template <typename T>
+struct remove_const_impl<T&&>
+{
+    typedef T&& type;
+};
+#endif
+
+} // namespace detail
+
+// * convert a type T to non-const type - remove_const<T>
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_const,T,typename boost::detail::remove_const_impl<T>::type)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_const,T&,T&)
+#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,remove_const,T const[N],T type[N])
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,remove_const,T const volatile[N],T volatile type[N])
+#endif
+
+#elif !BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_const,T,typename boost::detail::remove_const_impl<T>::type)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_REMOVE_CONST_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_rvalue_reference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_rvalue_reference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_rvalue_reference.hpp	(working copy)
@@ -0,0 +1,29 @@
+
+//  (C) John Maddock 2010.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_RVALUE_REFERENCE_HPP_INCLUDED
+#define BOOST_TT_IS_RVALUE_REFERENCE_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_rvalue_reference,T,false)
+#ifndef BOOST_NO_RVALUE_REFERENCES
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_rvalue_reference,T&&,true)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_REFERENCE_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/yes_no_type.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/yes_no_type.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/yes_no_type.hpp	(working copy)
@@ -0,0 +1,26 @@
+
+//  (C) Copyright John Maddock and Steve Cleary 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+//
+//  macros and helpers for working with integral-constant-expressions.
+
+#ifndef BOOST_TT_DETAIL_YES_NO_TYPE_HPP_INCLUDED
+#define BOOST_TT_DETAIL_YES_NO_TYPE_HPP_INCLUDED
+
+namespace boost {
+namespace type_traits {
+
+typedef char yes_type;
+struct no_type
+{
+   char padding[8];
+};
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_YES_NO_TYPE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_or.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_or.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_or.hpp	(working copy)
@@ -0,0 +1,34 @@
+//  (C) Copyright John Maddock and Steve Cleary 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_DETAIL_ICE_OR_HPP_INCLUDED
+#define BOOST_TT_DETAIL_ICE_OR_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+namespace boost {
+namespace type_traits {
+
+template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
+struct ice_or;
+
+template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
+struct ice_or
+{
+    BOOST_STATIC_CONSTANT(bool, value = true);
+};
+
+template <>
+struct ice_or<false, false, false, false, false, false, false>
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_ICE_OR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/type_trait_def.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/type_trait_def.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/type_trait_def.hpp	(working copy)
@@ -0,0 +1,67 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// $Source$
+// $Date: 2011-04-25 08:26:48 -0400 (Mon, 25 Apr 2011) $
+// $Revision: 71481 $
+
+#include <boost/type_traits/detail/template_arity_spec.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+
+#define BOOST_TT_AUX_TYPE_TRAIT_DEF1(trait,T,result) \
+template< typename T > struct trait \
+{ \
+public:\
+    typedef result type; \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,trait,(T)) \
+}; \
+\
+BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(1,trait) \
+/**/
+
+#define BOOST_TT_AUX_TYPE_TRAIT_SPEC1(trait,spec,result) \
+template<> struct trait<spec> \
+{ \
+public:\
+    typedef result type; \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(1,trait,(spec)) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1(trait,spec,result) \
+template<> struct trait##_impl<spec> \
+{ \
+public:\
+    typedef result type; \
+}; \
+/**/
+
+#define BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(param,trait,spec,result) \
+template< param > struct trait<spec> \
+{ \
+public:\
+    typedef result type; \
+}; \
+/**/
+
+#define BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2(param1,param2,trait,spec,result) \
+template< param1, param2 > struct trait<spec> \
+{ \
+public:\
+    typedef result; \
+}; \
+/**/
+
+#define BOOST_TT_AUX_TYPE_TRAIT_IMPL_PARTIAL_SPEC1_1(param,trait,spec,result) \
+template< param > struct trait##_impl<spec> \
+{ \
+public:\
+    typedef result type; \
+}; \
+/**/
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/bool_trait_def.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/bool_trait_def.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/bool_trait_def.hpp	(working copy)
@@ -0,0 +1,196 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// $Source$
+// $Date: 2011-10-09 18:28:33 -0400 (Sun, 09 Oct 2011) $
+// $Revision: 74865 $
+
+#include <boost/type_traits/detail/template_arity_spec.hpp>
+#include <boost/type_traits/integral_constant.hpp>
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+#include <boost/config.hpp>
+
+//
+// Unfortunately some libraries have started using this header without
+// cleaning up afterwards: so we'd better undef the macros just in case
+// they've been defined already....
+//
+#ifdef BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL
+#undef BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL
+#undef BOOST_TT_AUX_BOOL_C_BASE
+#undef BOOST_TT_AUX_BOOL_TRAIT_DEF1
+#undef BOOST_TT_AUX_BOOL_TRAIT_DEF2
+#undef BOOST_TT_AUX_BOOL_TRAIT_SPEC1
+#undef BOOST_TT_AUX_BOOL_TRAIT_SPEC2
+#undef BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1
+#undef BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_1
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_2
+#undef BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1
+#undef BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1
+#endif
+
+#if defined(__SUNPRO_CC) && (__SUNPRO_CC < 0x570)
+#   define BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    typedef ::boost::integral_constant<bool,C> type; \
+    enum { value = type::value }; \
+    /**/
+#   define BOOST_TT_AUX_BOOL_C_BASE(C)
+
+#elif defined(BOOST_MSVC) && BOOST_MSVC < 1300
+
+#   define BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    typedef ::boost::integral_constant<bool,C> base_; \
+    using base_::value; \
+    /**/
+
+#endif
+
+#ifndef BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL
+#   define BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) /**/
+#endif
+
+#ifndef BOOST_TT_AUX_BOOL_C_BASE
+#   define BOOST_TT_AUX_BOOL_C_BASE(C) : public ::boost::integral_constant<bool,C>
+#endif
+
+
+#define BOOST_TT_AUX_BOOL_TRAIT_DEF1(trait,T,C) \
+template< typename T > struct trait \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,trait,(T)) \
+}; \
+\
+BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(1,trait) \
+/**/
+
+
+#define BOOST_TT_AUX_BOOL_TRAIT_DEF2(trait,T1,T2,C) \
+template< typename T1, typename T2 > struct trait \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(2,trait,(T1,T2)) \
+}; \
+\
+BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(2,trait) \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_DEF3(trait,T1,T2,T3,C) \
+template< typename T1, typename T2, typename T3 > struct trait \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(3,trait,(T1,T2,T3)) \
+}; \
+\
+BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(3,trait) \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_SPEC1(trait,sp,C) \
+template<> struct trait< sp > \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(1,trait,(sp)) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_SPEC2(trait,sp1,sp2,C) \
+template<> struct trait< sp1,sp2 > \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(2,trait,(sp1,sp2)) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(trait,sp,C) \
+template<> struct trait##_impl< sp > \
+{ \
+public:\
+    BOOST_STATIC_CONSTANT(bool, value = (C)); \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2(trait,sp1,sp2,C) \
+template<> struct trait##_impl< sp1,sp2 > \
+{ \
+public:\
+    BOOST_STATIC_CONSTANT(bool, value = (C)); \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(param,trait,sp,C) \
+template< param > struct trait< sp > \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(param1,param2,trait,sp,C) \
+template< param1, param2 > struct trait< sp > \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_1(param,trait,sp1,sp2,C) \
+template< param > struct trait< sp1,sp2 > \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(2,trait,(sp1,sp2)) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_2(param1,param2,trait,sp1,sp2,C) \
+template< param1, param2 > struct trait< sp1,sp2 > \
+    BOOST_TT_AUX_BOOL_C_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(C) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1(param,trait,sp1,sp2,C) \
+template< param > struct trait##_impl< sp1,sp2 > \
+{ \
+public:\
+    BOOST_STATIC_CONSTANT(bool, value = (C)); \
+}; \
+/**/
+
+#ifndef BOOST_NO_CV_SPECIALIZATIONS
+#   define BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(trait,sp,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_SPEC1(trait,sp,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_SPEC1(trait,sp const,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_SPEC1(trait,sp volatile,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_SPEC1(trait,sp const volatile,value) \
+    /**/
+#else
+#   define BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(trait,sp,value) \
+    BOOST_TT_AUX_BOOL_TRAIT_SPEC1(trait,sp,value) \
+    /**/
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/size_t_trait_def.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/size_t_trait_def.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/size_t_trait_def.hpp	(working copy)
@@ -0,0 +1,60 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// $Source$
+// $Date: 2011-04-25 08:26:48 -0400 (Mon, 25 Apr 2011) $
+// $Revision: 71481 $
+
+#include <boost/type_traits/detail/template_arity_spec.hpp>
+#include <boost/type_traits/integral_constant.hpp>
+#include <boost/mpl/aux_/lambda_support.hpp>
+#include <boost/mpl/size_t.hpp>
+
+#include <cstddef>
+
+#if !defined(BOOST_MSVC) || BOOST_MSVC >= 1300
+#   define BOOST_TT_AUX_SIZE_T_BASE(C) public ::boost::integral_constant<std::size_t,C>
+#   define BOOST_TT_AUX_SIZE_T_TRAIT_VALUE_DECL(C) /**/
+#else
+#   define BOOST_TT_AUX_SIZE_T_BASE(C) public ::boost::mpl::size_t<C>
+#   define BOOST_TT_AUX_SIZE_T_TRAIT_VALUE_DECL(C) \
+    typedef ::boost::mpl::size_t<C> base_; \
+    using base_::value; \
+    /**/
+#endif
+
+
+#define BOOST_TT_AUX_SIZE_T_TRAIT_DEF1(trait,T,C) \
+template< typename T > struct trait \
+    : BOOST_TT_AUX_SIZE_T_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_SIZE_T_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,trait,(T)) \
+}; \
+\
+BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(1,trait) \
+/**/
+
+#define BOOST_TT_AUX_SIZE_T_TRAIT_SPEC1(trait,spec,C) \
+template<> struct trait<spec> \
+    : BOOST_TT_AUX_SIZE_T_BASE(C) \
+{ \
+public:\
+    BOOST_TT_AUX_SIZE_T_TRAIT_VALUE_DECL(C) \
+    BOOST_MPL_AUX_LAMBDA_SUPPORT_SPEC(1,trait,(spec)) \
+}; \
+/**/
+
+#define BOOST_TT_AUX_SIZE_T_TRAIT_PARTIAL_SPEC1_1(param,trait,spec,C) \
+template< param > struct trait<spec> \
+    : BOOST_TT_AUX_SIZE_T_BASE(C) \
+{ \
+}; \
+/**/
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/template_arity_spec.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/template_arity_spec.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/template_arity_spec.hpp	(working copy)
@@ -0,0 +1,31 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+#include <boost/mpl/int.hpp>
+#include <boost/mpl/aux_/template_arity_fwd.hpp>
+#include <boost/mpl/aux_/preprocessor/params.hpp>
+#include <boost/mpl/aux_/config/lambda.hpp>
+#include <boost/mpl/aux_/config/overload_resolution.hpp>
+
+#if defined(BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT) \
+    && defined(BOOST_MPL_CFG_BROKEN_OVERLOAD_RESOLUTION)
+#   define BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(i, name) \
+namespace mpl { namespace aux { \
+template< BOOST_MPL_PP_PARAMS(i, typename T) > \
+struct template_arity< \
+          name< BOOST_MPL_PP_PARAMS(i, T) > \
+        > \
+    : int_<i> \
+{ \
+}; \
+}} \
+/**/
+#else
+#   define BOOST_TT_AUX_TEMPLATE_ARITY_SPEC(i, name) /**/
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp	(working copy)
@@ -0,0 +1,817 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//  Aleksey Gurtovoy, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_TT_DETAIL_IS_MEM_FUN_POINTER_IMPL_HPP_INCLUDED
+#define BOOST_TT_DETAIL_IS_MEM_FUN_POINTER_IMPL_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+#if defined(BOOST_TT_PREPROCESSING_MODE)
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/enum_params.hpp>
+#   include <boost/preprocessor/comma_if.hpp>
+#endif
+
+namespace boost {
+namespace type_traits {
+
+template <typename T>
+struct is_mem_fun_pointer_impl
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+#if !defined(BOOST_TT_PREPROCESSING_MODE)
+// pre-processed code, don't edit, try GNU cpp with
+// cpp -I../../../ -DBOOST_TT_PREPROCESSING_MODE -x c++ -P filename
+
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)() > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)( ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)() const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)() volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T >
+struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+
+#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#endif
+
+#else
+
+#undef BOOST_STATIC_CONSTANT
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3, (0, 25, "boost/type_traits/detail/is_mem_fun_pointer_impl.hpp"))
+#include BOOST_PP_ITERATE()
+
+#endif // BOOST_TT_PREPROCESSING_MODE
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_IS_MEM_FUN_POINTER_IMPL_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define BOOST_PP_COUNTER BOOST_PP_FRAME_ITERATION(1)
+
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T)) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+@#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T) ...) > { BOOST_STATIC_CONSTANT(bool, value = true); };
+@#endif
+
+@#if !defined(BOOST_TT_NO_CV_FUNC_TEST)
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T)) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T)) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T)) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+@#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T) ...) const > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T) ...) volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+
+template <class R, class T BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_mem_fun_pointer_impl<R (T::*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T) ...) const volatile > { BOOST_STATIC_CONSTANT(bool, value = true); };
+@#endif
+@#endif
+
+#undef BOOST_PP_COUNTER
+#endif // BOOST_PP_IS_ITERATING
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/is_function_ptr_helper.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/is_function_ptr_helper.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/is_function_ptr_helper.hpp	(working copy)
@@ -0,0 +1,220 @@
+
+//  Copyright 2000 John Maddock (john@johnmaddock.co.uk)
+//  Copyright 2002 Aleksey Gurtovoy (agurtovoy@meta-comm.com)
+//
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#if !defined(BOOST_PP_IS_ITERATING)
+
+///// header body
+
+#ifndef BOOST_TT_DETAIL_IS_FUNCTION_PTR_HELPER_HPP_INCLUDED
+#define BOOST_TT_DETAIL_IS_FUNCTION_PTR_HELPER_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+
+#if defined(BOOST_TT_PREPROCESSING_MODE)
+#   include <boost/preprocessor/iterate.hpp>
+#   include <boost/preprocessor/enum_params.hpp>
+#   include <boost/preprocessor/comma_if.hpp>
+#endif
+
+namespace boost {
+namespace type_traits {
+
+template <class R>
+struct is_function_ptr_helper
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+#if !defined(BOOST_TT_PREPROCESSING_MODE)
+// preprocessor-generated part, don't edit by hand!
+
+template <class R >
+struct is_function_ptr_helper<R (*)()> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R >
+struct is_function_ptr_helper<R (*)( ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0>
+struct is_function_ptr_helper<R (*)( T0)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0>
+struct is_function_ptr_helper<R (*)( T0 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1>
+struct is_function_ptr_helper<R (*)( T0 , T1)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1>
+struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
+struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+#endif
+#else
+
+#undef BOOST_STATIC_CONSTANT
+#define BOOST_PP_ITERATION_PARAMS_1 \
+    (3, (0, 25, "boost/type_traits/detail/is_function_ptr_helper.hpp"))
+#include BOOST_PP_ITERATE()
+
+#endif // BOOST_TT_PREPROCESSING_MODE
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_IS_FUNCTION_PTR_HELPER_HPP_INCLUDED
+
+///// iteration
+
+#else
+#define BOOST_PP_COUNTER BOOST_PP_FRAME_ITERATION(1)
+
+template <class R BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_function_ptr_helper<R (*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T))> { BOOST_STATIC_CONSTANT(bool, value = true); };
+@#ifndef BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+template <class R BOOST_PP_COMMA_IF(BOOST_PP_COUNTER) BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,class T)>
+struct is_function_ptr_helper<R (*)(BOOST_PP_ENUM_PARAMS(BOOST_PP_COUNTER,T) ...)> { BOOST_STATIC_CONSTANT(bool, value = true); };
+@#endif
+#undef BOOST_PP_COUNTER
+#endif // BOOST_PP_IS_ITERATING
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/type_trait_undef.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/type_trait_undef.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/type_trait_undef.hpp	(working copy)
@@ -0,0 +1,19 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// $Source$
+// $Date: 2004-09-02 11:41:37 -0400 (Thu, 02 Sep 2004) $
+// $Revision: 24874 $
+
+#undef BOOST_TT_AUX_TYPE_TRAIT_DEF1
+#undef BOOST_TT_AUX_TYPE_TRAIT_SPEC1
+#undef BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1
+#undef BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1
+#undef BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2
+#undef BOOST_TT_AUX_TYPE_TRAIT_IMPL_PARTIAL_SPEC1_1
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/bool_trait_undef.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/bool_trait_undef.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/bool_trait_undef.hpp	(working copy)
@@ -0,0 +1,28 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// $Source$
+// $Date: 2011-10-09 18:28:33 -0400 (Sun, 09 Oct 2011) $
+// $Revision: 74865 $
+
+#undef BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL
+#undef BOOST_TT_AUX_BOOL_C_BASE
+#undef BOOST_TT_AUX_BOOL_TRAIT_DEF1
+#undef BOOST_TT_AUX_BOOL_TRAIT_DEF2
+#undef BOOST_TT_AUX_BOOL_TRAIT_DEF3
+#undef BOOST_TT_AUX_BOOL_TRAIT_SPEC1
+#undef BOOST_TT_AUX_BOOL_TRAIT_SPEC2
+#undef BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1
+#undef BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC2
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_1
+#undef BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC2_2
+#undef BOOST_TT_AUX_BOOL_TRAIT_IMPL_PARTIAL_SPEC2_1
+#undef BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/cv_traits_impl.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/cv_traits_impl.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/cv_traits_impl.hpp	(working copy)
@@ -0,0 +1,97 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_DETAIL_CV_TRAITS_IMPL_HPP_INCLUDED
+#define BOOST_TT_DETAIL_CV_TRAITS_IMPL_HPP_INCLUDED
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+// implementation helper:
+
+
+#if !(BOOST_WORKAROUND(__GNUC__,== 3) && BOOST_WORKAROUND(__GNUC_MINOR__, <= 2))
+namespace boost {
+namespace detail {
+#else
+#include <boost/type_traits/detail/yes_no_type.hpp>
+namespace boost {
+namespace type_traits {
+namespace gcc8503 {
+#endif
+
+template <typename T> struct cv_traits_imp {};
+
+template <typename T>
+struct cv_traits_imp<T*>
+{
+    BOOST_STATIC_CONSTANT(bool, is_const = false);
+    BOOST_STATIC_CONSTANT(bool, is_volatile = false);
+    typedef T unqualified_type;
+};
+
+template <typename T>
+struct cv_traits_imp<const T*>
+{
+    BOOST_STATIC_CONSTANT(bool, is_const = true);
+    BOOST_STATIC_CONSTANT(bool, is_volatile = false);
+    typedef T unqualified_type;
+};
+
+template <typename T>
+struct cv_traits_imp<volatile T*>
+{
+    BOOST_STATIC_CONSTANT(bool, is_const = false);
+    BOOST_STATIC_CONSTANT(bool, is_volatile = true);
+    typedef T unqualified_type;
+};
+
+template <typename T>
+struct cv_traits_imp<const volatile T*>
+{
+    BOOST_STATIC_CONSTANT(bool, is_const = true);
+    BOOST_STATIC_CONSTANT(bool, is_volatile = true);
+    typedef T unqualified_type;
+};
+
+#if BOOST_WORKAROUND(__GNUC__,== 3) && BOOST_WORKAROUND(__GNUC_MINOR__, <= 2)
+// We have to exclude function pointers
+// (see http://gcc.gnu.org/bugzilla/show_bug.cgi?8503)
+yes_type mini_funcptr_tester(...);
+no_type  mini_funcptr_tester(const volatile void*);
+
+} // namespace gcc8503
+} // namespace type_traits
+
+namespace detail {
+
+// Use the implementation above for non function pointers
+template <typename T, unsigned Select
+  = (unsigned)sizeof(::boost::type_traits::gcc8503::mini_funcptr_tester((T)0)) >
+struct cv_traits_imp : public ::boost::type_traits::gcc8503::cv_traits_imp<T> { };
+
+// Functions are never cv-qualified
+template <typename T> struct cv_traits_imp<T*,1>
+{
+    BOOST_STATIC_CONSTANT(bool, is_const = false);
+    BOOST_STATIC_CONSTANT(bool, is_volatile = false);
+    typedef T unqualified_type;
+};
+
+#endif
+
+} // namespace detail
+} // namespace boost
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#endif // BOOST_TT_DETAIL_CV_TRAITS_IMPL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_not.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_not.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_not.hpp	(working copy)
@@ -0,0 +1,31 @@
+//  (C) Copyright John Maddock and Steve Cleary 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_DETAIL_ICE_NOT_HPP_INCLUDED
+#define BOOST_TT_DETAIL_ICE_NOT_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+namespace boost {
+namespace type_traits {
+
+template <bool b>
+struct ice_not
+{
+    BOOST_STATIC_CONSTANT(bool, value = true);
+};
+
+template <>
+struct ice_not<true>
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_ICE_NOT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/size_t_trait_undef.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/size_t_trait_undef.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/size_t_trait_undef.hpp	(working copy)
@@ -0,0 +1,16 @@
+
+// NO INCLUDE GUARDS, THE HEADER IS INTENDED FOR MULTIPLE INCLUSION
+
+// Copyright Aleksey Gurtovoy 2002-2004
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// $Source$
+// $Date: 2004-09-02 11:41:37 -0400 (Thu, 02 Sep 2004) $
+// $Revision: 24874 $
+
+#undef BOOST_TT_AUX_SIZE_T_TRAIT_DEF1
+#undef BOOST_TT_AUX_SIZE_T_TRAIT_SPEC1
+#undef BOOST_TT_AUX_SIZE_T_TRAIT_PARTIAL_SPEC1_1
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_and.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_and.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_and.hpp	(working copy)
@@ -0,0 +1,35 @@
+//  (C) Copyright John Maddock and Steve Cleary 2000.
+//
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_DETAIL_ICE_AND_HPP_INCLUDED
+#define BOOST_TT_DETAIL_ICE_AND_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+namespace boost {
+namespace type_traits {
+
+template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
+struct ice_and;
+
+template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
+struct ice_and
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+template <>
+struct ice_and<true, true, true, true, true, true, true>
+{
+    BOOST_STATIC_CONSTANT(bool, value = true);
+};
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_ICE_AND_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_eq.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_eq.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/ice_eq.hpp	(working copy)
@@ -0,0 +1,36 @@
+//  (C) Copyright John Maddock and Steve Cleary 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_DETAIL_ICE_EQ_HPP_INCLUDED
+#define BOOST_TT_DETAIL_ICE_EQ_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+namespace boost {
+namespace type_traits {
+
+template <int b1, int b2>
+struct ice_eq
+{
+    BOOST_STATIC_CONSTANT(bool, value = (b1 == b2));
+};
+
+template <int b1, int b2>
+struct ice_ne
+{
+    BOOST_STATIC_CONSTANT(bool, value = (b1 != b2));
+};
+
+#ifndef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+template <int b1, int b2> bool const ice_eq<b1,b2>::value;
+template <int b1, int b2> bool const ice_ne<b1,b2>::value;
+#endif
+
+} // namespace type_traits
+} // namespace boost
+
+#endif // BOOST_TT_DETAIL_ICE_EQ_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/false_result.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/false_result.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/detail/false_result.hpp	(working copy)
@@ -0,0 +1,28 @@
+//  Copyright David Abrahams 2002.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_DETAIL_FALSE_RESULT_HPP_INCLUDED
+#define BOOST_TT_DETAIL_FALSE_RESULT_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+namespace boost {
+namespace type_traits {
+
+// Utility class which always "returns" false
+struct false_result
+{
+    template <typename T> struct result_
+    {
+        BOOST_STATIC_CONSTANT(bool, value = false);
+    };
+};
+
+}} // namespace boost::type_traits
+
+#endif // BOOST_TT_DETAIL_FALSE_RESULT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_pod.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_pod.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_pod.hpp	(working copy)
@@ -0,0 +1,143 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_POD_HPP_INCLUDED
+#define BOOST_TT_IS_POD_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/is_void.hpp>
+#include <boost/type_traits/is_scalar.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+#include <boost/type_traits/intrinsics.hpp>
+
+#include <cstddef>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+#ifndef BOOST_IS_POD
+#define BOOST_INTERNAL_IS_POD(T) false
+#else
+#define BOOST_INTERNAL_IS_POD(T) BOOST_IS_POD(T)
+#endif
+
+namespace boost {
+
+// forward declaration, needed by 'is_pod_array_helper' template below
+template< typename T > struct is_POD;
+
+namespace detail {
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+template <typename T> struct is_pod_impl
+{
+    BOOST_STATIC_CONSTANT(
+        bool, value =
+        (::boost::type_traits::ice_or<
+            ::boost::is_scalar<T>::value,
+            ::boost::is_void<T>::value,
+            BOOST_INTERNAL_IS_POD(T)
+         >::value));
+};
+
+#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+template <typename T, std::size_t sz>
+struct is_pod_impl<T[sz]>
+    : public is_pod_impl<T>
+{
+};
+#endif
+
+#else
+
+template <bool is_array = false>
+struct is_pod_helper
+{
+    template <typename T> struct result_
+    {
+        BOOST_STATIC_CONSTANT(
+            bool, value =
+            (::boost::type_traits::ice_or<
+                ::boost::is_scalar<T>::value,
+                ::boost::is_void<T>::value,
+                BOOST_INTERNAL_IS_POD(T)
+            >::value));
+    };
+};
+
+template <bool b>
+struct bool_to_yes_no_type
+{
+    typedef ::boost::type_traits::no_type type;
+};
+
+template <>
+struct bool_to_yes_no_type<true>
+{
+    typedef ::boost::type_traits::yes_type type;
+};
+
+template <typename ArrayType>
+struct is_pod_array_helper
+{
+    enum { is_pod = ::boost::is_POD<ArrayType>::value }; // MSVC workaround
+    typedef typename bool_to_yes_no_type<is_pod>::type type;
+    type instance() const;
+};
+
+template <typename T>
+is_pod_array_helper<T> is_POD_array(T*);
+
+template <>
+struct is_pod_helper<true>
+{
+    template <typename T> struct result_
+    {
+        static T& help();
+        BOOST_STATIC_CONSTANT(bool, value =
+            sizeof(is_POD_array(help()).instance()) == sizeof(::boost::type_traits::yes_type)
+            );
+    };
+};
+
+
+template <typename T> struct is_pod_impl
+{
+   BOOST_STATIC_CONSTANT(
+       bool, value = (
+           ::boost::detail::is_pod_helper<
+              ::boost::is_array<T>::value
+           >::template result_<T>::value
+           )
+       );
+};
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+// the following help compilers without partial specialization support:
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,void,true)
+
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,void const,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,void volatile,true)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pod,void const volatile,true)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_POD,T,::boost::detail::is_pod_impl<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_pod,T,::boost::detail::is_pod_impl<T>::value)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#undef BOOST_INTERNAL_IS_POD
+
+#endif // BOOST_TT_IS_POD_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/integral_constant.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/integral_constant.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/integral_constant.hpp	(working copy)
@@ -0,0 +1,53 @@
+//  (C) Copyright John Maddock 2005.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TYPE_TRAITS_INTEGRAL_CONSTANT_HPP
+#define BOOST_TYPE_TRAITS_INTEGRAL_CONSTANT_HPP
+
+#include <boost/config.hpp>
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/integral_c.hpp>
+
+namespace boost{
+
+#if defined(BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS) || defined(__BORLANDC__)
+template <class T, int val>
+#else
+template <class T, T val>
+#endif
+struct integral_constant : public mpl::integral_c<T, val>
+{
+   typedef integral_constant<T,val> type;
+};
+
+template<> struct integral_constant<bool,true> : public mpl::true_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+# pragma warning(push)
+# pragma warning(disable:4097)
+   typedef mpl::true_ base_;
+   using base_::value;
+# pragma warning(pop)
+#endif
+   typedef integral_constant<bool,true> type;
+};
+template<> struct integral_constant<bool,false> : public mpl::false_
+{
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+# pragma warning(push)
+# pragma warning(disable:4097)
+   typedef mpl::false_ base_;
+   using base_::value;
+# pragma warning(pop)
+#endif
+   typedef integral_constant<bool,false> type;
+};
+
+typedef integral_constant<bool,true> true_type;
+typedef integral_constant<bool,false> false_type;
+
+}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_function.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_function.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_function.hpp	(working copy)
@@ -0,0 +1,106 @@
+
+//  Copyright 2000 John Maddock (john@johnmaddock.co.uk)
+//  Copyright 2002 Aleksey Gurtovoy (agurtovoy@meta-comm.com)
+//
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_FUNCTION_HPP_INCLUDED
+#define BOOST_TT_IS_FUNCTION_HPP_INCLUDED
+
+#include <boost/type_traits/is_reference.hpp>
+#include <boost/type_traits/detail/false_result.hpp>
+#include <boost/config.hpp>
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_TT_TEST_MS_FUNC_SIGS)
+#   include <boost/type_traits/detail/is_function_ptr_helper.hpp>
+#else
+#   include <boost/type_traits/detail/is_function_ptr_tester.hpp>
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+// is a type a function?
+// Please note that this implementation is unnecessarily complex:
+// we could just use !is_convertible<T*, const volatile void*>::value,
+// except that some compilers erroneously allow conversions from
+// function pointers to void*.
+
+namespace boost {
+
+#if !defined( __CODEGEARC__ )
+
+namespace detail {
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_TT_TEST_MS_FUNC_SIGS)
+template<bool is_ref = true>
+struct is_function_chooser
+    : public ::boost::type_traits::false_result
+{
+};
+
+template <>
+struct is_function_chooser<false>
+{
+    template< typename T > struct result_
+        : public ::boost::type_traits::is_function_ptr_helper<T*>
+    {
+    };
+};
+
+template <typename T>
+struct is_function_impl
+    : public is_function_chooser< ::boost::is_reference<T>::value >
+        ::BOOST_NESTED_TEMPLATE result_<T>
+{
+};
+
+#else
+
+template <typename T>
+struct is_function_impl
+{
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(push)
+#pragma warning(disable:6334)
+#endif
+    static T* t;
+    BOOST_STATIC_CONSTANT(
+        bool, value = sizeof(::boost::type_traits::is_function_ptr_tester(t))
+        == sizeof(::boost::type_traits::yes_type)
+        );
+#if BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, >= 140050000)
+#pragma warning(pop)
+#endif
+};
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+template <typename T>
+struct is_function_impl<T&> : public false_type
+{};
+#endif
+
+#endif
+
+} // namespace detail
+
+#endif // !defined( __CODEGEARC__ )
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_function,T,__is_function(T))
+#else
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_function,T,::boost::detail::is_function_impl<T>::value)
+#ifndef BOOST_NO_RVALUE_REFERENCES
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_function,T&&,false)
+#endif
+#endif
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_FUNCTION_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_rvalue_reference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_rvalue_reference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_rvalue_reference.hpp	(working copy)
@@ -0,0 +1,66 @@
+//  add_rvalue_reference.hpp  ---------------------------------------------------------//
+
+//  Copyright 2010 Vicente J. Botet Escriba
+
+//  Distributed under the Boost Software License, Version 1.0.
+//  See http://www.boost.org/LICENSE_1_0.txt
+
+#ifndef BOOST_TYPE_TRAITS_EXT_ADD_RVALUE_REFERENCE__HPP
+#define BOOST_TYPE_TRAITS_EXT_ADD_RVALUE_REFERENCE__HPP
+
+#include <boost/config.hpp>
+
+//----------------------------------------------------------------------------//
+
+#include <boost/type_traits/is_void.hpp>
+#include <boost/type_traits/is_reference.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+//----------------------------------------------------------------------------//
+//                                                                            //
+//                           C++03 implementation of                          //
+//             20.7.6.2 Reference modifications [meta.trans.ref]              //
+//                          Written by Vicente J. Botet Escriba               //
+//                                                                            //
+// If T names an object or function type then the member typedef type
+// shall name T&&; otherwise, type shall name T. [ Note: This rule reflects
+// the semantics of reference collapsing. For example, when a type T names
+// a type T1&, the type add_rvalue_reference<T>::type is not an rvalue
+// reference. -end note ]
+//----------------------------------------------------------------------------//
+
+namespace boost {
+
+namespace type_traits_detail {
+
+    template <typename T, bool b>
+    struct add_rvalue_reference_helper
+    { typedef T   type; };
+
+#if !defined(BOOST_NO_RVALUE_REFERENCES) && !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+    template <typename T>
+    struct add_rvalue_reference_helper<T, true>
+    {
+        typedef T&&   type;
+    };
+#endif
+
+    template <typename T>
+    struct add_rvalue_reference_imp
+    {
+       typedef typename boost::type_traits_detail::add_rvalue_reference_helper
+                  <T, (!is_void<T>::value && !is_reference<T>::value) >::type type;
+    };
+
+}
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(add_rvalue_reference,T,typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type)
+
+}  // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif  // BOOST_TYPE_TRAITS_EXT_ADD_RVALUE_REFERENCE__HPP
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_nothrow_copy.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_nothrow_copy.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/has_nothrow_copy.hpp	(working copy)
@@ -0,0 +1,53 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_HAS_NOTHROW_COPY_HPP_INCLUDED
+#define BOOST_TT_HAS_NOTHROW_COPY_HPP_INCLUDED
+
+#include <boost/type_traits/has_trivial_copy.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail{
+
+template <class T>
+struct has_nothrow_copy_imp{
+#ifdef BOOST_HAS_NOTHROW_COPY
+   BOOST_STATIC_CONSTANT(bool, value = BOOST_HAS_NOTHROW_COPY(T));
+#else
+   BOOST_STATIC_CONSTANT(bool, value = ::boost::has_trivial_copy<T>::value);
+#endif
+};
+
+}
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_nothrow_copy,T,::boost::detail::has_nothrow_copy_imp<T>::value)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(has_nothrow_copy_constructor,T,::boost::detail::has_nothrow_copy_imp<T>::value)
+
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy,void const volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy,void volatile,false)
+#endif
+
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy_constructor,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy_constructor,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy_constructor,void const volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(has_nothrow_copy_constructor,void volatile,false)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_HAS_NOTHROW_COPY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_pointer.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_pointer.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/add_pointer.hpp	(working copy)
@@ -0,0 +1,72 @@
+
+// (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_ADD_POINTER_HPP_INCLUDED
+#define BOOST_TT_ADD_POINTER_HPP_INCLUDED
+
+#include <boost/type_traits/remove_reference.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+#if defined(__BORLANDC__) && (__BORLANDC__ < 0x5A0)
+//
+// For some reason this implementation stops Borlands compiler
+// from dropping cv-qualifiers, it still fails with references
+// to arrays for some reason though (shrug...) (JM 20021104)
+//
+template <typename T>
+struct add_pointer_impl
+{
+    typedef T* type;
+};
+template <typename T>
+struct add_pointer_impl<T&>
+{
+    typedef T* type;
+};
+template <typename T>
+struct add_pointer_impl<T&const>
+{
+    typedef T* type;
+};
+template <typename T>
+struct add_pointer_impl<T&volatile>
+{
+    typedef T* type;
+};
+template <typename T>
+struct add_pointer_impl<T&const volatile>
+{
+    typedef T* type;
+};
+
+#else
+
+template <typename T>
+struct add_pointer_impl
+{
+    typedef typename remove_reference<T>::type no_ref_type;
+    typedef no_ref_type* type;
+};
+
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(add_pointer,T,typename boost::detail::add_pointer_impl<T>::type)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_ADD_POINTER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_reference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_reference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_reference.hpp	(working copy)
@@ -0,0 +1,45 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000, 2010.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_REFERENCE_HPP_INCLUDED
+#define BOOST_TT_IS_REFERENCE_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+#include <boost/type_traits/is_lvalue_reference.hpp>
+#include <boost/type_traits/is_rvalue_reference.hpp>
+#include <boost/type_traits/ice.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+namespace detail {
+
+template <typename T>
+struct is_reference_impl
+{
+   BOOST_STATIC_CONSTANT(bool, value =
+      (::boost::type_traits::ice_or<
+         ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value
+       >::value));
+};
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_reference,T,::boost::detail::is_reference_impl<T>::value)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_REFERENCE_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_void.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_void.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_void.hpp	(working copy)
@@ -0,0 +1,38 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_VOID_HPP_INCLUDED
+#define BOOST_TT_IS_VOID_HPP_INCLUDED
+
+#include <boost/config.hpp>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+//* is a type T void - is_void<T>
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_void,T,__is_void(T))
+#else
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_void,T,false)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(is_void,void,true)
+
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(is_void,void const,true)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(is_void,void volatile,true)
+BOOST_TT_AUX_BOOL_TRAIT_SPEC1(is_void,void const volatile,true)
+#endif
+
+#endif  // non-CodeGear implementation
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_VOID_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_float.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_float.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_float.hpp	(working copy)
@@ -0,0 +1,27 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TYPE_TRAITS_IS_FLOAT_HPP_INCLUDED
+#define BOOST_TYPE_TRAITS_IS_FLOAT_HPP_INCLUDED
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+//* is a type T a floating-point type described in the standard (3.9.1p8)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_float,T,false)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_float,float,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_float,double,true)
+BOOST_TT_AUX_BOOL_TRAIT_CV_SPEC1(is_float,long double,true)
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TYPE_TRAITS_IS_FLOAT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/alignment_of.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/alignment_of.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/alignment_of.hpp	(working copy)
@@ -0,0 +1,128 @@
+
+//  (C) Copyright John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_ALIGNMENT_OF_HPP_INCLUDED
+#define BOOST_TT_ALIGNMENT_OF_HPP_INCLUDED
+
+#include <boost/config.hpp>
+#include <cstddef>
+
+#include <boost/type_traits/intrinsics.hpp>
+// should be the last #include
+#include <boost/type_traits/detail/size_t_trait_def.hpp>
+
+#ifdef BOOST_MSVC
+#   pragma warning(push)
+#   pragma warning(disable: 4121 4512) // alignment is sensitive to packing
+#endif
+#if defined(__BORLANDC__) && (__BORLANDC__ < 0x600)
+#pragma option push -Vx- -Ve-
+#endif
+
+namespace boost {
+
+template <typename T> struct alignment_of;
+
+// get the alignment of some arbitrary type:
+namespace detail {
+
+#ifdef BOOST_MSVC
+#pragma warning(push)
+#pragma warning(disable:4324) // structure was padded due to __declspec(align())
+#endif
+template <typename T>
+struct alignment_of_hack
+{
+    char c;
+    T t;
+    alignment_of_hack();
+};
+#ifdef BOOST_MSVC
+#pragma warning(pop)
+#endif
+
+template <unsigned A, unsigned S>
+struct alignment_logic
+{
+    BOOST_STATIC_CONSTANT(std::size_t, value = A < S ? A : S);
+};
+
+
+template< typename T >
+struct alignment_of_impl
+{
+#if defined(BOOST_MSVC) && (BOOST_MSVC >= 1400)
+    //
+    // With MSVC both the native __alignof operator
+    // and our own logic gets things wrong from time to time :-(
+    // Using a combination of the two seems to make the most of a bad job:
+    //
+    BOOST_STATIC_CONSTANT(std::size_t, value =
+        (::boost::detail::alignment_logic<
+            sizeof(::boost::detail::alignment_of_hack<T>) - sizeof(T),
+            __alignof(T)
+        >::value));
+#elif !defined(BOOST_ALIGNMENT_OF)
+    BOOST_STATIC_CONSTANT(std::size_t, value =
+        (::boost::detail::alignment_logic<
+            sizeof(::boost::detail::alignment_of_hack<T>) - sizeof(T),
+            sizeof(T)
+        >::value));
+#else
+   //
+   // We put this here, rather than in the definition of
+   // alignment_of below, because MSVC's __alignof doesn't
+   // always work in that context for some unexplained reason.
+   // (See type_with_alignment tests for test cases).
+   //
+   BOOST_STATIC_CONSTANT(std::size_t, value = BOOST_ALIGNMENT_OF(T));
+#endif
+};
+
+} // namespace detail
+
+BOOST_TT_AUX_SIZE_T_TRAIT_DEF1(alignment_of,T,::boost::detail::alignment_of_impl<T>::value)
+
+// references have to be treated specially, assume
+// that a reference is just a special pointer:
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+template <typename T>
+struct alignment_of<T&>
+    : public alignment_of<T*>
+{
+};
+#endif
+#ifdef __BORLANDC__
+// long double gives an incorrect value of 10 (!)
+// unless we do this...
+struct long_double_wrapper{ long double ld; };
+template<> struct alignment_of<long double>
+   : public alignment_of<long_double_wrapper>{};
+#endif
+
+// void has to be treated specially:
+BOOST_TT_AUX_SIZE_T_TRAIT_SPEC1(alignment_of,void,0)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_SIZE_T_TRAIT_SPEC1(alignment_of,void const,0)
+BOOST_TT_AUX_SIZE_T_TRAIT_SPEC1(alignment_of,void volatile,0)
+BOOST_TT_AUX_SIZE_T_TRAIT_SPEC1(alignment_of,void const volatile,0)
+#endif
+
+} // namespace boost
+
+#if defined(__BORLANDC__) && (__BORLANDC__ < 0x600)
+#pragma option pop
+#endif
+#ifdef BOOST_MSVC
+#   pragma warning(pop)
+#endif
+
+#include <boost/type_traits/detail/size_t_trait_undef.hpp>
+
+#endif // BOOST_TT_ALIGNMENT_OF_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/config.hpp	(working copy)
@@ -0,0 +1,76 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_CONFIG_HPP_INCLUDED
+#define BOOST_TT_CONFIG_HPP_INCLUDED
+
+#ifndef BOOST_CONFIG_HPP
+#include <boost/config.hpp>
+#endif
+
+#include <boost/detail/workaround.hpp>
+
+//
+// whenever we have a conversion function with elipses
+// it needs to be declared __cdecl to suppress compiler
+// warnings from MS and Borland compilers (this *must*
+// appear before we include is_same.hpp below):
+#if defined(BOOST_MSVC) || (defined(__BORLANDC__) && !defined(BOOST_DISABLE_WIN32))
+#   define BOOST_TT_DECL __cdecl
+#else
+#   define BOOST_TT_DECL /**/
+#endif
+
+# if (BOOST_WORKAROUND(__MWERKS__, < 0x3000)                         \
+    || BOOST_WORKAROUND(BOOST_MSVC, <= 1301)                        \
+    || !defined(__EDG_VERSION__) && BOOST_WORKAROUND(__GNUC__, < 3) \
+    || BOOST_WORKAROUND(__IBMCPP__, < 600 )                         \
+    || BOOST_WORKAROUND(__BORLANDC__, < 0x5A0)                      \
+    || defined(__ghs)                                               \
+    || BOOST_WORKAROUND(__HP_aCC, < 60700)           \
+    || BOOST_WORKAROUND(MPW_CPLUS, BOOST_TESTED_AT(0x890))          \
+    || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x580)))       \
+    && defined(BOOST_NO_IS_ABSTRACT)
+
+#   define BOOST_TT_NO_CONFORMING_IS_CLASS_IMPLEMENTATION 1
+
+#endif
+
+#ifndef BOOST_TT_NO_CONFORMING_IS_CLASS_IMPLEMENTATION
+# define BOOST_TT_HAS_CONFORMING_IS_CLASS_IMPLEMENTATION 1
+#endif
+
+//
+// Define BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+// when we can't test for function types with elipsis:
+//
+#if BOOST_WORKAROUND(__GNUC__, < 3)
+#  define BOOST_TT_NO_ELLIPSIS_IN_FUNC_TESTING
+#endif
+
+//
+// define BOOST_TT_TEST_MS_FUNC_SIGS
+// when we want to test __stdcall etc function types with is_function etc
+// (Note, does not work with Borland, even though it does support __stdcall etc):
+//
+#if defined(_MSC_EXTENSIONS) && !defined(__BORLANDC__)
+#  define BOOST_TT_TEST_MS_FUNC_SIGS
+#endif
+
+//
+// define BOOST_TT_NO_CV_FUNC_TEST
+// if tests for cv-qualified member functions don't
+// work in is_member_function_pointer
+//
+#if BOOST_WORKAROUND(__MWERKS__, < 0x3000) || BOOST_WORKAROUND(__IBMCPP__, <= 600)
+#  define BOOST_TT_NO_CV_FUNC_TEST
+#endif
+
+#endif // BOOST_TT_CONFIG_HPP_INCLUDED
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_array.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_array.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_array.hpp	(working copy)
@@ -0,0 +1,91 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+// Some fixes for is_array are based on a newgroup posting by Jonathan Lundquist.
+
+
+#ifndef BOOST_TT_IS_ARRAY_HPP_INCLUDED
+#define BOOST_TT_IS_ARRAY_HPP_INCLUDED
+
+#include <boost/type_traits/config.hpp>
+
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/type_traits/detail/yes_no_type.hpp>
+#   include <boost/type_traits/detail/wrap.hpp>
+#endif
+
+#include <cstddef>
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_array,T,__is_array(T))
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_array,T,false)
+#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,is_array,T[N],true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,is_array,T const[N],true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,is_array,T volatile[N],true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,is_array,T const volatile[N],true)
+#if !BOOST_WORKAROUND(__BORLANDC__, < 0x600) && !defined(__IBMCPP__) &&  !BOOST_WORKAROUND(__DMC__, BOOST_TESTED_AT(0x840))
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_array,T[],true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_array,T const[],true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_array,T volatile[],true)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_array,T const volatile[],true)
+#endif
+#endif
+
+#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+namespace detail {
+
+using ::boost::type_traits::yes_type;
+using ::boost::type_traits::no_type;
+using ::boost::type_traits::wrap;
+
+template< typename T > T(* is_array_tester1(wrap<T>) )(wrap<T>);
+char BOOST_TT_DECL is_array_tester1(...);
+
+template< typename T> no_type is_array_tester2(T(*)(wrap<T>));
+yes_type BOOST_TT_DECL is_array_tester2(...);
+
+template< typename T >
+struct is_array_impl
+{
+    BOOST_STATIC_CONSTANT(bool, value =
+        sizeof(::boost::detail::is_array_tester2(
+            ::boost::detail::is_array_tester1(
+                ::boost::type_traits::wrap<T>()
+                )
+        )) == 1
+    );
+};
+
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_array,void,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_array,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_array,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_array,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_array,T,::boost::detail::is_array_impl<T>::value)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_ARRAY_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_pointer.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_pointer.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_pointer.hpp	(working copy)
@@ -0,0 +1,162 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes,
+//      Howard Hinnant and John Maddock 2000.
+//  (C) Copyright Mat Marcus, Jesse Jones and Adobe Systems Inc 2001
+
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+//    Fixed is_pointer, is_reference, is_const, is_volatile, is_same,
+//    is_member_pointer based on the Simulated Partial Specialization work
+//    of Mat Marcus and Jesse Jones. See  http://opensource.adobe.com or
+//    http://groups.yahoo.com/group/boost/message/5441
+//    Some workarounds in here use ideas suggested from "Generic<Programming>:
+//    Mappings between Types and Values"
+//    by Andrei Alexandrescu (see http://www.cuj.com/experts/1810/alexandr.html).
+
+
+#ifndef BOOST_TT_IS_POINTER_HPP_INCLUDED
+#define BOOST_TT_IS_POINTER_HPP_INCLUDED
+
+#include <boost/type_traits/is_member_pointer.hpp>
+#include <boost/type_traits/detail/ice_and.hpp>
+#include <boost/type_traits/detail/ice_not.hpp>
+#include <boost/type_traits/config.hpp>
+#if !BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+#include <boost/type_traits/remove_cv.hpp>
+#endif
+
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_array.hpp>
+#   include <boost/type_traits/detail/is_function_ptr_tester.hpp>
+#   include <boost/type_traits/detail/false_result.hpp>
+#   include <boost/type_traits/detail/ice_or.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if defined( __CODEGEARC__ )
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_pointer,T,__is_pointer(T))
+#elif !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+namespace detail {
+
+template< typename T > struct is_pointer_helper
+{
+    BOOST_STATIC_CONSTANT(bool, value = false);
+};
+
+#   define TT_AUX_BOOL_TRAIT_HELPER_PARTIAL_SPEC(helper,sp,result) \
+template< typename T > struct helper<sp> \
+{ \
+    BOOST_STATIC_CONSTANT(bool, value = result); \
+}; \
+/**/
+
+TT_AUX_BOOL_TRAIT_HELPER_PARTIAL_SPEC(is_pointer_helper,T*,true)
+
+#   undef TT_AUX_BOOL_TRAIT_HELPER_PARTIAL_SPEC
+
+template< typename T >
+struct is_pointer_impl
+{
+#if BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::type_traits::ice_and<
+              ::boost::detail::is_pointer_helper<T>::value
+            , ::boost::type_traits::ice_not<
+                ::boost::is_member_pointer<T>::value
+                >::value
+            >::value)
+        );
+#else
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::type_traits::ice_and<
+        ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value
+            , ::boost::type_traits::ice_not<
+                ::boost::is_member_pointer<T>::value
+                >::value
+            >::value)
+        );
+#endif
+};
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_pointer,T,::boost::detail::is_pointer_impl<T>::value)
+
+#if defined(__BORLANDC__) && !defined(__COMO__) && (__BORLANDC__ < 0x600)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_pointer,T&,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_pointer,T& const,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_pointer,T& volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_PARTIAL_SPEC1_1(typename T,is_pointer,T& const volatile,false)
+#endif
+
+#else // no partial template specialization
+
+namespace detail {
+
+struct pointer_helper
+{
+    pointer_helper(const volatile void*);
+};
+
+yes_type BOOST_TT_DECL is_pointer_tester(pointer_helper);
+no_type BOOST_TT_DECL is_pointer_tester(...);
+
+template <bool>
+struct is_pointer_select
+    : public ::boost::type_traits::false_result
+{
+};
+
+template <>
+struct is_pointer_select<false>
+{
+    template <typename T> struct result_
+    {
+        static T& make_t();
+        BOOST_STATIC_CONSTANT(bool, value =
+                (::boost::type_traits::ice_or<
+                    (1 == sizeof(is_pointer_tester(make_t()))),
+                    (1 == sizeof(type_traits::is_function_ptr_tester(make_t())))
+                >::value));
+    };
+};
+
+template <typename T>
+struct is_pointer_impl
+    : public is_pointer_select<
+          ::boost::type_traits::ice_or<
+              ::boost::is_reference<T>::value
+            , ::boost::is_array<T>::value
+            >::value
+        >::template result_<T>
+{
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pointer,void,false)
+#ifndef BOOST_NO_CV_VOID_SPECIALIZATIONS
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pointer,void const,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pointer,void volatile,false)
+BOOST_TT_AUX_BOOL_TRAIT_IMPL_SPEC1(is_pointer,void const volatile,false)
+#endif
+
+} // namespace detail
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_pointer,T,::boost::detail::is_pointer_impl<T>::value)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_POINTER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/broken_compiler_spec.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/broken_compiler_spec.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/broken_compiler_spec.hpp	(working copy)
@@ -0,0 +1,117 @@
+
+//  Copyright 2001-2003 Aleksey Gurtovoy.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_BROKEN_COMPILER_SPEC_HPP_INCLUDED
+#define BOOST_TT_BROKEN_COMPILER_SPEC_HPP_INCLUDED
+
+#include <boost/mpl/aux_/lambda_support.hpp>
+#include <boost/config.hpp>
+
+// these are needed regardless of BOOST_TT_NO_BROKEN_COMPILER_SPEC
+#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+namespace boost { namespace detail {
+template< typename T > struct remove_const_impl     { typedef T type; };
+template< typename T > struct remove_volatile_impl  { typedef T type; };
+template< typename T > struct remove_pointer_impl   { typedef T type; };
+template< typename T > struct remove_reference_impl { typedef T type; };
+typedef int invoke_BOOST_TT_BROKEN_COMPILER_SPEC_outside_all_namespaces;
+}}
+#endif
+
+// agurt, 27/jun/03: disable the workaround if user defined
+// BOOST_TT_NO_BROKEN_COMPILER_SPEC
+#if    !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+    || defined(BOOST_TT_NO_BROKEN_COMPILER_SPEC)
+
+#   define BOOST_TT_BROKEN_COMPILER_SPEC(T) /**/
+
+#else
+
+// same as BOOST_TT_AUX_TYPE_TRAIT_IMPL_SPEC1 macro, except that it
+// never gets #undef-ined
+#   define BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(trait,spec,result) \
+template<> struct trait##_impl<spec> \
+{ \
+    typedef result type; \
+}; \
+/**/
+
+#   define BOOST_TT_AUX_REMOVE_CONST_VOLATILE_RANK1_SPEC(T)                         \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_const,T const,T)                    \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_const,T const volatile,T volatile)  \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_volatile,T volatile,T)              \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_volatile,T const volatile,T const)  \
+    /**/
+
+#   define BOOST_TT_AUX_REMOVE_PTR_REF_RANK_1_SPEC(T)                               \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_pointer,T*,T)                       \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_pointer,T*const,T)                  \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_pointer,T*volatile,T)               \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_pointer,T*const volatile,T)         \
+    BOOST_TT_AUX_BROKEN_TYPE_TRAIT_SPEC1(remove_reference,T&,T)                     \
+    /**/
+
+#   define BOOST_TT_AUX_REMOVE_PTR_REF_RANK_2_SPEC(T)                               \
+    BOOST_TT_AUX_REMOVE_PTR_REF_RANK_1_SPEC(T)                                      \
+    BOOST_TT_AUX_REMOVE_PTR_REF_RANK_1_SPEC(T const)                                \
+    BOOST_TT_AUX_REMOVE_PTR_REF_RANK_1_SPEC(T volatile)                             \
+    BOOST_TT_AUX_REMOVE_PTR_REF_RANK_1_SPEC(T const volatile)                       \
+    /**/
+
+#   define BOOST_TT_AUX_REMOVE_ALL_RANK_1_SPEC(T)                                   \
+    BOOST_TT_AUX_REMOVE_PTR_REF_RANK_2_SPEC(T)                                      \
+    BOOST_TT_AUX_REMOVE_CONST_VOLATILE_RANK1_SPEC(T)                                \
+    /**/
+
+#   define BOOST_TT_AUX_REMOVE_ALL_RANK_2_SPEC(T)                                   \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_1_SPEC(T*)                                         \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_1_SPEC(T const*)                                   \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_1_SPEC(T volatile*)                                \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_1_SPEC(T const volatile*)                          \
+    /**/
+
+#   define BOOST_TT_BROKEN_COMPILER_SPEC(T)                                         \
+    namespace boost { namespace detail {                                            \
+    typedef invoke_BOOST_TT_BROKEN_COMPILER_SPEC_outside_all_namespaces             \
+      please_invoke_BOOST_TT_BROKEN_COMPILER_SPEC_outside_all_namespaces;           \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_1_SPEC(T)                                          \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_2_SPEC(T)                                          \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_2_SPEC(T*)                                         \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_2_SPEC(T const*)                                   \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_2_SPEC(T volatile*)                                \
+    BOOST_TT_AUX_REMOVE_ALL_RANK_2_SPEC(T const volatile*)                          \
+    }}                                                                              \
+    /**/
+
+#   include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+BOOST_TT_BROKEN_COMPILER_SPEC(bool)
+BOOST_TT_BROKEN_COMPILER_SPEC(char)
+#ifndef BOOST_NO_INTRINSIC_WCHAR_T
+BOOST_TT_BROKEN_COMPILER_SPEC(wchar_t)
+#endif
+BOOST_TT_BROKEN_COMPILER_SPEC(signed char)
+BOOST_TT_BROKEN_COMPILER_SPEC(unsigned char)
+BOOST_TT_BROKEN_COMPILER_SPEC(signed short)
+BOOST_TT_BROKEN_COMPILER_SPEC(unsigned short)
+BOOST_TT_BROKEN_COMPILER_SPEC(signed int)
+BOOST_TT_BROKEN_COMPILER_SPEC(unsigned int)
+BOOST_TT_BROKEN_COMPILER_SPEC(signed long)
+BOOST_TT_BROKEN_COMPILER_SPEC(unsigned long)
+BOOST_TT_BROKEN_COMPILER_SPEC(float)
+BOOST_TT_BROKEN_COMPILER_SPEC(double)
+//BOOST_TT_BROKEN_COMPILER_SPEC(long double)
+
+// for backward compatibility
+#define BOOST_BROKEN_COMPILER_TYPE_TRAITS_SPECIALIZATION(T) \
+    BOOST_TT_BROKEN_COMPILER_SPEC(T) \
+/**/
+
+#endif // BOOST_TT_BROKEN_COMPILER_SPEC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_arithmetic.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_arithmetic.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/is_arithmetic.hpp	(working copy)
@@ -0,0 +1,51 @@
+
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_IS_ARITHMETIC_HPP_INCLUDED
+#define BOOST_TT_IS_ARITHMETIC_HPP_INCLUDED
+
+#if !defined( __CODEGEARC__ )
+#include <boost/type_traits/is_integral.hpp>
+#include <boost/type_traits/is_float.hpp>
+#include <boost/type_traits/detail/ice_or.hpp>
+#include <boost/config.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/bool_trait_def.hpp>
+
+namespace boost {
+
+#if !defined(__CODEGEARC__)
+namespace detail {
+
+template< typename T >
+struct is_arithmetic_impl
+{
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::type_traits::ice_or<
+            ::boost::is_integral<T>::value,
+            ::boost::is_float<T>::value
+        >::value));
+};
+
+} // namespace detail
+#endif
+
+//* is a type T an arithmetic type described in the standard (3.9.1p8)
+#if defined(__CODEGEARC__)
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_arithmetic,T,__is_arithmetic(T))
+#else
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(is_arithmetic,T,::boost::detail::is_arithmetic_impl<T>::value)
+#endif
+
+} // namespace boost
+
+#include <boost/type_traits/detail/bool_trait_undef.hpp>
+
+#endif // BOOST_TT_IS_ARITHMETIC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_cv.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_cv.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/remove_cv.hpp	(working copy)
@@ -0,0 +1,84 @@
+
+//  (C) Copyright Dave Abrahams, Steve Cleary, Beman Dawes, Howard
+//  Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+
+#ifndef BOOST_TT_REMOVE_CV_HPP_INCLUDED
+#define BOOST_TT_REMOVE_CV_HPP_INCLUDED
+
+#include <boost/type_traits/broken_compiler_spec.hpp>
+#include <boost/type_traits/detail/cv_traits_impl.hpp>
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+
+#include <cstddef>
+
+#if BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+#include <boost/type_traits/msvc/remove_cv.hpp>
+#endif
+
+// should be the last #include
+#include <boost/type_traits/detail/type_trait_def.hpp>
+
+namespace boost {
+
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+namespace detail{
+
+template <class T>
+struct rvalue_ref_filter_rem_cv
+{
+   typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
+};
+
+#ifndef BOOST_NO_RVALUE_REFERENCES
+//
+// We can't filter out rvalue_references at the same level as
+// references or we get ambiguities from msvc:
+//
+template <class T>
+struct rvalue_ref_filter_rem_cv<T&&>
+{
+   typedef T&& type;
+};
+#endif
+
+}
+
+
+//  convert a type T to a non-cv-qualified type - remove_cv<T>
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_cv,T,typename boost::detail::rvalue_ref_filter_rem_cv<T>::type)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_1(typename T,remove_cv,T&,T&)
+#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,remove_cv,T const[N],T type[N])
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,remove_cv,T volatile[N],T type[N])
+BOOST_TT_AUX_TYPE_TRAIT_PARTIAL_SPEC1_2(typename T,std::size_t N,remove_cv,T const volatile[N],T type[N])
+#endif
+
+#elif !BOOST_WORKAROUND(BOOST_MSVC,<=1300)
+
+namespace detail {
+template <typename T>
+struct remove_cv_impl
+{
+    typedef typename remove_volatile_impl<
+          typename remove_const_impl<T>::type
+        >::type type;
+};
+}
+
+BOOST_TT_AUX_TYPE_TRAIT_DEF1(remove_cv,T,typename boost::detail::remove_cv_impl<T>::type)
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+} // namespace boost
+
+#include <boost/type_traits/detail/type_trait_undef.hpp>
+
+#endif // BOOST_TT_REMOVE_CV_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/intrinsics.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/intrinsics.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type_traits/intrinsics.hpp	(working copy)
@@ -0,0 +1,288 @@
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/type_traits for most recent version including documentation.
+
+#ifndef BOOST_TT_INTRINSICS_HPP_INCLUDED
+#define BOOST_TT_INTRINSICS_HPP_INCLUDED
+
+#ifndef BOOST_TT_CONFIG_HPP_INCLUDED
+#include <boost/type_traits/config.hpp>
+#endif
+
+//
+// Helper macros for builtin compiler support.
+// If your compiler has builtin support for any of the following
+// traits concepts, then redefine the appropriate macros to pick
+// up on the compiler support:
+//
+// (these should largely ignore cv-qualifiers)
+// BOOST_IS_UNION(T) should evaluate to true if T is a union type
+// BOOST_IS_POD(T) should evaluate to true if T is a POD type
+// BOOST_IS_EMPTY(T) should evaluate to true if T is an empty class type (and not a union)
+// BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) should evaluate to true if "T x;" has no effect
+// BOOST_HAS_TRIVIAL_COPY(T) should evaluate to true if T(t) <==> memcpy
+// BOOST_HAS_TRIVIAL_ASSIGN(T) should evaluate to true if t = u <==> memcpy
+// BOOST_HAS_TRIVIAL_DESTRUCTOR(T) should evaluate to true if ~T() has no effect
+// BOOST_HAS_NOTHROW_CONSTRUCTOR(T) should evaluate to true if "T x;" can not throw
+// BOOST_HAS_NOTHROW_COPY(T) should evaluate to true if T(t) can not throw
+// BOOST_HAS_NOTHROW_ASSIGN(T) should evaluate to true if t = u can not throw
+// BOOST_HAS_VIRTUAL_DESTRUCTOR(T) should evaluate to true T has a virtual destructor
+//
+// The following can also be defined: when detected our implementation is greatly simplified.
+//
+// BOOST_IS_ABSTRACT(T) true if T is an abstract type
+// BOOST_IS_BASE_OF(T,U) true if T is a base class of U
+// BOOST_IS_CLASS(T) true if T is a class type (and not a union)
+// BOOST_IS_CONVERTIBLE(T,U) true if T is convertible to U
+// BOOST_IS_ENUM(T) true is T is an enum
+// BOOST_IS_POLYMORPHIC(T) true if T is a polymorphic type
+// BOOST_ALIGNMENT_OF(T) should evaluate to the alignment requirements of type T.
+
+#ifdef BOOST_HAS_SGI_TYPE_TRAITS
+    // Hook into SGI's __type_traits class, this will pick up user supplied
+    // specializations as well as SGI - compiler supplied specializations.
+#   include <boost/type_traits/is_same.hpp>
+#   ifdef __NetBSD__
+      // There are two different versions of type_traits.h on NetBSD on Spark
+      // use an implicit include via algorithm instead, to make sure we get
+      // the same version as the std lib:
+#     include <algorithm>
+#   else
+#    include <type_traits.h>
+#   endif
+#   define BOOST_IS_POD(T) ::boost::is_same< typename ::__type_traits<T>::is_POD_type, ::__true_type>::value
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) ::boost::is_same< typename ::__type_traits<T>::has_trivial_default_constructor, ::__true_type>::value
+#   define BOOST_HAS_TRIVIAL_COPY(T) ::boost::is_same< typename ::__type_traits<T>::has_trivial_copy_constructor, ::__true_type>::value
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) ::boost::is_same< typename ::__type_traits<T>::has_trivial_assignment_operator, ::__true_type>::value
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) ::boost::is_same< typename ::__type_traits<T>::has_trivial_destructor, ::__true_type>::value
+
+#   ifdef __sgi
+#      define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#   endif
+#endif
+
+#if defined(__MSL_CPP__) && (__MSL_CPP__ >= 0x8000)
+    // Metrowerks compiler is acquiring intrinsic type traits support
+    // post version 8.  We hook into the published interface to pick up
+    // user defined specializations as well as compiler intrinsics as
+    // and when they become available:
+#   include <msl_utility>
+#   define BOOST_IS_UNION(T) BOOST_STD_EXTENSION_NAMESPACE::is_union<T>::value
+#   define BOOST_IS_POD(T) BOOST_STD_EXTENSION_NAMESPACE::is_POD<T>::value
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) BOOST_STD_EXTENSION_NAMESPACE::has_trivial_default_ctor<T>::value
+#   define BOOST_HAS_TRIVIAL_COPY(T) BOOST_STD_EXTENSION_NAMESPACE::has_trivial_copy_ctor<T>::value
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) BOOST_STD_EXTENSION_NAMESPACE::has_trivial_assignment<T>::value
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) BOOST_STD_EXTENSION_NAMESPACE::has_trivial_dtor<T>::value
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+#if defined(BOOST_MSVC) && defined(BOOST_MSVC_FULL_VER) && (BOOST_MSVC_FULL_VER >=140050215)
+#   include <boost/type_traits/is_same.hpp>
+
+#   define BOOST_IS_UNION(T) __is_union(T)
+#   define BOOST_IS_POD(T) (__is_pod(T) && __has_trivial_constructor(T))
+#   define BOOST_IS_EMPTY(T) __is_empty(T)
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) __has_trivial_constructor(T)
+#   define BOOST_HAS_TRIVIAL_COPY(T) (__has_trivial_copy(T)|| ( ::boost::is_pod<T>::value && !::boost::is_volatile<T>::value))
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) (__has_trivial_assign(T) || ( ::boost::is_pod<T>::value && ! ::boost::is_const<T>::value && !::boost::is_volatile<T>::value))
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) (__has_trivial_destructor(T) || ::boost::is_pod<T>::value)
+#   define BOOST_HAS_NOTHROW_CONSTRUCTOR(T) (__has_nothrow_constructor(T) || ::boost::has_trivial_constructor<T>::value)
+#   define BOOST_HAS_NOTHROW_COPY(T) (__has_nothrow_copy(T) || ::boost::has_trivial_copy<T>::value)
+#   define BOOST_HAS_NOTHROW_ASSIGN(T) (__has_nothrow_assign(T) || ::boost::has_trivial_assign<T>::value)
+#   define BOOST_HAS_VIRTUAL_DESTRUCTOR(T) __has_virtual_destructor(T)
+
+#   define BOOST_IS_ABSTRACT(T) __is_abstract(T)
+#   define BOOST_IS_BASE_OF(T,U) (__is_base_of(T,U) && !is_same<T,U>::value)
+#   define BOOST_IS_CLASS(T) __is_class(T)
+#   define BOOST_IS_CONVERTIBLE(T,U) ((__is_convertible_to(T,U) || is_same<T,U>::value) && !__is_abstract(U))
+#   define BOOST_IS_ENUM(T) __is_enum(T)
+//  This one doesn't quite always do the right thing:
+//  #   define BOOST_IS_POLYMORPHIC(T) __is_polymorphic(T)
+//  This one fails if the default alignment has been changed with /Zp:
+//  #   define BOOST_ALIGNMENT_OF(T) __alignof(T)
+
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+#if defined(__DMC__) && (__DMC__ >= 0x848)
+// For Digital Mars C++, www.digitalmars.com
+#   define BOOST_IS_UNION(T) (__typeinfo(T) & 0x400)
+#   define BOOST_IS_POD(T) (__typeinfo(T) & 0x800)
+#   define BOOST_IS_EMPTY(T) (__typeinfo(T) & 0x1000)
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) (__typeinfo(T) & 0x10)
+#   define BOOST_HAS_TRIVIAL_COPY(T) (__typeinfo(T) & 0x20)
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) (__typeinfo(T) & 0x40)
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) (__typeinfo(T) & 0x8)
+#   define BOOST_HAS_NOTHROW_CONSTRUCTOR(T) (__typeinfo(T) & 0x80)
+#   define BOOST_HAS_NOTHROW_COPY(T) (__typeinfo(T) & 0x100)
+#   define BOOST_HAS_NOTHROW_ASSIGN(T) (__typeinfo(T) & 0x200)
+#   define BOOST_HAS_VIRTUAL_DESTRUCTOR(T) (__typeinfo(T) & 0x4)
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+#if defined(BOOST_CLANG) && defined(__has_feature)
+#   include <boost/type_traits/is_same.hpp>
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_volatile.hpp>
+
+#   if __has_feature(is_union)
+#     define BOOST_IS_UNION(T) __is_union(T)
+#   endif
+#   if __has_feature(is_pod) && defined(_LIBCPP_VERSION)
+#     define BOOST_IS_POD(T) __is_pod(T)
+#   endif
+#   if __has_feature(is_empty) && defined(_LIBCPP_VERSION)
+#     define BOOST_IS_EMPTY(T) __is_empty(T)
+#   endif
+#   if __has_feature(has_trivial_constructor)
+#     define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) __has_trivial_constructor(T)
+#   endif
+#   if __has_feature(has_trivial_copy)
+#     define BOOST_HAS_TRIVIAL_COPY(T) (__has_trivial_copy(T) && !is_reference<T>::value && !is_volatile<T>::value)
+#   endif
+#   if __has_feature(has_trivial_assign)
+#     define BOOST_HAS_TRIVIAL_ASSIGN(T) (__has_trivial_assign(T) && !is_volatile<T>::value)
+#   endif
+#   if __has_feature(has_trivial_destructor)
+#     define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) __has_trivial_destructor(T)
+#   endif
+#   if __has_feature(has_nothrow_constructor)
+#     define BOOST_HAS_NOTHROW_CONSTRUCTOR(T) __has_nothrow_constructor(T)
+#   endif
+#   if __has_feature(has_nothrow_copy)
+#     define BOOST_HAS_NOTHROW_COPY(T) (__has_nothrow_copy(T) && !is_volatile<T>::value && !is_reference<T>::value)
+#   endif
+#   if __has_feature(has_nothrow_assign)
+#     define BOOST_HAS_NOTHROW_ASSIGN(T) (__has_nothrow_assign(T) && !is_volatile<T>::value)
+#   endif
+#   if __has_feature(has_virtual_destructor)
+#     define BOOST_HAS_VIRTUAL_DESTRUCTOR(T) __has_virtual_destructor(T)
+#   endif
+#   if __has_feature(is_abstract)
+#     define BOOST_IS_ABSTRACT(T) __is_abstract(T)
+#   endif
+#   if __has_feature(is_base_of)
+#     define BOOST_IS_BASE_OF(T,U) (__is_base_of(T,U) && !is_same<T,U>::value)
+#   endif
+#   if __has_feature(is_class)
+#     define BOOST_IS_CLASS(T) __is_class(T)
+#   endif
+#   if __has_feature(is_convertible_to)
+#     include <boost/type_traits/is_abstract.hpp>
+#     define BOOST_IS_CONVERTIBLE(T,U) (__is_convertible_to(T,U) && !::boost::is_abstract<U>::value)
+#   endif
+#   if __has_feature(is_enum)
+#     define BOOST_IS_ENUM(T) __is_enum(T)
+#   endif
+#   if __has_feature(is_polymorphic)
+#     define BOOST_IS_POLYMORPHIC(T) __is_polymorphic(T)
+#   endif
+#   define BOOST_ALIGNMENT_OF(T) __alignof(T)
+
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+#if defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3) && !defined(__GCCXML__)))
+#   include <boost/type_traits/is_same.hpp>
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_volatile.hpp>
+
+#ifdef BOOST_INTEL
+#  define BOOST_INTEL_TT_OPTS || is_pod<T>::value
+#else
+#  define BOOST_INTEL_TT_OPTS
+#endif
+
+#   define BOOST_IS_UNION(T) __is_union(T)
+#   define BOOST_IS_POD(T) __is_pod(T)
+#   define BOOST_IS_EMPTY(T) __is_empty(T)
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) ((__has_trivial_constructor(T) BOOST_INTEL_TT_OPTS) && ! ::boost::is_volatile<T>::value)
+#   define BOOST_HAS_TRIVIAL_COPY(T) ((__has_trivial_copy(T) BOOST_INTEL_TT_OPTS) && !is_reference<T>::value && ! ::boost::is_volatile<T>::value)
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) ((__has_trivial_assign(T) BOOST_INTEL_TT_OPTS) && ! ::boost::is_volatile<T>::value && ! ::boost::is_const<T>::value)
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) (__has_trivial_destructor(T) BOOST_INTEL_TT_OPTS)
+#   define BOOST_HAS_NOTHROW_CONSTRUCTOR(T) (__has_nothrow_constructor(T) BOOST_INTEL_TT_OPTS)
+#   define BOOST_HAS_NOTHROW_COPY(T) ((__has_nothrow_copy(T) BOOST_INTEL_TT_OPTS) && !is_volatile<T>::value && !is_reference<T>::value)
+#   define BOOST_HAS_NOTHROW_ASSIGN(T) ((__has_nothrow_assign(T) BOOST_INTEL_TT_OPTS) && !is_volatile<T>::value && !is_const<T>::value)
+#   define BOOST_HAS_VIRTUAL_DESTRUCTOR(T) __has_virtual_destructor(T)
+
+#   define BOOST_IS_ABSTRACT(T) __is_abstract(T)
+#   define BOOST_IS_BASE_OF(T,U) (__is_base_of(T,U) && !is_same<T,U>::value)
+#   define BOOST_IS_CLASS(T) __is_class(T)
+#   define BOOST_IS_ENUM(T) __is_enum(T)
+#   define BOOST_IS_POLYMORPHIC(T) __is_polymorphic(T)
+#   if (!defined(unix) && !defined(__unix__)) || defined(__LP64__)
+      // GCC sometimes lies about alignment requirements
+      // of type double on 32-bit unix platforms, use the
+      // old implementation instead in that case:
+#     define BOOST_ALIGNMENT_OF(T) __alignof__(T)
+#   endif
+
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+#if defined(__ghs__) && (__GHS_VERSION_NUMBER >= 600)
+#   include <boost/type_traits/is_same.hpp>
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_volatile.hpp>
+
+#   define BOOST_IS_UNION(T) __is_union(T)
+#   define BOOST_IS_POD(T) __is_pod(T)
+#   define BOOST_IS_EMPTY(T) __is_empty(T)
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) __has_trivial_constructor(T)
+#   define BOOST_HAS_TRIVIAL_COPY(T) (__has_trivial_copy(T) && !is_reference<T>::value && !is_volatile<T>::value)
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) (__has_trivial_assign(T) && !is_volatile<T>::value)
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) __has_trivial_destructor(T)
+#   define BOOST_HAS_NOTHROW_CONSTRUCTOR(T) __has_nothrow_constructor(T)
+#   define BOOST_HAS_NOTHROW_COPY(T) (__has_nothrow_copy(T) && !is_volatile<T>::value && !is_reference<T>::value)
+#   define BOOST_HAS_NOTHROW_ASSIGN(T) (__has_nothrow_assign(T) && !is_volatile<T>::value)
+#   define BOOST_HAS_VIRTUAL_DESTRUCTOR(T) __has_virtual_destructor(T)
+
+#   define BOOST_IS_ABSTRACT(T) __is_abstract(T)
+#   define BOOST_IS_BASE_OF(T,U) (__is_base_of(T,U) && !is_same<T,U>::value)
+#   define BOOST_IS_CLASS(T) __is_class(T)
+#   define BOOST_IS_ENUM(T) __is_enum(T)
+#   define BOOST_IS_POLYMORPHIC(T) __is_polymorphic(T)
+#   define BOOST_ALIGNMENT_OF(T) __alignof__(T)
+
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+# if defined(__CODEGEARC__)
+#   include <boost/type_traits/is_same.hpp>
+#   include <boost/type_traits/is_reference.hpp>
+#   include <boost/type_traits/is_volatile.hpp>
+#   include <boost/type_traits/is_void.hpp>
+
+#   define BOOST_IS_UNION(T) __is_union(T)
+#   define BOOST_IS_POD(T) __is_pod(T)
+#   define BOOST_IS_EMPTY(T) __is_empty(T)
+#   define BOOST_HAS_TRIVIAL_CONSTRUCTOR(T) (__has_trivial_default_constructor(T))
+#   define BOOST_HAS_TRIVIAL_COPY(T) (__has_trivial_copy_constructor(T) && !is_volatile<T>::value && !is_reference<T>::value)
+#   define BOOST_HAS_TRIVIAL_ASSIGN(T) (__has_trivial_assign(T) && !is_volatile<T>::value)
+#   define BOOST_HAS_TRIVIAL_DESTRUCTOR(T) (__has_trivial_destructor(T))
+#   define BOOST_HAS_NOTHROW_CONSTRUCTOR(T) (__has_nothrow_default_constructor(T))
+#   define BOOST_HAS_NOTHROW_COPY(T) (__has_nothrow_copy_constructor(T) && !is_volatile<T>::value && !is_reference<T>::value)
+#   define BOOST_HAS_NOTHROW_ASSIGN(T) (__has_nothrow_assign(T) && !is_volatile<T>::value)
+#   define BOOST_HAS_VIRTUAL_DESTRUCTOR(T) __has_virtual_destructor(T)
+
+#   define BOOST_IS_ABSTRACT(T) __is_abstract(T)
+#   define BOOST_IS_BASE_OF(T,U) (__is_base_of(T,U) && !is_void<T>::value && !is_void<U>::value)
+#   define BOOST_IS_CLASS(T) __is_class(T)
+#   define BOOST_IS_CONVERTIBLE(T,U) (__is_convertible(T,U) || is_void<U>::value)
+#   define BOOST_IS_ENUM(T) __is_enum(T)
+#   define BOOST_IS_POLYMORPHIC(T) __is_polymorphic(T)
+#   define BOOST_ALIGNMENT_OF(T) alignof(T)
+
+#   define BOOST_HAS_TYPE_TRAITS_INTRINSICS
+#endif
+
+#endif // BOOST_TT_INTRINSICS_HPP_INCLUDED
+
+
+
+
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/implicit_cast.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/implicit_cast.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/implicit_cast.hpp	(working copy)
@@ -0,0 +1,29 @@
+// Copyright David Abrahams 2003.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef IMPLICIT_CAST_DWA200356_HPP
+# define IMPLICIT_CAST_DWA200356_HPP
+
+# include <boost/mpl/identity.hpp>
+
+namespace boost {
+
+// implementation originally suggested by C. Green in
+// http://lists.boost.org/MailArchives/boost/msg00886.php
+
+// The use of identity creates a non-deduced form, so that the
+// explicit template argument must be supplied
+template <typename T>
+inline T implicit_cast (typename mpl::identity<T>::type x) {
+    return x;
+}
+
+// incomplete return type now is here
+//template <typename T>
+//void implicit_cast (...);
+
+} // namespace boost
+
+
+#endif // IMPLICIT_CAST_DWA200356_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/version.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/version.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/version.hpp	(working copy)
@@ -0,0 +1,35 @@
+//  Boost version.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John maddock 1999. Distributed under the Boost
+//  Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/config for documentation
+
+#ifndef BOOST_VERSION_HPP
+#define BOOST_VERSION_HPP
+
+//
+//  Caution, this is the only boost header that is guarenteed
+//  to change with every boost release, including this header
+//  will cause a recompile every time a new boost version is
+//  released.
+//
+//  BOOST_VERSION % 100 is the patch level
+//  BOOST_VERSION / 100 % 1000 is the minor version
+//  BOOST_VERSION / 100000 is the major version
+
+#define BOOST_VERSION 104800
+
+//
+//  BOOST_LIB_VERSION must be defined to be the same as BOOST_VERSION
+//  but as a *string* in the form "x_y[_z]" where x is the major version
+//  number, y is the minor version number, and z is the patch level if not 0.
+//  This is used by <config/auto_link.hpp> to select which library version to link to.
+
+#define BOOST_LIB_VERSION "1_48"
+
+#endif
+
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/none.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/none.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/none.hpp	(working copy)
@@ -0,0 +1,28 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_NONE_17SEP2003_HPP
+#define BOOST_NONE_17SEP2003_HPP
+
+#include "boost/none_t.hpp"
+
+// NOTE: Borland users have to include this header outside any precompiled headers
+// (bcc<=5.64 cannot include instance data in a precompiled header)
+//  -- * To be verified, now that there's no unnamed namespace
+
+namespace boost {
+
+none_t const none = (static_cast<none_t>(0)) ;
+
+} // namespace boost
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/scoped_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/scoped_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/scoped_ptr.hpp	(working copy)
@@ -0,0 +1,16 @@
+#ifndef BOOST_SCOPED_PTR_HPP_INCLUDED
+#define BOOST_SCOPED_PTR_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  http://www.boost.org/libs/smart_ptr/scoped_ptr.htm
+//
+
+#include <boost/smart_ptr/scoped_ptr.hpp>
+
+#endif // #ifndef BOOST_SCOPED_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/interoperable.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/interoperable.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/interoperable.hpp	(working copy)
@@ -0,0 +1,50 @@
+// (C) Copyright David Abrahams 2002.
+// (C) Copyright Jeremy Siek    2002.
+// (C) Copyright Thomas Witt    2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_INTEROPERABLE_23022003THW_HPP
+# define BOOST_INTEROPERABLE_23022003THW_HPP
+
+# include <boost/mpl/bool.hpp>
+# include <boost/mpl/or.hpp>
+
+# include <boost/type_traits/is_convertible.hpp>
+
+# include <boost/iterator/detail/config_def.hpp> // must appear last
+
+namespace boost
+{
+
+  //
+  // Meta function that determines whether two
+  // iterator types are considered interoperable.
+  //
+  // Two iterator types A,B are considered interoperable if either
+  // A is convertible to B or vice versa.
+  // This interoperability definition is in sync with the
+  // standards requirements on constant/mutable container
+  // iterators (23.1 [lib.container.requirements]).
+  //
+  // For compilers that don't support is_convertible
+  // is_interoperable gives false positives. See comments
+  // on operator implementation for consequences.
+  //
+  template <typename A, typename B>
+  struct is_interoperable
+# ifdef BOOST_NO_STRICT_ITERATOR_INTEROPERABILITY
+    : mpl::true_
+# else
+    : mpl::or_<
+          is_convertible< A, B >
+        , is_convertible< B, A > >
+# endif
+  {
+  };
+
+} // namespace boost
+
+# include <boost/iterator/detail/config_undef.hpp>
+
+#endif // BOOST_INTEROPERABLE_23022003THW_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_facade.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_facade.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_facade.hpp	(working copy)
@@ -0,0 +1,878 @@
+// (C) Copyright David Abrahams 2002.
+// (C) Copyright Jeremy Siek    2002.
+// (C) Copyright Thomas Witt    2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_ITERATOR_FACADE_23022003THW_HPP
+#define BOOST_ITERATOR_FACADE_23022003THW_HPP
+
+#include <boost/iterator.hpp>
+#include <boost/iterator/interoperable.hpp>
+#include <boost/iterator/iterator_traits.hpp>
+
+#include <boost/iterator/detail/facade_iterator_category.hpp>
+#include <boost/iterator/detail/enable_if.hpp>
+
+#include <boost/implicit_cast.hpp>
+#include <boost/static_assert.hpp>
+
+#include <boost/type_traits/is_same.hpp>
+#include <boost/type_traits/add_const.hpp>
+#include <boost/type_traits/add_pointer.hpp>
+#include <boost/type_traits/remove_const.hpp>
+#include <boost/type_traits/remove_reference.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+#include <boost/type_traits/is_pod.hpp>
+
+#include <boost/mpl/eval_if.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/mpl/or.hpp>
+#include <boost/mpl/and.hpp>
+#include <boost/mpl/not.hpp>
+#include <boost/mpl/always.hpp>
+#include <boost/mpl/apply.hpp>
+#include <boost/mpl/identity.hpp>
+
+#include <boost/iterator/detail/config_def.hpp> // this goes last
+
+namespace boost
+{
+  // This forward declaration is required for the friend declaration
+  // in iterator_core_access
+  template <class I, class V, class TC, class R, class D> class iterator_facade;
+
+  namespace detail
+  {
+    // A binary metafunction class that always returns bool.  VC6
+    // ICEs on mpl::always<bool>, probably because of the default
+    // parameters.
+    struct always_bool2
+    {
+        template <class T, class U>
+        struct apply
+        {
+            typedef bool type;
+        };
+    };
+
+    //
+    // enable if for use in operator implementation.
+    //
+    template <
+        class Facade1
+      , class Facade2
+      , class Return
+    >
+    struct enable_if_interoperable
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+    {
+        typedef typename mpl::if_<
+            mpl::or_<
+                is_convertible<Facade1, Facade2>
+              , is_convertible<Facade2, Facade1>
+            >
+          , Return
+          , int[3]
+        >::type type;
+    };
+#else
+      : ::boost::iterators::enable_if<
+           mpl::or_<
+               is_convertible<Facade1, Facade2>
+             , is_convertible<Facade2, Facade1>
+           >
+         , Return
+        >
+    {};
+#endif
+
+    //
+    // Generates associated types for an iterator_facade with the
+    // given parameters.
+    //
+    template <
+        class ValueParam
+      , class CategoryOrTraversal
+      , class Reference
+      , class Difference
+    >
+    struct iterator_facade_types
+    {
+        typedef typename facade_iterator_category<
+            CategoryOrTraversal, ValueParam, Reference
+        >::type iterator_category;
+
+        typedef typename remove_const<ValueParam>::type value_type;
+
+        // Not the real associated pointer type
+        typedef typename mpl::eval_if<
+            boost::detail::iterator_writability_disabled<ValueParam,Reference>
+          , add_pointer<const value_type>
+          , add_pointer<value_type>
+        >::type pointer;
+
+# if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)                          \
+    && (BOOST_WORKAROUND(_STLPORT_VERSION, BOOST_TESTED_AT(0x452))              \
+        || BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, BOOST_TESTED_AT(310)))     \
+    || BOOST_WORKAROUND(BOOST_RWSTD_VER, BOOST_TESTED_AT(0x20101))              \
+    || BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, <= 310)
+
+        // To interoperate with some broken library/compiler
+        // combinations, user-defined iterators must be derived from
+        // std::iterator.  It is possible to implement a standard
+        // library for broken compilers without this limitation.
+#  define BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE 1
+
+        typedef
+           iterator<iterator_category, value_type, Difference, pointer, Reference>
+        base;
+# endif
+    };
+
+    // iterators whose dereference operators reference the same value
+    // for all iterators into the same sequence (like many input
+    // iterators) need help with their postfix ++: the referenced
+    // value must be read and stored away before the increment occurs
+    // so that *a++ yields the originally referenced element and not
+    // the next one.
+    template <class Iterator>
+    class postfix_increment_proxy
+    {
+        typedef typename iterator_value<Iterator>::type value_type;
+     public:
+        explicit postfix_increment_proxy(Iterator const& x)
+          : stored_value(*x)
+        {}
+
+        // Returning a mutable reference allows nonsense like
+        // (*r++).mutate(), but it imposes fewer assumptions about the
+        // behavior of the value_type.  In particular, recall taht
+        // (*r).mutate() is legal if operator* returns by value.
+        value_type&
+        operator*() const
+        {
+            return this->stored_value;
+        }
+     private:
+        mutable value_type stored_value;
+    };
+
+    //
+    // In general, we can't determine that such an iterator isn't
+    // writable -- we also need to store a copy of the old iterator so
+    // that it can be written into.
+    template <class Iterator>
+    class writable_postfix_increment_proxy
+    {
+        typedef typename iterator_value<Iterator>::type value_type;
+     public:
+        explicit writable_postfix_increment_proxy(Iterator const& x)
+          : stored_value(*x)
+          , stored_iterator(x)
+        {}
+
+        // Dereferencing must return a proxy so that both *r++ = o and
+        // value_type(*r++) can work.  In this case, *r is the same as
+        // *r++, and the conversion operator below is used to ensure
+        // readability.
+        writable_postfix_increment_proxy const&
+        operator*() const
+        {
+            return *this;
+        }
+
+        // Provides readability of *r++
+        operator value_type&() const
+        {
+            return stored_value;
+        }
+
+        // Provides writability of *r++
+        template <class T>
+        T const& operator=(T const& x) const
+        {
+            *this->stored_iterator = x;
+            return x;
+        }
+
+        // This overload just in case only non-const objects are writable
+        template <class T>
+        T& operator=(T& x) const
+        {
+            *this->stored_iterator = x;
+            return x;
+        }
+
+        // Provides X(r++)
+        operator Iterator const&() const
+        {
+            return stored_iterator;
+        }
+
+     private:
+        mutable value_type stored_value;
+        Iterator stored_iterator;
+    };
+
+# ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+    template <class Reference, class Value>
+    struct is_non_proxy_reference_impl
+    {
+        static Reference r;
+
+        template <class R>
+        static typename mpl::if_<
+            is_convertible<
+                R const volatile*
+              , Value const volatile*
+            >
+          , char[1]
+          , char[2]
+        >::type& helper(R const&);
+
+        BOOST_STATIC_CONSTANT(bool, value = sizeof(helper(r)) == 1);
+    };
+
+    template <class Reference, class Value>
+    struct is_non_proxy_reference
+      : mpl::bool_<
+            is_non_proxy_reference_impl<Reference, Value>::value
+        >
+    {};
+# else
+    template <class Reference, class Value>
+    struct is_non_proxy_reference
+      : is_convertible<
+            typename remove_reference<Reference>::type
+            const volatile*
+          , Value const volatile*
+        >
+    {};
+# endif
+
+    // A metafunction to choose the result type of postfix ++
+    //
+    // Because the C++98 input iterator requirements say that *r++ has
+    // type T (value_type), implementations of some standard
+    // algorithms like lexicographical_compare may use constructions
+    // like:
+    //
+    //          *r++ < *s++
+    //
+    // If *r++ returns a proxy (as required if r is writable but not
+    // multipass), this sort of expression will fail unless the proxy
+    // supports the operator<.  Since there are any number of such
+    // operations, we're not going to try to support them.  Therefore,
+    // even if r++ returns a proxy, *r++ will only return a proxy if
+    // *r also returns a proxy.
+    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
+    struct postfix_increment_result
+      : mpl::eval_if<
+            mpl::and_<
+                // A proxy is only needed for readable iterators
+                is_convertible<Reference,Value const&>
+
+                // No multipass iterator can have values that disappear
+                // before positions can be re-visited
+              , mpl::not_<
+                    is_convertible<
+                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
+                      , forward_traversal_tag
+                    >
+                >
+            >
+          , mpl::if_<
+                is_non_proxy_reference<Reference,Value>
+              , postfix_increment_proxy<Iterator>
+              , writable_postfix_increment_proxy<Iterator>
+            >
+          , mpl::identity<Iterator>
+        >
+    {};
+
+    // operator->() needs special support for input iterators to strictly meet the
+    // standard's requirements. If *i is not a reference type, we must still
+    // produce a lvalue to which a pointer can be formed. We do that by
+    // returning an instantiation of this special proxy class template.
+    template <class T>
+    struct operator_arrow_proxy
+    {
+        operator_arrow_proxy(T const* px) : m_value(*px) {}
+        T* operator->() const { return &m_value; }
+        // This function is needed for MWCW and BCC, which won't call operator->
+        // again automatically per 13.3.1.2 para 8
+        operator T*() const { return &m_value; }
+        mutable T m_value;
+    };
+
+    // A metafunction that gets the result type for operator->.  Also
+    // has a static function make() which builds the result from a
+    // Reference
+    template <class ValueType, class Reference, class Pointer>
+    struct operator_arrow_result
+    {
+        // CWPro8.3 won't accept "operator_arrow_result::type", and we
+        // need that type below, so metafunction forwarding would be a
+        // losing proposition here.
+        typedef typename mpl::if_<
+            is_reference<Reference>
+          , Pointer
+          , operator_arrow_proxy<ValueType>
+        >::type type;
+
+        static type make(Reference x)
+        {
+            return boost::implicit_cast<type>(&x);
+        }
+    };
+
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+    // Deal with ETI
+    template<>
+    struct operator_arrow_result<int, int, int>
+    {
+        typedef int type;
+    };
+# endif
+
+    // A proxy return type for operator[], needed to deal with
+    // iterators that may invalidate referents upon destruction.
+    // Consider the temporary iterator in *(a + n)
+    template <class Iterator>
+    class operator_brackets_proxy
+    {
+        // Iterator is actually an iterator_facade, so we do not have to
+        // go through iterator_traits to access the traits.
+        typedef typename Iterator::reference  reference;
+        typedef typename Iterator::value_type value_type;
+
+     public:
+        operator_brackets_proxy(Iterator const& iter)
+          : m_iter(iter)
+        {}
+
+        operator reference() const
+        {
+            return *m_iter;
+        }
+
+        operator_brackets_proxy& operator=(value_type const& val)
+        {
+            *m_iter = val;
+            return *this;
+        }
+
+     private:
+        Iterator m_iter;
+    };
+
+    // A metafunction that determines whether operator[] must return a
+    // proxy, or whether it can simply return a copy of the value_type.
+    template <class ValueType, class Reference>
+    struct use_operator_brackets_proxy
+      : mpl::not_<
+            mpl::and_<
+                // Really we want an is_copy_constructible trait here,
+                // but is_POD will have to suffice in the meantime.
+                boost::is_POD<ValueType>
+              , iterator_writability_disabled<ValueType,Reference>
+            >
+        >
+    {};
+
+    template <class Iterator, class Value, class Reference>
+    struct operator_brackets_result
+    {
+        typedef typename mpl::if_<
+            use_operator_brackets_proxy<Value,Reference>
+          , operator_brackets_proxy<Iterator>
+          , Value
+        >::type type;
+    };
+
+    template <class Iterator>
+    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
+    {
+        return operator_brackets_proxy<Iterator>(iter);
+    }
+
+    template <class Iterator>
+    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
+    {
+      return *iter;
+    }
+
+    struct choose_difference_type
+    {
+        template <class I1, class I2>
+        struct apply
+          :
+# ifdef BOOST_NO_ONE_WAY_ITERATOR_INTEROP
+          iterator_difference<I1>
+# elif BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+          mpl::if_<
+              is_convertible<I2,I1>
+            , typename I1::difference_type
+            , typename I2::difference_type
+          >
+# else
+          mpl::eval_if<
+              is_convertible<I2,I1>
+            , iterator_difference<I1>
+            , iterator_difference<I2>
+          >
+# endif
+        {};
+
+    };
+  } // namespace detail
+
+
+  // Macros which describe the declarations of binary operators
+# ifdef BOOST_NO_STRICT_ITERATOR_INTEROPERABILITY
+#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD(prefix, op, result_type)       \
+    template <                                                              \
+        class Derived1, class V1, class TC1, class Reference1, class Difference1 \
+      , class Derived2, class V2, class TC2, class Reference2, class Difference2 \
+    >                                                                       \
+    prefix typename mpl::apply2<result_type,Derived1,Derived2>::type \
+    operator op(                                                            \
+        iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs   \
+      , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)
+# else
+#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD(prefix, op, result_type)   \
+    template <                                                          \
+        class Derived1, class V1, class TC1, class Reference1, class Difference1 \
+      , class Derived2, class V2, class TC2, class Reference2, class Difference2 \
+    >                                                                   \
+    prefix typename boost::detail::enable_if_interoperable<             \
+        Derived1, Derived2                                              \
+      , typename mpl::apply2<result_type,Derived1,Derived2>::type       \
+    >::type                                                             \
+    operator op(                                                        \
+        iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs   \
+      , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)
+# endif
+
+#  define BOOST_ITERATOR_FACADE_PLUS_HEAD(prefix,args)              \
+    template <class Derived, class V, class TC, class R, class D>   \
+    prefix Derived operator+ args
+
+  //
+  // Helper class for granting access to the iterator core interface.
+  //
+  // The simple core interface is used by iterator_facade. The core
+  // interface of a user/library defined iterator type should not be made public
+  // so that it does not clutter the public interface. Instead iterator_core_access
+  // should be made friend so that iterator_facade can access the core
+  // interface through iterator_core_access.
+  //
+  class iterator_core_access
+  {
+# if defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)
+      // Tasteless as this may seem, making all members public allows member templates
+      // to work in the absence of member template friends.
+   public:
+# else
+
+      template <class I, class V, class TC, class R, class D> friend class iterator_facade;
+
+#  define BOOST_ITERATOR_FACADE_RELATION(op)                                \
+      BOOST_ITERATOR_FACADE_INTEROP_HEAD(friend,op, boost::detail::always_bool2);
+
+      BOOST_ITERATOR_FACADE_RELATION(==)
+      BOOST_ITERATOR_FACADE_RELATION(!=)
+
+      BOOST_ITERATOR_FACADE_RELATION(<)
+      BOOST_ITERATOR_FACADE_RELATION(>)
+      BOOST_ITERATOR_FACADE_RELATION(<=)
+      BOOST_ITERATOR_FACADE_RELATION(>=)
+#  undef BOOST_ITERATOR_FACADE_RELATION
+
+      BOOST_ITERATOR_FACADE_INTEROP_HEAD(
+          friend, -, boost::detail::choose_difference_type)
+      ;
+
+      BOOST_ITERATOR_FACADE_PLUS_HEAD(
+          friend inline
+          , (iterator_facade<Derived, V, TC, R, D> const&
+           , typename Derived::difference_type)
+      )
+      ;
+
+      BOOST_ITERATOR_FACADE_PLUS_HEAD(
+          friend inline
+        , (typename Derived::difference_type
+           , iterator_facade<Derived, V, TC, R, D> const&)
+      )
+      ;
+
+# endif
+
+      template <class Facade>
+      static typename Facade::reference dereference(Facade const& f)
+      {
+          return f.dereference();
+      }
+
+      template <class Facade>
+      static void increment(Facade& f)
+      {
+          f.increment();
+      }
+
+      template <class Facade>
+      static void decrement(Facade& f)
+      {
+          f.decrement();
+      }
+
+      template <class Facade1, class Facade2>
+      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
+      {
+          return f1.equal(f2);
+      }
+
+      template <class Facade1, class Facade2>
+      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
+      {
+          return f2.equal(f1);
+      }
+
+      template <class Facade>
+      static void advance(Facade& f, typename Facade::difference_type n)
+      {
+          f.advance(n);
+      }
+
+      template <class Facade1, class Facade2>
+      static typename Facade1::difference_type distance_from(
+          Facade1 const& f1, Facade2 const& f2, mpl::true_)
+      {
+          return -f1.distance_to(f2);
+      }
+
+      template <class Facade1, class Facade2>
+      static typename Facade2::difference_type distance_from(
+          Facade1 const& f1, Facade2 const& f2, mpl::false_)
+      {
+          return f2.distance_to(f1);
+      }
+
+      //
+      // Curiously Recurring Template interface.
+      //
+      template <class I, class V, class TC, class R, class D>
+      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
+      {
+          return *static_cast<I*>(&facade);
+      }
+
+      template <class I, class V, class TC, class R, class D>
+      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
+      {
+          return *static_cast<I const*>(&facade);
+      }
+
+   private:
+      // objects of this class are useless
+      iterator_core_access(); //undefined
+  };
+
+  //
+  // iterator_facade - use as a public base class for defining new
+  // standard-conforming iterators.
+  //
+  template <
+      class Derived             // The derived iterator type being constructed
+    , class Value
+    , class CategoryOrTraversal
+    , class Reference   = Value&
+    , class Difference  = std::ptrdiff_t
+  >
+  class iterator_facade
+# ifdef BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE
+    : public boost::detail::iterator_facade_types<
+         Value, CategoryOrTraversal, Reference, Difference
+      >::base
+#  undef BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE
+# endif
+  {
+   private:
+      //
+      // Curiously Recurring Template interface.
+      //
+      Derived& derived()
+      {
+          return *static_cast<Derived*>(this);
+      }
+
+      Derived const& derived() const
+      {
+          return *static_cast<Derived const*>(this);
+      }
+
+      typedef boost::detail::iterator_facade_types<
+         Value, CategoryOrTraversal, Reference, Difference
+      > associated_types;
+
+      typedef boost::detail::operator_arrow_result<
+        typename associated_types::value_type
+        , Reference
+        , typename associated_types::pointer
+      > pointer_;
+
+   protected:
+      // For use by derived classes
+      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;
+
+   public:
+
+      typedef typename associated_types::value_type value_type;
+      typedef Reference reference;
+      typedef Difference difference_type;
+
+      typedef typename pointer_::type pointer;
+
+      typedef typename associated_types::iterator_category iterator_category;
+
+      reference operator*() const
+      {
+          return iterator_core_access::dereference(this->derived());
+      }
+
+      pointer operator->() const
+      {
+          return pointer_::make(*this->derived());
+      }
+
+      typename boost::detail::operator_brackets_result<Derived,Value,reference>::type
+      operator[](difference_type n) const
+      {
+          typedef boost::detail::use_operator_brackets_proxy<Value,Reference> use_proxy;
+
+          return boost::detail::make_operator_brackets_result<Derived>(
+              this->derived() + n
+            , use_proxy()
+          );
+      }
+
+      Derived& operator++()
+      {
+          iterator_core_access::increment(this->derived());
+          return this->derived();
+      }
+
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+      typename boost::detail::postfix_increment_result<Derived,Value,Reference,CategoryOrTraversal>::type
+      operator++(int)
+      {
+          typename boost::detail::postfix_increment_result<Derived,Value,Reference,CategoryOrTraversal>::type
+          tmp(this->derived());
+          ++*this;
+          return tmp;
+      }
+# endif
+
+      Derived& operator--()
+      {
+          iterator_core_access::decrement(this->derived());
+          return this->derived();
+      }
+
+      Derived operator--(int)
+      {
+          Derived tmp(this->derived());
+          --*this;
+          return tmp;
+      }
+
+      Derived& operator+=(difference_type n)
+      {
+          iterator_core_access::advance(this->derived(), n);
+          return this->derived();
+      }
+
+      Derived& operator-=(difference_type n)
+      {
+          iterator_core_access::advance(this->derived(), -n);
+          return this->derived();
+      }
+
+      Derived operator-(difference_type x) const
+      {
+          Derived result(this->derived());
+          return result -= x;
+      }
+
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+      // There appears to be a bug which trashes the data of classes
+      // derived from iterator_facade when they are assigned unless we
+      // define this assignment operator.  This bug is only revealed
+      // (so far) in STLPort debug mode, but it's clearly a codegen
+      // problem so we apply the workaround for all MSVC6.
+      iterator_facade& operator=(iterator_facade const&)
+      {
+          return *this;
+      }
+# endif
+  };
+
+# if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+  template <class I, class V, class TC, class R, class D>
+  inline typename boost::detail::postfix_increment_result<I,V,R,TC>::type
+  operator++(
+      iterator_facade<I,V,TC,R,D>& i
+    , int
+  )
+  {
+      typename boost::detail::postfix_increment_result<I,V,R,TC>::type
+          tmp(*static_cast<I*>(&i));
+
+      ++i;
+
+      return tmp;
+  }
+# endif
+
+
+  //
+  // Comparison operator implementation. The library supplied operators
+  // enables the user to provide fully interoperable constant/mutable
+  // iterator types. I.e. the library provides all operators
+  // for all mutable/constant iterator combinations.
+  //
+  // Note though that this kind of interoperability for constant/mutable
+  // iterators is not required by the standard for container iterators.
+  // All the standard asks for is a conversion mutable -> constant.
+  // Most standard library implementations nowadays provide fully interoperable
+  // iterator implementations, but there are still heavily used implementations
+  // that do not provide them. (Actually it's even worse, they do not provide
+  // them for only a few iterators.)
+  //
+  // ?? Maybe a BOOST_ITERATOR_NO_FULL_INTEROPERABILITY macro should
+  //    enable the user to turn off mixed type operators
+  //
+  // The library takes care to provide only the right operator overloads.
+  // I.e.
+  //
+  // bool operator==(Iterator,      Iterator);
+  // bool operator==(ConstIterator, Iterator);
+  // bool operator==(Iterator,      ConstIterator);
+  // bool operator==(ConstIterator, ConstIterator);
+  //
+  //   ...
+  //
+  // In order to do so it uses c++ idioms that are not yet widely supported
+  // by current compiler releases. The library is designed to degrade gracefully
+  // in the face of compiler deficiencies. In general compiler
+  // deficiencies result in less strict error checking and more obscure
+  // error messages, functionality is not affected.
+  //
+  // For full operation compiler support for "Substitution Failure Is Not An Error"
+  // (aka. enable_if) and boost::is_convertible is required.
+  //
+  // The following problems occur if support is lacking.
+  //
+  // Pseudo code
+  //
+  // ---------------
+  // AdaptorA<Iterator1> a1;
+  // AdaptorA<Iterator2> a2;
+  //
+  // // This will result in a no such overload error in full operation
+  // // If enable_if or is_convertible is not supported
+  // // The instantiation will fail with an error hopefully indicating that
+  // // there is no operator== for Iterator1, Iterator2
+  // // The same will happen if no enable_if is used to remove
+  // // false overloads from the templated conversion constructor
+  // // of AdaptorA.
+  //
+  // a1 == a2;
+  // ----------------
+  //
+  // AdaptorA<Iterator> a;
+  // AdaptorB<Iterator> b;
+  //
+  // // This will result in a no such overload error in full operation
+  // // If enable_if is not supported the static assert used
+  // // in the operator implementation will fail.
+  // // This will accidently work if is_convertible is not supported.
+  //
+  // a == b;
+  // ----------------
+  //
+
+# ifdef BOOST_NO_ONE_WAY_ITERATOR_INTEROP
+#  define BOOST_ITERATOR_CONVERTIBLE(a,b) mpl::true_()
+# else
+#  define BOOST_ITERATOR_CONVERTIBLE(a,b) is_convertible<a,b>()
+# endif
+
+# define BOOST_ITERATOR_FACADE_INTEROP(op, result_type, return_prefix, base_op) \
+  BOOST_ITERATOR_FACADE_INTEROP_HEAD(inline, op, result_type)                   \
+  {                                                                             \
+      /* For those compilers that do not support enable_if */                   \
+      BOOST_STATIC_ASSERT((                                                     \
+          is_interoperable< Derived1, Derived2 >::value                         \
+      ));                                                                       \
+      return_prefix iterator_core_access::base_op(                              \
+          *static_cast<Derived1 const*>(&lhs)                                   \
+        , *static_cast<Derived2 const*>(&rhs)                                   \
+        , BOOST_ITERATOR_CONVERTIBLE(Derived2,Derived1)                         \
+      );                                                                        \
+  }
+
+# define BOOST_ITERATOR_FACADE_RELATION(op, return_prefix, base_op) \
+  BOOST_ITERATOR_FACADE_INTEROP(                                    \
+      op                                                            \
+    , boost::detail::always_bool2                                   \
+    , return_prefix                                                 \
+    , base_op                                                       \
+  )
+
+  BOOST_ITERATOR_FACADE_RELATION(==, return, equal)
+  BOOST_ITERATOR_FACADE_RELATION(!=, return !, equal)
+
+  BOOST_ITERATOR_FACADE_RELATION(<, return 0 >, distance_from)
+  BOOST_ITERATOR_FACADE_RELATION(>, return 0 <, distance_from)
+  BOOST_ITERATOR_FACADE_RELATION(<=, return 0 >=, distance_from)
+  BOOST_ITERATOR_FACADE_RELATION(>=, return 0 <=, distance_from)
+# undef BOOST_ITERATOR_FACADE_RELATION
+
+  // operator- requires an additional part in the static assertion
+  BOOST_ITERATOR_FACADE_INTEROP(
+      -
+    , boost::detail::choose_difference_type
+    , return
+    , distance_from
+  )
+# undef BOOST_ITERATOR_FACADE_INTEROP
+# undef BOOST_ITERATOR_FACADE_INTEROP_HEAD
+
+# define BOOST_ITERATOR_FACADE_PLUS(args)           \
+  BOOST_ITERATOR_FACADE_PLUS_HEAD(inline, args)     \
+  {                                                 \
+      Derived tmp(static_cast<Derived const&>(i));  \
+      return tmp += n;                              \
+  }
+
+BOOST_ITERATOR_FACADE_PLUS((
+  iterator_facade<Derived, V, TC, R, D> const& i
+  , typename Derived::difference_type n
+))
+
+BOOST_ITERATOR_FACADE_PLUS((
+    typename Derived::difference_type n
+    , iterator_facade<Derived, V, TC, R, D> const& i
+))
+# undef BOOST_ITERATOR_FACADE_PLUS
+# undef BOOST_ITERATOR_FACADE_PLUS_HEAD
+
+} // namespace boost
+
+#include <boost/iterator/detail/config_undef.hpp>
+
+#endif // BOOST_ITERATOR_FACADE_23022003THW_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/facade_iterator_category.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/facade_iterator_category.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/facade_iterator_category.hpp	(working copy)
@@ -0,0 +1,200 @@
+// Copyright David Abrahams 2003. Use, modification and distribution is
+// subject to the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef FACADE_ITERATOR_CATEGORY_DWA20031118_HPP
+# define FACADE_ITERATOR_CATEGORY_DWA20031118_HPP
+
+# include <boost/iterator/iterator_categories.hpp>
+
+# include <boost/mpl/or.hpp>  // used in iterator_tag inheritance logic
+# include <boost/mpl/and.hpp>
+# include <boost/mpl/if.hpp>
+# include <boost/mpl/eval_if.hpp>
+# include <boost/mpl/identity.hpp>
+# include <boost/mpl/assert.hpp>
+
+# include <boost/type_traits/is_same.hpp>
+# include <boost/type_traits/is_const.hpp>
+# include <boost/type_traits/is_reference.hpp>
+# include <boost/type_traits/is_convertible.hpp>
+
+# include <boost/type_traits/is_same.hpp>
+
+# include <boost/iterator/detail/config_def.hpp> // try to keep this last
+
+# ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY
+#  include <boost/detail/indirect_traits.hpp>
+# endif
+
+//
+// iterator_category deduction for iterator_facade
+//
+
+// forward declaration
+namespace boost { struct use_default; }
+
+namespace boost { namespace detail  {
+
+struct input_output_iterator_tag
+  : std::input_iterator_tag
+{
+    // Using inheritance for only input_iterator_tag helps to avoid
+    // ambiguities when a stdlib implementation dispatches on a
+    // function which is overloaded on both input_iterator_tag and
+    // output_iterator_tag, as STLPort does, in its __valid_range
+    // function.  I claim it's better to avoid the ambiguity in these
+    // cases.
+    operator std::output_iterator_tag() const
+    {
+        return std::output_iterator_tag();
+    }
+};
+
+//
+// True iff the user has explicitly disabled writability of this
+// iterator.  Pass the iterator_facade's Value parameter and its
+// nested ::reference type.
+//
+template <class ValueParam, class Reference>
+struct iterator_writability_disabled
+# ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY // Adding Thomas' logic?
+  : mpl::or_<
+        is_const<Reference>
+      , boost::detail::indirect_traits::is_reference_to_const<Reference>
+      , is_const<ValueParam>
+    >
+# else
+  : is_const<ValueParam>
+# endif
+{};
+
+
+//
+// Convert an iterator_facade's traversal category, Value parameter,
+// and ::reference type to an appropriate old-style category.
+//
+// If writability has been disabled per the above metafunction, the
+// result will not be convertible to output_iterator_tag.
+//
+// Otherwise, if Traversal == single_pass_traversal_tag, the following
+// conditions will result in a tag that is convertible both to
+// input_iterator_tag and output_iterator_tag:
+//
+//    1. Reference is a reference to non-const
+//    2. Reference is not a reference and is convertible to Value
+//
+template <class Traversal, class ValueParam, class Reference>
+struct iterator_facade_default_category
+  : mpl::eval_if<
+        mpl::and_<
+            is_reference<Reference>
+          , is_convertible<Traversal,forward_traversal_tag>
+        >
+      , mpl::eval_if<
+            is_convertible<Traversal,random_access_traversal_tag>
+          , mpl::identity<std::random_access_iterator_tag>
+          , mpl::if_<
+                is_convertible<Traversal,bidirectional_traversal_tag>
+              , std::bidirectional_iterator_tag
+              , std::forward_iterator_tag
+            >
+        >
+      , typename mpl::eval_if<
+            mpl::and_<
+                is_convertible<Traversal, single_pass_traversal_tag>
+
+                // check for readability
+              , is_convertible<Reference, ValueParam>
+            >
+          , mpl::identity<std::input_iterator_tag>
+          , mpl::identity<Traversal>
+        >
+    >
+{
+};
+
+// True iff T is convertible to an old-style iterator category.
+template <class T>
+struct is_iterator_category
+  : mpl::or_<
+        is_convertible<T,std::input_iterator_tag>
+      , is_convertible<T,std::output_iterator_tag>
+    >
+{
+};
+
+template <class T>
+struct is_iterator_traversal
+  : is_convertible<T,incrementable_traversal_tag>
+{};
+
+//
+// A composite iterator_category tag convertible to Category (a pure
+// old-style category) and Traversal (a pure traversal tag).
+// Traversal must be a strict increase of the traversal power given by
+// Category.
+//
+template <class Category, class Traversal>
+struct iterator_category_with_traversal
+  : Category, Traversal
+{
+# if !BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+    // Make sure this isn't used to build any categories where
+    // convertibility to Traversal is redundant.  Should just use the
+    // Category element in that case.
+    BOOST_MPL_ASSERT_NOT((
+        is_convertible<
+              typename iterator_category_to_traversal<Category>::type
+            , Traversal
+          >));
+
+    BOOST_MPL_ASSERT((is_iterator_category<Category>));
+    BOOST_MPL_ASSERT_NOT((is_iterator_category<Traversal>));
+    BOOST_MPL_ASSERT_NOT((is_iterator_traversal<Category>));
+#  if !BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1310))
+    BOOST_MPL_ASSERT((is_iterator_traversal<Traversal>));
+#  endif
+# endif
+};
+
+// Computes an iterator_category tag whose traversal is Traversal and
+// which is appropriate for an iterator
+template <class Traversal, class ValueParam, class Reference>
+struct facade_iterator_category_impl
+{
+# if !BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+    BOOST_MPL_ASSERT_NOT((is_iterator_category<Traversal>));
+# endif
+
+    typedef typename iterator_facade_default_category<
+        Traversal,ValueParam,Reference
+    >::type category;
+
+    typedef typename mpl::if_<
+        is_same<
+            Traversal
+          , typename iterator_category_to_traversal<category>::type
+        >
+      , category
+      , iterator_category_with_traversal<category,Traversal>
+    >::type type;
+};
+
+//
+// Compute an iterator_category for iterator_facade
+//
+template <class CategoryOrTraversal, class ValueParam, class Reference>
+struct facade_iterator_category
+  : mpl::eval_if<
+        is_iterator_category<CategoryOrTraversal>
+      , mpl::identity<CategoryOrTraversal> // old-style categories are fine as-is
+      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
+    >
+{
+};
+
+}} // namespace boost::detail
+
+# include <boost/iterator/detail/config_undef.hpp>
+
+#endif // FACADE_ITERATOR_CATEGORY_DWA20031118_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/config_def.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/config_def.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/config_def.hpp	(working copy)
@@ -0,0 +1,137 @@
+// (C) Copyright David Abrahams 2002.
+// (C) Copyright Jeremy Siek    2002.
+// (C) Copyright Thomas Witt    2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// no include guard multiple inclusion intended
+
+//
+// This is a temporary workaround until the bulk of this is
+// available in boost config.
+// 23/02/03 thw
+//
+
+#include <boost/config.hpp> // for prior
+#include <boost/detail/workaround.hpp>
+
+#ifdef BOOST_ITERATOR_CONFIG_DEF
+# error you have nested config_def #inclusion.
+#else
+# define BOOST_ITERATOR_CONFIG_DEF
+#endif
+
+// We enable this always now.  Otherwise, the simple case in
+// libs/iterator/test/constant_iterator_arrow.cpp fails to compile
+// because the operator-> return is improperly deduced as a non-const
+// pointer.
+#if 1 || defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)           \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x531))
+
+// Recall that in general, compilers without partial specialization
+// can't strip constness.  Consider counting_iterator, which normally
+// passes a const Value to iterator_facade.  As a result, any code
+// which makes a std::vector of the iterator's value_type will fail
+// when its allocator declares functions overloaded on reference and
+// const_reference (the same type).
+//
+// Furthermore, Borland 5.5.1 drops constness in enough ways that we
+// end up using a proxy for operator[] when we otherwise shouldn't.
+// Using reference constness gives it an extra hint that it can
+// return the value_type from operator[] directly, but is not
+// strictly necessary.  Not sure how best to resolve this one.
+
+# define BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY 1
+
+#endif
+
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)                                       \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x5A0))                   \
+    || (BOOST_WORKAROUND(BOOST_INTEL_CXX_VERSION, <= 700) && defined(_MSC_VER)) \
+    || BOOST_WORKAROUND(__DECCXX_VER, BOOST_TESTED_AT(60590042))                \
+    || BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x590))
+
+# define BOOST_NO_LVALUE_RETURN_DETECTION
+
+# if 0 // test code
+  struct v  {};
+
+  typedef  char (&no)[3];
+
+  template <class T>
+  no foo(T const&, ...);
+
+  template <class T>
+  char foo(T&, int);
+
+
+  struct value_iterator
+  {
+      v operator*() const;
+  };
+
+  template <class T>
+  struct lvalue_deref_helper
+  {
+      static T& x;
+      enum { value = (sizeof(foo(*x,0)) == 1) };
+  };
+
+  int z2[(lvalue_deref_helper<v*>::value == 1) ? 1 : -1];
+  int z[(lvalue_deref_helper<value_iterator>::value) == 1 ? -1 : 1 ];
+# endif
+
+#endif
+
+#if BOOST_WORKAROUND(__MWERKS__, <=0x2407)
+#  define BOOST_NO_IS_CONVERTIBLE // "is_convertible doesn't work for simple types"
+#endif
+
+#if BOOST_WORKAROUND(__GNUC__, == 2)                                                                            \
+    || BOOST_WORKAROUND(__GNUC__, == 3) && BOOST_WORKAROUND(__GNUC_MINOR__, < 4) && !defined(__EDG_VERSION__)   \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x551))
+#  define BOOST_NO_IS_CONVERTIBLE_TEMPLATE // The following program fails to compile:
+
+#  if 0 // test code
+    #include <boost/type_traits/is_convertible.hpp>
+    template <class T>
+    struct foo
+    {
+        foo(T);
+
+        template <class U>
+        foo(foo<U> const& other) : p(other.p) { }
+
+        T p;
+    };
+
+    bool x = boost::is_convertible<foo<int const*>, foo<int*> >::value;
+#  endif
+
+#endif
+
+
+#if !defined(BOOST_MSVC) && (defined(BOOST_NO_SFINAE) || defined(BOOST_NO_IS_CONVERTIBLE) || defined(BOOST_NO_IS_CONVERTIBLE_TEMPLATE))
+# define BOOST_NO_STRICT_ITERATOR_INTEROPERABILITY
+#endif
+
+# if !BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+#  define BOOST_ARG_DEPENDENT_TYPENAME typename
+# else
+#  define BOOST_ARG_DEPENDENT_TYPENAME
+# endif
+
+# if BOOST_WORKAROUND(__GNUC__, == 2) && BOOST_WORKAROUND(__GNUC_MINOR__, BOOST_TESTED_AT(95)) \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
+
+// GCC-2.95 eagerly instantiates templated constructors and conversion
+// operators in convertibility checks, causing premature errors.
+//
+// Borland's problems are harder to diagnose due to lack of an
+// instantiation stack backtrace.  They may be due in part to the fact
+// that it drops cv-qualification willy-nilly in templates.
+#  define BOOST_NO_ONE_WAY_ITERATOR_INTEROP
+# endif
+
+// no include guard; multiple inclusion intended
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/enable_if.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/enable_if.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/enable_if.hpp	(working copy)
@@ -0,0 +1,86 @@
+// (C) Copyright David Abrahams 2002.
+// (C) Copyright Jeremy Siek    2002.
+// (C) Copyright Thomas Witt    2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_ENABLE_IF_23022003THW_HPP
+#define BOOST_ENABLE_IF_23022003THW_HPP
+
+#include <boost/detail/workaround.hpp>
+#include <boost/mpl/identity.hpp>
+
+#include <boost/iterator/detail/config_def.hpp>
+
+//
+// Boost iterators uses its own enable_if cause we need
+// special semantics for deficient compilers.
+// 23/02/03 thw
+//
+
+namespace boost
+{
+
+  namespace iterators
+  {
+    //
+    // Base machinery for all kinds of enable if
+    //
+    template<bool>
+    struct enabled
+    {
+      template<typename T>
+      struct base
+      {
+        typedef T type;
+      };
+    };
+
+    //
+    // For compilers that don't support "Substitution Failure Is Not An Error"
+    // enable_if falls back to always enabled. See comments
+    // on operator implementation for consequences.
+    //
+    template<>
+    struct enabled<false>
+    {
+      template<typename T>
+      struct base
+      {
+#ifdef BOOST_NO_SFINAE
+
+        typedef T type;
+
+        // This way to do it would give a nice error message containing
+        // invalid overload, but has the big disadvantage that
+        // there is no reference to user code in the error message.
+        //
+        // struct invalid_overload;
+        // typedef invalid_overload type;
+        //
+#endif
+      };
+    };
+
+
+    template <class Cond,
+              class Return>
+    struct enable_if
+# if !defined(BOOST_NO_SFINAE) && !defined(BOOST_NO_IS_CONVERTIBLE)
+      : enabled<(Cond::value)>::template base<Return>
+# else
+      : mpl::identity<Return>
+# endif
+    {
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+        typedef Return type;
+# endif
+    };
+
+  } // namespace iterators
+
+} // namespace boost
+
+#include <boost/iterator/detail/config_undef.hpp>
+
+#endif // BOOST_ENABLE_IF_23022003THW_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/config_undef.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/config_undef.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/detail/config_undef.hpp	(working copy)
@@ -0,0 +1,25 @@
+// (C) Copyright Thomas Witt    2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// no include guard multiple inclusion intended
+
+//
+// This is a temporary workaround until the bulk of this is
+// available in boost config.
+// 23/02/03 thw
+//
+
+#undef BOOST_NO_IS_CONVERTIBLE
+#undef BOOST_NO_IS_CONVERTIBLE_TEMPLATE
+#undef BOOST_NO_STRICT_ITERATOR_INTEROPERABILITY
+#undef BOOST_ARG_DEPENDENT_TYPENAME
+#undef BOOST_NO_LVALUE_RETURN_DETECTION
+#undef BOOST_NO_ONE_WAY_ITERATOR_INTEROP
+
+#ifdef BOOST_ITERATOR_CONFIG_DEF
+# undef BOOST_ITERATOR_CONFIG_DEF
+#else
+# error missing or nested #include config_def
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_categories.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_categories.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_categories.hpp	(working copy)
@@ -0,0 +1,188 @@
+// (C) Copyright Jeremy Siek 2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_ITERATOR_CATEGORIES_HPP
+# define BOOST_ITERATOR_CATEGORIES_HPP
+
+# include <boost/config.hpp>
+# include <boost/detail/iterator.hpp>
+# include <boost/iterator/detail/config_def.hpp>
+
+# include <boost/detail/workaround.hpp>
+
+# include <boost/mpl/eval_if.hpp>
+# include <boost/mpl/identity.hpp>
+# include <boost/mpl/placeholders.hpp>
+# include <boost/mpl/aux_/lambda_support.hpp>
+
+# include <boost/type_traits/is_convertible.hpp>
+
+# include <boost/static_assert.hpp>
+
+namespace boost {
+
+//
+// Traversal Categories
+//
+
+struct no_traversal_tag {};
+
+struct incrementable_traversal_tag
+  : no_traversal_tag
+{
+//     incrementable_traversal_tag() {}
+//     incrementable_traversal_tag(std::output_iterator_tag const&) {};
+};
+
+struct single_pass_traversal_tag
+  : incrementable_traversal_tag
+{
+//     single_pass_traversal_tag() {}
+//     single_pass_traversal_tag(std::input_iterator_tag const&) {};
+};
+
+struct forward_traversal_tag
+  : single_pass_traversal_tag
+{
+//     forward_traversal_tag() {}
+//     forward_traversal_tag(std::forward_iterator_tag const&) {};
+};
+
+struct bidirectional_traversal_tag
+  : forward_traversal_tag
+{
+//     bidirectional_traversal_tag() {};
+//     bidirectional_traversal_tag(std::bidirectional_iterator_tag const&) {};
+};
+
+struct random_access_traversal_tag
+  : bidirectional_traversal_tag
+{
+//     random_access_traversal_tag() {};
+//     random_access_traversal_tag(std::random_access_iterator_tag const&) {};
+};
+
+namespace detail
+{
+  //
+  // Convert a "strictly old-style" iterator category to a traversal
+  // tag.  This is broken out into a separate metafunction to reduce
+  // the cost of instantiating iterator_category_to_traversal, below,
+  // for new-style types.
+  //
+  template <class Cat>
+  struct old_category_to_traversal
+    : mpl::eval_if<
+          is_convertible<Cat,std::random_access_iterator_tag>
+        , mpl::identity<random_access_traversal_tag>
+        , mpl::eval_if<
+              is_convertible<Cat,std::bidirectional_iterator_tag>
+            , mpl::identity<bidirectional_traversal_tag>
+            , mpl::eval_if<
+                  is_convertible<Cat,std::forward_iterator_tag>
+                , mpl::identity<forward_traversal_tag>
+                , mpl::eval_if<
+                      is_convertible<Cat,std::input_iterator_tag>
+                    , mpl::identity<single_pass_traversal_tag>
+                    , mpl::eval_if<
+                          is_convertible<Cat,std::output_iterator_tag>
+                        , mpl::identity<incrementable_traversal_tag>
+                        , void
+                      >
+                  >
+              >
+          >
+      >
+  {};
+
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+  template <>
+  struct old_category_to_traversal<int>
+  {
+      typedef int type;
+  };
+# endif
+
+  template <class Traversal>
+  struct pure_traversal_tag
+    : mpl::eval_if<
+          is_convertible<Traversal,random_access_traversal_tag>
+        , mpl::identity<random_access_traversal_tag>
+        , mpl::eval_if<
+              is_convertible<Traversal,bidirectional_traversal_tag>
+            , mpl::identity<bidirectional_traversal_tag>
+            , mpl::eval_if<
+                  is_convertible<Traversal,forward_traversal_tag>
+                , mpl::identity<forward_traversal_tag>
+                , mpl::eval_if<
+                      is_convertible<Traversal,single_pass_traversal_tag>
+                    , mpl::identity<single_pass_traversal_tag>
+                    , mpl::eval_if<
+                          is_convertible<Traversal,incrementable_traversal_tag>
+                        , mpl::identity<incrementable_traversal_tag>
+                        , void
+                      >
+                  >
+              >
+          >
+      >
+  {
+  };
+
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+  template <>
+  struct pure_traversal_tag<int>
+  {
+      typedef int type;
+  };
+# endif
+
+} // namespace detail
+
+
+//
+// Convert an iterator category into a traversal tag
+//
+template <class Cat>
+struct iterator_category_to_traversal
+  : mpl::eval_if< // if already convertible to a traversal tag, we're done.
+        is_convertible<Cat,incrementable_traversal_tag>
+      , mpl::identity<Cat>
+      , boost::detail::old_category_to_traversal<Cat>
+    >
+{};
+
+// Trait to get an iterator's traversal category
+template <class Iterator = mpl::_1>
+struct iterator_traversal
+  : iterator_category_to_traversal<
+        typename boost::detail::iterator_traits<Iterator>::iterator_category
+    >
+{};
+
+# ifdef BOOST_MPL_CFG_NO_FULL_LAMBDA_SUPPORT
+// Hack because BOOST_MPL_AUX_LAMBDA_SUPPORT doesn't seem to work
+// out well.  Instantiating the nested apply template also
+// requires instantiating iterator_traits on the
+// placeholder. Instead we just specialize it as a metafunction
+// class.
+template <>
+struct iterator_traversal<mpl::_1>
+{
+    template <class T>
+    struct apply : iterator_traversal<T>
+    {};
+};
+template <>
+struct iterator_traversal<mpl::_>
+  : iterator_traversal<mpl::_1>
+{};
+# endif
+
+} // namespace boost
+
+#include <boost/iterator/detail/config_undef.hpp>
+
+#endif // BOOST_ITERATOR_CATEGORIES_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_traits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_traits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_traits.hpp	(working copy)
@@ -0,0 +1,92 @@
+// Copyright David Abrahams 2003.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef ITERATOR_TRAITS_DWA200347_HPP
+# define ITERATOR_TRAITS_DWA200347_HPP
+
+# include <boost/detail/iterator.hpp>
+# include <boost/detail/workaround.hpp>
+
+namespace boost {
+
+// Unfortunately, g++ 2.95.x chokes when we define a class template
+// iterator_category which has the same name as its
+// std::iterator_category() function, probably due in part to the
+// "std:: is visible globally" hack it uses.  Use
+// BOOST_ITERATOR_CATEGORY to write code that's portable to older
+// GCCs.
+
+# if BOOST_WORKAROUND(__GNUC__, <= 2)
+#  define BOOST_ITERATOR_CATEGORY iterator_category_
+# else
+#  define BOOST_ITERATOR_CATEGORY iterator_category
+# endif
+
+
+template <class Iterator>
+struct iterator_value
+{
+    typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
+};
+
+template <class Iterator>
+struct iterator_reference
+{
+    typedef typename boost::detail::iterator_traits<Iterator>::reference type;
+};
+
+
+template <class Iterator>
+struct iterator_pointer
+{
+    typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
+};
+
+template <class Iterator>
+struct iterator_difference
+{
+    typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
+};
+
+template <class Iterator>
+struct BOOST_ITERATOR_CATEGORY
+{
+    typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
+};
+
+# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+template <>
+struct iterator_value<int>
+{
+    typedef void type;
+};
+
+template <>
+struct iterator_reference<int>
+{
+    typedef void type;
+};
+
+template <>
+struct iterator_pointer<int>
+{
+    typedef void type;
+};
+
+template <>
+struct iterator_difference<int>
+{
+    typedef void type;
+};
+
+template <>
+struct BOOST_ITERATOR_CATEGORY<int>
+{
+    typedef void type;
+};
+# endif
+
+} // namespace boost::iterator
+
+#endif // ITERATOR_TRAITS_DWA200347_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_adaptor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_adaptor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator/iterator_adaptor.hpp	(working copy)
@@ -0,0 +1,365 @@
+// (C) Copyright David Abrahams 2002.
+// (C) Copyright Jeremy Siek    2002.
+// (C) Copyright Thomas Witt    2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_ITERATOR_ADAPTOR_23022003THW_HPP
+#define BOOST_ITERATOR_ADAPTOR_23022003THW_HPP
+
+#include <boost/static_assert.hpp>
+#include <boost/iterator.hpp>
+#include <boost/detail/iterator.hpp>
+
+#include <boost/iterator/iterator_categories.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#include <boost/iterator/detail/enable_if.hpp>
+
+#include <boost/mpl/and.hpp>
+#include <boost/mpl/not.hpp>
+#include <boost/mpl/or.hpp>
+
+#include <boost/type_traits/is_same.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+
+#ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY
+# include <boost/type_traits/remove_reference.hpp>
+#endif
+
+#include <boost/type_traits/add_reference.hpp>
+#include <boost/iterator/detail/config_def.hpp>
+
+#include <boost/iterator/iterator_traits.hpp>
+
+namespace boost
+{
+  // Used as a default template argument internally, merely to
+  // indicate "use the default", this can also be passed by users
+  // explicitly in order to specify that the default should be used.
+  struct use_default;
+
+# ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+  // the incompleteness of use_default causes massive problems for
+  // is_convertible (naturally).  This workaround is fortunately not
+  // needed for vc6/vc7.
+  template<class To>
+  struct is_convertible<use_default,To>
+    : mpl::false_ {};
+# endif
+
+  namespace detail
+  {
+
+    //
+    // Result type used in enable_if_convertible meta function.
+    // This can be an incomplete type, as only pointers to
+    // enable_if_convertible< ... >::type are used.
+    // We could have used void for this, but conversion to
+    // void* is just to easy.
+    //
+    struct enable_type;
+  }
+
+
+  //
+  // enable_if for use in adapted iterators constructors.
+  //
+  // In order to provide interoperability between adapted constant and
+  // mutable iterators, adapted iterators will usually provide templated
+  // conversion constructors of the following form
+  //
+  // template <class BaseIterator>
+  // class adapted_iterator :
+  //   public iterator_adaptor< adapted_iterator<Iterator>, Iterator >
+  // {
+  // public:
+  //
+  //   ...
+  //
+  //   template <class OtherIterator>
+  //   adapted_iterator(
+  //       OtherIterator const& it
+  //     , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0);
+  //
+  //   ...
+  // };
+  //
+  // enable_if_convertible is used to remove those overloads from the overload
+  // set that cannot be instantiated. For all practical purposes only overloads
+  // for constant/mutable interaction will remain. This has the advantage that
+  // meta functions like boost::is_convertible do not return false positives,
+  // as they can only look at the signature of the conversion constructor
+  // and not at the actual instantiation.
+  //
+  // enable_if_interoperable can be safely used in user code. It falls back to
+  // always enabled for compilers that don't support enable_if or is_convertible.
+  // There is no need for compiler specific workarounds in user code.
+  //
+  // The operators implementation relies on boost::is_convertible not returning
+  // false positives for user/library defined iterator types. See comments
+  // on operator implementation for consequences.
+  //
+#  if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)
+
+  template<typename From, typename To>
+  struct enable_if_convertible
+  {
+     typedef typename mpl::if_<
+         mpl::or_<
+             is_same<From,To>
+           , is_convertible<From, To>
+         >
+      , boost::detail::enable_type
+      , int&
+     >::type type;
+  };
+
+#  elif defined(BOOST_NO_IS_CONVERTIBLE) || defined(BOOST_NO_SFINAE)
+
+  template <class From, class To>
+  struct enable_if_convertible
+  {
+      typedef boost::detail::enable_type type;
+  };
+
+#  elif BOOST_WORKAROUND(_MSC_FULL_VER, BOOST_TESTED_AT(13102292)) && BOOST_MSVC > 1300
+
+  // For some reason vc7.1 needs us to "cut off" instantiation
+  // of is_convertible in a few cases.
+  template<typename From, typename To>
+  struct enable_if_convertible
+    : iterators::enable_if<
+        mpl::or_<
+            is_same<From,To>
+          , is_convertible<From, To>
+        >
+      , boost::detail::enable_type
+    >
+  {};
+
+#  else
+
+  template<typename From, typename To>
+  struct enable_if_convertible
+    : iterators::enable_if<
+          is_convertible<From, To>
+        , boost::detail::enable_type
+      >
+  {};
+
+# endif
+
+  //
+  // Default template argument handling for iterator_adaptor
+  //
+  namespace detail
+  {
+    // If T is use_default, return the result of invoking
+    // DefaultNullaryFn, otherwise return T.
+    template <class T, class DefaultNullaryFn>
+    struct ia_dflt_help
+      : mpl::eval_if<
+            is_same<T, use_default>
+          , DefaultNullaryFn
+          , mpl::identity<T>
+        >
+    {
+    };
+
+    // A metafunction which computes an iterator_adaptor's base class,
+    // a specialization of iterator_facade.
+    template <
+        class Derived
+      , class Base
+      , class Value
+      , class Traversal
+      , class Reference
+      , class Difference
+    >
+    struct iterator_adaptor_base
+    {
+        typedef iterator_facade<
+            Derived
+
+# ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY
+          , typename boost::detail::ia_dflt_help<
+                Value
+              , mpl::eval_if<
+                    is_same<Reference,use_default>
+                  , iterator_value<Base>
+                  , remove_reference<Reference>
+                >
+            >::type
+# else
+          , typename boost::detail::ia_dflt_help<
+                Value, iterator_value<Base>
+            >::type
+# endif
+
+          , typename boost::detail::ia_dflt_help<
+                Traversal
+              , iterator_traversal<Base>
+            >::type
+
+          , typename boost::detail::ia_dflt_help<
+                Reference
+              , mpl::eval_if<
+                    is_same<Value,use_default>
+                  , iterator_reference<Base>
+                  , add_reference<Value>
+                >
+            >::type
+
+          , typename boost::detail::ia_dflt_help<
+                Difference, iterator_difference<Base>
+            >::type
+        >
+        type;
+    };
+
+    // workaround for aC++ CR JAGaf33512
+    template <class Tr1, class Tr2>
+    inline void iterator_adaptor_assert_traversal ()
+    {
+      BOOST_STATIC_ASSERT((is_convertible<Tr1, Tr2>::value));
+    }
+  }
+
+  //
+  // Iterator Adaptor
+  //
+  // The parameter ordering changed slightly with respect to former
+  // versions of iterator_adaptor The idea is that when the user needs
+  // to fiddle with the reference type it is highly likely that the
+  // iterator category has to be adjusted as well.  Any of the
+  // following four template arguments may be ommitted or explicitly
+  // replaced by use_default.
+  //
+  //   Value - if supplied, the value_type of the resulting iterator, unless
+  //      const. If const, a conforming compiler strips constness for the
+  //      value_type. If not supplied, iterator_traits<Base>::value_type is used
+  //
+  //   Category - the traversal category of the resulting iterator. If not
+  //      supplied, iterator_traversal<Base>::type is used.
+  //
+  //   Reference - the reference type of the resulting iterator, and in
+  //      particular, the result type of operator*(). If not supplied but
+  //      Value is supplied, Value& is used. Otherwise
+  //      iterator_traits<Base>::reference is used.
+  //
+  //   Difference - the difference_type of the resulting iterator. If not
+  //      supplied, iterator_traits<Base>::difference_type is used.
+  //
+  template <
+      class Derived
+    , class Base
+    , class Value        = use_default
+    , class Traversal    = use_default
+    , class Reference    = use_default
+    , class Difference   = use_default
+  >
+  class iterator_adaptor
+    : public boost::detail::iterator_adaptor_base<
+        Derived, Base, Value, Traversal, Reference, Difference
+      >::type
+  {
+      friend class iterator_core_access;
+
+   protected:
+      typedef typename boost::detail::iterator_adaptor_base<
+          Derived, Base, Value, Traversal, Reference, Difference
+      >::type super_t;
+   public:
+      iterator_adaptor() {}
+
+      explicit iterator_adaptor(Base const &iter)
+          : m_iterator(iter)
+      {
+      }
+
+      typedef Base base_type;
+
+      Base const& base() const
+        { return m_iterator; }
+
+   protected:
+      // for convenience in derived classes
+      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;
+
+      //
+      // lvalue access to the Base object for Derived
+      //
+      Base const& base_reference() const
+        { return m_iterator; }
+
+      Base& base_reference()
+        { return m_iterator; }
+
+   private:
+      //
+      // Core iterator interface for iterator_facade.  This is private
+      // to prevent temptation for Derived classes to use it, which
+      // will often result in an error.  Derived classes should use
+      // base_reference(), above, to get direct access to m_iterator.
+      //
+      typename super_t::reference dereference() const
+        { return *m_iterator; }
+
+      template <
+      class OtherDerived, class OtherIterator, class V, class C, class R, class D
+      >
+      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
+      {
+        // Maybe readd with same_distance
+        //           BOOST_STATIC_ASSERT(
+        //               (detail::same_category_and_difference<Derived,OtherDerived>::value)
+        //               );
+          return m_iterator == x.base();
+      }
+
+      typedef typename iterator_category_to_traversal<
+          typename super_t::iterator_category
+      >::type my_traversal;
+
+# define BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(cat) \
+      boost::detail::iterator_adaptor_assert_traversal<my_traversal, cat>();
+
+      void advance(typename super_t::difference_type n)
+      {
+          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(random_access_traversal_tag)
+          m_iterator += n;
+      }
+
+      void increment() { ++m_iterator; }
+
+      void decrement()
+      {
+          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(bidirectional_traversal_tag)
+           --m_iterator;
+      }
+
+      template <
+          class OtherDerived, class OtherIterator, class V, class C, class R, class D
+      >
+      typename super_t::difference_type distance_to(
+          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
+      {
+          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(random_access_traversal_tag)
+          // Maybe readd with same_distance
+          //           BOOST_STATIC_ASSERT(
+          //               (detail::same_category_and_difference<Derived,OtherDerived>::value)
+          //               );
+          return y.base() - m_iterator;
+      }
+
+# undef BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL
+
+   private: // data members
+      Base m_iterator;
+  };
+
+} // namespace boost
+
+#include <boost/iterator/detail/config_undef.hpp>
+
+#endif // BOOST_ITERATOR_ADAPTOR_23022003THW_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/checked_delete.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/checked_delete.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/checked_delete.hpp	(working copy)
@@ -0,0 +1,69 @@
+#ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED
+#define BOOST_CHECKED_DELETE_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/checked_delete.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//  Copyright (c) 2003 Daniel Frey
+//  Copyright (c) 2003 Howard Hinnant
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  See http://www.boost.org/libs/utility/checked_delete.html for documentation.
+//
+
+namespace boost
+{
+
+// verify that types are complete for increased safety
+
+template<class T> inline void checked_delete(T * x)
+{
+    // intentionally complex - simplification causes regressions
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete x;
+}
+
+template<class T> inline void checked_array_delete(T * x)
+{
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete [] x;
+}
+
+template<class T> struct checked_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        // boost:: disables ADL
+        boost::checked_delete(x);
+    }
+};
+
+template<class T> struct checked_array_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        boost::checked_array_delete(x);
+    }
+};
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/weak_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/weak_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/weak_ptr.hpp	(working copy)
@@ -0,0 +1,18 @@
+#ifndef BOOST_WEAK_PTR_HPP_INCLUDED
+#define BOOST_WEAK_PTR_HPP_INCLUDED
+
+//
+//  weak_ptr.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt
+//
+//  See http://www.boost.org/libs/smart_ptr/weak_ptr.htm for documentation.
+//
+
+#include <boost/smart_ptr/weak_ptr.hpp>
+
+#endif  // #ifndef BOOST_WEAK_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/stdlib/libstdcpp3.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/stdlib/libstdcpp3.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/stdlib/libstdcpp3.hpp	(working copy)
@@ -0,0 +1,153 @@
+//  (C) Copyright John Maddock 2001.
+//  (C) Copyright Jens Maurer 2001.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  config for libstdc++ v3
+//  not much to go in here:
+
+#define BOOST_GNU_STDLIB 1
+
+#ifdef __GLIBCXX__
+#define BOOST_STDLIB "GNU libstdc++ version " BOOST_STRINGIZE(__GLIBCXX__)
+#else
+#define BOOST_STDLIB "GNU libstdc++ version " BOOST_STRINGIZE(__GLIBCPP__)
+#endif
+
+#if !defined(_GLIBCPP_USE_WCHAR_T) && !defined(_GLIBCXX_USE_WCHAR_T)
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#  define BOOST_NO_STD_WSTRING
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+
+#if defined(__osf__) && !defined(_REENTRANT) \
+  && ( defined(_GLIBCXX_HAVE_GTHR_DEFAULT) || defined(_GLIBCPP_HAVE_GTHR_DEFAULT) )
+// GCC 3 on Tru64 forces the definition of _REENTRANT when any std lib header
+// file is included, therefore for consistency we define it here as well.
+#  define _REENTRANT
+#endif
+
+#ifdef __GLIBCXX__ // gcc 3.4 and greater:
+#  if defined(_GLIBCXX_HAVE_GTHR_DEFAULT) \
+        || defined(_GLIBCXX__PTHREADS)
+      //
+      // If the std lib has thread support turned on, then turn it on in Boost
+      // as well.  We do this because some gcc-3.4 std lib headers define _REENTANT
+      // while others do not...
+      //
+#     define BOOST_HAS_THREADS
+#  else
+#     define BOOST_DISABLE_THREADS
+#  endif
+#elif defined(__GLIBCPP__) \
+        && !defined(_GLIBCPP_HAVE_GTHR_DEFAULT) \
+        && !defined(_GLIBCPP__PTHREADS)
+   // disable thread support if the std lib was built single threaded:
+#  define BOOST_DISABLE_THREADS
+#endif
+
+#if (defined(linux) || defined(__linux) || defined(__linux__)) && defined(__arm__) && defined(_GLIBCPP_HAVE_GTHR_DEFAULT)
+// linux on arm apparently doesn't define _REENTRANT
+// so just turn on threading support whenever the std lib is thread safe:
+#  define BOOST_HAS_THREADS
+#endif
+
+#if !defined(_GLIBCPP_USE_LONG_LONG) \
+    && !defined(_GLIBCXX_USE_LONG_LONG)\
+    && defined(BOOST_HAS_LONG_LONG)
+// May have been set by compiler/*.hpp, but "long long" without library
+// support is useless.
+#  undef BOOST_HAS_LONG_LONG
+#endif
+
+// Apple doesn't seem to reliably defined a *unix* macro
+#if !defined(CYGWIN) && (  defined(__unix__)  \
+                        || defined(__unix)    \
+                        || defined(unix)      \
+                        || defined(__APPLE__) \
+                        || defined(__APPLE)   \
+                        || defined(APPLE))
+#  include <unistd.h>
+#endif
+
+#if defined(__GLIBCXX__) || (defined(__GLIBCPP__) && __GLIBCPP__>=20020514) // GCC >= 3.1.0
+#  define BOOST_STD_EXTENSION_NAMESPACE __gnu_cxx
+#  define BOOST_HAS_SLIST
+#  define BOOST_HAS_HASH
+#  define BOOST_SLIST_HEADER <ext/slist>
+# if !defined(__GNUC__) || __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3)
+#   define BOOST_HASH_SET_HEADER <ext/hash_set>
+#   define BOOST_HASH_MAP_HEADER <ext/hash_map>
+# else
+#   define BOOST_HASH_SET_HEADER <backward/hash_set>
+#   define BOOST_HASH_MAP_HEADER <backward/hash_map>
+# endif
+#endif
+
+//  stdlibc++ C++0x support is detected via __GNUC__, __GNUC_MINOR__, and possibly
+//  __GNUC_PATCHLEVEL__ at the suggestion of Jonathan Wakely, one of the stdlibc++
+//  developers. He also commented:
+//
+//       "I'm not sure how useful __GLIBCXX__ is for your purposes, for instance in
+//       GCC 4.2.4 it is set to 20080519 but in GCC 4.3.0 it is set to 20080305.
+//       Although 4.3.0 was released earlier than 4.2.4, it has better C++0x support
+//       than any release in the 4.2 series."
+//
+//  Another resource for understanding stdlibc++ features is:
+//  http://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#manual.intro.status.standard.200x
+
+//  C++0x headers in GCC 4.3.0 and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 3) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  define BOOST_NO_0X_HDR_ARRAY
+#  define BOOST_NO_0X_HDR_REGEX
+#  define BOOST_NO_0X_HDR_TUPLE
+#  define BOOST_NO_STD_UNORDERED  // deprecated; see following
+#  define BOOST_NO_0X_HDR_UNORDERED_MAP
+#  define BOOST_NO_0X_HDR_UNORDERED_SET
+#endif
+
+//  C++0x headers in GCC 4.4.0 and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 4) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  define BOOST_NO_0X_HDR_CHRONO
+#  define BOOST_NO_0X_HDR_CONDITION_VARIABLE
+#  define BOOST_NO_0X_HDR_FORWARD_LIST
+#  define BOOST_NO_0X_HDR_INITIALIZER_LIST
+#  define BOOST_NO_0X_HDR_MUTEX
+#  define BOOST_NO_0X_HDR_RATIO
+#  define BOOST_NO_0X_HDR_SYSTEM_ERROR
+#else
+#  define BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG
+#  define BOOST_HAS_TR1_COMPLEX_OVERLOADS
+#endif
+
+#if (!defined(_GLIBCXX_HAS_GTHREADS) || !defined(_GLIBCXX_USE_C99_STDINT_TR1)) && (!defined(BOOST_NO_0X_HDR_CONDITION_VARIABLE) || !defined(BOOST_NO_0X_HDR_MUTEX))
+#  define BOOST_NO_0X_HDR_CONDITION_VARIABLE
+#  define BOOST_NO_0X_HDR_MUTEX
+#endif
+
+//  C++0x features in GCC 4.5.0 and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  define BOOST_NO_NUMERIC_LIMITS_LOWEST
+#  define BOOST_NO_0X_HDR_FUTURE
+#  define BOOST_NO_0X_HDR_RANDOM
+#endif
+
+//  C++0x features in GCC 4.5.0 and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  define BOOST_NO_0X_HDR_TYPEINDEX
+#endif
+//  C++0x headers not yet (fully!) implemented
+//
+#  define BOOST_NO_0X_HDR_THREAD
+#  define BOOST_NO_0X_HDR_TYPE_TRAITS
+#  define BOOST_NO_0X_HDR_CODECVT
+
+//  --- end ---
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_compiler_config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_compiler_config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_compiler_config.hpp	(working copy)
@@ -0,0 +1,112 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Martin Wille 2003.
+//  (C) Copyright Guillaume Melquiond 2003.
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  (See accompanying file LICENSE_1_0.txt or copy at
+//   http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/ for most recent version.
+
+// locate which compiler we are using and define
+// BOOST_COMPILER_CONFIG as needed:
+
+#if defined(__GCCXML__)
+// GCC-XML emulates other compilers, it has to appear first here!
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/gcc_xml.hpp"
+
+#elif defined(_CRAYC)
+// EDG based Cray compiler:
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/cray.hpp"
+
+#elif defined __CUDACC__
+//  NVIDIA CUDA C++ compiler for GPU
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/nvcc.hpp"
+
+#elif defined __COMO__
+//  Comeau C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/comeau.hpp"
+
+#elif defined(__PATHSCALE__) && (__PATHCC__ >= 4)
+// PathScale EKOPath compiler (has to come before clang and gcc)
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/pathscale.hpp"
+
+#elif defined __clang__
+//  Clang C++ emulates GCC, so it has to appear early.
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/clang.hpp"
+
+#elif defined __DMC__
+//  Digital Mars C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/digitalmars.hpp"
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/intel.hpp"
+
+# elif defined __GNUC__
+//  GNU C++:
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/gcc.hpp"
+
+#elif defined __KCC
+//  Kai C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/kai.hpp"
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/sgi_mipspro.hpp"
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/compaq_cxx.hpp"
+
+#elif defined __ghs
+//  Greenhills C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/greenhills.hpp"
+
+#elif defined __CODEGEARC__
+//  CodeGear - must be checked for before Borland
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/codegear.hpp"
+
+#elif defined __BORLANDC__
+//  Borland
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/borland.hpp"
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/metrowerks.hpp"
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/sunpro_cc.hpp"
+
+#elif defined __HP_aCC
+//  HP aCC
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/hp_acc.hpp"
+
+#elif defined(__MRC__) || defined(__SC__)
+//  MPW MrCpp or SCpp
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/mpw.hpp"
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/vacpp.hpp"
+
+#elif defined(__PGI)
+//  Portland Group Inc.
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/pgi.hpp"
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/visualc.hpp"
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the compiler:
+#  error "Unknown compiler - please configure (http://www.boost.org/libs/config/config.htm#configuring) and report the results to the main boost mailing list (http://www.boost.org/more/mailing_lists.htm#main)"
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/platform/win32.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/platform/win32.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/platform/win32.hpp	(working copy)
@@ -0,0 +1,71 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Bill Kempf 2001.
+//  (C) Copyright Aleksey Gurtovoy 2003.
+//  (C) Copyright Rene Rivera 2005.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  Win32 specific config options:
+
+#define BOOST_PLATFORM "Win32"
+
+//  Get the information about the MinGW runtime, i.e. __MINGW32_*VERSION.
+#if defined(__MINGW32__)
+#  include <_mingw.h>
+#endif
+
+#if defined(__GNUC__) && !defined(BOOST_NO_SWPRINTF)
+#  define BOOST_NO_SWPRINTF
+#endif
+
+//  Default defines for BOOST_SYMBOL_EXPORT and BOOST_SYMBOL_IMPORT
+//  If a compiler doesn't support __declspec(dllexport)/__declspec(dllimport),
+//  its boost/config/compiler/ file must define BOOST_SYMBOL_EXPORT and
+//  BOOST_SYMBOL_IMPORT
+#ifndef BOOST_SYMBOL_EXPORT
+#  define BOOST_HAS_DECLSPEC
+#  define BOOST_SYMBOL_EXPORT __declspec(dllexport)
+#  define BOOST_SYMBOL_IMPORT __declspec(dllimport)
+#endif
+
+#if defined(__MINGW32__) && ((__MINGW32_MAJOR_VERSION > 2) || ((__MINGW32_MAJOR_VERSION == 2) && (__MINGW32_MINOR_VERSION >= 0)))
+#  define BOOST_HAS_STDINT_H
+#  define __STDC_LIMIT_MACROS
+#  define BOOST_HAS_DIRENT_H
+#  define BOOST_HAS_UNISTD_H
+#endif
+
+#if defined(__MINGW32__) && (__GNUC__ >= 4)
+#  define BOOST_HAS_EXPM1
+#  define BOOST_HAS_LOG1P
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+//
+// Win32 will normally be using native Win32 threads,
+// but there is a pthread library avaliable as an option,
+// we used to disable this when BOOST_DISABLE_WIN32 was
+// defined but no longer - this should allow some
+// files to be compiled in strict mode - while maintaining
+// a consistent setting of BOOST_HAS_THREADS across
+// all translation units (needed for shared_ptr etc).
+//
+
+#ifdef _WIN32_WCE
+#  define BOOST_NO_ANSI_APIS
+#else
+#  define BOOST_HAS_GETSYSTEMTIMEASFILETIME
+#endif
+
+#ifndef BOOST_HAS_PTHREADS
+#  define BOOST_HAS_WINTHREADS
+#endif
+
+#ifndef BOOST_DISABLE_WIN32
+// WEK: Added
+#define BOOST_HAS_FTIME
+#define BOOST_WINDOWS 1
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/suffix.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/suffix.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/suffix.hpp	(working copy)
@@ -0,0 +1,678 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  Copyright (c) 2001-2003 John Maddock
+//  Copyright (c) 2001 Darin Adler
+//  Copyright (c) 2001 Peter Dimov
+//  Copyright (c) 2002 Bill Kempf
+//  Copyright (c) 2002 Jens Maurer
+//  Copyright (c) 2002-2003 David Abrahams
+//  Copyright (c) 2003 Gennaro Prota
+//  Copyright (c) 2003 Eric Friedman
+//  Copyright (c) 2010 Eric Jourdanneau, Joel Falcou
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/ for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  http://www.boost.org/libs/config/
+//
+//  This file is intended to be stable, and relatively unchanging.
+//  It should contain boilerplate code only - no compiler specific
+//  code unless it is unavoidable - no changes unless unavoidable.
+
+#ifndef BOOST_CONFIG_SUFFIX_HPP
+#define BOOST_CONFIG_SUFFIX_HPP
+
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+//
+// Some GCC-4.x versions issue warnings even when __extension__ is used,
+// so use this as a workaround:
+//
+#pragma GCC system_header
+#endif
+
+//
+// ensure that visibility macros are always defined, thus symplifying use
+//
+#ifndef BOOST_SYMBOL_EXPORT
+# define BOOST_SYMBOL_EXPORT
+#endif
+#ifndef BOOST_SYMBOL_IMPORT
+# define BOOST_SYMBOL_IMPORT
+#endif
+#ifndef BOOST_SYMBOL_VISIBLE
+# define BOOST_SYMBOL_VISIBLE
+#endif
+
+//
+// look for long long by looking for the appropriate macros in <limits.h>.
+// Note that we use limits.h rather than climits for maximal portability,
+// remember that since these just declare a bunch of macros, there should be
+// no namespace issues from this.
+//
+#if !defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG)                                              \
+   && !defined(BOOST_MSVC) && !defined(__BORLANDC__)
+# include <limits.h>
+# if (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))
+#   define BOOST_HAS_LONG_LONG
+# else
+#   define BOOST_NO_LONG_LONG
+# endif
+#endif
+
+// GCC 3.x will clean up all of those nasty macro definitions that
+// BOOST_NO_CTYPE_FUNCTIONS is intended to help work around, so undefine
+// it under GCC 3.x.
+#if defined(__GNUC__) && (__GNUC__ >= 3) && defined(BOOST_NO_CTYPE_FUNCTIONS)
+#  undef BOOST_NO_CTYPE_FUNCTIONS
+#endif
+
+//
+// Assume any extensions are in namespace std:: unless stated otherwise:
+//
+#  ifndef BOOST_STD_EXTENSION_NAMESPACE
+#    define BOOST_STD_EXTENSION_NAMESPACE std
+#  endif
+
+//
+// If cv-qualified specializations are not allowed, then neither are cv-void ones:
+//
+#  if defined(BOOST_NO_CV_SPECIALIZATIONS) \
+      && !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+#     define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  endif
+
+//
+// If there is no numeric_limits template, then it can't have any compile time
+// constants either!
+//
+#  if defined(BOOST_NO_LIMITS) \
+      && !defined(BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS)
+#     define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#     define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#  endif
+
+//
+// if there is no long long then there is no specialisation
+// for numeric_limits<long long> either:
+//
+#if !defined(BOOST_HAS_LONG_LONG) && !defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#endif
+
+//
+// Normalize BOOST_NO_STATIC_ASSERT and (depricated) BOOST_HAS_STATIC_ASSERT:
+//
+#if !defined(BOOST_NO_STATIC_ASSERT) && !defined(BOOST_HAS_STATIC_ASSERT)
+#  define BOOST_HAS_STATIC_ASSERT
+#endif
+
+//
+// if there is no __int64 then there is no specialisation
+// for numeric_limits<__int64> either:
+//
+#if !defined(BOOST_HAS_MS_INT64) && !defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS)
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// if member templates are supported then so is the
+// VC6 subset of member templates:
+//
+#  if !defined(BOOST_NO_MEMBER_TEMPLATES) \
+       && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#     define BOOST_MSVC6_MEMBER_TEMPLATES
+#  endif
+
+//
+// Without partial specialization, can't test for partial specialisation bugs:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_BCB_PARTIAL_SPECIALIZATION_BUG)
+#     define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  endif
+
+//
+// Without partial specialization, we can't have array-type partial specialisations:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+#     define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#  endif
+
+//
+// Without partial specialization, std::iterator_traits can't work:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_NO_STD_ITERATOR_TRAITS)
+#     define BOOST_NO_STD_ITERATOR_TRAITS
+#  endif
+
+//
+// Without partial specialization, partial
+// specialization with default args won't work either:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      && !defined(BOOST_NO_PARTIAL_SPECIALIZATION_IMPLICIT_DEFAULT_ARGS)
+#     define BOOST_NO_PARTIAL_SPECIALIZATION_IMPLICIT_DEFAULT_ARGS
+#  endif
+
+//
+// Without member template support, we can't have template constructors
+// in the standard library either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      && !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      && !defined(BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS)
+#     define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  endif
+
+//
+// Without member template support, we can't have a conforming
+// std::allocator template either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      && !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      && !defined(BOOST_NO_STD_ALLOCATOR)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+
+//
+// without ADL support then using declarations will break ADL as well:
+//
+#if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP) && !defined(BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+//
+// Without typeid support we have no dynamic RTTI either:
+//
+#if defined(BOOST_NO_TYPEID) && !defined(BOOST_NO_RTTI)
+#  define BOOST_NO_RTTI
+#endif
+
+//
+// If we have a standard allocator, then we have a partial one as well:
+//
+#if !defined(BOOST_NO_STD_ALLOCATOR)
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+//
+// We can't have a working std::use_facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_USE_FACET)
+#     define BOOST_NO_STD_USE_FACET
+#  endif
+
+//
+// We can't have a std::messages facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_MESSAGES)
+#     define BOOST_NO_STD_MESSAGES
+#  endif
+
+//
+// We can't have a working std::wstreambuf if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) && !defined(BOOST_NO_STD_WSTREAMBUF)
+#     define BOOST_NO_STD_WSTREAMBUF
+#  endif
+
+//
+// We can't have a <cwctype> if there is no <cwchar>:
+//
+#  if defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_CWCTYPE)
+#     define BOOST_NO_CWCTYPE
+#  endif
+
+//
+// We can't have a swprintf if there is no <cwchar>:
+//
+#  if defined(BOOST_NO_CWCHAR) && !defined(BOOST_NO_SWPRINTF)
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+//
+// If Win32 support is turned off, then we must turn off
+// threading support also, unless there is some other
+// thread API enabled:
+//
+#if defined(BOOST_DISABLE_WIN32) && defined(_WIN32) \
+   && !defined(BOOST_DISABLE_THREADS) && !defined(BOOST_HAS_PTHREADS)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+//
+// Turn on threading support if the compiler thinks that it's in
+// multithreaded mode.  We put this here because there are only a
+// limited number of macros that identify this (if there's any missing
+// from here then add to the appropriate compiler section):
+//
+#if (defined(__MT__) || defined(_MT) || defined(_REENTRANT) \
+    || defined(_PTHREADS) || defined(__APPLE__) || defined(__DragonFly__)) \
+    && !defined(BOOST_HAS_THREADS)
+#  define BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if BOOST_DISABLE_THREADS is defined:
+//
+#if defined(BOOST_DISABLE_THREADS) && defined(BOOST_HAS_THREADS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if we don't recognise the threading API:
+//
+#if defined(BOOST_HAS_THREADS) && !defined(BOOST_HAS_PTHREADS)\
+      && !defined(BOOST_HAS_WINTHREADS) && !defined(BOOST_HAS_BETHREADS)\
+      && !defined(BOOST_HAS_MPTASKS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading detail macros off if we don't (want to) use threading
+//
+#ifndef BOOST_HAS_THREADS
+#  undef BOOST_HAS_PTHREADS
+#  undef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  undef BOOST_HAS_PTHREAD_YIELD
+#  undef BOOST_HAS_PTHREAD_DELAY_NP
+#  undef BOOST_HAS_WINTHREADS
+#  undef BOOST_HAS_BETHREADS
+#  undef BOOST_HAS_MPTASKS
+#endif
+
+//
+// If the compiler claims to be C99 conformant, then it had better
+// have a <stdint.h>:
+//
+#  if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)
+#     define BOOST_HAS_STDINT_H
+#     ifndef BOOST_HAS_LOG1P
+#        define BOOST_HAS_LOG1P
+#     endif
+#     ifndef BOOST_HAS_EXPM1
+#        define BOOST_HAS_EXPM1
+#     endif
+#  endif
+
+//
+// Define BOOST_NO_SLIST and BOOST_NO_HASH if required.
+// Note that this is for backwards compatibility only.
+//
+#  if !defined(BOOST_HAS_SLIST) && !defined(BOOST_NO_SLIST)
+#     define BOOST_NO_SLIST
+#  endif
+
+#  if !defined(BOOST_HAS_HASH) && !defined(BOOST_NO_HASH)
+#     define BOOST_NO_HASH
+#  endif
+
+//
+// Set BOOST_SLIST_HEADER if not set already:
+//
+#if defined(BOOST_HAS_SLIST) && !defined(BOOST_SLIST_HEADER)
+#  define BOOST_SLIST_HEADER <slist>
+#endif
+
+//
+// Set BOOST_HASH_SET_HEADER if not set already:
+//
+#if defined(BOOST_HAS_HASH) && !defined(BOOST_HASH_SET_HEADER)
+#  define BOOST_HASH_SET_HEADER <hash_set>
+#endif
+
+//
+// Set BOOST_HASH_MAP_HEADER if not set already:
+//
+#if defined(BOOST_HAS_HASH) && !defined(BOOST_HASH_MAP_HEADER)
+#  define BOOST_HASH_MAP_HEADER <hash_map>
+#endif
+
+//
+// Set BOOST_NO_INITIALIZER_LISTS if there is no library support.
+//
+
+#if defined(BOOST_NO_0X_HDR_INITIALIZER_LIST) && !defined(BOOST_NO_INITIALIZER_LISTS)
+#  define BOOST_NO_INITIALIZER_LISTS
+#endif
+#if defined(BOOST_NO_INITIALIZER_LISTS) && !defined(BOOST_NO_0X_HDR_INITIALIZER_LIST)
+#  define BOOST_NO_0X_HDR_INITIALIZER_LIST
+#endif
+
+//
+// Set BOOST_HAS_RVALUE_REFS when BOOST_NO_RVALUE_REFERENCES is not defined
+//
+#if !defined(BOOST_NO_RVALUE_REFERENCES) && !defined(BOOST_HAS_RVALUE_REFS)
+#define BOOST_HAS_RVALUE_REFS
+#endif
+
+//
+// Set BOOST_HAS_VARIADIC_TMPL when BOOST_NO_VARIADIC_TEMPLATES is not defined
+//
+#if !defined(BOOST_NO_VARIADIC_TEMPLATES) && !defined(BOOST_HAS_VARIADIC_TMPL)
+#define BOOST_HAS_VARIADIC_TMPL
+#endif
+
+//
+// Set BOOST_NO_DECLTYPE_N3276 when BOOST_NO_DECLTYPE is defined
+//
+#if !defined(BOOST_NO_DECLTYPE_N3276) && defined(BOOST_NO_DECLTYPE)
+#define BOOST_NO_DECLTYPE_N3276
+#endif
+
+//  BOOST_HAS_ABI_HEADERS
+//  This macro gets set if we have headers that fix the ABI,
+//  and prevent ODR violations when linking to external libraries:
+#if defined(BOOST_ABI_PREFIX) && defined(BOOST_ABI_SUFFIX) && !defined(BOOST_HAS_ABI_HEADERS)
+#  define BOOST_HAS_ABI_HEADERS
+#endif
+
+#if defined(BOOST_HAS_ABI_HEADERS) && defined(BOOST_DISABLE_ABI_HEADERS)
+#  undef BOOST_HAS_ABI_HEADERS
+#endif
+
+//  BOOST_NO_STDC_NAMESPACE workaround  --------------------------------------//
+//  Because std::size_t usage is so common, even in boost headers which do not
+//  otherwise use the C library, the <cstddef> workaround is included here so
+//  that ugly workaround code need not appear in many other boost headers.
+//  NOTE WELL: This is a workaround for non-conforming compilers; <cstddef>
+//  must still be #included in the usual places so that <cstddef> inclusion
+//  works as expected with standard conforming compilers.  The resulting
+//  double inclusion of <cstddef> is harmless.
+
+# if defined(BOOST_NO_STDC_NAMESPACE) && defined(__cplusplus)
+#   include <cstddef>
+    namespace std { using ::ptrdiff_t; using ::size_t; }
+# endif
+
+//  Workaround for the unfortunate min/max macros defined by some platform headers
+
+#define BOOST_PREVENT_MACRO_SUBSTITUTION
+
+#ifndef BOOST_USING_STD_MIN
+#  define BOOST_USING_STD_MIN() using std::min
+#endif
+
+#ifndef BOOST_USING_STD_MAX
+#  define BOOST_USING_STD_MAX() using std::max
+#endif
+
+//  BOOST_NO_STD_MIN_MAX workaround  -----------------------------------------//
+
+#  if defined(BOOST_NO_STD_MIN_MAX) && defined(__cplusplus)
+
+namespace std {
+  template <class _Tp>
+  inline const _Tp& min BOOST_PREVENT_MACRO_SUBSTITUTION (const _Tp& __a, const _Tp& __b) {
+    return __b < __a ? __b : __a;
+  }
+  template <class _Tp>
+  inline const _Tp& max BOOST_PREVENT_MACRO_SUBSTITUTION (const _Tp& __a, const _Tp& __b) {
+    return  __a < __b ? __b : __a;
+  }
+}
+
+#  endif
+
+// BOOST_STATIC_CONSTANT workaround --------------------------------------- //
+// On compilers which don't allow in-class initialization of static integral
+// constant members, we must use enums as a workaround if we want the constants
+// to be available at compile-time. This macro gives us a convenient way to
+// declare such constants.
+
+#  ifdef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#       define BOOST_STATIC_CONSTANT(type, assignment) enum { assignment }
+#  else
+#     define BOOST_STATIC_CONSTANT(type, assignment) static const type assignment
+#  endif
+
+// BOOST_USE_FACET / HAS_FACET workaround ----------------------------------//
+// When the standard library does not have a conforming std::use_facet there
+// are various workarounds available, but they differ from library to library.
+// The same problem occurs with has_facet.
+// These macros provide a consistent way to access a locale's facets.
+// Usage:
+//    replace
+//       std::use_facet<Type>(loc);
+//    with
+//       BOOST_USE_FACET(Type, loc);
+//    Note do not add a std:: prefix to the front of BOOST_USE_FACET!
+//  Use for BOOST_HAS_FACET is analogous.
+
+#if defined(BOOST_NO_STD_USE_FACET)
+#  ifdef BOOST_HAS_TWO_ARG_USE_FACET
+#     define BOOST_USE_FACET(Type, loc) std::use_facet(loc, static_cast<Type*>(0))
+#     define BOOST_HAS_FACET(Type, loc) std::has_facet(loc, static_cast<Type*>(0))
+#  elif defined(BOOST_HAS_MACRO_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) std::_USE(loc, Type)
+#     define BOOST_HAS_FACET(Type, loc) std::_HAS(loc, Type)
+#  elif defined(BOOST_HAS_STLP_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) (*std::_Use_facet<Type >(loc))
+#     define BOOST_HAS_FACET(Type, loc) std::has_facet< Type >(loc)
+#  endif
+#else
+#  define BOOST_USE_FACET(Type, loc) std::use_facet< Type >(loc)
+#  define BOOST_HAS_FACET(Type, loc) std::has_facet< Type >(loc)
+#endif
+
+// BOOST_NESTED_TEMPLATE workaround ------------------------------------------//
+// Member templates are supported by some compilers even though they can't use
+// the A::template member<U> syntax, as a workaround replace:
+//
+// typedef typename A::template rebind<U> binder;
+//
+// with:
+//
+// typedef typename A::BOOST_NESTED_TEMPLATE rebind<U> binder;
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#  define BOOST_NESTED_TEMPLATE template
+#else
+#  define BOOST_NESTED_TEMPLATE
+#endif
+
+// BOOST_UNREACHABLE_RETURN(x) workaround -------------------------------------//
+// Normally evaluates to nothing, unless BOOST_NO_UNREACHABLE_RETURN_DETECTION
+// is defined, in which case it evaluates to return x; Use when you have a return
+// statement that can never be reached.
+
+#ifdef BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#  define BOOST_UNREACHABLE_RETURN(x) return x;
+#else
+#  define BOOST_UNREACHABLE_RETURN(x)
+#endif
+
+// BOOST_DEDUCED_TYPENAME workaround ------------------------------------------//
+//
+// Some compilers don't support the use of `typename' for dependent
+// types in deduced contexts, e.g.
+//
+//     template <class T> void f(T, typename T::type);
+//                                  ^^^^^^^^
+// Replace these declarations with:
+//
+//     template <class T> void f(T, BOOST_DEDUCED_TYPENAME T::type);
+
+#ifndef BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_DEDUCED_TYPENAME typename
+#else
+#  define BOOST_DEDUCED_TYPENAME
+#endif
+
+#ifndef BOOST_NO_TYPENAME_WITH_CTOR
+#  define BOOST_CTOR_TYPENAME typename
+#else
+#  define BOOST_CTOR_TYPENAME
+#endif
+
+// long long workaround ------------------------------------------//
+// On gcc (and maybe other compilers?) long long is alway supported
+// but it's use may generate either warnings (with -ansi), or errors
+// (with -pedantic -ansi) unless it's use is prefixed by __extension__
+//
+#if defined(BOOST_HAS_LONG_LONG) && defined(__cplusplus)
+namespace boost{
+#  ifdef __GNUC__
+   __extension__ typedef long long long_long_type;
+   __extension__ typedef unsigned long long ulong_long_type;
+#  else
+   typedef long long long_long_type;
+   typedef unsigned long long ulong_long_type;
+#  endif
+}
+#endif
+
+// BOOST_[APPEND_]EXPLICIT_TEMPLATE_[NON_]TYPE macros --------------------------//
+//
+// Some compilers have problems with function templates whose template
+// parameters don't appear in the function parameter list (basically
+// they just link one instantiation of the template in the final
+// executable). These macros provide a uniform way to cope with the
+// problem with no effects on the calling syntax.
+
+// Example:
+//
+//  #include <iostream>
+//  #include <ostream>
+//  #include <typeinfo>
+//
+//  template <int n>
+//  void f() { std::cout << n << ' '; }
+//
+//  template <typename T>
+//  void g() { std::cout << typeid(T).name() << ' '; }
+//
+//  int main() {
+//    f<1>();
+//    f<2>();
+//
+//    g<int>();
+//    g<double>();
+//  }
+//
+// With VC++ 6.0 the output is:
+//
+//   2 2 double double
+//
+// To fix it, write
+//
+//   template <int n>
+//   void f(BOOST_EXPLICIT_TEMPLATE_NON_TYPE(int, n)) { ... }
+//
+//   template <typename T>
+//   void g(BOOST_EXPLICIT_TEMPLATE_TYPE(T)) { ... }
+//
+
+
+#if defined(BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS) && defined(__cplusplus)
+
+#  include "boost/type.hpp"
+#  include "boost/non_type.hpp"
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)              boost::type<t>* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)         boost::type<t>*
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)       boost::non_type<t, v>* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  boost::non_type<t, v>*
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)        \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)   \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v) \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)    \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#else
+
+// no workaround needed: expand to nothing
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+
+#endif // defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+// When BOOST_NO_STD_TYPEINFO is defined, we can just import
+// the global definition into std namespace:
+#if defined(BOOST_NO_STD_TYPEINFO) && defined(__cplusplus)
+#include <typeinfo>
+namespace std{ using ::type_info; }
+#endif
+
+// ---------------------------------------------------------------------------//
+
+//
+// Helper macro BOOST_STRINGIZE:
+// Converts the parameter X to a string after macro replacement
+// on X has been performed.
+//
+#define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#define BOOST_DO_STRINGIZE(X) #X
+
+//
+// Helper macro BOOST_JOIN:
+// The following piece of macro magic joins the two
+// arguments together, even when one of the arguments is
+// itself a macro (see 16.3.1 in C++ standard).  The key
+// is that macro expansion of macro arguments does not
+// occur in BOOST_DO_JOIN2 but does in BOOST_DO_JOIN.
+//
+#define BOOST_JOIN( X, Y ) BOOST_DO_JOIN( X, Y )
+#define BOOST_DO_JOIN( X, Y ) BOOST_DO_JOIN2(X,Y)
+#define BOOST_DO_JOIN2( X, Y ) X##Y
+
+//
+// Set some default values for compiler/library/platform names.
+// These are for debugging config setup only:
+//
+#  ifndef BOOST_COMPILER
+#     define BOOST_COMPILER "Unknown ISO C++ Compiler"
+#  endif
+#  ifndef BOOST_STDLIB
+#     define BOOST_STDLIB "Unknown ISO standard library"
+#  endif
+#  ifndef BOOST_PLATFORM
+#     if defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) \
+         || defined(_POSIX_SOURCE)
+#        define BOOST_PLATFORM "Generic Unix"
+#     else
+#        define BOOST_PLATFORM "Unknown"
+#     endif
+#  endif
+
+//
+// Set some default values GPU support
+//
+#  ifndef BOOST_GPU_ENABLED
+#  define BOOST_GPU_ENABLED
+#  endif
+
+//
+// constexpr workarounds
+//
+#if defined(BOOST_NO_CONSTEXPR)
+#define BOOST_CONSTEXPR
+#define BOOST_CONSTEXPR_OR_CONST const
+#else
+#define BOOST_CONSTEXPR constexpr
+#define BOOST_CONSTEXPR_OR_CONST constexpr
+#endif
+
+#define BOOST_STATIC_CONSTEXPR  static BOOST_CONSTEXPR_OR_CONST
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_stdlib_config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_stdlib_config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_stdlib_config.hpp	(working copy)
@@ -0,0 +1,85 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Jens Maurer 2001 - 2002.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+
+//  See http://www.boost.org for most recent version.
+
+// locate which std lib we are using and define BOOST_STDLIB_CONFIG as needed:
+
+// First include <cstddef> to determine if some version of STLport is in use as the std lib
+// (do not rely on this header being included since users can short-circuit this header
+//  if they know whose std lib they are using.)
+#ifdef __cplusplus
+#  include <cstddef>
+#else
+#  include <stddef.h>
+#endif
+
+#if defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+// STLPort library; this _must_ come first, otherwise since
+// STLport typically sits on top of some other library, we
+// can end up detecting that first rather than STLport:
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/stlport.hpp"
+
+#else
+
+// If our std lib was not some version of STLport, then include <utility> as it is about
+// the smallest of the std lib headers that includes real C++ stuff.  (Some std libs do not
+// include their C++-related macros in <cstddef> so this additional include makes sure
+// we get those definitions)
+// (again do not rely on this header being included since users can short-circuit this
+//  header if they know whose std lib they are using.)
+#include <boost/config/no_tr1/utility.hpp>
+
+#if defined(__LIBCOMO__)
+// Comeau STL:
+#define BOOST_STDLIB_CONFIG "boost/config/stdlib/libcomo.hpp"
+
+#elif defined(__STD_RWCOMPILER_H__) || defined(_RWSTD_VER)
+// Rogue Wave library:
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/roguewave.hpp"
+
+#elif defined(_LIBCPP_VERSION)
+// libc++
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/libcpp.hpp"
+
+#elif defined(__GLIBCPP__) || defined(__GLIBCXX__)
+// GNU libstdc++ 3
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/libstdcpp3.hpp"
+
+#elif defined(__STL_CONFIG_H)
+// generic SGI STL
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/sgi.hpp"
+
+#elif defined(__MSL_CPP__)
+// MSL standard lib:
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/msl.hpp"
+
+#elif defined(__IBMCPP__)
+// take the default VACPP std lib
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/vacpp.hpp"
+
+#elif defined(MSIPL_COMPILE_H)
+// Modena C++ standard library
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/modena.hpp"
+
+#elif (defined(_YVALS) && !defined(__IBMCPP__)) || defined(_CPPLIB_VER)
+// Dinkumware Library (this has to appear after any possible replacement libraries):
+#  define BOOST_STDLIB_CONFIG "boost/config/stdlib/dinkumware.hpp"
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the library:
+#  error "Unknown standard library - please configure and report the results to boost.org"
+
+#endif
+
+#endif
+
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_platform_config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_platform_config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/select_platform_config.hpp	(working copy)
@@ -0,0 +1,105 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2002.
+//  (C) Copyright Jens Maurer 2001.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+// locate which platform we are on and define BOOST_PLATFORM_CONFIG as needed.
+// Note that we define the headers to include using "header_name" not
+// <header_name> in order to prevent macro expansion within the header
+// name (for example "linux" is a macro on linux systems).
+
+#if (defined(linux) || defined(__linux) || defined(__linux__) || defined(__GNU__) || defined(__GLIBC__)) && !defined(_CRAYC)
+// linux, also other platforms (Hurd etc) that use GLIBC, should these really have their own config headers though?
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/linux.hpp"
+
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+// BSD:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/bsd.hpp"
+
+#elif defined(sun) || defined(__sun)
+// solaris:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/solaris.hpp"
+
+#elif defined(__sgi)
+// SGI Irix:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/irix.hpp"
+
+#elif defined(__hpux)
+// hp unix:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/hpux.hpp"
+
+#elif defined(__CYGWIN__)
+// cygwin is not win32:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/cygwin.hpp"
+
+#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
+// win32:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/win32.hpp"
+
+#elif defined(__BEOS__)
+// BeOS
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/beos.hpp"
+
+#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)
+// MacOS
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/macos.hpp"
+
+#elif defined(__IBMCPP__) || defined(_AIX)
+// IBM
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/aix.hpp"
+
+#elif defined(__amigaos__)
+// AmigaOS
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/amigaos.hpp"
+
+#elif defined(__QNXNTO__)
+// QNX:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/qnxnto.hpp"
+
+#elif defined(__VXWORKS__)
+// vxWorks:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/vxworks.hpp"
+
+#elif defined(__SYMBIAN32__)
+// Symbian:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/symbian.hpp"
+
+#elif defined(_CRAYC)
+// Cray:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/cray.hpp"
+
+#elif defined(__VMS)
+// VMS:
+#  define BOOST_PLATFORM_CONFIG "boost/config/platform/vms.hpp"
+#else
+
+#  if defined(unix) \
+      || defined(__unix) \
+      || defined(_XOPEN_SOURCE) \
+      || defined(_POSIX_SOURCE)
+
+   // generic unix platform:
+
+#  ifndef BOOST_HAS_UNISTD_H
+#     define BOOST_HAS_UNISTD_H
+#  endif
+
+#  include <boost/config/posix_features.hpp>
+
+#  endif
+
+#  if defined (BOOST_ASSERT_CONFIG)
+      // this must come last - generate an error if we don't
+      // recognise the platform:
+#     error "Unknown platform - please configure and report the results to boost.org"
+#  endif
+
+#endif
+
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/cmath.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/cmath.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/cmath.hpp	(working copy)
@@ -0,0 +1,28 @@
+//  (C) Copyright John Maddock 2008.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+// The aim of this header is just to include <cmath> but to do
+// so in a way that does not result in recursive inclusion of
+// the Boost TR1 components if boost/tr1/tr1/cmath is in the
+// include search path.  We have to do this to avoid circular
+// dependencies:
+//
+
+#ifndef BOOST_CONFIG_CMATH
+#  define BOOST_CONFIG_CMATH
+
+#  ifndef BOOST_TR1_NO_RECURSION
+#     define BOOST_TR1_NO_RECURSION
+#     define BOOST_CONFIG_NO_CMATH_RECURSION
+#  endif
+
+#  include <cmath>
+
+#  ifdef BOOST_CONFIG_NO_CMATH_RECURSION
+#     undef BOOST_TR1_NO_RECURSION
+#     undef BOOST_CONFIG_NO_CMATH_RECURSION
+#  endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/utility.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/utility.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/utility.hpp	(working copy)
@@ -0,0 +1,28 @@
+//  (C) Copyright John Maddock 2005.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+// The aim of this header is just to include <utility> but to do
+// so in a way that does not result in recursive inclusion of
+// the Boost TR1 components if boost/tr1/tr1/utility is in the
+// include search path.  We have to do this to avoid circular
+// dependencies:
+//
+
+#ifndef BOOST_CONFIG_UTILITY
+#  define BOOST_CONFIG_UTILITY
+
+#  ifndef BOOST_TR1_NO_RECURSION
+#     define BOOST_TR1_NO_RECURSION
+#     define BOOST_CONFIG_NO_UTILITY_RECURSION
+#  endif
+
+#  include <utility>
+
+#  ifdef BOOST_CONFIG_NO_UTILITY_RECURSION
+#     undef BOOST_TR1_NO_RECURSION
+#     undef BOOST_CONFIG_NO_UTILITY_RECURSION
+#  endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/memory.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/memory.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/no_tr1/memory.hpp	(working copy)
@@ -0,0 +1,28 @@
+//  (C) Copyright John Maddock 2005.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+// The aim of this header is just to include <memory> but to do
+// so in a way that does not result in recursive inclusion of
+// the Boost TR1 components if boost/tr1/tr1/memory is in the
+// include search path.  We have to do this to avoid circular
+// dependencies:
+//
+
+#ifndef BOOST_CONFIG_MEMORY
+#  define BOOST_CONFIG_MEMORY
+
+#  ifndef BOOST_TR1_NO_RECURSION
+#     define BOOST_TR1_NO_RECURSION
+#     define BOOST_CONFIG_NO_MEMORY_RECURSION
+#  endif
+
+#  include <memory>
+
+#  ifdef BOOST_CONFIG_NO_MEMORY_RECURSION
+#     undef BOOST_TR1_NO_RECURSION
+#     undef BOOST_CONFIG_NO_MEMORY_RECURSION
+#  endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/user.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/user.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/user.hpp	(working copy)
@@ -0,0 +1,124 @@
+//  boost/config/user.hpp  ---------------------------------------------------//
+
+//  (C) Copyright John Maddock 2001.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  Do not check in modified versions of this file,
+//  This file may be customized by the end user, but not by boost.
+
+//
+//  Use this file to define a site and compiler specific
+//  configuration policy:
+//
+
+// define this to locate a compiler config file:
+// #define BOOST_COMPILER_CONFIG <myheader>
+
+// define this to locate a stdlib config file:
+// #define BOOST_STDLIB_CONFIG   <myheader>
+
+// define this to locate a platform config file:
+// #define BOOST_PLATFORM_CONFIG <myheader>
+
+// define this to disable compiler config,
+// use if your compiler config has nothing to set:
+// #define BOOST_NO_COMPILER_CONFIG
+
+// define this to disable stdlib config,
+// use if your stdlib config has nothing to set:
+// #define BOOST_NO_STDLIB_CONFIG
+
+// define this to disable platform config,
+// use if your platform config has nothing to set:
+// #define BOOST_NO_PLATFORM_CONFIG
+
+// define this to disable all config options,
+// excluding the user config.  Use if your
+// setup is fully ISO compliant, and has no
+// useful extensions, or for autoconf generated
+// setups:
+// #define BOOST_NO_CONFIG
+
+// define this to make the config "optimistic"
+// about unknown compiler versions.  Normally
+// unknown compiler versions are assumed to have
+// all the defects of the last known version, however
+// setting this flag, causes the config to assume
+// that unknown compiler versions are fully conformant
+// with the standard:
+// #define BOOST_STRICT_CONFIG
+
+// define this to cause the config to halt compilation
+// with an #error if it encounters anything unknown --
+// either an unknown compiler version or an unknown
+// compiler/platform/library:
+// #define BOOST_ASSERT_CONFIG
+
+
+// define if you want to disable threading support, even
+// when available:
+// #define BOOST_DISABLE_THREADS
+
+// define when you want to disable Win32 specific features
+// even when available:
+// #define BOOST_DISABLE_WIN32
+
+// BOOST_DISABLE_ABI_HEADERS: Stops boost headers from including any
+// prefix/suffix headers that normally control things like struct
+// packing and alignment.
+// #define BOOST_DISABLE_ABI_HEADERS
+
+// BOOST_ABI_PREFIX: A prefix header to include in place of whatever
+// boost.config would normally select, any replacement should set up
+// struct packing and alignment options as required.
+// #define BOOST_ABI_PREFIX my-header-name
+
+// BOOST_ABI_SUFFIX: A suffix header to include in place of whatever
+// boost.config would normally select, any replacement should undo
+// the effects of the prefix header.
+// #define BOOST_ABI_SUFFIX my-header-name
+
+// BOOST_ALL_DYN_LINK: Forces all libraries that have separate source,
+// to be linked as dll's rather than static libraries on Microsoft Windows
+// (this macro is used to turn on __declspec(dllimport) modifiers, so that
+// the compiler knows which symbols to look for in a dll rather than in a
+// static library).  Note that there may be some libraries that can only
+// be statically linked (Boost.Test for example) and others which may only
+// be dynamically linked (Boost.Threads for example), in these cases this
+// macro has no effect.
+// #define BOOST_ALL_DYN_LINK
+
+// BOOST_WHATEVER_DYN_LINK: Forces library "whatever" to be linked as a dll
+// rather than a static library on Microsoft Windows: replace the WHATEVER
+// part of the macro name with the name of the library that you want to
+// dynamically link to, for example use BOOST_DATE_TIME_DYN_LINK or
+// BOOST_REGEX_DYN_LINK etc (this macro is used to turn on __declspec(dllimport)
+// modifiers, so that the compiler knows which symbols to look for in a dll
+// rather than in a static library).
+// Note that there may be some libraries that can only be statically linked
+// (Boost.Test for example) and others which may only be dynamically linked
+// (Boost.Threads for example), in these cases this macro is unsupported.
+// #define BOOST_WHATEVER_DYN_LINK
+
+// BOOST_ALL_NO_LIB: Tells the config system not to automatically select
+// which libraries to link against.
+// Normally if a compiler supports #pragma lib, then the correct library
+// build variant will be automatically selected and linked against,
+// simply by the act of including one of that library's headers.
+// This macro turns that feature off.
+// #define BOOST_ALL_NO_LIB
+
+// BOOST_WHATEVER_NO_LIB: Tells the config system not to automatically
+// select which library to link against for library "whatever",
+// replace WHATEVER in the macro name with the name of the library;
+// for example BOOST_DATE_TIME_NO_LIB or BOOST_REGEX_NO_LIB.
+// Normally if a compiler supports #pragma lib, then the correct library
+// build variant will be automatically selected and linked against, simply
+// by the act of including one of that library's headers.  This macro turns
+// that feature off.
+// #define BOOST_WHATEVER_NO_LIB
+
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config/compiler/gcc.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config/compiler/gcc.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config/compiler/gcc.hpp	(working copy)
@@ -0,0 +1,252 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Darin Adler 2001 - 2002.
+//  (C) Copyright Jens Maurer 2001 - 2002.
+//  (C) Copyright Beman Dawes 2001 - 2003.
+//  (C) Copyright Douglas Gregor 2002.
+//  (C) Copyright David Abrahams 2002 - 2003.
+//  (C) Copyright Synge Todo 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org for most recent version.
+
+//  GNU C++ compiler setup:
+
+#if __GNUC__ < 3
+#   if __GNUC_MINOR__ == 91
+       // egcs 1.1 won't parse shared_ptr.hpp without this:
+#      define BOOST_NO_AUTO_PTR
+#   endif
+#   if __GNUC_MINOR__ < 95
+      //
+      // Prior to gcc 2.95 member templates only partly
+      // work - define BOOST_MSVC6_MEMBER_TEMPLATES
+      // instead since inline member templates mostly work.
+      //
+#     define BOOST_NO_MEMBER_TEMPLATES
+#     if __GNUC_MINOR__ >= 9
+#       define BOOST_MSVC6_MEMBER_TEMPLATES
+#     endif
+#   endif
+
+#   if __GNUC_MINOR__ < 96
+#     define BOOST_NO_SFINAE
+#   endif
+
+#   if __GNUC_MINOR__ <= 97
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     define BOOST_NO_OPERATORS_IN_NAMESPACE
+#   endif
+
+#   define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#   define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#   define BOOST_NO_IS_ABSTRACT
+#   define BOOST_NO_EXTERN_TEMPLATE
+// Variadic macros do not exist for gcc versions before 3.0
+#   define BOOST_NO_VARIADIC_MACROS
+#elif __GNUC__ == 3
+#  if defined (__PATHSCALE__)
+#     define BOOST_NO_TWO_PHASE_NAME_LOOKUP
+#     define BOOST_NO_IS_ABSTRACT
+#  endif
+   //
+   // gcc-3.x problems:
+   //
+   // Bug specific to gcc 3.1 and 3.2:
+   //
+#  if ((__GNUC_MINOR__ == 1) || (__GNUC_MINOR__ == 2))
+#     define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  endif
+#  if __GNUC_MINOR__ < 4
+#     define BOOST_NO_IS_ABSTRACT
+#  endif
+#  define BOOST_NO_EXTERN_TEMPLATE
+#endif
+#if __GNUC__ < 4
+//
+// All problems to gcc-3.x and earlier here:
+//
+#define BOOST_NO_TWO_PHASE_NAME_LOOKUP
+#  ifdef __OPEN64__
+#     define BOOST_NO_IS_ABSTRACT
+#  endif
+#endif
+
+#if __GNUC__ < 4 || ( __GNUC__ == 4 && __GNUC_MINOR__ < 4 )
+// Previous versions of GCC did not completely implement value-initialization:
+// GCC Bug 30111, "Value-initialization of POD base class doesn't initialize
+// members", reported by Jonathan Wakely in 2006,
+// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=30111 (fixed for GCC 4.4)
+// GCC Bug 33916, "Default constructor fails to initialize array members",
+// reported by Michael Elizabeth Chastain in 2007,
+// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33916 (fixed for GCC 4.2.4)
+// See also: http://www.boost.org/libs/utility/value_init.htm#compiler_issues
+#define BOOST_NO_COMPLETE_VALUE_INITIALIZATION
+#endif
+
+#if !defined(__EXCEPTIONS) && !defined(BOOST_NO_EXCEPTIONS)
+# define BOOST_NO_EXCEPTIONS
+#endif
+
+
+//
+// Threading support: Turn this on unconditionally here (except for
+// those platforms where we can know for sure). It will get turned off again
+// later if no threading API is detected.
+//
+#if !defined(__MINGW32__) && !defined(linux) && !defined(__linux) && !defined(__linux__)
+# define BOOST_HAS_THREADS
+#endif
+
+//
+// gcc has "long long"
+//
+#define BOOST_HAS_LONG_LONG
+
+//
+// gcc implements the named return value optimization since version 3.1
+//
+#if __GNUC__ > 3 || ( __GNUC__ == 3 && __GNUC_MINOR__ >= 1 )
+#define BOOST_HAS_NRVO
+#endif
+
+//
+// Dynamic shared object (DSO) and dynamic-link library (DLL) support
+//
+#if __GNUC__ >= 4
+#  if (defined(_WIN32) || defined(__WIN32__) || defined(WIN32)) && !defined(__CYGWIN__)
+     // All Win32 development environments, including 64-bit Windows and MinGW, define
+     // _WIN32 or one of its variant spellings. Note that Cygwin is a POSIX environment,
+     // so does not define _WIN32 or its variants.
+#    define BOOST_HAS_DECLSPEC
+#    define BOOST_SYMBOL_EXPORT __attribute__((dllexport))
+#    define BOOST_SYMBOL_IMPORT __attribute__((dllimport))
+#  else
+#    define BOOST_SYMBOL_EXPORT __attribute__((visibility("default")))
+#    define BOOST_SYMBOL_IMPORT
+#  endif
+#  define BOOST_SYMBOL_VISIBLE __attribute__((visibility("default")))
+#else
+// config/platform/win32.hpp will define BOOST_SYMBOL_EXPORT, etc., unless already defined
+#  define BOOST_SYMBOL_EXPORT
+#endif
+
+//
+// RTTI and typeinfo detection is possible post gcc-4.3:
+//
+#if __GNUC__ * 100 + __GNUC_MINOR__ >= 403
+#  ifndef __GXX_RTTI
+#     ifndef BOOST_NO_TYPEID
+#        define BOOST_NO_TYPEID
+#     endif
+#     ifndef BOOST_NO_RTTI
+#        define BOOST_NO_RTTI
+#     endif
+#  endif
+#endif
+
+// C++0x features not implemented in any GCC version
+//
+#define BOOST_NO_TEMPLATE_ALIASES
+
+// C++0x features in 4.3.n and later
+//
+#if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 2)) && defined(__GXX_EXPERIMENTAL_CXX0X__)
+// C++0x features are only enabled when -std=c++0x or -std=gnu++0x are
+// passed on the command line, which in turn defines
+// __GXX_EXPERIMENTAL_CXX0X__.
+#  define BOOST_HAS_DECLTYPE
+#  define BOOST_HAS_RVALUE_REFS
+#  define BOOST_HAS_STATIC_ASSERT
+#  define BOOST_HAS_VARIADIC_TMPL
+#else
+#  define BOOST_NO_DECLTYPE
+#  define BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS
+#  define BOOST_NO_RVALUE_REFERENCES
+#  define BOOST_NO_STATIC_ASSERT
+
+// Variadic templates compiler:
+//   http://www.generic-programming.org/~dgregor/cpp/variadic-templates.html
+#  if defined(__VARIADIC_TEMPLATES) || (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4) && defined(__GXX_EXPERIMENTAL_CXX0X__))
+#    define BOOST_HAS_VARIADIC_TMPL
+#  else
+#    define BOOST_NO_VARIADIC_TEMPLATES
+#  endif
+#endif
+
+// C++0x features in 4.4.n and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 4) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  define BOOST_NO_AUTO_DECLARATIONS
+#  define BOOST_NO_AUTO_MULTIDECLARATIONS
+#  define BOOST_NO_CHAR16_T
+#  define BOOST_NO_CHAR32_T
+#  define BOOST_NO_INITIALIZER_LISTS
+#  define BOOST_NO_DEFAULTED_FUNCTIONS
+#  define BOOST_NO_DELETED_FUNCTIONS
+#endif
+
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 4)
+#  define BOOST_NO_SFINAE_EXPR
+#endif
+
+// C++0x features in 4.5.0 and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  define BOOST_NO_EXPLICIT_CONVERSION_OPERATORS
+#  define BOOST_NO_LAMBDAS
+#  define BOOST_NO_RAW_LITERALS
+#  define BOOST_NO_UNICODE_LITERALS
+#endif
+
+// C++0x features in 4.5.1 and later
+//
+#if (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__ < 40501) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+// scoped enums have a serious bug in 4.4.0, so define BOOST_NO_SCOPED_ENUMS before 4.5.1
+// See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=38064
+#  define BOOST_NO_SCOPED_ENUMS
+#endif
+
+// C++0x features in 4.6.n and later
+//
+#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6) || !defined(__GXX_EXPERIMENTAL_CXX0X__)
+#define BOOST_NO_CONSTEXPR
+#define BOOST_NO_NOEXCEPT
+#define BOOST_NO_NULLPTR
+#define BOOST_NO_UNIFIED_INITIALIZATION_SYNTAX
+#endif
+
+// C++0x features not supported at all yet
+//
+#define BOOST_NO_DECLTYPE_N3276
+
+#ifndef BOOST_COMPILER
+#  define BOOST_COMPILER "GNU C++ version " __VERSION__
+#endif
+
+// ConceptGCC compiler:
+//   http://www.generic-programming.org/software/ConceptGCC/
+#ifdef __GXX_CONCEPTS__
+#  define BOOST_HAS_CONCEPTS
+#  define BOOST_COMPILER "ConceptGCC version " __VERSION__
+#endif
+
+// versions check:
+// we don't know gcc prior to version 2.90:
+#if (__GNUC__ == 2) && (__GNUC_MINOR__ < 90)
+#  error "Compiler not configured - please reconfigure"
+#endif
+//
+// last known and checked version is 4.6 (Pre-release):
+#if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 6))
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error "Unknown compiler version - please run the configure tests and report the results"
+#  else
+// we don't emit warnings here anymore since there are no defect macros defined for
+// gcc post 3.4, so any failures are gcc regressions...
+//#     warning "Unknown compiler version - please run the configure tests and report the results"
+#  endif
+#endif
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/type.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/type.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/type.hpp	(working copy)
@@ -0,0 +1,18 @@
+// (C) Copyright David Abrahams 2001.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_TYPE_DWA20010120_HPP
+# define BOOST_TYPE_DWA20010120_HPP
+
+namespace boost {
+
+  // Just a simple "type envelope". Useful in various contexts, mostly to work
+  // around some MSVC deficiencies.
+  template <class T>
+  struct type {};
+
+}
+
+#endif // BOOST_TYPE_DWA20010120_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/optional/optional_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/optional/optional_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/optional/optional_fwd.hpp	(working copy)
@@ -0,0 +1,29 @@
+// Copyright (C) 2003, 2008 Fernando Luis Cacciola Carballal.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+// Revisions:
+// 10 May 2008 (added swap related forward declaration) Niels Dekker
+//
+#ifndef BOOST_OPTIONAL_OPTIONAL_FWD_FLC_19NOV2002_HPP
+#define BOOST_OPTIONAL_OPTIONAL_FWD_FLC_19NOV2002_HPP
+
+namespace boost {
+
+template<class T> class optional ;
+
+template<class T> void swap ( optional<T>& , optional<T>& ) ;
+
+template<class T> struct optional_swap_should_use_default_constructor ;
+
+} // namespace boost
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/optional/optional.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/optional/optional.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/optional/optional.hpp	(working copy)
@@ -0,0 +1,991 @@
+// Copyright (C) 2003, 2008 Fernando Luis Cacciola Carballal.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+// Revisions:
+// 27 Apr 2008 (improved swap) Fernando Cacciola, Niels Dekker, Thorsten Ottosen
+//
+#ifndef BOOST_OPTIONAL_OPTIONAL_FLC_19NOV2002_HPP
+#define BOOST_OPTIONAL_OPTIONAL_FLC_19NOV2002_HPP
+
+#include <new>
+#include <algorithm>
+
+#include <boost/config.hpp>
+#include <boost/assert.hpp>
+#include <boost/type.hpp>
+#include <boost/type_traits/alignment_of.hpp>
+#include <boost/type_traits/has_nothrow_constructor.hpp>
+#include <boost/type_traits/type_with_alignment.hpp>
+#include <boost/type_traits/remove_reference.hpp>
+#include <boost/type_traits/is_reference.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/not.hpp>
+#include <boost/detail/reference_content.hpp>
+#include <boost/none.hpp>
+#include <boost/utility/swap.hpp>
+#include <boost/utility/addressof.hpp>
+#include <boost/utility/compare_pointees.hpp>
+#include <boost/utility/in_place_factory.hpp>
+
+#include <boost/optional/optional_fwd.hpp>
+
+#if BOOST_WORKAROUND(BOOST_MSVC, == 1200)
+// VC6.0 has the following bug:
+//   When a templated assignment operator exist, an implicit conversion
+//   constructing an optional<T> is used when assigment of the form:
+//     optional<T> opt ; opt = T(...);
+//   is compiled.
+//   However, optional's ctor is _explicit_ and the assignemt shouldn't compile.
+//   Therefore, for VC6.0 templated assignment is disabled.
+//
+#define BOOST_OPTIONAL_NO_CONVERTING_ASSIGNMENT
+#endif
+
+#if BOOST_WORKAROUND(BOOST_MSVC, == 1300)
+// VC7.0 has the following bug:
+//   When both a non-template and a template copy-ctor exist
+//   and the templated version is made 'explicit', the explicit is also
+//   given to the non-templated version, making the class non-implicitely-copyable.
+//
+#define BOOST_OPTIONAL_NO_CONVERTING_COPY_CTOR
+#endif
+
+#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300) || BOOST_WORKAROUND(BOOST_INTEL_CXX_VERSION,<=700)
+// AFAICT only VC7.1 correctly resolves the overload set
+// that includes the in-place factory taking functions,
+// so for the other VC versions, in-place factory support
+// is disabled
+#define BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT
+#endif
+
+#if BOOST_WORKAROUND(__BORLANDC__, <= 0x551)
+// BCB (5.5.1) cannot parse the nested template struct in an inplace factory.
+#define BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT
+#endif
+
+#if !defined(BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT) \
+    && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x581) )
+// BCB (up to 5.64) has the following bug:
+//   If there is a member function/operator template of the form
+//     template<class Expr> mfunc( Expr expr ) ;
+//   some calls are resolved to this even if there are other better matches.
+//   The effect of this bug is that calls to converting ctors and assignments
+//   are incrorrectly sink to this general catch-all member function template as shown above.
+#define BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION
+#endif
+
+#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) > 302 \
+    && !defined(__INTEL_COMPILER)
+// GCC since 3.3 has may_alias attribute that helps to alleviate optimizer issues with
+// regard to violation of the strict aliasing rules. The optional< T > storage type is marked
+// with this attribute in order to let the compiler know that it will alias objects of type T
+// and silence compilation warnings.
+#define BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS
+#endif
+
+// Daniel Wallin discovered that bind/apply.hpp badly interacts with the apply<>
+// member template of a factory as used in the optional<> implementation.
+// He proposed this simple fix which is to move the call to apply<> outside
+// namespace boost.
+namespace boost_optional_detail
+{
+  template <class T, class Factory>
+  inline void construct(Factory const& factory, void* address)
+  {
+    factory.BOOST_NESTED_TEMPLATE apply<T>(address);
+  }
+}
+
+
+namespace boost {
+
+class in_place_factory_base ;
+class typed_in_place_factory_base ;
+
+// This forward is needed to refer to namespace scope swap from the member swap
+template<class T> void swap ( optional<T>& x, optional<T>& y );
+
+namespace optional_detail {
+
+// This local class is used instead of that in "aligned_storage.hpp"
+// because I've found the 'official' class to ICE BCB5.5
+// when some types are used with optional<>
+// (due to sizeof() passed down as a non-type template parameter)
+template <class T>
+class aligned_storage
+{
+    // Borland ICEs if unnamed unions are used for this!
+    union
+    // This works around GCC warnings about breaking strict aliasing rules when casting storage address to T*
+#if defined(BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS)
+    __attribute__((may_alias))
+#endif
+    dummy_u
+    {
+        char data[ sizeof(T) ];
+        BOOST_DEDUCED_TYPENAME type_with_alignment<
+          ::boost::alignment_of<T>::value >::type aligner_;
+    } dummy_ ;
+
+  public:
+
+#if defined(BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS)
+    void const* address() const { return &dummy_; }
+    void      * address()       { return &dummy_; }
+#else
+    void const* address() const { return dummy_.data; }
+    void      * address()       { return dummy_.data; }
+#endif
+} ;
+
+template<class T>
+struct types_when_isnt_ref
+{
+  typedef T const& reference_const_type ;
+  typedef T &      reference_type ;
+  typedef T const* pointer_const_type ;
+  typedef T *      pointer_type ;
+  typedef T const& argument_type ;
+} ;
+template<class T>
+struct types_when_is_ref
+{
+  typedef BOOST_DEDUCED_TYPENAME remove_reference<T>::type raw_type ;
+
+  typedef raw_type& reference_const_type ;
+  typedef raw_type& reference_type ;
+  typedef raw_type* pointer_const_type ;
+  typedef raw_type* pointer_type ;
+  typedef raw_type& argument_type ;
+} ;
+
+struct optional_tag {} ;
+
+template<class T>
+class optional_base : public optional_tag
+{
+  private :
+
+    typedef
+#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
+    BOOST_DEDUCED_TYPENAME
+#endif
+    ::boost::detail::make_reference_content<T>::type internal_type ;
+
+    typedef aligned_storage<internal_type> storage_type ;
+
+    typedef types_when_isnt_ref<T> types_when_not_ref ;
+    typedef types_when_is_ref<T>   types_when_ref   ;
+
+    typedef optional_base<T> this_type ;
+
+  protected :
+
+    typedef T value_type ;
+
+    typedef mpl::true_  is_reference_tag ;
+    typedef mpl::false_ is_not_reference_tag ;
+
+    typedef BOOST_DEDUCED_TYPENAME is_reference<T>::type is_reference_predicate ;
+
+  public:
+    typedef BOOST_DEDUCED_TYPENAME mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;
+
+  protected:
+    typedef bool (this_type::*unspecified_bool_type)() const;
+
+    typedef BOOST_DEDUCED_TYPENAME types::reference_type       reference_type ;
+    typedef BOOST_DEDUCED_TYPENAME types::reference_const_type reference_const_type ;
+    typedef BOOST_DEDUCED_TYPENAME types::pointer_type         pointer_type ;
+    typedef BOOST_DEDUCED_TYPENAME types::pointer_const_type   pointer_const_type ;
+    typedef BOOST_DEDUCED_TYPENAME types::argument_type        argument_type ;
+
+    // Creates an optional<T> uninitialized.
+    // No-throw
+    optional_base()
+      :
+      m_initialized(false) {}
+
+    // Creates an optional<T> uninitialized.
+    // No-throw
+    optional_base ( none_t )
+      :
+      m_initialized(false) {}
+
+    // Creates an optional<T> initialized with 'val'.
+    // Can throw if T::T(T const&) does
+    optional_base ( argument_type val )
+      :
+      m_initialized(false)
+    {
+      construct(val);
+    }
+
+    // Creates an optional<T> initialized with 'val' IFF cond is true, otherwise creates an uninitialzed optional<T>.
+    // Can throw if T::T(T const&) does
+    optional_base ( bool cond, argument_type val )
+      :
+      m_initialized(false)
+    {
+      if ( cond )
+        construct(val);
+    }
+
+    // Creates a deep copy of another optional<T>
+    // Can throw if T::T(T const&) does
+    optional_base ( optional_base const& rhs )
+      :
+      m_initialized(false)
+    {
+      if ( rhs.is_initialized() )
+        construct(rhs.get_impl());
+    }
+
+
+    // This is used for both converting and in-place constructions.
+    // Derived classes use the 'tag' to select the appropriate
+    // implementation (the correct 'construct()' overload)
+    template<class Expr>
+    explicit optional_base ( Expr const& expr, Expr const* tag )
+      :
+      m_initialized(false)
+    {
+      construct(expr,tag);
+    }
+
+
+
+    // No-throw (assuming T::~T() doesn't)
+    ~optional_base() { destroy() ; }
+
+    // Assigns from another optional<T> (deep-copies the rhs value)
+    void assign ( optional_base const& rhs )
+    {
+      if (is_initialized())
+      {
+        if ( rhs.is_initialized() )
+             assign_value(rhs.get_impl(), is_reference_predicate() );
+        else destroy();
+      }
+      else
+      {
+        if ( rhs.is_initialized() )
+          construct(rhs.get_impl());
+      }
+    }
+
+    // Assigns from another _convertible_ optional<U> (deep-copies the rhs value)
+    template<class U>
+    void assign ( optional<U> const& rhs )
+    {
+      if (is_initialized())
+      {
+        if ( rhs.is_initialized() )
+             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );
+        else destroy();
+      }
+      else
+      {
+        if ( rhs.is_initialized() )
+          construct(static_cast<value_type>(rhs.get()));
+      }
+    }
+
+    // Assigns from a T (deep-copies the rhs value)
+    void assign ( argument_type val )
+    {
+      if (is_initialized())
+           assign_value(val, is_reference_predicate() );
+      else construct(val);
+    }
+
+    // Assigns from "none", destroying the current value, if any, leaving this UNINITIALIZED
+    // No-throw (assuming T::~T() doesn't)
+    void assign ( none_t ) { destroy(); }
+
+#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT
+    template<class Expr>
+    void assign_expr ( Expr const& expr, Expr const* tag )
+      {
+        if (is_initialized())
+             assign_expr_to_initialized(expr,tag);
+        else construct(expr,tag);
+      }
+#endif
+
+  public :
+
+    // Destroys the current value, if any, leaving this UNINITIALIZED
+    // No-throw (assuming T::~T() doesn't)
+    void reset() { destroy(); }
+
+    // Replaces the current value -if any- with 'val'
+    void reset ( argument_type val ) { assign(val); }
+
+    // Returns a pointer to the value if this is initialized, otherwise,
+    // returns NULL.
+    // No-throw
+    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }
+    pointer_type       get_ptr()       { return m_initialized ? get_ptr_impl() : 0 ; }
+
+    bool is_initialized() const { return m_initialized ; }
+
+  protected :
+
+    void construct ( argument_type val )
+     {
+       new (m_storage.address()) internal_type(val) ;
+       m_initialized = true ;
+     }
+
+#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT
+    // Constructs in-place using the given factory
+    template<class Expr>
+    void construct ( Expr const& factory, in_place_factory_base const* )
+     {
+       BOOST_STATIC_ASSERT ( ::boost::mpl::not_<is_reference_predicate>::value ) ;
+       boost_optional_detail::construct<value_type>(factory, m_storage.address());
+       m_initialized = true ;
+     }
+
+    // Constructs in-place using the given typed factory
+    template<class Expr>
+    void construct ( Expr const& factory, typed_in_place_factory_base const* )
+     {
+       BOOST_STATIC_ASSERT ( ::boost::mpl::not_<is_reference_predicate>::value ) ;
+       factory.apply(m_storage.address()) ;
+       m_initialized = true ;
+     }
+
+    template<class Expr>
+    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )
+     {
+       destroy();
+       construct(factory,tag);
+     }
+
+    // Constructs in-place using the given typed factory
+    template<class Expr>
+    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )
+     {
+       destroy();
+       construct(factory,tag);
+     }
+#endif
+
+    // Constructs using any expression implicitely convertible to the single argument
+    // of a one-argument T constructor.
+    // Converting constructions of optional<T> from optional<U> uses this function with
+    // 'Expr' being of type 'U' and relying on a converting constructor of T from U.
+    template<class Expr>
+    void construct ( Expr const& expr, void const* )
+     {
+       new (m_storage.address()) internal_type(expr) ;
+       m_initialized = true ;
+     }
+
+    // Assigns using a form any expression implicitely convertible to the single argument
+    // of a T's assignment operator.
+    // Converting assignments of optional<T> from optional<U> uses this function with
+    // 'Expr' being of type 'U' and relying on a converting assignment of T from U.
+    template<class Expr>
+    void assign_expr_to_initialized ( Expr const& expr, void const* )
+     {
+       assign_value(expr, is_reference_predicate());
+     }
+
+#ifdef BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION
+    // BCB5.64 (and probably lower versions) workaround.
+    //   The in-place factories are supported by means of catch-all constructors
+    //   and assignment operators (the functions are parameterized in terms of
+    //   an arbitrary 'Expr' type)
+    //   This compiler incorrectly resolves the overload set and sinks optional<T> and optional<U>
+    //   to the 'Expr'-taking functions even though explicit overloads are present for them.
+    //   Thus, the following overload is needed to properly handle the case when the 'lhs'
+    //   is another optional.
+    //
+    // For VC<=70 compilers this workaround dosen't work becasue the comnpiler issues and error
+    // instead of choosing the wrong overload
+    //
+    // Notice that 'Expr' will be optional<T> or optional<U> (but not optional_base<..>)
+    template<class Expr>
+    void construct ( Expr const& expr, optional_tag const* )
+     {
+       if ( expr.is_initialized() )
+       {
+         // An exception can be thrown here.
+         // It it happens, THIS will be left uninitialized.
+         new (m_storage.address()) internal_type(expr.get()) ;
+         m_initialized = true ;
+       }
+     }
+#endif
+
+    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }
+    void assign_value ( argument_type val, is_reference_tag     ) { construct(val); }
+
+    void destroy()
+    {
+      if ( m_initialized )
+        destroy_impl(is_reference_predicate()) ;
+    }
+
+    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }
+
+    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }
+    reference_type       get_impl()       { return dereference(get_object(), is_reference_predicate() ) ; }
+
+    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }
+    pointer_type       get_ptr_impl()       { return cast_ptr(get_object(), is_reference_predicate() ) ; }
+
+  private :
+
+    // internal_type can be either T or reference_content<T>
+#if defined(BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS)
+    // This workaround is supposed to silence GCC warnings about broken strict aliasing rules
+    internal_type const* get_object() const
+    {
+        union { void const* ap_pvoid; internal_type const* as_ptype; } caster = { m_storage.address() };
+        return caster.as_ptype;
+    }
+    internal_type *      get_object()
+    {
+        union { void* ap_pvoid; internal_type* as_ptype; } caster = { m_storage.address() };
+        return caster.as_ptype;
+    }
+#else
+    internal_type const* get_object() const { return static_cast<internal_type const*>(m_storage.address()); }
+    internal_type *      get_object()       { return static_cast<internal_type *>     (m_storage.address()); }
+#endif
+
+    // reference_content<T> lacks an implicit conversion to T&, so the following is needed to obtain a proper reference.
+    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }
+    reference_type       dereference( internal_type*       p, is_not_reference_tag )       { return *p ; }
+    reference_const_type dereference( internal_type const* p, is_reference_tag     ) const { return p->get() ; }
+    reference_type       dereference( internal_type*       p, is_reference_tag     )       { return p->get() ; }
+
+#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x581))
+    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->internal_type::~internal_type() ; m_initialized = false ; }
+#else
+    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }
+#endif
+
+    void destroy_impl ( is_reference_tag     ) { m_initialized = false ; }
+
+    // If T is of reference type, trying to get a pointer to the held value must result in a compile-time error.
+    // Decent compilers should disallow conversions from reference_content<T>* to T*, but just in case,
+    // the following olverloads are used to filter out the case and guarantee an error in case of T being a reference.
+    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }
+    pointer_type       cast_ptr( internal_type *      p, is_not_reference_tag )       { return p ; }
+    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag     ) const { return &p->get() ; }
+    pointer_type       cast_ptr( internal_type *      p, is_reference_tag     )       { return &p->get() ; }
+
+    bool m_initialized ;
+    storage_type m_storage ;
+} ;
+
+} // namespace optional_detail
+
+template<class T>
+class optional : public optional_detail::optional_base<T>
+{
+    typedef optional_detail::optional_base<T> base ;
+
+    typedef BOOST_DEDUCED_TYPENAME base::unspecified_bool_type  unspecified_bool_type ;
+
+  public :
+
+    typedef optional<T> this_type ;
+
+    typedef BOOST_DEDUCED_TYPENAME base::value_type           value_type ;
+    typedef BOOST_DEDUCED_TYPENAME base::reference_type       reference_type ;
+    typedef BOOST_DEDUCED_TYPENAME base::reference_const_type reference_const_type ;
+    typedef BOOST_DEDUCED_TYPENAME base::pointer_type         pointer_type ;
+    typedef BOOST_DEDUCED_TYPENAME base::pointer_const_type   pointer_const_type ;
+    typedef BOOST_DEDUCED_TYPENAME base::argument_type        argument_type ;
+
+    // Creates an optional<T> uninitialized.
+    // No-throw
+    optional() : base() {}
+
+    // Creates an optional<T> uninitialized.
+    // No-throw
+    optional( none_t none_ ) : base(none_) {}
+
+    // Creates an optional<T> initialized with 'val'.
+    // Can throw if T::T(T const&) does
+    optional ( argument_type val ) : base(val) {}
+
+    // Creates an optional<T> initialized with 'val' IFF cond is true, otherwise creates an uninitialized optional.
+    // Can throw if T::T(T const&) does
+    optional ( bool cond, argument_type val ) : base(cond,val) {}
+
+#ifndef BOOST_OPTIONAL_NO_CONVERTING_COPY_CTOR
+    // NOTE: MSVC needs templated versions first
+
+    // Creates a deep copy of another convertible optional<U>
+    // Requires a valid conversion from U to T.
+    // Can throw if T::T(U const&) does
+    template<class U>
+    explicit optional ( optional<U> const& rhs )
+      :
+      base()
+    {
+      if ( rhs.is_initialized() )
+        this->construct(rhs.get());
+    }
+#endif
+
+#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT
+    // Creates an optional<T> with an expression which can be either
+    //  (a) An instance of InPlaceFactory (i.e. in_place(a,b,...,n);
+    //  (b) An instance of TypedInPlaceFactory ( i.e. in_place<T>(a,b,...,n);
+    //  (c) Any expression implicitely convertible to the single type
+    //      of a one-argument T's constructor.
+    //  (d*) Weak compilers (BCB) might also resolved Expr as optional<T> and optional<U>
+    //       even though explicit overloads are present for these.
+    // Depending on the above some T ctor is called.
+    // Can throw is the resolved T ctor throws.
+    template<class Expr>
+    explicit optional ( Expr const& expr ) : base(expr,boost::addressof(expr)) {}
+#endif
+
+    // Creates a deep copy of another optional<T>
+    // Can throw if T::T(T const&) does
+    optional ( optional const& rhs ) : base( static_cast<base const&>(rhs) ) {}
+
+   // No-throw (assuming T::~T() doesn't)
+    ~optional() {}
+
+#if !defined(BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT) && !defined(BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION)
+    // Assigns from an expression. See corresponding constructor.
+    // Basic Guarantee: If the resolved T ctor throws, this is left UNINITIALIZED
+    template<class Expr>
+    optional& operator= ( Expr const& expr )
+      {
+        this->assign_expr(expr,boost::addressof(expr));
+        return *this ;
+      }
+#endif
+
+
+#ifndef BOOST_OPTIONAL_NO_CONVERTING_ASSIGNMENT
+    // Assigns from another convertible optional<U> (converts && deep-copies the rhs value)
+    // Requires a valid conversion from U to T.
+    // Basic Guarantee: If T::T( U const& ) throws, this is left UNINITIALIZED
+    template<class U>
+    optional& operator= ( optional<U> const& rhs )
+      {
+        this->assign(rhs);
+        return *this ;
+      }
+#endif
+
+    // Assigns from another optional<T> (deep-copies the rhs value)
+    // Basic Guarantee: If T::T( T const& ) throws, this is left UNINITIALIZED
+    //  (NOTE: On BCB, this operator is not actually called and left is left UNMODIFIED in case of a throw)
+    optional& operator= ( optional const& rhs )
+      {
+        this->assign( static_cast<base const&>(rhs) ) ;
+        return *this ;
+      }
+
+    // Assigns from a T (deep-copies the rhs value)
+    // Basic Guarantee: If T::( T const& ) throws, this is left UNINITIALIZED
+    optional& operator= ( argument_type val )
+      {
+        this->assign( val ) ;
+        return *this ;
+      }
+
+    // Assigns from a "none"
+    // Which destroys the current value, if any, leaving this UNINITIALIZED
+    // No-throw (assuming T::~T() doesn't)
+    optional& operator= ( none_t none_ )
+      {
+        this->assign( none_ ) ;
+        return *this ;
+      }
+
+    void swap( optional & arg )
+      {
+        // allow for Koenig lookup
+        using boost::swap;
+        swap(*this, arg);
+      }
+
+
+    // Returns a reference to the value if this is initialized, otherwise,
+    // the behaviour is UNDEFINED
+    // No-throw
+    reference_const_type get() const { BOOST_ASSERT(this->is_initialized()) ; return this->get_impl(); }
+    reference_type       get()       { BOOST_ASSERT(this->is_initialized()) ; return this->get_impl(); }
+
+    // Returns a copy of the value if this is initialized, 'v' otherwise
+    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }
+    reference_type       get_value_or ( reference_type       v )       { return this->is_initialized() ? get() : v ; }
+
+    // Returns a pointer to the value if this is initialized, otherwise,
+    // the behaviour is UNDEFINED
+    // No-throw
+    pointer_const_type operator->() const { BOOST_ASSERT(this->is_initialized()) ; return this->get_ptr_impl() ; }
+    pointer_type       operator->()       { BOOST_ASSERT(this->is_initialized()) ; return this->get_ptr_impl() ; }
+
+    // Returns a reference to the value if this is initialized, otherwise,
+    // the behaviour is UNDEFINED
+    // No-throw
+    reference_const_type operator *() const { return this->get() ; }
+    reference_type       operator *()       { return this->get() ; }
+
+    // implicit conversion to "bool"
+    // No-throw
+    operator unspecified_bool_type() const { return this->safe_bool() ; }
+
+    // This is provided for those compilers which don't like the conversion to bool
+    // on some contexts.
+    bool operator!() const { return !this->is_initialized() ; }
+} ;
+
+// Returns optional<T>(v)
+template<class T>
+inline
+optional<T> make_optional ( T const& v  )
+{
+  return optional<T>(v);
+}
+
+// Returns optional<T>(cond,v)
+template<class T>
+inline
+optional<T> make_optional ( bool cond, T const& v )
+{
+  return optional<T>(cond,v);
+}
+
+// Returns a reference to the value if this is initialized, otherwise, the behaviour is UNDEFINED.
+// No-throw
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::reference_const_type
+get ( optional<T> const& opt )
+{
+  return opt.get() ;
+}
+
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::reference_type
+get ( optional<T>& opt )
+{
+  return opt.get() ;
+}
+
+// Returns a pointer to the value if this is initialized, otherwise, returns NULL.
+// No-throw
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::pointer_const_type
+get ( optional<T> const* opt )
+{
+  return opt->get_ptr() ;
+}
+
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::pointer_type
+get ( optional<T>* opt )
+{
+  return opt->get_ptr() ;
+}
+
+// Returns a reference to the value if this is initialized, otherwise, the behaviour is UNDEFINED.
+// No-throw
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::reference_const_type
+get_optional_value_or ( optional<T> const& opt, BOOST_DEDUCED_TYPENAME optional<T>::reference_const_type v )
+{
+  return opt.get_value_or(v) ;
+}
+
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::reference_type
+get_optional_value_or ( optional<T>& opt, BOOST_DEDUCED_TYPENAME optional<T>::reference_type v )
+{
+  return opt.get_value_or(v) ;
+}
+
+// Returns a pointer to the value if this is initialized, otherwise, returns NULL.
+// No-throw
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::pointer_const_type
+get_pointer ( optional<T> const& opt )
+{
+  return opt.get_ptr() ;
+}
+
+template<class T>
+inline
+BOOST_DEDUCED_TYPENAME optional<T>::pointer_type
+get_pointer ( optional<T>& opt )
+{
+  return opt.get_ptr() ;
+}
+
+// optional's relational operators ( ==, !=, <, >, <=, >= ) have deep-semantics (compare values).
+// WARNING: This is UNLIKE pointers. Use equal_pointees()/less_pointess() in generic code instead.
+
+
+//
+// optional<T> vs optional<T> cases
+//
+
+template<class T>
+inline
+bool operator == ( optional<T> const& x, optional<T> const& y )
+{ return equal_pointees(x,y); }
+
+template<class T>
+inline
+bool operator < ( optional<T> const& x, optional<T> const& y )
+{ return less_pointees(x,y); }
+
+template<class T>
+inline
+bool operator != ( optional<T> const& x, optional<T> const& y )
+{ return !( x == y ) ; }
+
+template<class T>
+inline
+bool operator > ( optional<T> const& x, optional<T> const& y )
+{ return y < x ; }
+
+template<class T>
+inline
+bool operator <= ( optional<T> const& x, optional<T> const& y )
+{ return !( y < x ) ; }
+
+template<class T>
+inline
+bool operator >= ( optional<T> const& x, optional<T> const& y )
+{ return !( x < y ) ; }
+
+
+//
+// optional<T> vs T cases
+//
+template<class T>
+inline
+bool operator == ( optional<T> const& x, T const& y )
+{ return equal_pointees(x, optional<T>(y)); }
+
+template<class T>
+inline
+bool operator < ( optional<T> const& x, T const& y )
+{ return less_pointees(x, optional<T>(y)); }
+
+template<class T>
+inline
+bool operator != ( optional<T> const& x, T const& y )
+{ return !( x == y ) ; }
+
+template<class T>
+inline
+bool operator > ( optional<T> const& x, T const& y )
+{ return y < x ; }
+
+template<class T>
+inline
+bool operator <= ( optional<T> const& x, T const& y )
+{ return !( y < x ) ; }
+
+template<class T>
+inline
+bool operator >= ( optional<T> const& x, T const& y )
+{ return !( x < y ) ; }
+
+//
+// T vs optional<T> cases
+//
+
+template<class T>
+inline
+bool operator == ( T const& x, optional<T> const& y )
+{ return equal_pointees( optional<T>(x), y ); }
+
+template<class T>
+inline
+bool operator < ( T const& x, optional<T> const& y )
+{ return less_pointees( optional<T>(x), y ); }
+
+template<class T>
+inline
+bool operator != ( T const& x, optional<T> const& y )
+{ return !( x == y ) ; }
+
+template<class T>
+inline
+bool operator > ( T const& x, optional<T> const& y )
+{ return y < x ; }
+
+template<class T>
+inline
+bool operator <= ( T const& x, optional<T> const& y )
+{ return !( y < x ) ; }
+
+template<class T>
+inline
+bool operator >= ( T const& x, optional<T> const& y )
+{ return !( x < y ) ; }
+
+
+//
+// optional<T> vs none cases
+//
+
+template<class T>
+inline
+bool operator == ( optional<T> const& x, none_t )
+{ return equal_pointees(x, optional<T>() ); }
+
+template<class T>
+inline
+bool operator < ( optional<T> const& x, none_t )
+{ return less_pointees(x,optional<T>() ); }
+
+template<class T>
+inline
+bool operator != ( optional<T> const& x, none_t y )
+{ return !( x == y ) ; }
+
+template<class T>
+inline
+bool operator > ( optional<T> const& x, none_t y )
+{ return y < x ; }
+
+template<class T>
+inline
+bool operator <= ( optional<T> const& x, none_t y )
+{ return !( y < x ) ; }
+
+template<class T>
+inline
+bool operator >= ( optional<T> const& x, none_t y )
+{ return !( x < y ) ; }
+
+//
+// none vs optional<T> cases
+//
+
+template<class T>
+inline
+bool operator == ( none_t x, optional<T> const& y )
+{ return equal_pointees(optional<T>() ,y); }
+
+template<class T>
+inline
+bool operator < ( none_t x, optional<T> const& y )
+{ return less_pointees(optional<T>() ,y); }
+
+template<class T>
+inline
+bool operator != ( none_t x, optional<T> const& y )
+{ return !( x == y ) ; }
+
+template<class T>
+inline
+bool operator > ( none_t x, optional<T> const& y )
+{ return y < x ; }
+
+template<class T>
+inline
+bool operator <= ( none_t x, optional<T> const& y )
+{ return !( y < x ) ; }
+
+template<class T>
+inline
+bool operator >= ( none_t x, optional<T> const& y )
+{ return !( x < y ) ; }
+
+namespace optional_detail {
+
+template<bool use_default_constructor> struct swap_selector;
+
+template<>
+struct swap_selector<true>
+{
+    template<class T>
+    static void optional_swap ( optional<T>& x, optional<T>& y )
+    {
+        const bool hasX = !!x;
+        const bool hasY = !!y;
+
+        if ( !hasX && !hasY )
+            return;
+
+        if( !hasX )
+            x = boost::in_place();
+        else if ( !hasY )
+            y = boost::in_place();
+
+        // Boost.Utility.Swap will take care of ADL and workarounds for broken compilers
+        boost::swap(x.get(),y.get());
+
+        if( !hasX )
+            y = boost::none ;
+        else if( !hasY )
+            x = boost::none ;
+    }
+};
+
+template<>
+struct swap_selector<false>
+{
+    template<class T>
+    static void optional_swap ( optional<T>& x, optional<T>& y )
+    {
+        const bool hasX = !!x;
+        const bool hasY = !!y;
+
+        if ( !hasX && hasY )
+        {
+            x = y.get();
+            y = boost::none ;
+        }
+        else if ( hasX && !hasY )
+        {
+            y = x.get();
+            x = boost::none ;
+        }
+        else if ( hasX && hasY )
+        {
+            // Boost.Utility.Swap will take care of ADL and workarounds for broken compilers
+            boost::swap(x.get(),y.get());
+        }
+    }
+};
+
+} // namespace optional_detail
+
+template<class T>
+struct optional_swap_should_use_default_constructor : has_nothrow_default_constructor<T> {} ;
+
+template<class T> inline void swap ( optional<T>& x, optional<T>& y )
+{
+    optional_detail::swap_selector<optional_swap_should_use_default_constructor<T>::value>::optional_swap(x, y);
+}
+
+} // namespace boost
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/memory_order.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/memory_order.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/memory_order.hpp	(working copy)
@@ -0,0 +1,53 @@
+#ifndef BOOST_MEMORY_ORDER_HPP_INCLUDED
+#define BOOST_MEMORY_ORDER_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//  boost/memory_order.hpp
+//
+//  Defines enum boost::memory_order per the C++0x working draft
+//
+//  Copyright (c) 2008, 2009 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+
+
+namespace boost
+{
+
+//
+// Enum values are chosen so that code that needs to insert
+// a trailing fence for acquire semantics can use a single
+// test such as:
+//
+// if( mo & memory_order_acquire ) { ...fence... }
+//
+// For leading fences one can use:
+//
+// if( mo & memory_order_release ) { ...fence... }
+//
+// Architectures such as Alpha that need a fence on consume
+// can use:
+//
+// if( mo & ( memory_order_acquire | memory_order_consume ) ) { ...fence... }
+//
+
+enum memory_order
+{
+    memory_order_relaxed = 0,
+    memory_order_acquire = 1,
+    memory_order_release = 2,
+    memory_order_acq_rel = 3, // acquire | release
+    memory_order_seq_cst = 7, // acq_rel | 4
+    memory_order_consume = 8
+};
+
+} // namespace boost
+
+#endif // #ifndef BOOST_MEMORY_ORDER_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/exception/detail/attribute_noreturn.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/exception/detail/attribute_noreturn.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/exception/detail/attribute_noreturn.hpp	(working copy)
@@ -0,0 +1,17 @@
+//Copyright (c) 2009 Emil Dotchevski and Reverge Studios, Inc.
+
+//Distributed under the Boost Software License, Version 1.0. (See accompanying
+//file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef UUID_61531AB0680611DEADD5846855D89593
+#define UUID_61531AB0680611DEADD5846855D89593
+
+#if defined(_MSC_VER)
+#define BOOST_ATTRIBUTE_NORETURN __declspec(noreturn)
+#elif defined(__GNUC__)
+#define BOOST_ATTRIBUTE_NORETURN __attribute__((noreturn))
+#else
+#define BOOST_ATTRIBUTE_NORETURN
+#endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/exception/exception.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/exception/exception.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/exception/exception.hpp	(working copy)
@@ -0,0 +1,456 @@
+//Copyright (c) 2006-2009 Emil Dotchevski and Reverge Studios, Inc.
+
+//Distributed under the Boost Software License, Version 1.0. (See accompanying
+//file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef UUID_274DA366004E11DCB1DDFE2E56D89593
+#define UUID_274DA366004E11DCB1DDFE2E56D89593
+#if defined(__GNUC__) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)
+#pragma GCC system_header
+#endif
+#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)
+#pragma warning(push,1)
+#endif
+
+namespace
+boost
+    {
+    namespace
+    exception_detail
+        {
+        template <class T>
+        class
+        refcount_ptr
+            {
+            public:
+
+            refcount_ptr():
+                px_(0)
+                {
+                }
+
+            ~refcount_ptr()
+                {
+                release();
+                }
+
+            refcount_ptr( refcount_ptr const & x ):
+                px_(x.px_)
+                {
+                add_ref();
+                }
+
+            refcount_ptr &
+            operator=( refcount_ptr const & x )
+                {
+                adopt(x.px_);
+                return *this;
+                }
+
+            void
+            adopt( T * px )
+                {
+                release();
+                px_=px;
+                add_ref();
+                }
+
+            T *
+            get() const
+                {
+                return px_;
+                }
+
+            private:
+
+            T * px_;
+
+            void
+            add_ref()
+                {
+                if( px_ )
+                    px_->add_ref();
+                }
+
+            void
+            release()
+                {
+                if( px_ && px_->release() )
+                    px_=0;
+                }
+            };
+        }
+
+    ////////////////////////////////////////////////////////////////////////
+
+    template <class Tag,class T>
+    class error_info;
+
+    typedef error_info<struct throw_function_,char const *> throw_function;
+    typedef error_info<struct throw_file_,char const *> throw_file;
+    typedef error_info<struct throw_line_,int> throw_line;
+
+    template <>
+    class
+    error_info<throw_function_,char const *>
+        {
+        public:
+        typedef char const * value_type;
+        value_type v_;
+        explicit
+        error_info( value_type v ):
+            v_(v)
+            {
+            }
+        };
+
+    template <>
+    class
+    error_info<throw_file_,char const *>
+        {
+        public:
+        typedef char const * value_type;
+        value_type v_;
+        explicit
+        error_info( value_type v ):
+            v_(v)
+            {
+            }
+        };
+
+    template <>
+    class
+    error_info<throw_line_,int>
+        {
+        public:
+        typedef int value_type;
+        value_type v_;
+        explicit
+        error_info( value_type v ):
+            v_(v)
+            {
+            }
+        };
+
+#if defined(__GNUC__)
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility push (default)
+# endif
+#endif
+    class exception;
+#if defined(__GNUC__)
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility pop
+# endif
+#endif
+
+    template <class T>
+    class shared_ptr;
+
+    namespace
+    exception_detail
+        {
+        class error_info_base;
+        struct type_info_;
+
+        struct
+        error_info_container
+            {
+            virtual char const * diagnostic_information( char const * ) const = 0;
+            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
+            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
+            virtual void add_ref() const = 0;
+            virtual bool release() const = 0;
+            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;
+
+            protected:
+
+            ~error_info_container() throw()
+                {
+                }
+            };
+
+        template <class>
+        struct get_info;
+
+        template <>
+        struct get_info<throw_function>;
+
+        template <>
+        struct get_info<throw_file>;
+
+        template <>
+        struct get_info<throw_line>;
+
+        char const * get_diagnostic_information( exception const &, char const * );
+
+        void copy_boost_exception( exception *, exception const * );
+
+        template <class E,class Tag,class T>
+        E const & set_info( E const &, error_info<Tag,T> const & );
+
+        template <class E>
+        E const & set_info( E const &, throw_function const & );
+
+        template <class E>
+        E const & set_info( E const &, throw_file const & );
+
+        template <class E>
+        E const & set_info( E const &, throw_line const & );
+        }
+
+#if defined(__GNUC__)
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility push (default)
+# endif
+#endif
+    class
+    exception
+        {
+        protected:
+
+        exception():
+            throw_function_(0),
+            throw_file_(0),
+            throw_line_(-1)
+            {
+            }
+
+#ifdef __HP_aCC
+        //On HP aCC, this protected copy constructor prevents throwing boost::exception.
+        //On all other platforms, the same effect is achieved by the pure virtual destructor.
+        exception( exception const & x ) throw():
+            data_(x.data_),
+            throw_function_(x.throw_function_),
+            throw_file_(x.throw_file_),
+            throw_line_(x.throw_line_)
+            {
+            }
+#endif
+
+        virtual ~exception() throw()
+#ifndef __HP_aCC
+            = 0 //Workaround for HP aCC, =0 incorrectly leads to link errors.
+#endif
+            ;
+
+#if (defined(__MWERKS__) && __MWERKS__<=0x3207) || (defined(_MSC_VER) && _MSC_VER<=1310)
+        public:
+#else
+        private:
+
+        template <class E>
+        friend E const & exception_detail::set_info( E const &, throw_function const & );
+
+        template <class E>
+        friend E const & exception_detail::set_info( E const &, throw_file const & );
+
+        template <class E>
+        friend E const & exception_detail::set_info( E const &, throw_line const & );
+
+        template <class E,class Tag,class T>
+        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );
+
+        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );
+
+        template <class>
+        friend struct exception_detail::get_info;
+        friend struct exception_detail::get_info<throw_function>;
+        friend struct exception_detail::get_info<throw_file>;
+        friend struct exception_detail::get_info<throw_line>;
+        friend void exception_detail::copy_boost_exception( exception *, exception const * );
+#endif
+        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
+        mutable char const * throw_function_;
+        mutable char const * throw_file_;
+        mutable int throw_line_;
+        };
+#if defined(__GNUC__)
+# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)
+#  pragma GCC visibility pop
+# endif
+#endif
+
+    inline
+    exception::
+    ~exception() throw()
+        {
+        }
+
+    namespace
+    exception_detail
+        {
+        template <class E>
+        E const &
+        set_info( E const & x, throw_function const & y )
+            {
+            x.throw_function_=y.v_;
+            return x;
+            }
+
+        template <class E>
+        E const &
+        set_info( E const & x, throw_file const & y )
+            {
+            x.throw_file_=y.v_;
+            return x;
+            }
+
+        template <class E>
+        E const &
+        set_info( E const & x, throw_line const & y )
+            {
+            x.throw_line_=y.v_;
+            return x;
+            }
+        }
+
+    ////////////////////////////////////////////////////////////////////////
+
+    namespace
+    exception_detail
+        {
+        template <class T>
+        struct
+        error_info_injector:
+            public T,
+            public exception
+            {
+            explicit
+            error_info_injector( T const & x ):
+                T(x)
+                {
+                }
+
+            ~error_info_injector() throw()
+                {
+                }
+            };
+
+        struct large_size { char c[256]; };
+        large_size dispatch_boost_exception( exception const * );
+
+        struct small_size { };
+        small_size dispatch_boost_exception( void const * );
+
+        template <class,int>
+        struct enable_error_info_helper;
+
+        template <class T>
+        struct
+        enable_error_info_helper<T,sizeof(large_size)>
+            {
+            typedef T type;
+            };
+
+        template <class T>
+        struct
+        enable_error_info_helper<T,sizeof(small_size)>
+            {
+            typedef error_info_injector<T> type;
+            };
+
+        template <class T>
+        struct
+        enable_error_info_return_type
+            {
+            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
+            };
+        }
+
+    template <class T>
+    inline
+    typename
+    exception_detail::enable_error_info_return_type<T>::type
+    enable_error_info( T const & x )
+        {
+        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
+        return rt(x);
+        }
+
+    ////////////////////////////////////////////////////////////////////////
+
+    namespace
+    exception_detail
+        {
+        class
+        clone_base
+            {
+            public:
+
+            virtual clone_base const * clone() const = 0;
+            virtual void rethrow() const = 0;
+
+            virtual
+            ~clone_base() throw()
+                {
+                }
+            };
+
+        inline
+        void
+        copy_boost_exception( exception * a, exception const * b )
+            {
+            refcount_ptr<error_info_container> data;
+            if( error_info_container * d=b->data_.get() )
+                data = d->clone();
+            a->throw_file_ = b->throw_file_;
+            a->throw_line_ = b->throw_line_;
+            a->throw_function_ = b->throw_function_;
+            a->data_ = data;
+            }
+
+        inline
+        void
+        copy_boost_exception( void *, void const * )
+            {
+            }
+
+        template <class T>
+        class
+        clone_impl:
+            public T,
+            public clone_base
+            {
+            public:
+
+            explicit
+            clone_impl( T const & x ):
+                T(x)
+                {
+                copy_boost_exception(this,&x);
+                }
+
+            ~clone_impl() throw()
+                {
+                }
+
+            private:
+
+            clone_base const *
+            clone() const
+                {
+                return new clone_impl(*this);
+                }
+
+            void
+            rethrow() const
+                {
+                throw*this;
+                }
+            };
+        }
+
+    template <class T>
+    inline
+    exception_detail::clone_impl<T>
+    enable_current_exception( T const & x )
+        {
+        return exception_detail::clone_impl<T>(x);
+        }
+    }
+
+#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)
+#pragma warning(pop)
+#endif
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/iterator.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/iterator.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/iterator.hpp	(working copy)
@@ -0,0 +1,494 @@
+// (C) Copyright David Abrahams 2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+// Boost versions of
+//
+//    std::iterator_traits<>::iterator_category
+//    std::iterator_traits<>::difference_type
+//    std::distance()
+//
+// ...for all compilers and iterators
+//
+// Additionally, if X is a pointer
+//    std::iterator_traits<X>::pointer
+
+// Otherwise, if partial specialization is supported or X is not a pointer
+//    std::iterator_traits<X>::value_type
+//    std::iterator_traits<X>::pointer
+//    std::iterator_traits<X>::reference
+//
+// See http://www.boost.org for most recent version including documentation.
+
+// Revision History
+// 04 Mar 2001 - More attempted fixes for Intel C++ (David Abrahams)
+// 03 Mar 2001 - Put all implementation into namespace
+//               boost::detail::iterator_traits_. Some progress made on fixes
+//               for Intel compiler. (David Abrahams)
+// 02 Mar 2001 - Changed BOOST_MSVC to BOOST_MSVC_STD_ITERATOR in a few
+//               places. (Jeremy Siek)
+// 19 Feb 2001 - Improved workarounds for stock MSVC6; use yes_type and
+//               no_type from type_traits.hpp; stopped trying to remove_cv
+//               before detecting is_pointer, in honor of the new type_traits
+//               semantics. (David Abrahams)
+// 13 Feb 2001 - Make it work with nearly all standard-conforming iterators
+//               under raw VC6. The one category remaining which will fail is
+//               that of iterators derived from std::iterator but not
+//               boost::iterator and which redefine difference_type.
+// 11 Feb 2001 - Clean away code which can never be used (David Abrahams)
+// 09 Feb 2001 - Always have a definition for each traits member, even if it
+//               can't be properly deduced. These will be incomplete types in
+//               some cases (undefined<void>), but it helps suppress MSVC errors
+//               elsewhere (David Abrahams)
+// 07 Feb 2001 - Support for more of the traits members where possible, making
+//               this useful as a replacement for std::iterator_traits<T> when
+//               used as a default template parameter.
+// 06 Feb 2001 - Removed useless #includes of standard library headers
+//               (David Abrahams)
+
+#ifndef ITERATOR_DWA122600_HPP_
+# define ITERATOR_DWA122600_HPP_
+
+# include <boost/config.hpp>
+# include <iterator>
+
+// STLPort 4.0 and betas have a bug when debugging is enabled and there is no
+// partial specialization: instead of an iterator_category typedef, the standard
+// container iterators have _Iterator_category.
+//
+// Also, whether debugging is enabled or not, there is a broken specialization
+// of std::iterator<output_iterator_tag,void,void,void,void> which has no
+// typedefs but iterator_category.
+# if defined(__SGI_STL_PORT)
+
+#  if (__SGI_STL_PORT <= 0x410) && !defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && defined(__STL_DEBUG)
+#   define BOOST_BAD_CONTAINER_ITERATOR_CATEGORY_TYPEDEF
+#  endif
+
+#  define BOOST_BAD_OUTPUT_ITERATOR_SPECIALIZATION
+
+# endif // STLPort <= 4.1b4 && no partial specialization
+
+# if !defined(BOOST_NO_STD_ITERATOR_TRAITS)             \
+  && !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+  && !defined(BOOST_MSVC_STD_ITERATOR)
+
+namespace boost { namespace detail {
+
+// Define a new template so it can be specialized
+template <class Iterator>
+struct iterator_traits
+    : std::iterator_traits<Iterator>
+{};
+using std::distance;
+
+}} // namespace boost::detail
+
+# else
+
+#  if  !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)  \
+    && !defined(BOOST_MSVC_STD_ITERATOR)
+
+// This is the case where everything conforms except BOOST_NO_STD_ITERATOR_TRAITS
+
+namespace boost { namespace detail {
+
+// Rogue Wave Standard Library fools itself into thinking partial
+// specialization is missing on some platforms (e.g. Sun), so fails to
+// supply iterator_traits!
+template <class Iterator>
+struct iterator_traits
+{
+    typedef typename Iterator::value_type value_type;
+    typedef typename Iterator::reference reference;
+    typedef typename Iterator::pointer pointer;
+    typedef typename Iterator::difference_type difference_type;
+    typedef typename Iterator::iterator_category iterator_category;
+};
+
+template <class T>
+struct iterator_traits<T*>
+{
+    typedef T value_type;
+    typedef T& reference;
+    typedef T* pointer;
+    typedef std::ptrdiff_t difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+
+template <class T>
+struct iterator_traits<T const*>
+{
+    typedef T value_type;
+    typedef T const& reference;
+    typedef T const* pointer;
+    typedef std::ptrdiff_t difference_type;
+    typedef std::random_access_iterator_tag iterator_category;
+};
+
+}} // namespace boost::detail
+
+#  else
+
+# include <boost/type_traits/remove_const.hpp>
+# include <boost/type_traits/detail/yes_no_type.hpp>
+# include <boost/type_traits/is_pointer.hpp>
+
+# ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  include <boost/type_traits/is_same.hpp>
+#  include <boost/type_traits/remove_pointer.hpp>
+# endif
+# ifdef BOOST_BAD_OUTPUT_ITERATOR_SPECIALIZATION
+#  include <boost/type_traits/is_base_and_derived.hpp>
+# endif
+
+# include <boost/mpl/if.hpp>
+# include <boost/mpl/has_xxx.hpp>
+# include <cstddef>
+
+// should be the last #include
+# include "boost/type_traits/detail/bool_trait_def.hpp"
+
+namespace boost { namespace detail {
+
+BOOST_MPL_HAS_XXX_TRAIT_DEF(value_type)
+BOOST_MPL_HAS_XXX_TRAIT_DEF(reference)
+BOOST_MPL_HAS_XXX_TRAIT_DEF(pointer)
+BOOST_MPL_HAS_XXX_TRAIT_DEF(difference_type)
+BOOST_MPL_HAS_XXX_TRAIT_DEF(iterator_category)
+
+// is_mutable_iterator --
+//
+//   A metafunction returning true iff T is a mutable iterator type
+//   with a nested value_type. Will only work portably with iterators
+//   whose operator* returns a reference, but that seems to be OK for
+//   the iterators supplied by Dinkumware. Some input iterators may
+//   compile-time if they arrive here, and if the compiler is strict
+//   about not taking the address of an rvalue.
+
+// This one detects ordinary mutable iterators - the result of
+// operator* is convertible to the value_type.
+template <class T>
+type_traits::yes_type is_mutable_iterator_helper(T const*, BOOST_DEDUCED_TYPENAME T::value_type*);
+
+// Since you can't take the address of an rvalue, the guts of
+// is_mutable_iterator_impl will fail if we use &*t directly.  This
+// makes sure we can still work with non-lvalue iterators.
+template <class T> T* mutable_iterator_lvalue_helper(T& x);
+int mutable_iterator_lvalue_helper(...);
+
+
+// This one detects output iterators such as ostream_iterator which
+// return references to themselves.
+template <class T>
+type_traits::yes_type is_mutable_iterator_helper(T const*, T const*);
+
+type_traits::no_type is_mutable_iterator_helper(...);
+
+template <class T>
+struct is_mutable_iterator_impl
+{
+    static T t;
+
+    BOOST_STATIC_CONSTANT(
+        bool, value = sizeof(
+            detail::is_mutable_iterator_helper(
+                (T*)0
+              , mutable_iterator_lvalue_helper(*t) // like &*t
+            ))
+        == sizeof(type_traits::yes_type)
+    );
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(
+    is_mutable_iterator,T,::boost::detail::is_mutable_iterator_impl<T>::value)
+
+
+// is_full_iterator_traits --
+//
+//   A metafunction returning true iff T has all the requisite nested
+//   types to satisfy the requirements for a fully-conforming
+//   iterator_traits implementation.
+template <class T>
+struct is_full_iterator_traits_impl
+{
+    enum { value =
+           has_value_type<T>::value
+           & has_reference<T>::value
+           & has_pointer<T>::value
+           & has_difference_type<T>::value
+           & has_iterator_category<T>::value
+    };
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(
+    is_full_iterator_traits,T,::boost::detail::is_full_iterator_traits_impl<T>::value)
+
+
+#   ifdef BOOST_BAD_CONTAINER_ITERATOR_CATEGORY_TYPEDEF
+BOOST_MPL_HAS_XXX_TRAIT_DEF(_Iterator_category)
+
+// is_stlport_40_debug_iterator --
+//
+//   A metafunction returning true iff T has all the requisite nested
+//   types to satisfy the requirements of an STLPort 4.0 debug iterator
+//   iterator_traits implementation.
+template <class T>
+struct is_stlport_40_debug_iterator_impl
+{
+    enum { value =
+           has_value_type<T>::value
+           & has_reference<T>::value
+           & has_pointer<T>::value
+           & has_difference_type<T>::value
+           & has__Iterator_category<T>::value
+    };
+};
+
+BOOST_TT_AUX_BOOL_TRAIT_DEF1(
+    is_stlport_40_debug_iterator,T,::boost::detail::is_stlport_40_debug_iterator_impl<T>::value)
+
+template <class T>
+struct stlport_40_debug_iterator_traits
+{
+    typedef typename T::value_type value_type;
+    typedef typename T::reference reference;
+    typedef typename T::pointer pointer;
+    typedef typename T::difference_type difference_type;
+    typedef typename T::_Iterator_category iterator_category;
+};
+#   endif // BOOST_BAD_CONTAINER_ITERATOR_CATEGORY_TYPEDEF
+
+template <class T> struct pointer_iterator_traits;
+
+#   ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+template <class T>
+struct pointer_iterator_traits<T*>
+{
+    typedef typename remove_const<T>::type value_type;
+    typedef T* pointer;
+    typedef T& reference;
+    typedef std::random_access_iterator_tag iterator_category;
+    typedef std::ptrdiff_t difference_type;
+};
+#   else
+
+// In case of no template partial specialization, and if T is a
+// pointer, iterator_traits<T>::value_type can still be computed.  For
+// some basic types, remove_pointer is manually defined in
+// type_traits/broken_compiler_spec.hpp. For others, do it yourself.
+
+template<class P> class please_invoke_BOOST_TT_BROKEN_COMPILER_SPEC_on_cv_unqualified_pointee;
+
+template<class P>
+struct pointer_value_type
+  : mpl::if_<
+        is_same<P, typename remove_pointer<P>::type>
+      , please_invoke_BOOST_TT_BROKEN_COMPILER_SPEC_on_cv_unqualified_pointee<P>
+      , typename remove_const<
+            typename remove_pointer<P>::type
+        >::type
+    >
+{
+};
+
+
+template<class P>
+struct pointer_reference
+  : mpl::if_<
+        is_same<P, typename remove_pointer<P>::type>
+      , please_invoke_BOOST_TT_BROKEN_COMPILER_SPEC_on_cv_unqualified_pointee<P>
+      , typename remove_pointer<P>::type&
+    >
+{
+};
+
+template <class T>
+struct pointer_iterator_traits
+{
+    typedef T pointer;
+    typedef std::random_access_iterator_tag iterator_category;
+    typedef std::ptrdiff_t difference_type;
+
+    typedef typename pointer_value_type<T>::type value_type;
+    typedef typename pointer_reference<T>::type reference;
+};
+
+#   endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+// We'll sort iterator types into one of these classifications, from which we
+// can determine the difference_type, pointer, reference, and value_type
+template <class Iterator>
+struct standard_iterator_traits
+{
+    typedef typename Iterator::difference_type difference_type;
+    typedef typename Iterator::value_type value_type;
+    typedef typename Iterator::pointer pointer;
+    typedef typename Iterator::reference reference;
+    typedef typename Iterator::iterator_category iterator_category;
+};
+
+template <class Iterator>
+struct msvc_stdlib_mutable_traits
+    : std::iterator_traits<Iterator>
+{
+    typedef typename std::iterator_traits<Iterator>::distance_type difference_type;
+    typedef typename std::iterator_traits<Iterator>::value_type* pointer;
+    typedef typename std::iterator_traits<Iterator>::value_type& reference;
+};
+
+template <class Iterator>
+struct msvc_stdlib_const_traits
+    : std::iterator_traits<Iterator>
+{
+    typedef typename std::iterator_traits<Iterator>::distance_type difference_type;
+    typedef const typename std::iterator_traits<Iterator>::value_type* pointer;
+    typedef const typename std::iterator_traits<Iterator>::value_type& reference;
+};
+
+#   ifdef BOOST_BAD_OUTPUT_ITERATOR_SPECIALIZATION
+template <class Iterator>
+struct is_bad_output_iterator
+    : is_base_and_derived<
+        std::iterator<std::output_iterator_tag,void,void,void,void>
+        , Iterator>
+{
+};
+
+struct bad_output_iterator_traits
+{
+    typedef void value_type;
+    typedef void difference_type;
+    typedef std::output_iterator_tag iterator_category;
+    typedef void pointer;
+    typedef void reference;
+};
+#   endif
+
+// If we're looking at an MSVC6 (old Dinkumware) ``standard''
+// iterator, this will generate an appropriate traits class.
+template <class Iterator>
+struct msvc_stdlib_iterator_traits
+    : mpl::if_<
+       is_mutable_iterator<Iterator>
+       , msvc_stdlib_mutable_traits<Iterator>
+       , msvc_stdlib_const_traits<Iterator>
+      >::type
+{};
+
+template <class Iterator>
+struct non_pointer_iterator_traits
+    : mpl::if_<
+        // if the iterator contains all the right nested types...
+        is_full_iterator_traits<Iterator>
+        // Use a standard iterator_traits implementation
+        , standard_iterator_traits<Iterator>
+#   ifdef BOOST_BAD_CONTAINER_ITERATOR_CATEGORY_TYPEDEF
+        // Check for STLPort 4.0 broken _Iterator_category type
+        , mpl::if_<
+             is_stlport_40_debug_iterator<Iterator>
+             , stlport_40_debug_iterator_traits<Iterator>
+#   endif
+        // Otherwise, assume it's a Dinkum iterator
+        , msvc_stdlib_iterator_traits<Iterator>
+#   ifdef BOOST_BAD_CONTAINER_ITERATOR_CATEGORY_TYPEDEF
+        >::type
+#   endif
+    >::type
+{
+};
+
+template <class Iterator>
+struct iterator_traits_aux
+    : mpl::if_<
+        is_pointer<Iterator>
+        , pointer_iterator_traits<Iterator>
+        , non_pointer_iterator_traits<Iterator>
+    >::type
+{
+};
+
+template <class Iterator>
+struct iterator_traits
+{
+    // Explicit forwarding from base class needed to keep MSVC6 happy
+    // under some circumstances.
+ private:
+#   ifdef BOOST_BAD_OUTPUT_ITERATOR_SPECIALIZATION
+    typedef
+    typename mpl::if_<
+        is_bad_output_iterator<Iterator>
+        , bad_output_iterator_traits
+        , iterator_traits_aux<Iterator>
+    >::type base;
+#   else
+    typedef iterator_traits_aux<Iterator> base;
+#   endif
+ public:
+    typedef typename base::value_type value_type;
+    typedef typename base::pointer pointer;
+    typedef typename base::reference reference;
+    typedef typename base::difference_type difference_type;
+    typedef typename base::iterator_category iterator_category;
+};
+
+// This specialization cuts off ETI (Early Template Instantiation) for MSVC.
+template <> struct iterator_traits<int>
+{
+    typedef int value_type;
+    typedef int pointer;
+    typedef int reference;
+    typedef int difference_type;
+    typedef int iterator_category;
+};
+
+}} // namespace boost::detail
+
+#  endif // workarounds
+
+namespace boost { namespace detail {
+
+namespace iterator_traits_
+{
+  template <class Iterator, class Difference>
+  struct distance_select
+  {
+      static Difference execute(Iterator i1, const Iterator i2, ...)
+      {
+          Difference result = 0;
+          while (i1 != i2)
+          {
+              ++i1;
+              ++result;
+          }
+          return result;
+      }
+
+      static Difference execute(Iterator i1, const Iterator i2, std::random_access_iterator_tag*)
+      {
+          return i2 - i1;
+      }
+  };
+} // namespace boost::detail::iterator_traits_
+
+template <class Iterator>
+inline typename iterator_traits<Iterator>::difference_type
+distance(Iterator first, Iterator last)
+{
+    typedef typename iterator_traits<Iterator>::difference_type diff_t;
+    typedef typename ::boost::detail::iterator_traits<Iterator>::iterator_category iterator_category;
+
+    return iterator_traits_::distance_select<Iterator,diff_t>::execute(
+        first, last, (iterator_category*)0);
+}
+
+}}
+
+# endif
+
+
+# undef BOOST_BAD_CONTAINER_ITERATOR_CATEGORY_TYPEDEF
+# undef BOOST_BAD_OUTPUT_ITERATOR_SPECIALIZATION
+
+#endif // ITERATOR_DWA122600_HPP_
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/workaround.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/workaround.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/workaround.hpp	(working copy)
@@ -0,0 +1,267 @@
+// Copyright David Abrahams 2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef WORKAROUND_DWA2002126_HPP
+# define WORKAROUND_DWA2002126_HPP
+
+// Compiler/library version workaround macro
+//
+// Usage:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+//        // workaround for eVC4 and VC6
+//        ... // workaround code here
+//     #endif
+//
+// When BOOST_STRICT_CONFIG is defined, expands to 0. Otherwise, the
+// first argument must be undefined or expand to a numeric
+// value. The above expands to:
+//
+//     (BOOST_MSVC) != 0 && (BOOST_MSVC) < 1300
+//
+// When used for workarounds that apply to the latest known version
+// and all earlier versions of a compiler, the following convention
+// should be observed:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1301))
+//
+// The version number in this case corresponds to the last version in
+// which the workaround was known to have been required. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is not the defined, the macro
+// BOOST_TESTED_AT(x) expands to "!= 0", which effectively activates
+// the workaround for any version of the compiler. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is defined, a compiler warning or
+// error will be issued if the compiler version exceeds the argument
+// to BOOST_TESTED_AT().  This can be used to locate workarounds which
+// may be obsoleted by newer versions.
+
+# ifndef BOOST_STRICT_CONFIG
+
+#include <boost/config.hpp>
+
+#ifndef __BORLANDC__
+#define __BORLANDC___WORKAROUND_GUARD 1
+#else
+#define __BORLANDC___WORKAROUND_GUARD 0
+#endif
+#ifndef __CODEGEARC__
+#define __CODEGEARC___WORKAROUND_GUARD 1
+#else
+#define __CODEGEARC___WORKAROUND_GUARD 0
+#endif
+#ifndef _MSC_VER
+#define _MSC_VER_WORKAROUND_GUARD 1
+#else
+#define _MSC_VER_WORKAROUND_GUARD 0
+#endif
+#ifndef _MSC_FULL_VER
+#define _MSC_FULL_VER_WORKAROUND_GUARD 1
+#else
+#define _MSC_FULL_VER_WORKAROUND_GUARD 0
+#endif
+#ifndef BOOST_MSVC
+#define BOOST_MSVC_WORKAROUND_GUARD 1
+#else
+#define BOOST_MSVC_WORKAROUND_GUARD 0
+#endif
+#ifndef BOOST_MSVC_FULL_VER
+#define BOOST_MSVC_FULL_VER_WORKAROUND_GUARD 1
+#else
+#define BOOST_MSVC_FULL_VER_WORKAROUND_GUARD 0
+#endif
+#ifndef __GNUC__
+#define __GNUC___WORKAROUND_GUARD 1
+#else
+#define __GNUC___WORKAROUND_GUARD 0
+#endif
+#ifndef __GNUC_MINOR__
+#define __GNUC_MINOR___WORKAROUND_GUARD 1
+#else
+#define __GNUC_MINOR___WORKAROUND_GUARD 0
+#endif
+#ifndef __GNUC_PATCHLEVEL__
+#define __GNUC_PATCHLEVEL___WORKAROUND_GUARD 1
+#else
+#define __GNUC_PATCHLEVEL___WORKAROUND_GUARD 0
+#endif
+#ifndef __IBMCPP__
+#define __IBMCPP___WORKAROUND_GUARD 1
+#else
+#define __IBMCPP___WORKAROUND_GUARD 0
+#endif
+#ifndef __SUNPRO_CC
+#define __SUNPRO_CC_WORKAROUND_GUARD 1
+#else
+#define __SUNPRO_CC_WORKAROUND_GUARD 0
+#endif
+#ifndef __DECCXX_VER
+#define __DECCXX_VER_WORKAROUND_GUARD 1
+#else
+#define __DECCXX_VER_WORKAROUND_GUARD 0
+#endif
+#ifndef __MWERKS__
+#define __MWERKS___WORKAROUND_GUARD 1
+#else
+#define __MWERKS___WORKAROUND_GUARD 0
+#endif
+#ifndef __EDG__
+#define __EDG___WORKAROUND_GUARD 1
+#else
+#define __EDG___WORKAROUND_GUARD 0
+#endif
+#ifndef __EDG_VERSION__
+#define __EDG_VERSION___WORKAROUND_GUARD 1
+#else
+#define __EDG_VERSION___WORKAROUND_GUARD 0
+#endif
+#ifndef __HP_aCC
+#define __HP_aCC_WORKAROUND_GUARD 1
+#else
+#define __HP_aCC_WORKAROUND_GUARD 0
+#endif
+#ifndef __hpxstd98
+#define __hpxstd98_WORKAROUND_GUARD 1
+#else
+#define __hpxstd98_WORKAROUND_GUARD 0
+#endif
+#ifndef _CRAYC
+#define _CRAYC_WORKAROUND_GUARD 1
+#else
+#define _CRAYC_WORKAROUND_GUARD 0
+#endif
+#ifndef __DMC__
+#define __DMC___WORKAROUND_GUARD 1
+#else
+#define __DMC___WORKAROUND_GUARD 0
+#endif
+#ifndef MPW_CPLUS
+#define MPW_CPLUS_WORKAROUND_GUARD 1
+#else
+#define MPW_CPLUS_WORKAROUND_GUARD 0
+#endif
+#ifndef __COMO__
+#define __COMO___WORKAROUND_GUARD 1
+#else
+#define __COMO___WORKAROUND_GUARD 0
+#endif
+#ifndef __COMO_VERSION__
+#define __COMO_VERSION___WORKAROUND_GUARD 1
+#else
+#define __COMO_VERSION___WORKAROUND_GUARD 0
+#endif
+#ifndef __INTEL_COMPILER
+#define __INTEL_COMPILER_WORKAROUND_GUARD 1
+#else
+#define __INTEL_COMPILER_WORKAROUND_GUARD 0
+#endif
+#ifndef __ICL
+#define __ICL_WORKAROUND_GUARD 1
+#else
+#define __ICL_WORKAROUND_GUARD 0
+#endif
+#ifndef _COMPILER_VERSION
+#define _COMPILER_VERSION_WORKAROUND_GUARD 1
+#else
+#define _COMPILER_VERSION_WORKAROUND_GUARD 0
+#endif
+
+#ifndef _RWSTD_VER
+#define _RWSTD_VER_WORKAROUND_GUARD 1
+#else
+#define _RWSTD_VER_WORKAROUND_GUARD 0
+#endif
+#ifndef BOOST_RWSTD_VER
+#define BOOST_RWSTD_VER_WORKAROUND_GUARD 1
+#else
+#define BOOST_RWSTD_VER_WORKAROUND_GUARD 0
+#endif
+#ifndef __GLIBCPP__
+#define __GLIBCPP___WORKAROUND_GUARD 1
+#else
+#define __GLIBCPP___WORKAROUND_GUARD 0
+#endif
+#ifndef _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC
+#define _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC_WORKAROUND_GUARD 1
+#else
+#define _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC_WORKAROUND_GUARD 0
+#endif
+#ifndef __SGI_STL_PORT
+#define __SGI_STL_PORT_WORKAROUND_GUARD 1
+#else
+#define __SGI_STL_PORT_WORKAROUND_GUARD 0
+#endif
+#ifndef _STLPORT_VERSION
+#define _STLPORT_VERSION_WORKAROUND_GUARD 1
+#else
+#define _STLPORT_VERSION_WORKAROUND_GUARD 0
+#endif
+#ifndef __LIBCOMO_VERSION__
+#define __LIBCOMO_VERSION___WORKAROUND_GUARD 1
+#else
+#define __LIBCOMO_VERSION___WORKAROUND_GUARD 0
+#endif
+#ifndef _CPPLIB_VER
+#define _CPPLIB_VER_WORKAROUND_GUARD 1
+#else
+#define _CPPLIB_VER_WORKAROUND_GUARD 0
+#endif
+
+#ifndef BOOST_INTEL_CXX_VERSION
+#define BOOST_INTEL_CXX_VERSION_WORKAROUND_GUARD 1
+#else
+#define BOOST_INTEL_CXX_VERSION_WORKAROUND_GUARD 0
+#endif
+#ifndef BOOST_INTEL_WIN
+#define BOOST_INTEL_WIN_WORKAROUND_GUARD 1
+#else
+#define BOOST_INTEL_WIN_WORKAROUND_GUARD 0
+#endif
+#ifndef BOOST_DINKUMWARE_STDLIB
+#define BOOST_DINKUMWARE_STDLIB_WORKAROUND_GUARD 1
+#else
+#define BOOST_DINKUMWARE_STDLIB_WORKAROUND_GUARD 0
+#endif
+#ifndef BOOST_INTEL
+#define BOOST_INTEL_WORKAROUND_GUARD 1
+#else
+#define BOOST_INTEL_WORKAROUND_GUARD 0
+#endif
+// Always define to zero, if it's used it'll be defined my MPL:
+#define BOOST_MPL_CFG_GCC_WORKAROUND_GUARD 0
+
+#  define BOOST_WORKAROUND(symbol, test)                \
+         ((symbol ## _WORKAROUND_GUARD + 0 == 0) &&     \
+         (symbol != 0) && (1 % (( (symbol test) ) + 1)))
+//                              ^ ^           ^ ^
+// The extra level of parenthesis nesting above, along with the
+// BOOST_OPEN_PAREN indirection below, is required to satisfy the
+// broken preprocessor in MWCW 8.3 and earlier.
+//
+// The basic mechanism works as follows:
+//      (symbol test) + 1        =>   if (symbol test) then 2 else 1
+//      1 % ((symbol test) + 1)  =>   if (symbol test) then 1 else 0
+//
+// The complication with % is for cooperation with BOOST_TESTED_AT().
+// When "test" is BOOST_TESTED_AT(x) and
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is #defined,
+//
+//      symbol test              =>   if (symbol <= x) then 1 else -1
+//      (symbol test) + 1        =>   if (symbol <= x) then 2 else 0
+//      1 % ((symbol test) + 1)  =>   if (symbol <= x) then 1 else divide-by-zero
+//
+
+#  ifdef BOOST_DETECT_OUTDATED_WORKAROUNDS
+#   define BOOST_OPEN_PAREN (
+#   define BOOST_TESTED_AT(value)  > value) ?(-1): BOOST_OPEN_PAREN 1
+#  else
+#   define BOOST_TESTED_AT(value) != ((value)-(value))
+#  endif
+
+# else
+
+#  define BOOST_WORKAROUND(symbol, test) 0
+
+# endif
+
+#endif // WORKAROUND_DWA2002126_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/sp_typeinfo.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/sp_typeinfo.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/sp_typeinfo.hpp	(working copy)
@@ -0,0 +1,135 @@
+#ifndef BOOST_DETAIL_SP_TYPEINFO_HPP_INCLUDED
+#define BOOST_DETAIL_SP_TYPEINFO_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//  detail/sp_typeinfo.hpp
+//
+//  Copyright 2007 Peter Dimov
+//
+// Distributed under the Boost Software License, Version 1.0.
+// See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+#include <boost/config.hpp>
+
+#if defined( BOOST_NO_TYPEID )
+
+#include <boost/current_function.hpp>
+#include <functional>
+
+namespace boost
+{
+
+namespace detail
+{
+
+class sp_typeinfo
+{
+private:
+
+    sp_typeinfo( sp_typeinfo const& );
+    sp_typeinfo& operator=( sp_typeinfo const& );
+
+    char const * name_;
+
+public:
+
+    explicit sp_typeinfo( char const * name ): name_( name )
+    {
+    }
+
+    bool operator==( sp_typeinfo const& rhs ) const
+    {
+        return this == &rhs;
+    }
+
+    bool operator!=( sp_typeinfo const& rhs ) const
+    {
+        return this != &rhs;
+    }
+
+    bool before( sp_typeinfo const& rhs ) const
+    {
+        return std::less< sp_typeinfo const* >()( this, &rhs );
+    }
+
+    char const* name() const
+    {
+        return name_;
+    }
+};
+
+template<class T> struct sp_typeid_
+{
+    static sp_typeinfo ti_;
+
+    static char const * name()
+    {
+        return BOOST_CURRENT_FUNCTION;
+    }
+};
+
+#if defined(__SUNPRO_CC)
+// see #4199, the Sun Studio compiler gets confused about static initialization
+// constructor arguments. But an assignment works just fine.
+template<class T> sp_typeinfo sp_typeid_< T >::ti_ = sp_typeid_< T >::name();
+#else
+template<class T> sp_typeinfo sp_typeid_< T >::ti_(sp_typeid_< T >::name());
+#endif
+
+template<class T> struct sp_typeid_< T & >: sp_typeid_< T >
+{
+};
+
+template<class T> struct sp_typeid_< T const >: sp_typeid_< T >
+{
+};
+
+template<class T> struct sp_typeid_< T volatile >: sp_typeid_< T >
+{
+};
+
+template<class T> struct sp_typeid_< T const volatile >: sp_typeid_< T >
+{
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#define BOOST_SP_TYPEID(T) (boost::detail::sp_typeid_<T>::ti_)
+
+#else
+
+#include <typeinfo>
+
+namespace boost
+{
+
+namespace detail
+{
+
+#if defined( BOOST_NO_STD_TYPEINFO )
+
+typedef ::type_info sp_typeinfo;
+
+#else
+
+typedef std::type_info sp_typeinfo;
+
+#endif
+
+} // namespace detail
+
+} // namespace boost
+
+#define BOOST_SP_TYPEID(T) typeid(T)
+
+#endif
+
+#endif  // #ifndef BOOST_DETAIL_SP_TYPEINFO_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/compressed_pair.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/compressed_pair.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/compressed_pair.hpp	(working copy)
@@ -0,0 +1,443 @@
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/utility for most recent version including documentation.
+
+// compressed_pair: pair that "compresses" empty members
+// (see libs/utility/compressed_pair.htm)
+//
+// JM changes 25 Jan 2004:
+// For the case where T1 == T2 and both are empty, then first() and second()
+// should return different objects.
+// JM changes 25 Jan 2000:
+// Removed default arguments from compressed_pair_switch to get
+// C++ Builder 4 to accept them
+// rewriten swap to get gcc and C++ builder to compile.
+// added partial specialisations for case T1 == T2 to avoid duplicate constructor defs.
+
+#ifndef BOOST_DETAIL_COMPRESSED_PAIR_HPP
+#define BOOST_DETAIL_COMPRESSED_PAIR_HPP
+
+#include <algorithm>
+
+#include <boost/type_traits/remove_cv.hpp>
+#include <boost/type_traits/is_empty.hpp>
+#include <boost/type_traits/is_same.hpp>
+#include <boost/call_traits.hpp>
+
+#ifdef BOOST_MSVC
+# pragma warning(push)
+# pragma warning(disable:4512)
+#endif
+namespace boost
+{
+
+template <class T1, class T2>
+class compressed_pair;
+
+
+// compressed_pair
+
+namespace details
+{
+   // JM altered 26 Jan 2000:
+   template <class T1, class T2, bool IsSame, bool FirstEmpty, bool SecondEmpty>
+   struct compressed_pair_switch;
+
+   template <class T1, class T2>
+   struct compressed_pair_switch<T1, T2, false, false, false>
+      {static const int value = 0;};
+
+   template <class T1, class T2>
+   struct compressed_pair_switch<T1, T2, false, true, true>
+      {static const int value = 3;};
+
+   template <class T1, class T2>
+   struct compressed_pair_switch<T1, T2, false, true, false>
+      {static const int value = 1;};
+
+   template <class T1, class T2>
+   struct compressed_pair_switch<T1, T2, false, false, true>
+      {static const int value = 2;};
+
+   template <class T1, class T2>
+   struct compressed_pair_switch<T1, T2, true, true, true>
+      {static const int value = 4;};
+
+   template <class T1, class T2>
+   struct compressed_pair_switch<T1, T2, true, false, false>
+      {static const int value = 5;};
+
+   template <class T1, class T2, int Version> class compressed_pair_imp;
+
+#ifdef __GNUC__
+   // workaround for GCC (JM):
+   using std::swap;
+#endif
+   //
+   // can't call unqualified swap from within classname::swap
+   // as Koenig lookup rules will find only the classname::swap
+   // member function not the global declaration, so use cp_swap
+   // as a forwarding function (JM):
+   template <typename T>
+   inline void cp_swap(T& t1, T& t2)
+   {
+#ifndef __GNUC__
+      using std::swap;
+#endif
+      swap(t1, t2);
+   }
+
+   // 0    derive from neither
+
+   template <class T1, class T2>
+   class compressed_pair_imp<T1, T2, 0>
+   {
+   public:
+      typedef T1                                                 first_type;
+      typedef T2                                                 second_type;
+      typedef typename call_traits<first_type>::param_type       first_param_type;
+      typedef typename call_traits<second_type>::param_type      second_param_type;
+      typedef typename call_traits<first_type>::reference        first_reference;
+      typedef typename call_traits<second_type>::reference       second_reference;
+      typedef typename call_traits<first_type>::const_reference  first_const_reference;
+      typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+      compressed_pair_imp() {}
+
+      compressed_pair_imp(first_param_type x, second_param_type y)
+         : first_(x), second_(y) {}
+
+      compressed_pair_imp(first_param_type x)
+         : first_(x) {}
+
+      compressed_pair_imp(second_param_type y)
+         : second_(y) {}
+
+      first_reference       first()       {return first_;}
+      first_const_reference first() const {return first_;}
+
+      second_reference       second()       {return second_;}
+      second_const_reference second() const {return second_;}
+
+      void swap(::boost::compressed_pair<T1, T2>& y)
+      {
+         cp_swap(first_, y.first());
+         cp_swap(second_, y.second());
+      }
+   private:
+      first_type first_;
+      second_type second_;
+   };
+
+   // 1    derive from T1
+
+   template <class T1, class T2>
+   class compressed_pair_imp<T1, T2, 1>
+      : protected ::boost::remove_cv<T1>::type
+   {
+   public:
+      typedef T1                                                 first_type;
+      typedef T2                                                 second_type;
+      typedef typename call_traits<first_type>::param_type       first_param_type;
+      typedef typename call_traits<second_type>::param_type      second_param_type;
+      typedef typename call_traits<first_type>::reference        first_reference;
+      typedef typename call_traits<second_type>::reference       second_reference;
+      typedef typename call_traits<first_type>::const_reference  first_const_reference;
+      typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+      compressed_pair_imp() {}
+
+      compressed_pair_imp(first_param_type x, second_param_type y)
+         : first_type(x), second_(y) {}
+
+      compressed_pair_imp(first_param_type x)
+         : first_type(x) {}
+
+      compressed_pair_imp(second_param_type y)
+         : second_(y) {}
+
+      first_reference       first()       {return *this;}
+      first_const_reference first() const {return *this;}
+
+      second_reference       second()       {return second_;}
+      second_const_reference second() const {return second_;}
+
+      void swap(::boost::compressed_pair<T1,T2>& y)
+      {
+         // no need to swap empty base class:
+         cp_swap(second_, y.second());
+      }
+   private:
+      second_type second_;
+   };
+
+   // 2    derive from T2
+
+   template <class T1, class T2>
+   class compressed_pair_imp<T1, T2, 2>
+      : protected ::boost::remove_cv<T2>::type
+   {
+   public:
+      typedef T1                                                 first_type;
+      typedef T2                                                 second_type;
+      typedef typename call_traits<first_type>::param_type       first_param_type;
+      typedef typename call_traits<second_type>::param_type      second_param_type;
+      typedef typename call_traits<first_type>::reference        first_reference;
+      typedef typename call_traits<second_type>::reference       second_reference;
+      typedef typename call_traits<first_type>::const_reference  first_const_reference;
+      typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+      compressed_pair_imp() {}
+
+      compressed_pair_imp(first_param_type x, second_param_type y)
+         : second_type(y), first_(x) {}
+
+      compressed_pair_imp(first_param_type x)
+         : first_(x) {}
+
+      compressed_pair_imp(second_param_type y)
+         : second_type(y) {}
+
+      first_reference       first()       {return first_;}
+      first_const_reference first() const {return first_;}
+
+      second_reference       second()       {return *this;}
+      second_const_reference second() const {return *this;}
+
+      void swap(::boost::compressed_pair<T1,T2>& y)
+      {
+         // no need to swap empty base class:
+         cp_swap(first_, y.first());
+      }
+
+   private:
+      first_type first_;
+   };
+
+   // 3    derive from T1 and T2
+
+   template <class T1, class T2>
+   class compressed_pair_imp<T1, T2, 3>
+      : protected ::boost::remove_cv<T1>::type,
+        protected ::boost::remove_cv<T2>::type
+   {
+   public:
+      typedef T1                                                 first_type;
+      typedef T2                                                 second_type;
+      typedef typename call_traits<first_type>::param_type       first_param_type;
+      typedef typename call_traits<second_type>::param_type      second_param_type;
+      typedef typename call_traits<first_type>::reference        first_reference;
+      typedef typename call_traits<second_type>::reference       second_reference;
+      typedef typename call_traits<first_type>::const_reference  first_const_reference;
+      typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+      compressed_pair_imp() {}
+
+      compressed_pair_imp(first_param_type x, second_param_type y)
+         : first_type(x), second_type(y) {}
+
+      compressed_pair_imp(first_param_type x)
+         : first_type(x) {}
+
+      compressed_pair_imp(second_param_type y)
+         : second_type(y) {}
+
+      first_reference       first()       {return *this;}
+      first_const_reference first() const {return *this;}
+
+      second_reference       second()       {return *this;}
+      second_const_reference second() const {return *this;}
+      //
+      // no need to swap empty bases:
+      void swap(::boost::compressed_pair<T1,T2>&) {}
+   };
+
+   // JM
+   // 4    T1 == T2, T1 and T2 both empty
+   //      Originally this did not store an instance of T2 at all
+   //      but that led to problems beause it meant &x.first() == &x.second()
+   //      which is not true for any other kind of pair, so now we store an instance
+   //      of T2 just in case the user is relying on first() and second() returning
+   //      different objects (albeit both empty).
+   template <class T1, class T2>
+   class compressed_pair_imp<T1, T2, 4>
+      : protected ::boost::remove_cv<T1>::type
+   {
+   public:
+      typedef T1                                                 first_type;
+      typedef T2                                                 second_type;
+      typedef typename call_traits<first_type>::param_type       first_param_type;
+      typedef typename call_traits<second_type>::param_type      second_param_type;
+      typedef typename call_traits<first_type>::reference        first_reference;
+      typedef typename call_traits<second_type>::reference       second_reference;
+      typedef typename call_traits<first_type>::const_reference  first_const_reference;
+      typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+      compressed_pair_imp() {}
+
+      compressed_pair_imp(first_param_type x, second_param_type y)
+         : first_type(x), m_second(y) {}
+
+      compressed_pair_imp(first_param_type x)
+         : first_type(x), m_second(x) {}
+
+      first_reference       first()       {return *this;}
+      first_const_reference first() const {return *this;}
+
+      second_reference       second()       {return m_second;}
+      second_const_reference second() const {return m_second;}
+
+      void swap(::boost::compressed_pair<T1,T2>&) {}
+   private:
+      T2 m_second;
+   };
+
+   // 5    T1 == T2 and are not empty:   //JM
+
+   template <class T1, class T2>
+   class compressed_pair_imp<T1, T2, 5>
+   {
+   public:
+      typedef T1                                                 first_type;
+      typedef T2                                                 second_type;
+      typedef typename call_traits<first_type>::param_type       first_param_type;
+      typedef typename call_traits<second_type>::param_type      second_param_type;
+      typedef typename call_traits<first_type>::reference        first_reference;
+      typedef typename call_traits<second_type>::reference       second_reference;
+      typedef typename call_traits<first_type>::const_reference  first_const_reference;
+      typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+      compressed_pair_imp() {}
+
+      compressed_pair_imp(first_param_type x, second_param_type y)
+         : first_(x), second_(y) {}
+
+      compressed_pair_imp(first_param_type x)
+         : first_(x), second_(x) {}
+
+      first_reference       first()       {return first_;}
+      first_const_reference first() const {return first_;}
+
+      second_reference       second()       {return second_;}
+      second_const_reference second() const {return second_;}
+
+      void swap(::boost::compressed_pair<T1, T2>& y)
+      {
+         cp_swap(first_, y.first());
+         cp_swap(second_, y.second());
+      }
+   private:
+      first_type first_;
+      second_type second_;
+   };
+
+}  // details
+
+template <class T1, class T2>
+class compressed_pair
+   : private ::boost::details::compressed_pair_imp<T1, T2,
+             ::boost::details::compressed_pair_switch<
+                    T1,
+                    T2,
+                    ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
+                    ::boost::is_empty<T1>::value,
+                    ::boost::is_empty<T2>::value>::value>
+{
+private:
+   typedef details::compressed_pair_imp<T1, T2,
+             ::boost::details::compressed_pair_switch<
+                    T1,
+                    T2,
+                    ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
+                    ::boost::is_empty<T1>::value,
+                    ::boost::is_empty<T2>::value>::value> base;
+public:
+   typedef T1                                                 first_type;
+   typedef T2                                                 second_type;
+   typedef typename call_traits<first_type>::param_type       first_param_type;
+   typedef typename call_traits<second_type>::param_type      second_param_type;
+   typedef typename call_traits<first_type>::reference        first_reference;
+   typedef typename call_traits<second_type>::reference       second_reference;
+   typedef typename call_traits<first_type>::const_reference  first_const_reference;
+   typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+            compressed_pair() : base() {}
+            compressed_pair(first_param_type x, second_param_type y) : base(x, y) {}
+   explicit compressed_pair(first_param_type x) : base(x) {}
+   explicit compressed_pair(second_param_type y) : base(y) {}
+
+   first_reference       first()       {return base::first();}
+   first_const_reference first() const {return base::first();}
+
+   second_reference       second()       {return base::second();}
+   second_const_reference second() const {return base::second();}
+
+   void swap(compressed_pair& y) { base::swap(y); }
+};
+
+// JM
+// Partial specialisation for case where T1 == T2:
+//
+template <class T>
+class compressed_pair<T, T>
+   : private details::compressed_pair_imp<T, T,
+             ::boost::details::compressed_pair_switch<
+                    T,
+                    T,
+                    ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
+                    ::boost::is_empty<T>::value,
+                    ::boost::is_empty<T>::value>::value>
+{
+private:
+   typedef details::compressed_pair_imp<T, T,
+             ::boost::details::compressed_pair_switch<
+                    T,
+                    T,
+                    ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
+                    ::boost::is_empty<T>::value,
+                    ::boost::is_empty<T>::value>::value> base;
+public:
+   typedef T                                                  first_type;
+   typedef T                                                  second_type;
+   typedef typename call_traits<first_type>::param_type       first_param_type;
+   typedef typename call_traits<second_type>::param_type      second_param_type;
+   typedef typename call_traits<first_type>::reference        first_reference;
+   typedef typename call_traits<second_type>::reference       second_reference;
+   typedef typename call_traits<first_type>::const_reference  first_const_reference;
+   typedef typename call_traits<second_type>::const_reference second_const_reference;
+
+            compressed_pair() : base() {}
+            compressed_pair(first_param_type x, second_param_type y) : base(x, y) {}
+#if !(defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x530))
+   explicit
+#endif
+      compressed_pair(first_param_type x) : base(x) {}
+
+   first_reference       first()       {return base::first();}
+   first_const_reference first() const {return base::first();}
+
+   second_reference       second()       {return base::second();}
+   second_const_reference second() const {return base::second();}
+
+   void swap(::boost::compressed_pair<T,T>& y) { base::swap(y); }
+};
+
+template <class T1, class T2>
+inline
+void
+swap(compressed_pair<T1, T2>& x, compressed_pair<T1, T2>& y)
+{
+   x.swap(y);
+}
+
+} // boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif
+
+#endif // BOOST_DETAIL_COMPRESSED_PAIR_HPP
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/call_traits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/call_traits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/call_traits.hpp	(working copy)
@@ -0,0 +1,164 @@
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/utility for most recent version including documentation.
+
+// call_traits: defines typedefs for function usage
+// (see libs/utility/call_traits.htm)
+
+/* Release notes:
+   23rd July 2000:
+      Fixed array specialization. (JM)
+      Added Borland specific fixes for reference types
+      (issue raised by Steve Cleary).
+*/
+
+#ifndef BOOST_DETAIL_CALL_TRAITS_HPP
+#define BOOST_DETAIL_CALL_TRAITS_HPP
+
+#ifndef BOOST_CONFIG_HPP
+#include <boost/config.hpp>
+#endif
+#include <cstddef>
+
+#include <boost/type_traits/is_arithmetic.hpp>
+#include <boost/type_traits/is_pointer.hpp>
+#include <boost/detail/workaround.hpp>
+
+namespace boost{
+
+namespace detail{
+
+template <typename T, bool small_>
+struct ct_imp2
+{
+   typedef const T& param_type;
+};
+
+template <typename T>
+struct ct_imp2<T, true>
+{
+   typedef const T param_type;
+};
+
+template <typename T, bool isp, bool b1>
+struct ct_imp
+{
+   typedef const T& param_type;
+};
+
+template <typename T, bool isp>
+struct ct_imp<T, isp, true>
+{
+   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
+};
+
+template <typename T, bool b1>
+struct ct_imp<T, true, b1>
+{
+   typedef const T param_type;
+};
+
+}
+
+template <typename T>
+struct call_traits
+{
+public:
+   typedef T value_type;
+   typedef T& reference;
+   typedef const T& const_reference;
+   //
+   // C++ Builder workaround: we should be able to define a compile time
+   // constant and pass that as a single template parameter to ct_imp<T,bool>,
+   // however compiler bugs prevent this - instead pass three bool's to
+   // ct_imp<T,bool,bool,bool> and add an extra partial specialisation
+   // of ct_imp to handle the logic. (JM)
+   typedef typename boost::detail::ct_imp<
+      T,
+      ::boost::is_pointer<T>::value,
+      ::boost::is_arithmetic<T>::value
+   >::param_type param_type;
+};
+
+template <typename T>
+struct call_traits<T&>
+{
+   typedef T& value_type;
+   typedef T& reference;
+   typedef const T& const_reference;
+   typedef T& param_type;  // hh removed const
+};
+
+#if BOOST_WORKAROUND( __BORLANDC__,  < 0x5A0 )
+// these are illegal specialisations; cv-qualifies applied to
+// references have no effect according to [8.3.2p1],
+// C++ Builder requires them though as it treats cv-qualified
+// references as distinct types...
+template <typename T>
+struct call_traits<T&const>
+{
+   typedef T& value_type;
+   typedef T& reference;
+   typedef const T& const_reference;
+   typedef T& param_type;  // hh removed const
+};
+template <typename T>
+struct call_traits<T&volatile>
+{
+   typedef T& value_type;
+   typedef T& reference;
+   typedef const T& const_reference;
+   typedef T& param_type;  // hh removed const
+};
+template <typename T>
+struct call_traits<T&const volatile>
+{
+   typedef T& value_type;
+   typedef T& reference;
+   typedef const T& const_reference;
+   typedef T& param_type;  // hh removed const
+};
+
+template <typename T>
+struct call_traits< T * >
+{
+   typedef T * value_type;
+   typedef T * & reference;
+   typedef T * const & const_reference;
+   typedef T * const param_type;  // hh removed const
+};
+#endif
+#if !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+template <typename T, std::size_t N>
+struct call_traits<T [N]>
+{
+private:
+   typedef T array_type[N];
+public:
+   // degrades array to pointer:
+   typedef const T* value_type;
+   typedef array_type& reference;
+   typedef const array_type& const_reference;
+   typedef const T* const param_type;
+};
+
+template <typename T, std::size_t N>
+struct call_traits<const T [N]>
+{
+private:
+   typedef const T array_type[N];
+public:
+   // degrades array to pointer:
+   typedef const T* value_type;
+   typedef array_type& reference;
+   typedef const array_type& const_reference;
+   typedef const T* const param_type;
+};
+#endif
+
+}
+
+#endif // BOOST_DETAIL_CALL_TRAITS_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/indirect_traits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/indirect_traits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/indirect_traits.hpp	(working copy)
@@ -0,0 +1,487 @@
+// Copyright David Abrahams 2002.
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+#ifndef INDIRECT_TRAITS_DWA2002131_HPP
+# define INDIRECT_TRAITS_DWA2002131_HPP
+# include <boost/type_traits/is_function.hpp>
+# include <boost/type_traits/is_reference.hpp>
+# include <boost/type_traits/is_pointer.hpp>
+# include <boost/type_traits/is_class.hpp>
+# include <boost/type_traits/is_const.hpp>
+# include <boost/type_traits/is_volatile.hpp>
+# include <boost/type_traits/is_member_function_pointer.hpp>
+# include <boost/type_traits/is_member_pointer.hpp>
+# include <boost/type_traits/remove_cv.hpp>
+# include <boost/type_traits/remove_reference.hpp>
+# include <boost/type_traits/remove_pointer.hpp>
+
+# include <boost/type_traits/detail/ice_and.hpp>
+# include <boost/detail/workaround.hpp>
+
+# include <boost/mpl/eval_if.hpp>
+# include <boost/mpl/if.hpp>
+# include <boost/mpl/bool.hpp>
+# include <boost/mpl/and.hpp>
+# include <boost/mpl/not.hpp>
+# include <boost/mpl/aux_/lambda_support.hpp>
+
+#  ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#   include <boost/detail/is_function_ref_tester.hpp>
+#  endif
+
+namespace boost { namespace detail {
+
+namespace indirect_traits {
+
+#  ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+template <class T>
+struct is_reference_to_const : mpl::false_
+{
+};
+
+template <class T>
+struct is_reference_to_const<T const&> : mpl::true_
+{
+};
+
+#   if defined(BOOST_MSVC) && _MSC_FULL_VER <= 13102140 // vc7.01 alpha workaround
+template<class T>
+struct is_reference_to_const<T const volatile&> : mpl::true_
+{
+};
+#   endif
+
+template <class T>
+struct is_reference_to_function : mpl::false_
+{
+};
+
+template <class T>
+struct is_reference_to_function<T&> : is_function<T>
+{
+};
+
+template <class T>
+struct is_pointer_to_function : mpl::false_
+{
+};
+
+// There's no such thing as a pointer-to-cv-function, so we don't need
+// specializations for those
+template <class T>
+struct is_pointer_to_function<T*> : is_function<T>
+{
+};
+
+template <class T>
+struct is_reference_to_member_function_pointer_impl : mpl::false_
+{
+};
+
+template <class T>
+struct is_reference_to_member_function_pointer_impl<T&>
+    : is_member_function_pointer<typename remove_cv<T>::type>
+{
+};
+
+
+template <class T>
+struct is_reference_to_member_function_pointer
+    : is_reference_to_member_function_pointer_impl<T>
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_member_function_pointer,(T))
+};
+
+template <class T>
+struct is_reference_to_function_pointer_aux
+    : mpl::and_<
+          is_reference<T>
+        , is_pointer_to_function<
+              typename remove_cv<
+                  typename remove_reference<T>::type
+              >::type
+          >
+      >
+{
+    // There's no such thing as a pointer-to-cv-function, so we don't need specializations for those
+};
+
+template <class T>
+struct is_reference_to_function_pointer
+    : mpl::if_<
+          is_reference_to_function<T>
+        , mpl::false_
+        , is_reference_to_function_pointer_aux<T>
+     >::type
+{
+};
+
+template <class T>
+struct is_reference_to_non_const
+    : mpl::and_<
+          is_reference<T>
+        , mpl::not_<
+             is_reference_to_const<T>
+          >
+      >
+{
+};
+
+template <class T>
+struct is_reference_to_volatile : mpl::false_
+{
+};
+
+template <class T>
+struct is_reference_to_volatile<T volatile&> : mpl::true_
+{
+};
+
+#   if defined(BOOST_MSVC) && _MSC_FULL_VER <= 13102140 // vc7.01 alpha workaround
+template <class T>
+struct is_reference_to_volatile<T const volatile&> : mpl::true_
+{
+};
+#   endif
+
+
+template <class T>
+struct is_reference_to_pointer : mpl::false_
+{
+};
+
+template <class T>
+struct is_reference_to_pointer<T*&> : mpl::true_
+{
+};
+
+template <class T>
+struct is_reference_to_pointer<T* const&> : mpl::true_
+{
+};
+
+template <class T>
+struct is_reference_to_pointer<T* volatile&> : mpl::true_
+{
+};
+
+template <class T>
+struct is_reference_to_pointer<T* const volatile&> : mpl::true_
+{
+};
+
+template <class T>
+struct is_reference_to_class
+    : mpl::and_<
+          is_reference<T>
+        , is_class<
+              typename remove_cv<
+                  typename remove_reference<T>::type
+              >::type
+          >
+      >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_class,(T))
+};
+
+template <class T>
+struct is_pointer_to_class
+    : mpl::and_<
+          is_pointer<T>
+        , is_class<
+              typename remove_cv<
+                  typename remove_pointer<T>::type
+              >::type
+          >
+      >
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_pointer_to_class,(T))
+};
+
+#  else
+
+using namespace boost::detail::is_function_ref_tester_;
+
+typedef char (&inner_yes_type)[3];
+typedef char (&inner_no_type)[2];
+typedef char (&outer_no_type)[1];
+
+template <typename V>
+struct is_const_help
+{
+    typedef typename mpl::if_<
+          is_const<V>
+        , inner_yes_type
+        , inner_no_type
+        >::type type;
+};
+
+template <typename V>
+struct is_volatile_help
+{
+    typedef typename mpl::if_<
+          is_volatile<V>
+        , inner_yes_type
+        , inner_no_type
+        >::type type;
+};
+
+template <typename V>
+struct is_pointer_help
+{
+    typedef typename mpl::if_<
+          is_pointer<V>
+        , inner_yes_type
+        , inner_no_type
+        >::type type;
+};
+
+template <typename V>
+struct is_class_help
+{
+    typedef typename mpl::if_<
+          is_class<V>
+        , inner_yes_type
+        , inner_no_type
+        >::type type;
+};
+
+template <class T>
+struct is_reference_to_function_aux
+{
+    static T t;
+    BOOST_STATIC_CONSTANT(
+        bool, value = sizeof(detail::is_function_ref_tester(t,0)) == sizeof(::boost::type_traits::yes_type));
+    typedef mpl::bool_<value> type;
+ };
+
+template <class T>
+struct is_reference_to_function
+    : mpl::if_<is_reference<T>, is_reference_to_function_aux<T>, mpl::bool_<false> >::type
+{
+};
+
+template <class T>
+struct is_pointer_to_function_aux
+{
+    static T t;
+    BOOST_STATIC_CONSTANT(
+        bool, value
+        = sizeof(::boost::type_traits::is_function_ptr_tester(t)) == sizeof(::boost::type_traits::yes_type));
+    typedef mpl::bool_<value> type;
+};
+
+template <class T>
+struct is_pointer_to_function
+    : mpl::if_<is_pointer<T>, is_pointer_to_function_aux<T>, mpl::bool_<false> >::type
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_pointer_to_function,(T))
+};
+
+struct false_helper1
+{
+    template <class T>
+    struct apply : mpl::false_
+    {
+    };
+};
+
+template <typename V>
+typename is_const_help<V>::type reference_to_const_helper(V&);
+outer_no_type
+reference_to_const_helper(...);
+
+struct true_helper1
+{
+    template <class T>
+    struct apply
+    {
+        static T t;
+        BOOST_STATIC_CONSTANT(
+            bool, value
+            = sizeof(reference_to_const_helper(t)) == sizeof(inner_yes_type));
+        typedef mpl::bool_<value> type;
+    };
+};
+
+template <bool ref = true>
+struct is_reference_to_const_helper1 : true_helper1
+{
+};
+
+template <>
+struct is_reference_to_const_helper1<false> : false_helper1
+{
+};
+
+
+template <class T>
+struct is_reference_to_const
+    : is_reference_to_const_helper1<is_reference<T>::value>::template apply<T>
+{
+};
+
+
+template <bool ref = true>
+struct is_reference_to_non_const_helper1
+{
+    template <class T>
+    struct apply
+    {
+        static T t;
+        BOOST_STATIC_CONSTANT(
+            bool, value
+            = sizeof(reference_to_const_helper(t)) == sizeof(inner_no_type));
+
+        typedef mpl::bool_<value> type;
+    };
+};
+
+template <>
+struct is_reference_to_non_const_helper1<false> : false_helper1
+{
+};
+
+
+template <class T>
+struct is_reference_to_non_const
+    : is_reference_to_non_const_helper1<is_reference<T>::value>::template apply<T>
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_non_const,(T))
+};
+
+
+template <typename V>
+typename is_volatile_help<V>::type reference_to_volatile_helper(V&);
+outer_no_type
+reference_to_volatile_helper(...);
+
+template <bool ref = true>
+struct is_reference_to_volatile_helper1
+{
+    template <class T>
+    struct apply
+    {
+        static T t;
+        BOOST_STATIC_CONSTANT(
+            bool, value
+            = sizeof(reference_to_volatile_helper(t)) == sizeof(inner_yes_type));
+        typedef mpl::bool_<value> type;
+    };
+};
+
+template <>
+struct is_reference_to_volatile_helper1<false> : false_helper1
+{
+};
+
+
+template <class T>
+struct is_reference_to_volatile
+    : is_reference_to_volatile_helper1<is_reference<T>::value>::template apply<T>
+{
+};
+
+template <typename V>
+typename is_pointer_help<V>::type reference_to_pointer_helper(V&);
+outer_no_type reference_to_pointer_helper(...);
+
+template <class T>
+struct reference_to_pointer_impl
+{
+    static T t;
+    BOOST_STATIC_CONSTANT(
+        bool, value
+        = (sizeof((reference_to_pointer_helper)(t)) == sizeof(inner_yes_type))
+        );
+
+    typedef mpl::bool_<value> type;
+};
+
+template <class T>
+struct is_reference_to_pointer
+  : mpl::eval_if<is_reference<T>, reference_to_pointer_impl<T>, mpl::false_>::type
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_pointer,(T))
+};
+
+template <class T>
+struct is_reference_to_function_pointer
+  : mpl::eval_if<is_reference<T>, is_pointer_to_function_aux<T>, mpl::false_>::type
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_function_pointer,(T))
+};
+
+
+template <class T>
+struct is_member_function_pointer_help
+    : mpl::if_<is_member_function_pointer<T>, inner_yes_type, inner_no_type>
+{};
+
+template <typename V>
+typename is_member_function_pointer_help<V>::type member_function_pointer_helper(V&);
+outer_no_type member_function_pointer_helper(...);
+
+template <class T>
+struct is_pointer_to_member_function_aux
+{
+    static T t;
+    BOOST_STATIC_CONSTANT(
+        bool, value
+        = sizeof((member_function_pointer_helper)(t)) == sizeof(inner_yes_type));
+    typedef mpl::bool_<value> type;
+};
+
+template <class T>
+struct is_reference_to_member_function_pointer
+    : mpl::if_<
+        is_reference<T>
+        , is_pointer_to_member_function_aux<T>
+        , mpl::bool_<false>
+     >::type
+{
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_member_function_pointer,(T))
+};
+
+template <typename V>
+typename is_class_help<V>::type reference_to_class_helper(V const volatile&);
+outer_no_type reference_to_class_helper(...);
+
+template <class T>
+struct is_reference_to_class
+{
+    static T t;
+    BOOST_STATIC_CONSTANT(
+        bool, value
+        = (is_reference<T>::value
+           & (sizeof(reference_to_class_helper(t)) == sizeof(inner_yes_type)))
+        );
+    typedef mpl::bool_<value> type;
+    BOOST_MPL_AUX_LAMBDA_SUPPORT(1,is_reference_to_class,(T))
+};
+
+template <typename V>
+typename is_class_help<V>::type pointer_to_class_helper(V const volatile*);
+outer_no_type pointer_to_class_helper(...);
+
+template <class T>
+struct is_pointer_to_class
+{
+    static T t;
+    BOOST_STATIC_CONSTANT(
+        bool, value
+        = (is_pointer<T>::value
+           && sizeof(pointer_to_class_helper(t)) == sizeof(inner_yes_type))
+        );
+    typedef mpl::bool_<value> type;
+};
+#  endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+}
+
+using namespace indirect_traits;
+
+}} // namespace boost::python::detail
+
+#endif // INDIRECT_TRAITS_DWA2002131_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/reference_content.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/reference_content.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/detail/reference_content.hpp	(working copy)
@@ -0,0 +1,141 @@
+//-----------------------------------------------------------------------------
+// boost detail/reference_content.hpp header file
+// See http://www.boost.org for updates, documentation, and revision history.
+//-----------------------------------------------------------------------------
+//
+// Copyright (c) 2003
+// Eric Friedman
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+
+#ifndef BOOST_DETAIL_REFERENCE_CONTENT_HPP
+#define BOOST_DETAIL_REFERENCE_CONTENT_HPP
+
+#include "boost/config.hpp"
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+#   include "boost/mpl/bool.hpp"
+#   include "boost/type_traits/has_nothrow_copy.hpp"
+#else
+#   include "boost/mpl/if.hpp"
+#   include "boost/type_traits/is_reference.hpp"
+#endif
+
+#include "boost/mpl/void.hpp"
+
+namespace boost {
+
+namespace detail {
+
+///////////////////////////////////////////////////////////////////////////////
+// (detail) class template reference_content
+//
+// Non-Assignable wrapper for references.
+//
+template <typename RefT>
+class reference_content
+{
+private: // representation
+
+    RefT content_;
+
+public: // structors
+
+    ~reference_content()
+    {
+    }
+
+    reference_content(RefT r)
+        : content_( r )
+    {
+    }
+
+    reference_content(const reference_content& operand)
+        : content_( operand.content_ )
+    {
+    }
+
+private: // non-Assignable
+
+    reference_content& operator=(const reference_content&);
+
+public: // queries
+
+    RefT get() const
+    {
+        return content_;
+    }
+
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// (detail) metafunction make_reference_content
+//
+// Wraps with reference_content if specified type is reference.
+//
+
+template <typename T = mpl::void_> struct make_reference_content;
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template <typename T>
+struct make_reference_content
+{
+    typedef T type;
+};
+
+template <typename T>
+struct make_reference_content< T& >
+{
+    typedef reference_content<T&> type;
+};
+
+#else // defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template <typename T>
+struct make_reference_content
+    : mpl::if_<
+          is_reference<T>
+        , reference_content<T>
+        , T
+        >
+{
+};
+
+#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION workaround
+
+template <>
+struct make_reference_content< mpl::void_ >
+{
+    template <typename T>
+    struct apply
+        : make_reference_content<T>
+    {
+    };
+
+    typedef mpl::void_ type;
+};
+
+} // namespace detail
+
+///////////////////////////////////////////////////////////////////////////////
+// reference_content<T&> type traits specializations
+//
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+template <typename T>
+struct has_nothrow_copy<
+      ::boost::detail::reference_content< T& >
+    >
+    : mpl::true_
+{
+};
+
+#endif // !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+} // namespace boost
+
+#endif // BOOST_DETAIL_REFERENCE_CONTENT_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/throw_exception.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/throw_exception.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/throw_exception.hpp	(working copy)
@@ -0,0 +1,91 @@
+#ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED
+#define BOOST_THROW_EXCEPTION_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/throw_exception.hpp
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//  Copyright (c) 2008-2009 Emil Dotchevski and Reverge Studios, Inc.
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  http://www.boost.org/libs/utility/throw_exception.html
+//
+
+#include <boost/exception/detail/attribute_noreturn.hpp>
+#include <boost/detail/workaround.hpp>
+#include <boost/config.hpp>
+#include <exception>
+
+#if !defined( BOOST_EXCEPTION_DISABLE ) && defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x593) )
+# define BOOST_EXCEPTION_DISABLE
+#endif
+
+#if !defined( BOOST_EXCEPTION_DISABLE ) && defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, < 1310 )
+# define BOOST_EXCEPTION_DISABLE
+#endif
+
+#if !defined( BOOST_EXCEPTION_DISABLE )
+# include <boost/exception/exception.hpp>
+# include <boost/current_function.hpp>
+# define BOOST_THROW_EXCEPTION(x) ::boost::exception_detail::throw_exception_(x,BOOST_CURRENT_FUNCTION,__FILE__,__LINE__)
+#else
+# define BOOST_THROW_EXCEPTION(x) ::boost::throw_exception(x)
+#endif
+
+namespace boost
+{
+#ifdef BOOST_NO_EXCEPTIONS
+
+void throw_exception( std::exception const & e ); // user defined
+
+#else
+
+inline void throw_exception_assert_compatibility( std::exception const & ) { }
+
+template<class E> BOOST_ATTRIBUTE_NORETURN inline void throw_exception( E const & e )
+{
+    //All boost exceptions are required to derive from std::exception,
+    //to ensure compatibility with BOOST_NO_EXCEPTIONS.
+    throw_exception_assert_compatibility(e);
+
+#ifndef BOOST_EXCEPTION_DISABLE
+    throw enable_current_exception(enable_error_info(e));
+#else
+    throw e;
+#endif
+}
+
+#endif
+
+#if !defined( BOOST_EXCEPTION_DISABLE )
+    namespace
+    exception_detail
+    {
+        template <class E>
+        BOOST_ATTRIBUTE_NORETURN
+        void
+        throw_exception_( E const & x, char const * current_function, char const * file, int line )
+        {
+            boost::throw_exception(
+                set_info(
+                    set_info(
+                        set_info(
+                            boost::enable_error_info(x),
+                            throw_function(current_function)),
+                        throw_file(file)),
+                    throw_line(line)));
+        }
+    }
+#endif
+} // namespace boost
+
+#endif // #ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/none_t.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/none_t.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/none_t.hpp	(working copy)
@@ -0,0 +1,24 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_NONE_T_17SEP2003_HPP
+#define BOOST_NONE_T_17SEP2003_HPP
+
+namespace boost {
+
+namespace detail { struct none_helper{}; }
+
+typedef int detail::none_helper::*none_t ;
+
+} // namespace boost
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/shared_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/shared_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/shared_ptr.hpp	(working copy)
@@ -0,0 +1,712 @@
+#ifndef BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED
+#define BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED
+
+//
+//  shared_ptr.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001-2008 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  See http://www.boost.org/libs/smart_ptr/shared_ptr.htm for documentation.
+//
+
+#include <boost/config.hpp>   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include <boost/smart_ptr/detail/shared_ptr_nmt.hpp>
+#else
+
+// In order to avoid circular dependencies with Boost.TR1
+// we make sure that our include of <memory> doesn't try to
+// pull in the TR1 headers: that's why we use this header
+// rather than including <memory> directly:
+#include <boost/config/no_tr1/memory.hpp>  // std::auto_ptr
+
+#include <boost/assert.hpp>
+#include <boost/checked_delete.hpp>
+#include <boost/throw_exception.hpp>
+#include <boost/smart_ptr/detail/shared_count.hpp>
+#include <boost/detail/workaround.hpp>
+#include <boost/smart_ptr/detail/sp_convertible.hpp>
+
+#if !defined(BOOST_SP_NO_ATOMIC_ACCESS)
+#include <boost/smart_ptr/detail/spinlock_pool.hpp>
+#include <boost/memory_order.hpp>
+#endif
+
+#include <algorithm>            // for std::swap
+#include <functional>           // for std::less
+#include <typeinfo>             // for std::bad_cast
+#include <cstddef>              // for std::size_t
+
+#if !defined(BOOST_NO_IOSTREAM)
+#if !defined(BOOST_NO_IOSFWD)
+#include <iosfwd>               // for std::basic_ostream
+#else
+#include <ostream>
+#endif
+#endif
+
+namespace boost
+{
+
+template<class T> class shared_ptr;
+template<class T> class weak_ptr;
+template<class T> class enable_shared_from_this;
+template<class T> class enable_shared_from_this2;
+
+namespace detail
+{
+
+struct static_cast_tag {};
+struct const_cast_tag {};
+struct dynamic_cast_tag {};
+struct polymorphic_cast_tag {};
+
+template<class T> struct shared_ptr_traits
+{
+    typedef T & reference;
+};
+
+template<> struct shared_ptr_traits<void>
+{
+    typedef void reference;
+};
+
+#if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+
+template<> struct shared_ptr_traits<void const>
+{
+    typedef void reference;
+};
+
+template<> struct shared_ptr_traits<void volatile>
+{
+    typedef void reference;
+};
+
+template<> struct shared_ptr_traits<void const volatile>
+{
+    typedef void reference;
+};
+
+#endif
+
+// enable_shared_from_this support
+
+template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
+{
+    if( pe != 0 )
+    {
+        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
+    }
+}
+
+template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_this2< T > const * pe )
+{
+    if( pe != 0 )
+    {
+        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
+    }
+}
+
+#ifdef _MANAGED
+
+// Avoid C4793, ... causes native code generation
+
+struct sp_any_pointer
+{
+    template<class T> sp_any_pointer( T* ) {}
+};
+
+inline void sp_enable_shared_from_this( sp_any_pointer, sp_any_pointer, sp_any_pointer )
+{
+}
+
+#else // _MANAGED
+
+inline void sp_enable_shared_from_this( ... )
+{
+}
+
+#endif // _MANAGED
+
+#if !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION ) && !defined( BOOST_NO_AUTO_PTR )
+
+// rvalue auto_ptr support based on a technique by Dave Abrahams
+
+template< class T, class R > struct sp_enable_if_auto_ptr
+{
+};
+
+template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
+{
+    typedef R type;
+};
+
+#endif
+
+} // namespace detail
+
+
+//
+//  shared_ptr
+//
+//  An enhanced relative of scoped_ptr with reference counted copy semantics.
+//  The object pointed to is deleted when the last shared_ptr pointing to it
+//  is destroyed or reset.
+//
+
+template<class T> class shared_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workaround
+    typedef shared_ptr<T> this_type;
+
+public:
+
+    typedef T element_type;
+    typedef T value_type;
+    typedef T * pointer;
+    typedef typename boost::detail::shared_ptr_traits<T>::reference reference;
+
+    shared_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+    template<class Y>
+    explicit shared_ptr( Y * p ): px( p ), pn( p ) // Y must be complete
+    {
+        boost::detail::sp_enable_shared_from_this( this, p, p );
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_ptr will release p by calling d(p)
+    //
+
+    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
+    {
+        boost::detail::sp_enable_shared_from_this( this, p, p );
+    }
+
+    // As above, but with allocator. A's copy constructor shall not throw.
+
+    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
+    {
+        boost::detail::sp_enable_shared_from_this( this, p, p );
+    }
+
+//  generated copy constructor, destructor are fine...
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+// ... except in C++0x, move disables the implicit copy
+
+    shared_ptr( shared_ptr const & r ): px( r.px ), pn( r.pn ) // never throws
+    {
+    }
+
+#endif
+
+    template<class Y>
+    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn) // may throw
+    {
+        // it is now safe to copy r.px, as pn(r.pn) did not throw
+        px = r.px;
+    }
+
+    template<class Y>
+    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() ) // never throws
+    {
+        if( !pn.empty() )
+        {
+            px = r.px;
+        }
+    }
+
+    template<class Y>
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+
+#else
+
+    shared_ptr( shared_ptr<Y> const & r )
+
+#endif
+    : px( r.px ), pn( r.pn ) // never throws
+    {
+    }
+
+    // aliasing
+    template< class Y >
+    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn ) // never throws
+    {
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
+    {
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
+    {
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    {
+        if(px == 0) // need to allocate new counter -- the cast failed
+        {
+            pn = boost::detail::shared_count();
+        }
+    }
+
+    template<class Y>
+    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
+    {
+        if(px == 0)
+        {
+            boost::throw_exception(std::bad_cast());
+        }
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template<class Y>
+    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
+    {
+        Y * tmp = r.get();
+        pn = boost::detail::shared_count(r);
+        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
+    }
+
+#if !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )
+
+    template<class Ap>
+    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
+    {
+        typename Ap::element_type * tmp = r.get();
+        pn = boost::detail::shared_count( r );
+        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
+    }
+
+
+#endif // BOOST_NO_SFINAE, BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#endif // BOOST_NO_AUTO_PTR
+
+    // assignment
+
+    shared_ptr & operator=( shared_ptr const & r ) // never throws
+    {
+        this_type(r).swap(*this);
+        return *this;
+    }
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC >= 1400)
+
+    template<class Y>
+    shared_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    {
+        this_type(r).swap(*this);
+        return *this;
+    }
+
+#endif
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template<class Y>
+    shared_ptr & operator=( std::auto_ptr<Y> & r )
+    {
+        this_type(r).swap(*this);
+        return *this;
+    }
+
+#if !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )
+
+    template<class Ap>
+    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
+    {
+        this_type( r ).swap( *this );
+        return *this;
+    }
+
+
+#endif // BOOST_NO_SFINAE, BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+#endif // BOOST_NO_AUTO_PTR
+
+// Move support
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+    shared_ptr( shared_ptr && r ): px( r.px ), pn() // never throws
+    {
+        pn.swap( r.pn );
+        r.px = 0;
+    }
+
+    template<class Y>
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+    shared_ptr( shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+
+#else
+
+    shared_ptr( shared_ptr<Y> && r )
+
+#endif
+    : px( r.px ), pn() // never throws
+    {
+        pn.swap( r.pn );
+        r.px = 0;
+    }
+
+    shared_ptr & operator=( shared_ptr && r ) // never throws
+    {
+        this_type( static_cast< shared_ptr && >( r ) ).swap( *this );
+        return *this;
+    }
+
+    template<class Y>
+    shared_ptr & operator=( shared_ptr<Y> && r ) // never throws
+    {
+        this_type( static_cast< shared_ptr<Y> && >( r ) ).swap( *this );
+        return *this;
+    }
+
+#endif
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    template<class Y> void reset(Y * p) // Y must be complete
+    {
+        BOOST_ASSERT(p == 0 || p != px); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    template<class Y, class D> void reset( Y * p, D d )
+    {
+        this_type( p, d ).swap( *this );
+    }
+
+    template<class Y, class D, class A> void reset( Y * p, D d, A a )
+    {
+        this_type( p, d, a ).swap( *this );
+    }
+
+    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
+    {
+        this_type( r, p ).swap( *this );
+    }
+
+    reference operator* () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return *px;
+    }
+
+    T * operator-> () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return px;
+    }
+
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+// implicit conversion to "bool"
+#include <boost/smart_ptr/detail/operator_bool.hpp>
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_ptr<T> & other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
+    {
+        return pn < rhs.pn;
+    }
+
+    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const
+    {
+        return pn.get_deleter( ti );
+    }
+
+    bool _internal_equiv( shared_ptr const & r ) const
+    {
+        return px == r.px && pn == r.pn;
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template<class Y> friend class shared_ptr;
+    template<class Y> friend class weak_ptr;
+
+
+#endif
+
+    T * px;                     // contained pointer
+    boost::detail::shared_count pn;    // reference counter
+
+};  // shared_ptr
+
+template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
+{
+    return a.get() == b.get();
+}
+
+template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
+{
+    return a.get() != b.get();
+}
+
+#if __GNUC__ == 2 && __GNUC_MINOR__ <= 96
+
+// Resolve the ambiguity between our op!= and the one in rel_ops
+
+template<class T> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<T> const & b)
+{
+    return a.get() != b.get();
+}
+
+#endif
+
+template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
+{
+    return a._internal_less(b);
+}
+
+template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
+{
+    a.swap(b);
+}
+
+template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, boost::detail::static_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, boost::detail::const_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
+}
+
+// shared_*_cast names are deprecated. Use *_pointer_cast instead.
+
+template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, boost::detail::static_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
+{
+    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
+}
+
+template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
+{
+    BOOST_ASSERT(dynamic_cast<T *>(r.get()) == r.get());
+    return shared_static_cast<T>(r);
+}
+
+// get_pointer() enables boost::mem_fn to recognize shared_ptr
+
+template<class T> inline T * get_pointer(shared_ptr<T> const & p)
+{
+    return p.get();
+}
+
+// operator<<
+
+#if !defined(BOOST_NO_IOSTREAM)
+
+#if defined(BOOST_NO_TEMPLATED_IOSTREAMS) || ( defined(__GNUC__) &&  (__GNUC__ < 3) )
+
+template<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> const & p)
+{
+    os << p.get();
+    return os;
+}
+
+#else
+
+// in STLport's no-iostreams mode no iostream symbols can be used
+#ifndef _STLP_NO_IOSTREAMS
+
+# if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, < 1300 && __SGI_STL_PORT)
+// MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
+using std::basic_ostream;
+template<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+# else
+template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)
+# endif
+{
+    os << p.get();
+    return os;
+}
+
+#endif // _STLP_NO_IOSTREAMS
+
+#endif // __GNUC__ < 3
+
+#endif // !defined(BOOST_NO_IOSTREAM)
+
+// get_deleter
+
+#if ( defined(__GNUC__) && BOOST_WORKAROUND(__GNUC__, < 3) ) || \
+    ( defined(__EDG_VERSION__) && BOOST_WORKAROUND(__EDG_VERSION__, <= 238) ) || \
+    ( defined(__HP_aCC) && BOOST_WORKAROUND(__HP_aCC, <= 33500) )
+
+// g++ 2.9x doesn't allow static_cast<X const *>(void *)
+// apparently EDG 2.38 and HP aCC A.03.35 also don't accept it
+
+template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
+{
+    void const * q = p._internal_get_deleter(BOOST_SP_TYPEID(D));
+    return const_cast<D *>(static_cast<D const *>(q));
+}
+
+#else
+
+template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
+{
+    return static_cast<D *>(p._internal_get_deleter(BOOST_SP_TYPEID(D)));
+}
+
+#endif
+
+// atomic access
+
+#if !defined(BOOST_SP_NO_ATOMIC_ACCESS)
+
+template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * /*p*/ )
+{
+    return false;
+}
+
+template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
+{
+    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
+    return *p;
+}
+
+template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order /*mo*/ )
+{
+    return atomic_load( p );
+}
+
+template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
+{
+    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
+    p->swap( r );
+}
+
+template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order /*mo*/ )
+{
+    atomic_store( p, r ); // std::move( r )
+}
+
+template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
+{
+    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );
+
+    sp.lock();
+    p->swap( r );
+    sp.unlock();
+
+    return r; // return std::move( r )
+}
+
+template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order /*mo*/ )
+{
+    return atomic_exchange( p, r ); // std::move( r )
+}
+
+template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
+{
+    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );
+
+    sp.lock();
+
+    if( p->_internal_equiv( *v ) )
+    {
+        p->swap( w );
+
+        sp.unlock();
+
+        return true;
+    }
+    else
+    {
+        shared_ptr<T> tmp( *p );
+
+        sp.unlock();
+
+        tmp.swap( *v );
+        return false;
+    }
+}
+
+template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order /*success*/, memory_order /*failure*/ )
+{
+    return atomic_compare_exchange( p, v, w ); // std::move( w )
+}
+
+#endif // !defined(BOOST_SP_NO_ATOMIC_ACCESS)
+
+// hash_value
+
+template< class T > struct hash;
+
+template< class T > std::size_t hash_value( boost::shared_ptr<T> const & p )
+{
+    return boost::hash< T* >()( p.get() );
+}
+
+} // namespace boost
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/weak_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/weak_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/weak_ptr.hpp	(working copy)
@@ -0,0 +1,246 @@
+#ifndef BOOST_SMART_PTR_WEAK_PTR_HPP_INCLUDED
+#define BOOST_SMART_PTR_WEAK_PTR_HPP_INCLUDED
+
+//
+//  weak_ptr.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+//  See http://www.boost.org/libs/smart_ptr/weak_ptr.htm for documentation.
+//
+
+#include <memory> // boost.TR1 include order fix
+#include <boost/smart_ptr/detail/shared_count.hpp>
+#include <boost/smart_ptr/shared_ptr.hpp>
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator->
+#endif
+
+namespace boost
+{
+
+template<class T> class weak_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef weak_ptr<T> this_type;
+
+public:
+
+    typedef T element_type;
+
+    weak_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine...
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+// ... except in C++0x, move disables the implicit copy
+
+    weak_ptr( weak_ptr const & r ): px( r.px ), pn( r.pn ) // never throws
+    {
+    }
+
+    weak_ptr & operator=( weak_ptr const & r ) // never throws
+    {
+        px = r.px;
+        pn = r.pn;
+        return *this;
+    }
+
+#endif
+
+//
+//  The "obvious" converting constructor implementation:
+//
+//  template<class Y>
+//  weak_ptr(weak_ptr<Y> const & r): px(r.px), pn(r.pn) // never throws
+//  {
+//  }
+//
+//  has a serious problem.
+//
+//  r.px may already have been invalidated. The px(r.px)
+//  conversion may require access to *r.px (virtual inheritance).
+//
+//  It is not possible to avoid spurious access violations since
+//  in multithreaded programs r.px may be invalidated at any point.
+//
+
+    template<class Y>
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+    weak_ptr( weak_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+
+#else
+
+    weak_ptr( weak_ptr<Y> const & r )
+
+#endif
+    : px(r.lock().get()), pn(r.pn) // never throws
+    {
+    }
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+    template<class Y>
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+    weak_ptr( weak_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+
+#else
+
+    weak_ptr( weak_ptr<Y> && r )
+
+#endif
+    : px( r.lock().get() ), pn( static_cast< boost::detail::weak_count && >( r.pn ) ) // never throws
+    {
+        r.px = 0;
+    }
+
+    // for better efficiency in the T == Y case
+    weak_ptr( weak_ptr && r ): px( r.px ), pn( static_cast< boost::detail::weak_count && >( r.pn ) ) // never throws
+    {
+        r.px = 0;
+    }
+
+    // for better efficiency in the T == Y case
+    weak_ptr & operator=( weak_ptr && r ) // never throws
+    {
+        this_type( static_cast< weak_ptr && >( r ) ).swap( *this );
+        return *this;
+    }
+
+
+#endif
+
+    template<class Y>
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+    weak_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
+
+#else
+
+    weak_ptr( shared_ptr<Y> const & r )
+
+#endif
+    : px( r.px ), pn( r.pn ) // never throws
+    {
+    }
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC >= 1300)
+
+    template<class Y>
+    weak_ptr & operator=(weak_ptr<Y> const & r) // never throws
+    {
+        px = r.lock().get();
+        pn = r.pn;
+        return *this;
+    }
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+    template<class Y>
+    weak_ptr & operator=( weak_ptr<Y> && r )
+    {
+        this_type( static_cast< weak_ptr<Y> && >( r ) ).swap( *this );
+        return *this;
+    }
+
+#endif
+
+    template<class Y>
+    weak_ptr & operator=(shared_ptr<Y> const & r) // never throws
+    {
+        px = r.px;
+        pn = r.pn;
+        return *this;
+    }
+
+#endif
+
+    shared_ptr<T> lock() const // never throws
+    {
+        return shared_ptr<element_type>( *this, boost::detail::sp_nothrow_tag() );
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    bool expired() const // never throws
+    {
+        return pn.use_count() == 0;
+    }
+
+    bool _empty() const // extension, not in std::weak_ptr
+    {
+        return pn.empty();
+    }
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    void swap(this_type & other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    void _internal_assign(T * px2, boost::detail::shared_count const & pn2)
+    {
+        px = px2;
+        pn = pn2;
+    }
+
+    template<class Y> bool _internal_less(weak_ptr<Y> const & rhs) const
+    {
+        return pn < rhs.pn;
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template<class Y> friend class weak_ptr;
+    template<class Y> friend class shared_ptr;
+
+#endif
+
+    T * px;                       // contained pointer
+    boost::detail::weak_count pn; // reference counter
+
+};  // weak_ptr
+
+template<class T, class U> inline bool operator<(weak_ptr<T> const & a, weak_ptr<U> const & b)
+{
+    return a._internal_less(b);
+}
+
+template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b)
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif
+
+#endif  // #ifndef BOOST_SMART_PTR_WEAK_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base_gcc_ia64.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base_gcc_ia64.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base_gcc_ia64.hpp	(working copy)
@@ -0,0 +1,157 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_IA64_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_IA64_HPP_INCLUDED
+
+//
+//  detail/sp_counted_base_gcc_ia64.hpp - g++ on IA64
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//  Copyright 2004-2006 Peter Dimov
+//  Copyright 2005 Ben Hutchings
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//
+//  Lock-free algorithm by Alexander Terekhov
+//
+
+#include <boost/detail/sp_typeinfo.hpp>
+
+namespace boost
+{
+
+namespace detail
+{
+
+inline void atomic_increment( int * pw )
+{
+    // ++*pw;
+
+    int tmp;
+
+    // No barrier is required here but fetchadd always has an acquire or
+    // release barrier associated with it.  We choose release as it should be
+    // cheaper.
+    __asm__ ("fetchadd4.rel %0=%1,1" :
+         "=r"(tmp), "=m"(*pw) :
+         "m"( *pw ));
+}
+
+inline int atomic_decrement( int * pw )
+{
+    // return --*pw;
+
+    int rv;
+
+    __asm__ ("     fetchadd4.rel %0=%1,-1 ;; \n"
+             "     cmp.eq        p7,p0=1,%0 ;; \n"
+             "(p7) ld4.acq       %0=%1    " :
+             "=&r"(rv), "=m"(*pw) :
+             "m"( *pw ) :
+             "p7");
+
+    return rv;
+}
+
+inline int atomic_conditional_increment( int * pw )
+{
+    // if( *pw != 0 ) ++*pw;
+    // return *pw;
+
+    int rv, tmp, tmp2;
+
+    __asm__ ("0:   ld4          %0=%3           ;; \n"
+         "     cmp.eq       p7,p0=0,%0        ;; \n"
+         "(p7) br.cond.spnt 1f                \n"
+         "     mov          ar.ccv=%0         \n"
+         "     add          %1=1,%0           ;; \n"
+         "     cmpxchg4.acq %2=%3,%1,ar.ccv ;; \n"
+         "     cmp.ne       p7,p0=%0,%2       ;; \n"
+         "(p7) br.cond.spnt 0b                \n"
+         "     mov          %0=%1             ;; \n"
+         "1:" :
+         "=&r"(rv), "=&r"(tmp), "=&r"(tmp2), "=m"(*pw) :
+         "m"( *pw ) :
+         "ar.ccv", "p7");
+
+    return rv;
+}
+
+class sp_counted_base
+{
+private:
+
+    sp_counted_base( sp_counted_base const & );
+    sp_counted_base & operator= ( sp_counted_base const & );
+
+    int use_count_;        // #shared
+    int weak_count_;       // #weak + (#shared != 0)
+
+public:
+
+    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
+    {
+    }
+
+    virtual ~sp_counted_base() // nothrow
+    {
+    }
+
+    // dispose() is called when use_count_ drops to zero, to release
+    // the resources managed by *this.
+
+    virtual void dispose() = 0; // nothrow
+
+    // destroy() is called when weak_count_ drops to zero.
+
+    virtual void destroy() // nothrow
+    {
+        delete this;
+    }
+
+    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;
+
+    void add_ref_copy()
+    {
+        atomic_increment( &use_count_ );
+    }
+
+    bool add_ref_lock() // true on success
+    {
+        return atomic_conditional_increment( &use_count_ ) != 0;
+    }
+
+    void release() // nothrow
+    {
+        if( atomic_decrement( &use_count_ ) == 0 )
+        {
+            dispose();
+            weak_release();
+        }
+    }
+
+    void weak_add_ref() // nothrow
+    {
+        atomic_increment( &weak_count_ );
+    }
+
+    void weak_release() // nothrow
+    {
+        if( atomic_decrement( &weak_count_ ) == 0 )
+        {
+            destroy();
+        }
+    }
+
+    long use_count() const // nothrow
+    {
+        return static_cast<int const volatile &>( use_count_ ); // TODO use ld.acq here
+    }
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_IA64_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base.hpp	(working copy)
@@ -0,0 +1,70 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  detail/sp_counted_base.hpp
+//
+//  Copyright 2005, 2006 Peter Dimov
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#include <boost/config.hpp>
+#include <boost/smart_ptr/detail/sp_has_sync.hpp>
+
+#if defined( BOOST_SP_DISABLE_THREADS )
+# include <boost/smart_ptr/detail/sp_counted_base_nt.hpp>
+
+#elif defined( BOOST_SP_USE_SPINLOCK )
+# include <boost/smart_ptr/detail/sp_counted_base_spin.hpp>
+
+#elif defined( BOOST_SP_USE_PTHREADS )
+# include <boost/smart_ptr/detail/sp_counted_base_pt.hpp>
+
+#elif defined( BOOST_DISABLE_THREADS ) && !defined( BOOST_SP_ENABLE_THREADS ) && !defined( BOOST_DISABLE_WIN32 )
+# include <boost/smart_ptr/detail/sp_counted_base_nt.hpp>
+
+#elif defined( __GNUC__ ) && ( defined( __i386__ ) || defined( __x86_64__ ) )
+# include <boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp>
+
+#elif defined( __GNUC__ ) && defined( __ia64__ ) && !defined( __INTEL_COMPILER )
+# include <boost/smart_ptr/detail/sp_counted_base_gcc_ia64.hpp>
+
+#elif defined(__HP_aCC) && defined(__ia64)
+# include <boost/smart_ptr/detail/sp_counted_base_acc_ia64.hpp>
+
+#elif defined( __MWERKS__ ) && defined( __POWERPC__ )
+# include <boost/smart_ptr/detail/sp_counted_base_cw_ppc.hpp>
+
+#elif defined( __GNUC__ ) && ( defined( __powerpc__ ) || defined( __ppc__ ) || defined( __ppc ) )
+# include <boost/smart_ptr/detail/sp_counted_base_gcc_ppc.hpp>
+
+#elif defined( __GNUC__ ) && ( defined( __mips__ ) || defined( _mips ) )
+# include <boost/smart_ptr/detail/sp_counted_base_gcc_mips.hpp>
+
+#elif defined( BOOST_SP_HAS_SYNC )
+# include <boost/smart_ptr/detail/sp_counted_base_sync.hpp>
+
+#elif defined(__GNUC__) && ( defined( __sparcv9 ) || ( defined( __sparcv8 ) && ( __GNUC__ * 100 + __GNUC_MINOR__ >= 402 ) ) )
+# include <boost/smart_ptr/detail/sp_counted_base_gcc_sparc.hpp>
+
+#elif defined( WIN32 ) || defined( _WIN32 ) || defined( __WIN32__ ) || defined(__CYGWIN__)
+# include <boost/smart_ptr/detail/sp_counted_base_w32.hpp>
+
+#elif !defined( BOOST_HAS_THREADS )
+# include <boost/smart_ptr/detail/sp_counted_base_nt.hpp>
+
+#else
+# include <boost/smart_ptr/detail/sp_counted_base_spin.hpp>
+
+#endif
+
+#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/operator_bool.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/operator_bool.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/operator_bool.hpp	(working copy)
@@ -0,0 +1,56 @@
+//  This header intentionally has no include guards.
+//
+//  Copyright (c) 2001-2009 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt
+
+#if ( defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, < 0x570) ) || defined(__CINT__)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined( _MANAGED )
+
+    static void unspecified_bool( this_type*** )
+    {
+    }
+
+    typedef void (*unspecified_bool_type)( this_type*** );
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: unspecified_bool;
+    }
+
+#elif \
+    ( defined(__MWERKS__) && BOOST_WORKAROUND(__MWERKS__, < 0x3200) ) || \
+    ( defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ < 304) ) || \
+    ( defined(__SUNPRO_CC) && BOOST_WORKAROUND(__SUNPRO_CC, <= 0x590) )
+
+    typedef T * (this_type::*unspecified_bool_type)() const;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &this_type::get;
+    }
+
+#else
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &this_type::px;
+    }
+
+#endif
+
+    // operator! is redundant, but some compilers need it
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_has_sync.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_has_sync.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_has_sync.hpp	(working copy)
@@ -0,0 +1,53 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SP_HAS_SYNC_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SP_HAS_SYNC_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/smart_ptr/detail/sp_has_sync.hpp
+//
+//  Copyright (c) 2008, 2009 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  Defines the BOOST_SP_HAS_SYNC macro if the __sync_* intrinsics
+//  are available.
+//
+
+#if defined( __GNUC__ ) && ( __GNUC__ * 100 + __GNUC_MINOR__ >= 401 ) && !defined( BOOST_SP_NO_SYNC )
+
+#define BOOST_SP_HAS_SYNC
+
+#if defined( __arm__ )  || defined( __armel__ )
+#undef BOOST_SP_HAS_SYNC
+#endif
+
+#if defined( __hppa ) || defined( __hppa__ )
+#undef BOOST_SP_HAS_SYNC
+#endif
+
+#if defined( __m68k__ )
+#undef BOOST_SP_HAS_SYNC
+#endif
+
+#if defined( __sh__ )
+#undef BOOST_SP_HAS_SYNC
+#endif
+
+#if defined( __sparc__ )
+#undef BOOST_SP_HAS_SYNC
+#endif
+
+#if defined( __INTEL_COMPILER ) && !defined( __ia64__ ) && ( __INTEL_COMPILER < 1100 )
+#undef BOOST_SP_HAS_SYNC
+#endif
+
+#endif // __GNUC__ * 100 + __GNUC_MINOR__ >= 401
+
+#endif // #ifndef BOOST_SMART_PTR_DETAIL_SP_HAS_SYNC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock_pool.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock_pool.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock_pool.hpp	(working copy)
@@ -0,0 +1,91 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_POOL_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SPINLOCK_POOL_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/spinlock_pool.hpp
+//
+//  Copyright (c) 2008 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  spinlock_pool<0> is reserved for atomic<>, when/if it arrives
+//  spinlock_pool<1> is reserved for shared_ptr reference counts
+//  spinlock_pool<2> is reserved for shared_ptr atomic access
+//
+
+#include <boost/config.hpp>
+#include <boost/smart_ptr/detail/spinlock.hpp>
+#include <cstddef>
+
+namespace boost
+{
+
+namespace detail
+{
+
+template< int I > class spinlock_pool
+{
+private:
+
+    static spinlock pool_[ 41 ];
+
+public:
+
+    static spinlock & spinlock_for( void const * pv )
+    {
+#if defined(__VMS) && __INITIAL_POINTER_SIZE == 64
+        std::size_t i = reinterpret_cast< unsigned long long >( pv ) % 41;
+#else
+        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;
+#endif
+        return pool_[ i ];
+    }
+
+    class scoped_lock
+    {
+    private:
+
+        spinlock & sp_;
+
+        scoped_lock( scoped_lock const & );
+        scoped_lock & operator=( scoped_lock const & );
+
+    public:
+
+        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
+        {
+            sp_.lock();
+        }
+
+        ~scoped_lock()
+        {
+            sp_.unlock();
+        }
+    };
+};
+
+template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
+{
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT, BOOST_DETAIL_SPINLOCK_INIT,
+    BOOST_DETAIL_SPINLOCK_INIT
+};
+
+} // namespace detail
+} // namespace boost
+
+#endif // #ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_POOL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp	(working copy)
@@ -0,0 +1,173 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_X86_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_X86_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  detail/sp_counted_base_gcc_x86.hpp - g++ on 486+ or AMD64
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//  Copyright 2004-2005 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//
+//  Lock-free algorithm by Alexander Terekhov
+//
+//  Thanks to Ben Hitchings for the #weak + (#shared != 0)
+//  formulation
+//
+
+#include <boost/detail/sp_typeinfo.hpp>
+
+namespace boost
+{
+
+namespace detail
+{
+
+inline int atomic_exchange_and_add( int * pw, int dv )
+{
+    // int r = *pw;
+    // *pw += dv;
+    // return r;
+
+    int r;
+
+    __asm__ __volatile__
+    (
+        "lock\n\t"
+        "xadd %1, %0":
+        "=m"( *pw ), "=r"( r ): // outputs (%0, %1)
+        "m"( *pw ), "1"( dv ): // inputs (%2, %3 == %1)
+        "memory", "cc" // clobbers
+    );
+
+    return r;
+}
+
+inline void atomic_increment( int * pw )
+{
+    //atomic_exchange_and_add( pw, 1 );
+
+    __asm__
+    (
+        "lock\n\t"
+        "incl %0":
+        "=m"( *pw ): // output (%0)
+        "m"( *pw ): // input (%1)
+        "cc" // clobbers
+    );
+}
+
+inline int atomic_conditional_increment( int * pw )
+{
+    // int rv = *pw;
+    // if( rv != 0 ) ++*pw;
+    // return rv;
+
+    int rv, tmp;
+
+    __asm__
+    (
+        "movl %0, %%eax\n\t"
+        "0:\n\t"
+        "test %%eax, %%eax\n\t"
+        "je 1f\n\t"
+        "movl %%eax, %2\n\t"
+        "incl %2\n\t"
+        "lock\n\t"
+        "cmpxchgl %2, %0\n\t"
+        "jne 0b\n\t"
+        "1:":
+        "=m"( *pw ), "=&a"( rv ), "=&r"( tmp ): // outputs (%0, %1, %2)
+        "m"( *pw ): // input (%3)
+        "cc" // clobbers
+    );
+
+    return rv;
+}
+
+class sp_counted_base
+{
+private:
+
+    sp_counted_base( sp_counted_base const & );
+    sp_counted_base & operator= ( sp_counted_base const & );
+
+    int use_count_;        // #shared
+    int weak_count_;       // #weak + (#shared != 0)
+
+public:
+
+    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
+    {
+    }
+
+    virtual ~sp_counted_base() // nothrow
+    {
+    }
+
+    // dispose() is called when use_count_ drops to zero, to release
+    // the resources managed by *this.
+
+    virtual void dispose() = 0; // nothrow
+
+    // destroy() is called when weak_count_ drops to zero.
+
+    virtual void destroy() // nothrow
+    {
+        delete this;
+    }
+
+    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;
+
+    void add_ref_copy()
+    {
+        atomic_increment( &use_count_ );
+    }
+
+    bool add_ref_lock() // true on success
+    {
+        return atomic_conditional_increment( &use_count_ ) != 0;
+    }
+
+    void release() // nothrow
+    {
+        if( atomic_exchange_and_add( &use_count_, -1 ) == 1 )
+        {
+            dispose();
+            weak_release();
+        }
+    }
+
+    void weak_add_ref() // nothrow
+    {
+        atomic_increment( &weak_count_ );
+    }
+
+    void weak_release() // nothrow
+    {
+        if( atomic_exchange_and_add( &weak_count_, -1 ) == 1 )
+        {
+            destroy();
+        }
+    }
+
+    long use_count() const // nothrow
+    {
+        return static_cast<int const volatile &>( use_count_ );
+    }
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_GCC_X86_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_convertible.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_convertible.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_convertible.hpp	(working copy)
@@ -0,0 +1,76 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SP_CONVERTIBLE_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SP_CONVERTIBLE_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//  detail/sp_convertible.hpp
+//
+//  Copyright 2008 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt
+
+#include <boost/config.hpp>
+
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE ) && defined( BOOST_NO_SFINAE )
+# define BOOST_SP_NO_SP_CONVERTIBLE
+#endif
+
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE ) && defined( __GNUC__ ) && ( __GNUC__ * 100 + __GNUC_MINOR__ < 303 )
+# define BOOST_SP_NO_SP_CONVERTIBLE
+#endif
+
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE ) && defined( __BORLANDC__ ) && ( __BORLANDC__ < 0x630 )
+# define BOOST_SP_NO_SP_CONVERTIBLE
+#endif
+
+#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+namespace boost
+{
+
+namespace detail
+{
+
+template< class Y, class T > struct sp_convertible
+{
+    typedef char (&yes) [1];
+    typedef char (&no)  [2];
+
+    static yes f( T* );
+    static no  f( ... );
+
+    enum _vt { value = sizeof( (f)( static_cast<Y*>(0) ) ) == sizeof(yes) };
+};
+
+struct sp_empty
+{
+};
+
+template< bool > struct sp_enable_if_convertible_impl;
+
+template<> struct sp_enable_if_convertible_impl<true>
+{
+    typedef sp_empty type;
+};
+
+template<> struct sp_enable_if_convertible_impl<false>
+{
+};
+
+template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
+{
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // !defined( BOOST_SP_NO_SP_CONVERTIBLE )
+
+#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_CONVERTIBLE_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock_sync.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock_sync.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock_sync.hpp	(working copy)
@@ -0,0 +1,87 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_SYNC_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SPINLOCK_SYNC_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  Copyright (c) 2008 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#include <boost/smart_ptr/detail/yield_k.hpp>
+
+#if defined( __ia64__ ) && defined( __INTEL_COMPILER )
+# include <ia64intrin.h>
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+class spinlock
+{
+public:
+
+    int v_;
+
+public:
+
+    bool try_lock()
+    {
+        int r = __sync_lock_test_and_set( &v_, 1 );
+        return r == 0;
+    }
+
+    void lock()
+    {
+        for( unsigned k = 0; !try_lock(); ++k )
+        {
+            boost::detail::yield( k );
+        }
+    }
+
+    void unlock()
+    {
+        __sync_lock_release( &v_ );
+    }
+
+public:
+
+    class scoped_lock
+    {
+    private:
+
+        spinlock & sp_;
+
+        scoped_lock( scoped_lock const & );
+        scoped_lock & operator=( scoped_lock const & );
+
+    public:
+
+        explicit scoped_lock( spinlock & sp ): sp_( sp )
+        {
+            sp.lock();
+        }
+
+        ~scoped_lock()
+        {
+            sp_.unlock();
+        }
+    };
+};
+
+} // namespace detail
+} // namespace boost
+
+#define BOOST_DETAIL_SPINLOCK_INIT {0}
+
+#endif // #ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_SYNC_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/shared_count.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/shared_count.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/shared_count.hpp	(working copy)
@@ -0,0 +1,532 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  detail/shared_count.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//  Copyright 2004-2005 Peter Dimov
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifdef __BORLANDC__
+# pragma warn -8027     // Functions containing try are not expanded inline
+#endif
+
+#include <boost/config.hpp>
+#include <boost/checked_delete.hpp>
+#include <boost/throw_exception.hpp>
+#include <boost/smart_ptr/bad_weak_ptr.hpp>
+#include <boost/smart_ptr/detail/sp_counted_base.hpp>
+#include <boost/smart_ptr/detail/sp_counted_impl.hpp>
+#include <boost/detail/workaround.hpp>
+// In order to avoid circular dependencies with Boost.TR1
+// we make sure that our include of <memory> doesn't try to
+// pull in the TR1 headers: that's why we use this header
+// rather than including <memory> directly:
+#include <boost/config/no_tr1/memory.hpp>  // std::auto_ptr
+#include <functional>       // std::less
+#include <new>              // std::bad_alloc
+
+namespace boost
+{
+
+namespace detail
+{
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+int const shared_count_id = 0x2C35F101;
+int const   weak_count_id = 0x298C38A4;
+
+#endif
+
+struct sp_nothrow_tag {};
+
+template< class D > struct sp_inplace_tag
+{
+};
+
+class weak_count;
+
+class shared_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class weak_count;
+
+public:
+
+    shared_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+    }
+
+    template<class Y> explicit shared_count( Y * p ): pi_( 0 )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = new sp_counted_impl_p<Y>( p );
+        }
+        catch(...)
+        {
+            boost::checked_delete( p );
+            throw;
+        }
+
+#else
+
+        pi_ = new sp_counted_impl_p<Y>( p );
+
+        if( pi_ == 0 )
+        {
+            boost::checked_delete( p );
+            boost::throw_exception( std::bad_alloc() );
+        }
+
+#endif
+    }
+
+#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, <= 1200 )
+    template<class Y, class D> shared_count( Y * p, D d ): pi_(0)
+#else
+    template<class P, class D> shared_count( P p, D d ): pi_(0)
+#endif
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, <= 1200 )
+        typedef Y* P;
+#endif
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = new sp_counted_impl_pd<P, D>(p, d);
+        }
+        catch(...)
+        {
+            d(p); // delete p
+            throw;
+        }
+
+#else
+
+        pi_ = new sp_counted_impl_pd<P, D>(p, d);
+
+        if(pi_ == 0)
+        {
+            d(p); // delete p
+            boost::throw_exception(std::bad_alloc());
+        }
+
+#endif
+    }
+
+#if !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )
+
+    template< class P, class D > shared_count( P p, sp_inplace_tag<D> ): pi_( 0 )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = new sp_counted_impl_pd< P, D >( p );
+        }
+        catch( ... )
+        {
+            D()( p ); // delete p
+            throw;
+        }
+
+#else
+
+        pi_ = new sp_counted_impl_pd< P, D >( p );
+
+        if( pi_ == 0 )
+        {
+            D()( p ); // delete p
+            boost::throw_exception( std::bad_alloc() );
+        }
+
+#endif // #ifndef BOOST_NO_EXCEPTIONS
+    }
+
+#endif // !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )
+
+    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        typedef sp_counted_impl_pda<P, D, A> impl_type;
+        typedef typename A::template rebind< impl_type >::other A2;
+
+        A2 a2( a );
+
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
+            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
+        }
+        catch(...)
+        {
+            d( p );
+
+            if( pi_ != 0 )
+            {
+                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
+            }
+
+            throw;
+        }
+
+#else
+
+        pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
+
+        if( pi_ != 0 )
+        {
+            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
+        }
+        else
+        {
+            d( p );
+            boost::throw_exception( std::bad_alloc() );
+        }
+
+#endif
+    }
+
+#if !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )
+
+    template< class P, class D, class A > shared_count( P p, sp_inplace_tag< D >, A a ): pi_( 0 )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        typedef sp_counted_impl_pda< P, D, A > impl_type;
+        typedef typename A::template rebind< impl_type >::other A2;
+
+        A2 a2( a );
+
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
+            new( static_cast< void* >( pi_ ) ) impl_type( p, a );
+        }
+        catch(...)
+        {
+            D()( p );
+
+            if( pi_ != 0 )
+            {
+                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
+            }
+
+            throw;
+        }
+
+#else
+
+        pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
+
+        if( pi_ != 0 )
+        {
+            new( static_cast< void* >( pi_ ) ) impl_type( p, a );
+        }
+        else
+        {
+            D()( p );
+            boost::throw_exception( std::bad_alloc() );
+        }
+
+#endif // #ifndef BOOST_NO_EXCEPTIONS
+    }
+
+#endif // !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    // auto_ptr<Y> is special cased to provide the strong guarantee
+
+    template<class Y>
+    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#ifdef BOOST_NO_EXCEPTIONS
+
+        if( pi_ == 0 )
+        {
+            boost::throw_exception(std::bad_alloc());
+        }
+
+#endif
+
+        r.release();
+    }
+
+#endif
+
+    ~shared_count() // nothrow
+    {
+        if( pi_ != 0 ) pi_->release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    shared_count(shared_count const & r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if( pi_ != 0 ) pi_->add_ref_copy();
+    }
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+    shared_count(shared_count && r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        r.pi_ = 0;
+    }
+
+#endif
+
+    explicit shared_count(weak_count const & r); // throws bad_weak_ptr when r.use_count() == 0
+    shared_count( weak_count const & r, sp_nothrow_tag ); // constructs an empty *this when r.use_count() == 0
+
+    shared_count & operator= (shared_count const & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+
+        if( tmp != pi_ )
+        {
+            if( tmp != 0 ) tmp->add_ref_copy();
+            if( pi_ != 0 ) pi_->release();
+            pi_ = tmp;
+        }
+
+        return *this;
+    }
+
+    void swap(shared_count & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_->use_count(): 0;
+    }
+
+    bool unique() const // nothrow
+    {
+        return use_count() == 1;
+    }
+
+    bool empty() const // nothrow
+    {
+        return pi_ == 0;
+    }
+
+    friend inline bool operator==(shared_count const & a, shared_count const & b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator<(shared_count const & a, shared_count const & b)
+    {
+        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
+    }
+
+    void * get_deleter( sp_typeinfo const & ti ) const
+    {
+        return pi_? pi_->get_deleter( ti ): 0;
+    }
+};
+
+
+class weak_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class shared_count;
+
+public:
+
+    weak_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+    }
+
+    weak_count(shared_count const & r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_->weak_add_ref();
+    }
+
+    weak_count(weak_count const & r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_->weak_add_ref();
+    }
+
+// Move support
+
+#if defined( BOOST_HAS_RVALUE_REFS )
+
+    weak_count(weak_count && r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+        r.pi_ = 0;
+    }
+
+#endif
+
+    ~weak_count() // nothrow
+    {
+        if(pi_ != 0) pi_->weak_release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    weak_count & operator= (shared_count const & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+
+        if( tmp != pi_ )
+        {
+            if(tmp != 0) tmp->weak_add_ref();
+            if(pi_ != 0) pi_->weak_release();
+            pi_ = tmp;
+        }
+
+        return *this;
+    }
+
+    weak_count & operator= (weak_count const & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+
+        if( tmp != pi_ )
+        {
+            if(tmp != 0) tmp->weak_add_ref();
+            if(pi_ != 0) pi_->weak_release();
+            pi_ = tmp;
+        }
+
+        return *this;
+    }
+
+    void swap(weak_count & r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_->use_count(): 0;
+    }
+
+    bool empty() const // nothrow
+    {
+        return pi_ == 0;
+    }
+
+    friend inline bool operator==(weak_count const & a, weak_count const & b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator<(weak_count const & a, weak_count const & b)
+    {
+        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
+    }
+};
+
+inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+{
+    if( pi_ == 0 || !pi_->add_ref_lock() )
+    {
+        boost::throw_exception( boost::bad_weak_ptr() );
+    }
+}
+
+inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+{
+    if( pi_ != 0 && !pi_->add_ref_lock() )
+    {
+        pi_ = 0;
+    }
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing try are not expanded inline
+#endif
+
+#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/yield_k.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/yield_k.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/yield_k.hpp	(working copy)
@@ -0,0 +1,149 @@
+#ifndef BOOST_SMART_PTR_DETAIL_YIELD_K_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_YIELD_K_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  yield_k.hpp
+//
+//  Copyright (c) 2008 Peter Dimov
+//
+//  void yield( unsigned k );
+//
+//  Typical use:
+//
+//  for( unsigned k = 0; !try_lock(); ++k ) yield( k );
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt
+//
+
+#include <boost/config.hpp>
+
+// BOOST_SMT_PAUSE
+
+#if defined(_MSC_VER) && _MSC_VER >= 1310 && ( defined(_M_IX86) || defined(_M_X64) )
+
+extern "C" void _mm_pause();
+#pragma intrinsic( _mm_pause )
+
+#define BOOST_SMT_PAUSE _mm_pause();
+
+#elif defined(__GNUC__) && ( defined(__i386__) || defined(__x86_64__) )
+
+#define BOOST_SMT_PAUSE __asm__ __volatile__( "rep; nop" : : : "memory" );
+
+#endif
+
+//
+
+#if defined( WIN32 ) || defined( _WIN32 ) || defined( __WIN32__ ) || defined( __CYGWIN__ )
+
+#if defined( BOOST_USE_WINDOWS_H )
+# include <windows.h>
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#if !defined( BOOST_USE_WINDOWS_H )
+  extern "C" void __stdcall Sleep( unsigned long ms );
+#endif
+
+inline void yield( unsigned k )
+{
+    if( k < 4 )
+    {
+    }
+#if defined( BOOST_SMT_PAUSE )
+    else if( k < 16 )
+    {
+        BOOST_SMT_PAUSE
+    }
+#endif
+    else if( k < 32 )
+    {
+        Sleep( 0 );
+    }
+    else
+    {
+        Sleep( 1 );
+    }
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#elif defined( BOOST_HAS_PTHREADS )
+
+#include <sched.h>
+#include <time.h>
+
+namespace boost
+{
+
+namespace detail
+{
+
+inline void yield( unsigned k )
+{
+    if( k < 4 )
+    {
+    }
+#if defined( BOOST_SMT_PAUSE )
+    else if( k < 16 )
+    {
+        BOOST_SMT_PAUSE
+    }
+#endif
+    else if( k < 32 || k & 1 )
+    {
+        sched_yield();
+    }
+    else
+    {
+        // g++ -Wextra warns on {} or {0}
+        struct timespec rqtp = { 0, 0 };
+
+        // POSIX says that timespec has tv_sec and tv_nsec
+        // But it doesn't guarantee order or placement
+
+        rqtp.tv_sec = 0;
+        rqtp.tv_nsec = 1000;
+
+        nanosleep( &rqtp, 0 );
+    }
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#else
+
+namespace boost
+{
+
+namespace detail
+{
+
+inline void yield( unsigned )
+{
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#endif
+
+#endif // #ifndef BOOST_SMART_PTR_DETAIL_YIELD_K_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/spinlock.hpp	(working copy)
@@ -0,0 +1,56 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SPINLOCK_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/spinlock.hpp
+//
+//  Copyright (c) 2008 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0.
+//  See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  struct spinlock
+//  {
+//      void lock();
+//      bool try_lock();
+//      void unlock();
+//
+//      class scoped_lock;
+//  };
+//
+//  #define BOOST_DETAIL_SPINLOCK_INIT <unspecified>
+//
+
+#include <boost/config.hpp>
+#include <boost/smart_ptr/detail/sp_has_sync.hpp>
+
+#if defined( BOOST_SP_USE_PTHREADS )
+#  include <boost/smart_ptr/detail/spinlock_pt.hpp>
+
+#elif defined(__GNUC__) && defined( __arm__ ) && !defined( __thumb__ )
+#  include <boost/smart_ptr/detail/spinlock_gcc_arm.hpp>
+
+#elif defined( BOOST_SP_HAS_SYNC )
+#  include <boost/smart_ptr/detail/spinlock_sync.hpp>
+
+#elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  include <boost/smart_ptr/detail/spinlock_w32.hpp>
+
+#elif defined(BOOST_HAS_PTHREADS)
+#  include <boost/smart_ptr/detail/spinlock_pt.hpp>
+
+#elif !defined(BOOST_HAS_THREADS)
+#  include <boost/smart_ptr/detail/spinlock_nt.hpp>
+
+#else
+#  error Unrecognized threading platform
+#endif
+
+#endif // #ifndef BOOST_SMART_PTR_DETAIL_SPINLOCK_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_impl.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_impl.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/detail/sp_counted_impl.hpp	(working copy)
@@ -0,0 +1,239 @@
+#ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED
+#define BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  detail/sp_counted_impl.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//  Copyright 2004-2005 Peter Dimov
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#include <boost/config.hpp>
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR) && defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+# error BOOST_SP_USE_STD_ALLOCATOR and BOOST_SP_USE_QUICK_ALLOCATOR are incompatible.
+#endif
+
+#include <boost/checked_delete.hpp>
+#include <boost/smart_ptr/detail/sp_counted_base.hpp>
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+#include <boost/smart_ptr/detail/quick_allocator.hpp>
+#endif
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR)
+#include <memory>           // std::allocator
+#endif
+
+#include <cstddef>          // std::size_t
+
+namespace boost
+{
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook( void * px, std::size_t size, void * pn );
+void sp_scalar_destructor_hook( void * px, std::size_t size, void * pn );
+
+#endif
+
+namespace detail
+{
+
+template<class X> class sp_counted_impl_p: public sp_counted_base
+{
+private:
+
+    X * px_;
+
+    sp_counted_impl_p( sp_counted_impl_p const & );
+    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );
+
+    typedef sp_counted_impl_p<X> this_type;
+
+public:
+
+    explicit sp_counted_impl_p( X * px ): px_( px )
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook( px, sizeof(X), this );
+#endif
+    }
+
+    virtual void dispose() // nothrow
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_destructor_hook( px_, sizeof(X), this );
+#endif
+        boost::checked_delete( px_ );
+    }
+
+    virtual void * get_deleter( detail::sp_typeinfo const & )
+    {
+        return 0;
+    }
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR)
+
+    void * operator new( std::size_t )
+    {
+        return std::allocator<this_type>().allocate( 1, static_cast<this_type *>(0) );
+    }
+
+    void operator delete( void * p )
+    {
+        std::allocator<this_type>().deallocate( static_cast<this_type *>(p), 1 );
+    }
+
+#endif
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+
+    void * operator new( std::size_t )
+    {
+        return quick_allocator<this_type>::alloc();
+    }
+
+    void operator delete( void * p )
+    {
+        quick_allocator<this_type>::dealloc( p );
+    }
+
+#endif
+};
+
+//
+// Borland's Codeguard trips up over the -Vx- option here:
+//
+#ifdef __CODEGUARD__
+# pragma option push -Vx-
+#endif
+
+template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
+{
+private:
+
+    P ptr; // copy constructor must not throw
+    D del; // copy constructor must not throw
+
+    sp_counted_impl_pd( sp_counted_impl_pd const & );
+    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );
+
+    typedef sp_counted_impl_pd<P, D> this_type;
+
+public:
+
+    // pre: d(p) must not throw
+
+    sp_counted_impl_pd( P p, D & d ): ptr( p ), del( d )
+    {
+    }
+
+    sp_counted_impl_pd( P p ): ptr( p ), del()
+    {
+    }
+
+    virtual void dispose() // nothrow
+    {
+        del( ptr );
+    }
+
+    virtual void * get_deleter( detail::sp_typeinfo const & ti )
+    {
+        return ti == BOOST_SP_TYPEID(D)? &reinterpret_cast<char&>( del ): 0;
+    }
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR)
+
+    void * operator new( std::size_t )
+    {
+        return std::allocator<this_type>().allocate( 1, static_cast<this_type *>(0) );
+    }
+
+    void operator delete( void * p )
+    {
+        std::allocator<this_type>().deallocate( static_cast<this_type *>(p), 1 );
+    }
+
+#endif
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+
+    void * operator new( std::size_t )
+    {
+        return quick_allocator<this_type>::alloc();
+    }
+
+    void operator delete( void * p )
+    {
+        quick_allocator<this_type>::dealloc( p );
+    }
+
+#endif
+};
+
+template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
+{
+private:
+
+    P p_; // copy constructor must not throw
+    D d_; // copy constructor must not throw
+    A a_; // copy constructor must not throw
+
+    sp_counted_impl_pda( sp_counted_impl_pda const & );
+    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );
+
+    typedef sp_counted_impl_pda<P, D, A> this_type;
+
+public:
+
+    // pre: d( p ) must not throw
+
+    sp_counted_impl_pda( P p, D & d, A a ): p_( p ), d_( d ), a_( a )
+    {
+    }
+
+    sp_counted_impl_pda( P p, A a ): p_( p ), d_(), a_( a )
+    {
+    }
+
+    virtual void dispose() // nothrow
+    {
+        d_( p_ );
+    }
+
+    virtual void destroy() // nothrow
+    {
+        typedef typename A::template rebind< this_type >::other A2;
+
+        A2 a2( a_ );
+
+        this->~this_type();
+        a2.deallocate( this, 1 );
+    }
+
+    virtual void * get_deleter( detail::sp_typeinfo const & ti )
+    {
+        return ti == BOOST_SP_TYPEID( D )? &reinterpret_cast<char&>( d_ ): 0;
+    }
+};
+
+#ifdef __CODEGUARD__
+# pragma option pop
+#endif
+
+} // namespace detail
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/scoped_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/scoped_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/scoped_ptr.hpp	(working copy)
@@ -0,0 +1,131 @@
+#ifndef BOOST_SMART_PTR_SCOPED_PTR_HPP_INCLUDED
+#define BOOST_SMART_PTR_SCOPED_PTR_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  http://www.boost.org/libs/smart_ptr/scoped_ptr.htm
+//
+
+#include <boost/assert.hpp>
+#include <boost/checked_delete.hpp>
+#include <boost/detail/workaround.hpp>
+
+#ifndef BOOST_NO_AUTO_PTR
+# include <memory>          // for std::auto_ptr
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * p);
+void sp_scalar_destructor_hook(void * p);
+
+#endif
+
+//  scoped_ptr mimics a built-in pointer except that it guarantees deletion
+//  of the object pointed to, either on destruction of the scoped_ptr or via
+//  an explicit reset(). scoped_ptr is a simple solution for simple needs;
+//  use shared_ptr or std::auto_ptr if your needs are more complex.
+
+template<class T> class scoped_ptr // noncopyable
+{
+private:
+
+    T * px;
+
+    scoped_ptr(scoped_ptr const &);
+    scoped_ptr & operator=(scoped_ptr const &);
+
+    typedef scoped_ptr<T> this_type;
+
+    void operator==( scoped_ptr const& ) const;
+    void operator!=( scoped_ptr const& ) const;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_ptr( T * p = 0 ): px( p ) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook( px );
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    explicit scoped_ptr( std::auto_ptr<T> p ): px( p.release() ) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook( px );
+#endif
+    }
+
+#endif
+
+    ~scoped_ptr() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_destructor_hook( px );
+#endif
+        boost::checked_delete( px );
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT( p == 0 || p != px ); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T & operator*() const // never throws
+    {
+        BOOST_ASSERT( px != 0 );
+        return *px;
+    }
+
+    T * operator->() const // never throws
+    {
+        BOOST_ASSERT( px != 0 );
+        return px;
+    }
+
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+// implicit conversion to "bool"
+#include <boost/smart_ptr/detail/operator_bool.hpp>
+
+    void swap(scoped_ptr & b) // never throws
+    {
+        T * tmp = b.px;
+        b.px = px;
+        px = tmp;
+    }
+};
+
+template<class T> inline void swap(scoped_ptr<T> & a, scoped_ptr<T> & b) // never throws
+{
+    a.swap(b);
+}
+
+// get_pointer(p) is a generic way to say p.get()
+
+template<class T> inline T * get_pointer(scoped_ptr<T> const & p)
+{
+    return p.get();
+}
+
+} // namespace boost
+
+#endif // #ifndef BOOST_SMART_PTR_SCOPED_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/bad_weak_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/bad_weak_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/smart_ptr/bad_weak_ptr.hpp	(working copy)
@@ -0,0 +1,59 @@
+#ifndef BOOST_SMART_PTR_BAD_WEAK_PTR_HPP_INCLUDED
+#define BOOST_SMART_PTR_BAD_WEAK_PTR_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/smart_ptr/bad_weak_ptr.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#include <exception>
+
+#ifdef __BORLANDC__
+# pragma warn -8026     // Functions with excep. spec. are not expanded inline
+#endif
+
+namespace boost
+{
+
+// The standard library that comes with Borland C++ 5.5.1, 5.6.4
+// defines std::exception and its members as having C calling
+// convention (-pc). When the definition of bad_weak_ptr
+// is compiled with -ps, the compiler issues an error.
+// Hence, the temporary #pragma option -pc below.
+
+#if defined(__BORLANDC__) && __BORLANDC__ <= 0x564
+# pragma option push -pc
+#endif
+
+class bad_weak_ptr: public std::exception
+{
+public:
+
+    virtual char const * what() const throw()
+    {
+        return "tr1::bad_weak_ptr";
+    }
+};
+
+#if defined(__BORLANDC__) && __BORLANDC__ <= 0x564
+# pragma option pop
+#endif
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8026     // Functions with excep. spec. are not expanded inline
+#endif
+
+#endif  // #ifndef BOOST_SMART_PTR_BAD_WEAK_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator_adaptors.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator_adaptors.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator_adaptors.hpp	(working copy)
@@ -0,0 +1,13 @@
+// Copyright David Abrahams 2004. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See www.boost.org/libs/iterator for documentation.
+
+#ifndef ITERATOR_ADAPTORS_DWA2004725_HPP
+# define ITERATOR_ADAPTORS_DWA2004725_HPP
+
+#define BOOST_ITERATOR_ADAPTORS_VERSION 0x0200
+#include <boost/iterator/iterator_adaptor.hpp>
+
+#endif // ITERATOR_ADAPTORS_DWA2004725_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/current_function.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/current_function.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/current_function.hpp	(working copy)
@@ -0,0 +1,68 @@
+#ifndef BOOST_CURRENT_FUNCTION_HPP_INCLUDED
+#define BOOST_CURRENT_FUNCTION_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1020)
+# pragma once
+#endif
+
+//
+//  boost/current_function.hpp - BOOST_CURRENT_FUNCTION
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+//  http://www.boost.org/libs/utility/current_function.html
+//
+
+namespace boost
+{
+
+namespace detail
+{
+
+inline void current_function_helper()
+{
+
+#if defined(__GNUC__) || (defined(__MWERKS__) && (__MWERKS__ >= 0x3000)) || (defined(__ICC) && (__ICC >= 600)) || defined(__ghs__)
+
+# define BOOST_CURRENT_FUNCTION __PRETTY_FUNCTION__
+
+#elif defined(__DMC__) && (__DMC__ >= 0x810)
+
+# define BOOST_CURRENT_FUNCTION __PRETTY_FUNCTION__
+
+#elif defined(__FUNCSIG__)
+
+# define BOOST_CURRENT_FUNCTION __FUNCSIG__
+
+#elif (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 600)) || (defined(__IBMCPP__) && (__IBMCPP__ >= 500))
+
+# define BOOST_CURRENT_FUNCTION __FUNCTION__
+
+#elif defined(__BORLANDC__) && (__BORLANDC__ >= 0x550)
+
+# define BOOST_CURRENT_FUNCTION __FUNC__
+
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901)
+
+# define BOOST_CURRENT_FUNCTION __func__
+
+#else
+
+# define BOOST_CURRENT_FUNCTION "(unknown)"
+
+#endif
+
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_CURRENT_FUNCTION_HPP_INCLUDED
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/iterator.hpp	(working copy)
@@ -0,0 +1,59 @@
+//  iterator.hpp workarounds for non-conforming standard libraries  ---------//
+
+//  (C) Copyright Beman Dawes 2000. Distributed under the Boost
+//  Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/utility for documentation.
+
+//  Revision History
+//  12 Jan 01 added <cstddef> for std::ptrdiff_t (Jens Maurer)
+//  28 Jun 00 Workarounds to deal with known MSVC bugs (David Abrahams)
+//  26 Jun 00 Initial version (Jeremy Siek)
+
+#ifndef BOOST_ITERATOR_HPP
+#define BOOST_ITERATOR_HPP
+
+#include <iterator>
+#include <cstddef>           // std::ptrdiff_t
+#include <boost/config.hpp>
+
+namespace boost
+{
+# if defined(BOOST_NO_STD_ITERATOR) && !defined(BOOST_MSVC_STD_ITERATOR)
+  template <class Category, class T,
+    class Distance = std::ptrdiff_t,
+    class Pointer = T*, class Reference = T&>
+  struct iterator
+  {
+    typedef T         value_type;
+    typedef Distance  difference_type;
+    typedef Pointer   pointer;
+    typedef Reference reference;
+    typedef Category  iterator_category;
+  };
+# else
+
+  // declare iterator_base in namespace detail to work around MSVC bugs which
+  // prevent derivation from an identically-named class in a different namespace.
+  namespace detail {
+   template <class Category, class T, class Distance, class Pointer, class Reference>
+#  if !defined(BOOST_MSVC_STD_ITERATOR)
+   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
+#  else
+   struct iterator_base : std::iterator<Category, T, Distance>
+   {
+     typedef Reference reference;
+     typedef Pointer pointer;
+     typedef Distance difference_type;
+   };
+#  endif
+  }
+
+  template <class Category, class T, class Distance = std::ptrdiff_t,
+            class Pointer = T*, class Reference = T&>
+  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};
+# endif
+} // namespace boost
+
+#endif // BOOST_ITERATOR_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/shared_ptr.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/shared_ptr.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/shared_ptr.hpp	(working copy)
@@ -0,0 +1,19 @@
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#define BOOST_SHARED_PTR_HPP_INCLUDED
+
+//
+//  shared_ptr.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001-2008 Peter Dimov
+//
+//  Distributed under the Boost Software License, Version 1.0. (See
+//  accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt)
+//
+//  See http://www.boost.org/libs/smart_ptr/shared_ptr.htm for documentation.
+//
+
+#include <boost/smart_ptr/shared_ptr.hpp>
+
+#endif  // #ifndef BOOST_SHARED_PTR_HPP_INCLUDED
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/detail/while.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/detail/while.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/detail/while.hpp	(working copy)
@@ -0,0 +1,536 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CONTROL_DETAIL_WHILE_HPP
+# define BOOST_PREPROCESSOR_CONTROL_DETAIL_WHILE_HPP
+#
+# include <boost/preprocessor/control/iif.hpp>
+# include <boost/preprocessor/logical/bool.hpp>
+# include <boost/preprocessor/tuple/eat.hpp>
+#
+# define BOOST_PP_WHILE_1(p, o, s) BOOST_PP_WHILE_1_C(BOOST_PP_BOOL(p(2, s)), p, o, s)
+# define BOOST_PP_WHILE_2(p, o, s) BOOST_PP_WHILE_2_C(BOOST_PP_BOOL(p(3, s)), p, o, s)
+# define BOOST_PP_WHILE_3(p, o, s) BOOST_PP_WHILE_3_C(BOOST_PP_BOOL(p(4, s)), p, o, s)
+# define BOOST_PP_WHILE_4(p, o, s) BOOST_PP_WHILE_4_C(BOOST_PP_BOOL(p(5, s)), p, o, s)
+# define BOOST_PP_WHILE_5(p, o, s) BOOST_PP_WHILE_5_C(BOOST_PP_BOOL(p(6, s)), p, o, s)
+# define BOOST_PP_WHILE_6(p, o, s) BOOST_PP_WHILE_6_C(BOOST_PP_BOOL(p(7, s)), p, o, s)
+# define BOOST_PP_WHILE_7(p, o, s) BOOST_PP_WHILE_7_C(BOOST_PP_BOOL(p(8, s)), p, o, s)
+# define BOOST_PP_WHILE_8(p, o, s) BOOST_PP_WHILE_8_C(BOOST_PP_BOOL(p(9, s)), p, o, s)
+# define BOOST_PP_WHILE_9(p, o, s) BOOST_PP_WHILE_9_C(BOOST_PP_BOOL(p(10, s)), p, o, s)
+# define BOOST_PP_WHILE_10(p, o, s) BOOST_PP_WHILE_10_C(BOOST_PP_BOOL(p(11, s)), p, o, s)
+# define BOOST_PP_WHILE_11(p, o, s) BOOST_PP_WHILE_11_C(BOOST_PP_BOOL(p(12, s)), p, o, s)
+# define BOOST_PP_WHILE_12(p, o, s) BOOST_PP_WHILE_12_C(BOOST_PP_BOOL(p(13, s)), p, o, s)
+# define BOOST_PP_WHILE_13(p, o, s) BOOST_PP_WHILE_13_C(BOOST_PP_BOOL(p(14, s)), p, o, s)
+# define BOOST_PP_WHILE_14(p, o, s) BOOST_PP_WHILE_14_C(BOOST_PP_BOOL(p(15, s)), p, o, s)
+# define BOOST_PP_WHILE_15(p, o, s) BOOST_PP_WHILE_15_C(BOOST_PP_BOOL(p(16, s)), p, o, s)
+# define BOOST_PP_WHILE_16(p, o, s) BOOST_PP_WHILE_16_C(BOOST_PP_BOOL(p(17, s)), p, o, s)
+# define BOOST_PP_WHILE_17(p, o, s) BOOST_PP_WHILE_17_C(BOOST_PP_BOOL(p(18, s)), p, o, s)
+# define BOOST_PP_WHILE_18(p, o, s) BOOST_PP_WHILE_18_C(BOOST_PP_BOOL(p(19, s)), p, o, s)
+# define BOOST_PP_WHILE_19(p, o, s) BOOST_PP_WHILE_19_C(BOOST_PP_BOOL(p(20, s)), p, o, s)
+# define BOOST_PP_WHILE_20(p, o, s) BOOST_PP_WHILE_20_C(BOOST_PP_BOOL(p(21, s)), p, o, s)
+# define BOOST_PP_WHILE_21(p, o, s) BOOST_PP_WHILE_21_C(BOOST_PP_BOOL(p(22, s)), p, o, s)
+# define BOOST_PP_WHILE_22(p, o, s) BOOST_PP_WHILE_22_C(BOOST_PP_BOOL(p(23, s)), p, o, s)
+# define BOOST_PP_WHILE_23(p, o, s) BOOST_PP_WHILE_23_C(BOOST_PP_BOOL(p(24, s)), p, o, s)
+# define BOOST_PP_WHILE_24(p, o, s) BOOST_PP_WHILE_24_C(BOOST_PP_BOOL(p(25, s)), p, o, s)
+# define BOOST_PP_WHILE_25(p, o, s) BOOST_PP_WHILE_25_C(BOOST_PP_BOOL(p(26, s)), p, o, s)
+# define BOOST_PP_WHILE_26(p, o, s) BOOST_PP_WHILE_26_C(BOOST_PP_BOOL(p(27, s)), p, o, s)
+# define BOOST_PP_WHILE_27(p, o, s) BOOST_PP_WHILE_27_C(BOOST_PP_BOOL(p(28, s)), p, o, s)
+# define BOOST_PP_WHILE_28(p, o, s) BOOST_PP_WHILE_28_C(BOOST_PP_BOOL(p(29, s)), p, o, s)
+# define BOOST_PP_WHILE_29(p, o, s) BOOST_PP_WHILE_29_C(BOOST_PP_BOOL(p(30, s)), p, o, s)
+# define BOOST_PP_WHILE_30(p, o, s) BOOST_PP_WHILE_30_C(BOOST_PP_BOOL(p(31, s)), p, o, s)
+# define BOOST_PP_WHILE_31(p, o, s) BOOST_PP_WHILE_31_C(BOOST_PP_BOOL(p(32, s)), p, o, s)
+# define BOOST_PP_WHILE_32(p, o, s) BOOST_PP_WHILE_32_C(BOOST_PP_BOOL(p(33, s)), p, o, s)
+# define BOOST_PP_WHILE_33(p, o, s) BOOST_PP_WHILE_33_C(BOOST_PP_BOOL(p(34, s)), p, o, s)
+# define BOOST_PP_WHILE_34(p, o, s) BOOST_PP_WHILE_34_C(BOOST_PP_BOOL(p(35, s)), p, o, s)
+# define BOOST_PP_WHILE_35(p, o, s) BOOST_PP_WHILE_35_C(BOOST_PP_BOOL(p(36, s)), p, o, s)
+# define BOOST_PP_WHILE_36(p, o, s) BOOST_PP_WHILE_36_C(BOOST_PP_BOOL(p(37, s)), p, o, s)
+# define BOOST_PP_WHILE_37(p, o, s) BOOST_PP_WHILE_37_C(BOOST_PP_BOOL(p(38, s)), p, o, s)
+# define BOOST_PP_WHILE_38(p, o, s) BOOST_PP_WHILE_38_C(BOOST_PP_BOOL(p(39, s)), p, o, s)
+# define BOOST_PP_WHILE_39(p, o, s) BOOST_PP_WHILE_39_C(BOOST_PP_BOOL(p(40, s)), p, o, s)
+# define BOOST_PP_WHILE_40(p, o, s) BOOST_PP_WHILE_40_C(BOOST_PP_BOOL(p(41, s)), p, o, s)
+# define BOOST_PP_WHILE_41(p, o, s) BOOST_PP_WHILE_41_C(BOOST_PP_BOOL(p(42, s)), p, o, s)
+# define BOOST_PP_WHILE_42(p, o, s) BOOST_PP_WHILE_42_C(BOOST_PP_BOOL(p(43, s)), p, o, s)
+# define BOOST_PP_WHILE_43(p, o, s) BOOST_PP_WHILE_43_C(BOOST_PP_BOOL(p(44, s)), p, o, s)
+# define BOOST_PP_WHILE_44(p, o, s) BOOST_PP_WHILE_44_C(BOOST_PP_BOOL(p(45, s)), p, o, s)
+# define BOOST_PP_WHILE_45(p, o, s) BOOST_PP_WHILE_45_C(BOOST_PP_BOOL(p(46, s)), p, o, s)
+# define BOOST_PP_WHILE_46(p, o, s) BOOST_PP_WHILE_46_C(BOOST_PP_BOOL(p(47, s)), p, o, s)
+# define BOOST_PP_WHILE_47(p, o, s) BOOST_PP_WHILE_47_C(BOOST_PP_BOOL(p(48, s)), p, o, s)
+# define BOOST_PP_WHILE_48(p, o, s) BOOST_PP_WHILE_48_C(BOOST_PP_BOOL(p(49, s)), p, o, s)
+# define BOOST_PP_WHILE_49(p, o, s) BOOST_PP_WHILE_49_C(BOOST_PP_BOOL(p(50, s)), p, o, s)
+# define BOOST_PP_WHILE_50(p, o, s) BOOST_PP_WHILE_50_C(BOOST_PP_BOOL(p(51, s)), p, o, s)
+# define BOOST_PP_WHILE_51(p, o, s) BOOST_PP_WHILE_51_C(BOOST_PP_BOOL(p(52, s)), p, o, s)
+# define BOOST_PP_WHILE_52(p, o, s) BOOST_PP_WHILE_52_C(BOOST_PP_BOOL(p(53, s)), p, o, s)
+# define BOOST_PP_WHILE_53(p, o, s) BOOST_PP_WHILE_53_C(BOOST_PP_BOOL(p(54, s)), p, o, s)
+# define BOOST_PP_WHILE_54(p, o, s) BOOST_PP_WHILE_54_C(BOOST_PP_BOOL(p(55, s)), p, o, s)
+# define BOOST_PP_WHILE_55(p, o, s) BOOST_PP_WHILE_55_C(BOOST_PP_BOOL(p(56, s)), p, o, s)
+# define BOOST_PP_WHILE_56(p, o, s) BOOST_PP_WHILE_56_C(BOOST_PP_BOOL(p(57, s)), p, o, s)
+# define BOOST_PP_WHILE_57(p, o, s) BOOST_PP_WHILE_57_C(BOOST_PP_BOOL(p(58, s)), p, o, s)
+# define BOOST_PP_WHILE_58(p, o, s) BOOST_PP_WHILE_58_C(BOOST_PP_BOOL(p(59, s)), p, o, s)
+# define BOOST_PP_WHILE_59(p, o, s) BOOST_PP_WHILE_59_C(BOOST_PP_BOOL(p(60, s)), p, o, s)
+# define BOOST_PP_WHILE_60(p, o, s) BOOST_PP_WHILE_60_C(BOOST_PP_BOOL(p(61, s)), p, o, s)
+# define BOOST_PP_WHILE_61(p, o, s) BOOST_PP_WHILE_61_C(BOOST_PP_BOOL(p(62, s)), p, o, s)
+# define BOOST_PP_WHILE_62(p, o, s) BOOST_PP_WHILE_62_C(BOOST_PP_BOOL(p(63, s)), p, o, s)
+# define BOOST_PP_WHILE_63(p, o, s) BOOST_PP_WHILE_63_C(BOOST_PP_BOOL(p(64, s)), p, o, s)
+# define BOOST_PP_WHILE_64(p, o, s) BOOST_PP_WHILE_64_C(BOOST_PP_BOOL(p(65, s)), p, o, s)
+# define BOOST_PP_WHILE_65(p, o, s) BOOST_PP_WHILE_65_C(BOOST_PP_BOOL(p(66, s)), p, o, s)
+# define BOOST_PP_WHILE_66(p, o, s) BOOST_PP_WHILE_66_C(BOOST_PP_BOOL(p(67, s)), p, o, s)
+# define BOOST_PP_WHILE_67(p, o, s) BOOST_PP_WHILE_67_C(BOOST_PP_BOOL(p(68, s)), p, o, s)
+# define BOOST_PP_WHILE_68(p, o, s) BOOST_PP_WHILE_68_C(BOOST_PP_BOOL(p(69, s)), p, o, s)
+# define BOOST_PP_WHILE_69(p, o, s) BOOST_PP_WHILE_69_C(BOOST_PP_BOOL(p(70, s)), p, o, s)
+# define BOOST_PP_WHILE_70(p, o, s) BOOST_PP_WHILE_70_C(BOOST_PP_BOOL(p(71, s)), p, o, s)
+# define BOOST_PP_WHILE_71(p, o, s) BOOST_PP_WHILE_71_C(BOOST_PP_BOOL(p(72, s)), p, o, s)
+# define BOOST_PP_WHILE_72(p, o, s) BOOST_PP_WHILE_72_C(BOOST_PP_BOOL(p(73, s)), p, o, s)
+# define BOOST_PP_WHILE_73(p, o, s) BOOST_PP_WHILE_73_C(BOOST_PP_BOOL(p(74, s)), p, o, s)
+# define BOOST_PP_WHILE_74(p, o, s) BOOST_PP_WHILE_74_C(BOOST_PP_BOOL(p(75, s)), p, o, s)
+# define BOOST_PP_WHILE_75(p, o, s) BOOST_PP_WHILE_75_C(BOOST_PP_BOOL(p(76, s)), p, o, s)
+# define BOOST_PP_WHILE_76(p, o, s) BOOST_PP_WHILE_76_C(BOOST_PP_BOOL(p(77, s)), p, o, s)
+# define BOOST_PP_WHILE_77(p, o, s) BOOST_PP_WHILE_77_C(BOOST_PP_BOOL(p(78, s)), p, o, s)
+# define BOOST_PP_WHILE_78(p, o, s) BOOST_PP_WHILE_78_C(BOOST_PP_BOOL(p(79, s)), p, o, s)
+# define BOOST_PP_WHILE_79(p, o, s) BOOST_PP_WHILE_79_C(BOOST_PP_BOOL(p(80, s)), p, o, s)
+# define BOOST_PP_WHILE_80(p, o, s) BOOST_PP_WHILE_80_C(BOOST_PP_BOOL(p(81, s)), p, o, s)
+# define BOOST_PP_WHILE_81(p, o, s) BOOST_PP_WHILE_81_C(BOOST_PP_BOOL(p(82, s)), p, o, s)
+# define BOOST_PP_WHILE_82(p, o, s) BOOST_PP_WHILE_82_C(BOOST_PP_BOOL(p(83, s)), p, o, s)
+# define BOOST_PP_WHILE_83(p, o, s) BOOST_PP_WHILE_83_C(BOOST_PP_BOOL(p(84, s)), p, o, s)
+# define BOOST_PP_WHILE_84(p, o, s) BOOST_PP_WHILE_84_C(BOOST_PP_BOOL(p(85, s)), p, o, s)
+# define BOOST_PP_WHILE_85(p, o, s) BOOST_PP_WHILE_85_C(BOOST_PP_BOOL(p(86, s)), p, o, s)
+# define BOOST_PP_WHILE_86(p, o, s) BOOST_PP_WHILE_86_C(BOOST_PP_BOOL(p(87, s)), p, o, s)
+# define BOOST_PP_WHILE_87(p, o, s) BOOST_PP_WHILE_87_C(BOOST_PP_BOOL(p(88, s)), p, o, s)
+# define BOOST_PP_WHILE_88(p, o, s) BOOST_PP_WHILE_88_C(BOOST_PP_BOOL(p(89, s)), p, o, s)
+# define BOOST_PP_WHILE_89(p, o, s) BOOST_PP_WHILE_89_C(BOOST_PP_BOOL(p(90, s)), p, o, s)
+# define BOOST_PP_WHILE_90(p, o, s) BOOST_PP_WHILE_90_C(BOOST_PP_BOOL(p(91, s)), p, o, s)
+# define BOOST_PP_WHILE_91(p, o, s) BOOST_PP_WHILE_91_C(BOOST_PP_BOOL(p(92, s)), p, o, s)
+# define BOOST_PP_WHILE_92(p, o, s) BOOST_PP_WHILE_92_C(BOOST_PP_BOOL(p(93, s)), p, o, s)
+# define BOOST_PP_WHILE_93(p, o, s) BOOST_PP_WHILE_93_C(BOOST_PP_BOOL(p(94, s)), p, o, s)
+# define BOOST_PP_WHILE_94(p, o, s) BOOST_PP_WHILE_94_C(BOOST_PP_BOOL(p(95, s)), p, o, s)
+# define BOOST_PP_WHILE_95(p, o, s) BOOST_PP_WHILE_95_C(BOOST_PP_BOOL(p(96, s)), p, o, s)
+# define BOOST_PP_WHILE_96(p, o, s) BOOST_PP_WHILE_96_C(BOOST_PP_BOOL(p(97, s)), p, o, s)
+# define BOOST_PP_WHILE_97(p, o, s) BOOST_PP_WHILE_97_C(BOOST_PP_BOOL(p(98, s)), p, o, s)
+# define BOOST_PP_WHILE_98(p, o, s) BOOST_PP_WHILE_98_C(BOOST_PP_BOOL(p(99, s)), p, o, s)
+# define BOOST_PP_WHILE_99(p, o, s) BOOST_PP_WHILE_99_C(BOOST_PP_BOOL(p(100, s)), p, o, s)
+# define BOOST_PP_WHILE_100(p, o, s) BOOST_PP_WHILE_100_C(BOOST_PP_BOOL(p(101, s)), p, o, s)
+# define BOOST_PP_WHILE_101(p, o, s) BOOST_PP_WHILE_101_C(BOOST_PP_BOOL(p(102, s)), p, o, s)
+# define BOOST_PP_WHILE_102(p, o, s) BOOST_PP_WHILE_102_C(BOOST_PP_BOOL(p(103, s)), p, o, s)
+# define BOOST_PP_WHILE_103(p, o, s) BOOST_PP_WHILE_103_C(BOOST_PP_BOOL(p(104, s)), p, o, s)
+# define BOOST_PP_WHILE_104(p, o, s) BOOST_PP_WHILE_104_C(BOOST_PP_BOOL(p(105, s)), p, o, s)
+# define BOOST_PP_WHILE_105(p, o, s) BOOST_PP_WHILE_105_C(BOOST_PP_BOOL(p(106, s)), p, o, s)
+# define BOOST_PP_WHILE_106(p, o, s) BOOST_PP_WHILE_106_C(BOOST_PP_BOOL(p(107, s)), p, o, s)
+# define BOOST_PP_WHILE_107(p, o, s) BOOST_PP_WHILE_107_C(BOOST_PP_BOOL(p(108, s)), p, o, s)
+# define BOOST_PP_WHILE_108(p, o, s) BOOST_PP_WHILE_108_C(BOOST_PP_BOOL(p(109, s)), p, o, s)
+# define BOOST_PP_WHILE_109(p, o, s) BOOST_PP_WHILE_109_C(BOOST_PP_BOOL(p(110, s)), p, o, s)
+# define BOOST_PP_WHILE_110(p, o, s) BOOST_PP_WHILE_110_C(BOOST_PP_BOOL(p(111, s)), p, o, s)
+# define BOOST_PP_WHILE_111(p, o, s) BOOST_PP_WHILE_111_C(BOOST_PP_BOOL(p(112, s)), p, o, s)
+# define BOOST_PP_WHILE_112(p, o, s) BOOST_PP_WHILE_112_C(BOOST_PP_BOOL(p(113, s)), p, o, s)
+# define BOOST_PP_WHILE_113(p, o, s) BOOST_PP_WHILE_113_C(BOOST_PP_BOOL(p(114, s)), p, o, s)
+# define BOOST_PP_WHILE_114(p, o, s) BOOST_PP_WHILE_114_C(BOOST_PP_BOOL(p(115, s)), p, o, s)
+# define BOOST_PP_WHILE_115(p, o, s) BOOST_PP_WHILE_115_C(BOOST_PP_BOOL(p(116, s)), p, o, s)
+# define BOOST_PP_WHILE_116(p, o, s) BOOST_PP_WHILE_116_C(BOOST_PP_BOOL(p(117, s)), p, o, s)
+# define BOOST_PP_WHILE_117(p, o, s) BOOST_PP_WHILE_117_C(BOOST_PP_BOOL(p(118, s)), p, o, s)
+# define BOOST_PP_WHILE_118(p, o, s) BOOST_PP_WHILE_118_C(BOOST_PP_BOOL(p(119, s)), p, o, s)
+# define BOOST_PP_WHILE_119(p, o, s) BOOST_PP_WHILE_119_C(BOOST_PP_BOOL(p(120, s)), p, o, s)
+# define BOOST_PP_WHILE_120(p, o, s) BOOST_PP_WHILE_120_C(BOOST_PP_BOOL(p(121, s)), p, o, s)
+# define BOOST_PP_WHILE_121(p, o, s) BOOST_PP_WHILE_121_C(BOOST_PP_BOOL(p(122, s)), p, o, s)
+# define BOOST_PP_WHILE_122(p, o, s) BOOST_PP_WHILE_122_C(BOOST_PP_BOOL(p(123, s)), p, o, s)
+# define BOOST_PP_WHILE_123(p, o, s) BOOST_PP_WHILE_123_C(BOOST_PP_BOOL(p(124, s)), p, o, s)
+# define BOOST_PP_WHILE_124(p, o, s) BOOST_PP_WHILE_124_C(BOOST_PP_BOOL(p(125, s)), p, o, s)
+# define BOOST_PP_WHILE_125(p, o, s) BOOST_PP_WHILE_125_C(BOOST_PP_BOOL(p(126, s)), p, o, s)
+# define BOOST_PP_WHILE_126(p, o, s) BOOST_PP_WHILE_126_C(BOOST_PP_BOOL(p(127, s)), p, o, s)
+# define BOOST_PP_WHILE_127(p, o, s) BOOST_PP_WHILE_127_C(BOOST_PP_BOOL(p(128, s)), p, o, s)
+# define BOOST_PP_WHILE_128(p, o, s) BOOST_PP_WHILE_128_C(BOOST_PP_BOOL(p(129, s)), p, o, s)
+# define BOOST_PP_WHILE_129(p, o, s) BOOST_PP_WHILE_129_C(BOOST_PP_BOOL(p(130, s)), p, o, s)
+# define BOOST_PP_WHILE_130(p, o, s) BOOST_PP_WHILE_130_C(BOOST_PP_BOOL(p(131, s)), p, o, s)
+# define BOOST_PP_WHILE_131(p, o, s) BOOST_PP_WHILE_131_C(BOOST_PP_BOOL(p(132, s)), p, o, s)
+# define BOOST_PP_WHILE_132(p, o, s) BOOST_PP_WHILE_132_C(BOOST_PP_BOOL(p(133, s)), p, o, s)
+# define BOOST_PP_WHILE_133(p, o, s) BOOST_PP_WHILE_133_C(BOOST_PP_BOOL(p(134, s)), p, o, s)
+# define BOOST_PP_WHILE_134(p, o, s) BOOST_PP_WHILE_134_C(BOOST_PP_BOOL(p(135, s)), p, o, s)
+# define BOOST_PP_WHILE_135(p, o, s) BOOST_PP_WHILE_135_C(BOOST_PP_BOOL(p(136, s)), p, o, s)
+# define BOOST_PP_WHILE_136(p, o, s) BOOST_PP_WHILE_136_C(BOOST_PP_BOOL(p(137, s)), p, o, s)
+# define BOOST_PP_WHILE_137(p, o, s) BOOST_PP_WHILE_137_C(BOOST_PP_BOOL(p(138, s)), p, o, s)
+# define BOOST_PP_WHILE_138(p, o, s) BOOST_PP_WHILE_138_C(BOOST_PP_BOOL(p(139, s)), p, o, s)
+# define BOOST_PP_WHILE_139(p, o, s) BOOST_PP_WHILE_139_C(BOOST_PP_BOOL(p(140, s)), p, o, s)
+# define BOOST_PP_WHILE_140(p, o, s) BOOST_PP_WHILE_140_C(BOOST_PP_BOOL(p(141, s)), p, o, s)
+# define BOOST_PP_WHILE_141(p, o, s) BOOST_PP_WHILE_141_C(BOOST_PP_BOOL(p(142, s)), p, o, s)
+# define BOOST_PP_WHILE_142(p, o, s) BOOST_PP_WHILE_142_C(BOOST_PP_BOOL(p(143, s)), p, o, s)
+# define BOOST_PP_WHILE_143(p, o, s) BOOST_PP_WHILE_143_C(BOOST_PP_BOOL(p(144, s)), p, o, s)
+# define BOOST_PP_WHILE_144(p, o, s) BOOST_PP_WHILE_144_C(BOOST_PP_BOOL(p(145, s)), p, o, s)
+# define BOOST_PP_WHILE_145(p, o, s) BOOST_PP_WHILE_145_C(BOOST_PP_BOOL(p(146, s)), p, o, s)
+# define BOOST_PP_WHILE_146(p, o, s) BOOST_PP_WHILE_146_C(BOOST_PP_BOOL(p(147, s)), p, o, s)
+# define BOOST_PP_WHILE_147(p, o, s) BOOST_PP_WHILE_147_C(BOOST_PP_BOOL(p(148, s)), p, o, s)
+# define BOOST_PP_WHILE_148(p, o, s) BOOST_PP_WHILE_148_C(BOOST_PP_BOOL(p(149, s)), p, o, s)
+# define BOOST_PP_WHILE_149(p, o, s) BOOST_PP_WHILE_149_C(BOOST_PP_BOOL(p(150, s)), p, o, s)
+# define BOOST_PP_WHILE_150(p, o, s) BOOST_PP_WHILE_150_C(BOOST_PP_BOOL(p(151, s)), p, o, s)
+# define BOOST_PP_WHILE_151(p, o, s) BOOST_PP_WHILE_151_C(BOOST_PP_BOOL(p(152, s)), p, o, s)
+# define BOOST_PP_WHILE_152(p, o, s) BOOST_PP_WHILE_152_C(BOOST_PP_BOOL(p(153, s)), p, o, s)
+# define BOOST_PP_WHILE_153(p, o, s) BOOST_PP_WHILE_153_C(BOOST_PP_BOOL(p(154, s)), p, o, s)
+# define BOOST_PP_WHILE_154(p, o, s) BOOST_PP_WHILE_154_C(BOOST_PP_BOOL(p(155, s)), p, o, s)
+# define BOOST_PP_WHILE_155(p, o, s) BOOST_PP_WHILE_155_C(BOOST_PP_BOOL(p(156, s)), p, o, s)
+# define BOOST_PP_WHILE_156(p, o, s) BOOST_PP_WHILE_156_C(BOOST_PP_BOOL(p(157, s)), p, o, s)
+# define BOOST_PP_WHILE_157(p, o, s) BOOST_PP_WHILE_157_C(BOOST_PP_BOOL(p(158, s)), p, o, s)
+# define BOOST_PP_WHILE_158(p, o, s) BOOST_PP_WHILE_158_C(BOOST_PP_BOOL(p(159, s)), p, o, s)
+# define BOOST_PP_WHILE_159(p, o, s) BOOST_PP_WHILE_159_C(BOOST_PP_BOOL(p(160, s)), p, o, s)
+# define BOOST_PP_WHILE_160(p, o, s) BOOST_PP_WHILE_160_C(BOOST_PP_BOOL(p(161, s)), p, o, s)
+# define BOOST_PP_WHILE_161(p, o, s) BOOST_PP_WHILE_161_C(BOOST_PP_BOOL(p(162, s)), p, o, s)
+# define BOOST_PP_WHILE_162(p, o, s) BOOST_PP_WHILE_162_C(BOOST_PP_BOOL(p(163, s)), p, o, s)
+# define BOOST_PP_WHILE_163(p, o, s) BOOST_PP_WHILE_163_C(BOOST_PP_BOOL(p(164, s)), p, o, s)
+# define BOOST_PP_WHILE_164(p, o, s) BOOST_PP_WHILE_164_C(BOOST_PP_BOOL(p(165, s)), p, o, s)
+# define BOOST_PP_WHILE_165(p, o, s) BOOST_PP_WHILE_165_C(BOOST_PP_BOOL(p(166, s)), p, o, s)
+# define BOOST_PP_WHILE_166(p, o, s) BOOST_PP_WHILE_166_C(BOOST_PP_BOOL(p(167, s)), p, o, s)
+# define BOOST_PP_WHILE_167(p, o, s) BOOST_PP_WHILE_167_C(BOOST_PP_BOOL(p(168, s)), p, o, s)
+# define BOOST_PP_WHILE_168(p, o, s) BOOST_PP_WHILE_168_C(BOOST_PP_BOOL(p(169, s)), p, o, s)
+# define BOOST_PP_WHILE_169(p, o, s) BOOST_PP_WHILE_169_C(BOOST_PP_BOOL(p(170, s)), p, o, s)
+# define BOOST_PP_WHILE_170(p, o, s) BOOST_PP_WHILE_170_C(BOOST_PP_BOOL(p(171, s)), p, o, s)
+# define BOOST_PP_WHILE_171(p, o, s) BOOST_PP_WHILE_171_C(BOOST_PP_BOOL(p(172, s)), p, o, s)
+# define BOOST_PP_WHILE_172(p, o, s) BOOST_PP_WHILE_172_C(BOOST_PP_BOOL(p(173, s)), p, o, s)
+# define BOOST_PP_WHILE_173(p, o, s) BOOST_PP_WHILE_173_C(BOOST_PP_BOOL(p(174, s)), p, o, s)
+# define BOOST_PP_WHILE_174(p, o, s) BOOST_PP_WHILE_174_C(BOOST_PP_BOOL(p(175, s)), p, o, s)
+# define BOOST_PP_WHILE_175(p, o, s) BOOST_PP_WHILE_175_C(BOOST_PP_BOOL(p(176, s)), p, o, s)
+# define BOOST_PP_WHILE_176(p, o, s) BOOST_PP_WHILE_176_C(BOOST_PP_BOOL(p(177, s)), p, o, s)
+# define BOOST_PP_WHILE_177(p, o, s) BOOST_PP_WHILE_177_C(BOOST_PP_BOOL(p(178, s)), p, o, s)
+# define BOOST_PP_WHILE_178(p, o, s) BOOST_PP_WHILE_178_C(BOOST_PP_BOOL(p(179, s)), p, o, s)
+# define BOOST_PP_WHILE_179(p, o, s) BOOST_PP_WHILE_179_C(BOOST_PP_BOOL(p(180, s)), p, o, s)
+# define BOOST_PP_WHILE_180(p, o, s) BOOST_PP_WHILE_180_C(BOOST_PP_BOOL(p(181, s)), p, o, s)
+# define BOOST_PP_WHILE_181(p, o, s) BOOST_PP_WHILE_181_C(BOOST_PP_BOOL(p(182, s)), p, o, s)
+# define BOOST_PP_WHILE_182(p, o, s) BOOST_PP_WHILE_182_C(BOOST_PP_BOOL(p(183, s)), p, o, s)
+# define BOOST_PP_WHILE_183(p, o, s) BOOST_PP_WHILE_183_C(BOOST_PP_BOOL(p(184, s)), p, o, s)
+# define BOOST_PP_WHILE_184(p, o, s) BOOST_PP_WHILE_184_C(BOOST_PP_BOOL(p(185, s)), p, o, s)
+# define BOOST_PP_WHILE_185(p, o, s) BOOST_PP_WHILE_185_C(BOOST_PP_BOOL(p(186, s)), p, o, s)
+# define BOOST_PP_WHILE_186(p, o, s) BOOST_PP_WHILE_186_C(BOOST_PP_BOOL(p(187, s)), p, o, s)
+# define BOOST_PP_WHILE_187(p, o, s) BOOST_PP_WHILE_187_C(BOOST_PP_BOOL(p(188, s)), p, o, s)
+# define BOOST_PP_WHILE_188(p, o, s) BOOST_PP_WHILE_188_C(BOOST_PP_BOOL(p(189, s)), p, o, s)
+# define BOOST_PP_WHILE_189(p, o, s) BOOST_PP_WHILE_189_C(BOOST_PP_BOOL(p(190, s)), p, o, s)
+# define BOOST_PP_WHILE_190(p, o, s) BOOST_PP_WHILE_190_C(BOOST_PP_BOOL(p(191, s)), p, o, s)
+# define BOOST_PP_WHILE_191(p, o, s) BOOST_PP_WHILE_191_C(BOOST_PP_BOOL(p(192, s)), p, o, s)
+# define BOOST_PP_WHILE_192(p, o, s) BOOST_PP_WHILE_192_C(BOOST_PP_BOOL(p(193, s)), p, o, s)
+# define BOOST_PP_WHILE_193(p, o, s) BOOST_PP_WHILE_193_C(BOOST_PP_BOOL(p(194, s)), p, o, s)
+# define BOOST_PP_WHILE_194(p, o, s) BOOST_PP_WHILE_194_C(BOOST_PP_BOOL(p(195, s)), p, o, s)
+# define BOOST_PP_WHILE_195(p, o, s) BOOST_PP_WHILE_195_C(BOOST_PP_BOOL(p(196, s)), p, o, s)
+# define BOOST_PP_WHILE_196(p, o, s) BOOST_PP_WHILE_196_C(BOOST_PP_BOOL(p(197, s)), p, o, s)
+# define BOOST_PP_WHILE_197(p, o, s) BOOST_PP_WHILE_197_C(BOOST_PP_BOOL(p(198, s)), p, o, s)
+# define BOOST_PP_WHILE_198(p, o, s) BOOST_PP_WHILE_198_C(BOOST_PP_BOOL(p(199, s)), p, o, s)
+# define BOOST_PP_WHILE_199(p, o, s) BOOST_PP_WHILE_199_C(BOOST_PP_BOOL(p(200, s)), p, o, s)
+# define BOOST_PP_WHILE_200(p, o, s) BOOST_PP_WHILE_200_C(BOOST_PP_BOOL(p(201, s)), p, o, s)
+# define BOOST_PP_WHILE_201(p, o, s) BOOST_PP_WHILE_201_C(BOOST_PP_BOOL(p(202, s)), p, o, s)
+# define BOOST_PP_WHILE_202(p, o, s) BOOST_PP_WHILE_202_C(BOOST_PP_BOOL(p(203, s)), p, o, s)
+# define BOOST_PP_WHILE_203(p, o, s) BOOST_PP_WHILE_203_C(BOOST_PP_BOOL(p(204, s)), p, o, s)
+# define BOOST_PP_WHILE_204(p, o, s) BOOST_PP_WHILE_204_C(BOOST_PP_BOOL(p(205, s)), p, o, s)
+# define BOOST_PP_WHILE_205(p, o, s) BOOST_PP_WHILE_205_C(BOOST_PP_BOOL(p(206, s)), p, o, s)
+# define BOOST_PP_WHILE_206(p, o, s) BOOST_PP_WHILE_206_C(BOOST_PP_BOOL(p(207, s)), p, o, s)
+# define BOOST_PP_WHILE_207(p, o, s) BOOST_PP_WHILE_207_C(BOOST_PP_BOOL(p(208, s)), p, o, s)
+# define BOOST_PP_WHILE_208(p, o, s) BOOST_PP_WHILE_208_C(BOOST_PP_BOOL(p(209, s)), p, o, s)
+# define BOOST_PP_WHILE_209(p, o, s) BOOST_PP_WHILE_209_C(BOOST_PP_BOOL(p(210, s)), p, o, s)
+# define BOOST_PP_WHILE_210(p, o, s) BOOST_PP_WHILE_210_C(BOOST_PP_BOOL(p(211, s)), p, o, s)
+# define BOOST_PP_WHILE_211(p, o, s) BOOST_PP_WHILE_211_C(BOOST_PP_BOOL(p(212, s)), p, o, s)
+# define BOOST_PP_WHILE_212(p, o, s) BOOST_PP_WHILE_212_C(BOOST_PP_BOOL(p(213, s)), p, o, s)
+# define BOOST_PP_WHILE_213(p, o, s) BOOST_PP_WHILE_213_C(BOOST_PP_BOOL(p(214, s)), p, o, s)
+# define BOOST_PP_WHILE_214(p, o, s) BOOST_PP_WHILE_214_C(BOOST_PP_BOOL(p(215, s)), p, o, s)
+# define BOOST_PP_WHILE_215(p, o, s) BOOST_PP_WHILE_215_C(BOOST_PP_BOOL(p(216, s)), p, o, s)
+# define BOOST_PP_WHILE_216(p, o, s) BOOST_PP_WHILE_216_C(BOOST_PP_BOOL(p(217, s)), p, o, s)
+# define BOOST_PP_WHILE_217(p, o, s) BOOST_PP_WHILE_217_C(BOOST_PP_BOOL(p(218, s)), p, o, s)
+# define BOOST_PP_WHILE_218(p, o, s) BOOST_PP_WHILE_218_C(BOOST_PP_BOOL(p(219, s)), p, o, s)
+# define BOOST_PP_WHILE_219(p, o, s) BOOST_PP_WHILE_219_C(BOOST_PP_BOOL(p(220, s)), p, o, s)
+# define BOOST_PP_WHILE_220(p, o, s) BOOST_PP_WHILE_220_C(BOOST_PP_BOOL(p(221, s)), p, o, s)
+# define BOOST_PP_WHILE_221(p, o, s) BOOST_PP_WHILE_221_C(BOOST_PP_BOOL(p(222, s)), p, o, s)
+# define BOOST_PP_WHILE_222(p, o, s) BOOST_PP_WHILE_222_C(BOOST_PP_BOOL(p(223, s)), p, o, s)
+# define BOOST_PP_WHILE_223(p, o, s) BOOST_PP_WHILE_223_C(BOOST_PP_BOOL(p(224, s)), p, o, s)
+# define BOOST_PP_WHILE_224(p, o, s) BOOST_PP_WHILE_224_C(BOOST_PP_BOOL(p(225, s)), p, o, s)
+# define BOOST_PP_WHILE_225(p, o, s) BOOST_PP_WHILE_225_C(BOOST_PP_BOOL(p(226, s)), p, o, s)
+# define BOOST_PP_WHILE_226(p, o, s) BOOST_PP_WHILE_226_C(BOOST_PP_BOOL(p(227, s)), p, o, s)
+# define BOOST_PP_WHILE_227(p, o, s) BOOST_PP_WHILE_227_C(BOOST_PP_BOOL(p(228, s)), p, o, s)
+# define BOOST_PP_WHILE_228(p, o, s) BOOST_PP_WHILE_228_C(BOOST_PP_BOOL(p(229, s)), p, o, s)
+# define BOOST_PP_WHILE_229(p, o, s) BOOST_PP_WHILE_229_C(BOOST_PP_BOOL(p(230, s)), p, o, s)
+# define BOOST_PP_WHILE_230(p, o, s) BOOST_PP_WHILE_230_C(BOOST_PP_BOOL(p(231, s)), p, o, s)
+# define BOOST_PP_WHILE_231(p, o, s) BOOST_PP_WHILE_231_C(BOOST_PP_BOOL(p(232, s)), p, o, s)
+# define BOOST_PP_WHILE_232(p, o, s) BOOST_PP_WHILE_232_C(BOOST_PP_BOOL(p(233, s)), p, o, s)
+# define BOOST_PP_WHILE_233(p, o, s) BOOST_PP_WHILE_233_C(BOOST_PP_BOOL(p(234, s)), p, o, s)
+# define BOOST_PP_WHILE_234(p, o, s) BOOST_PP_WHILE_234_C(BOOST_PP_BOOL(p(235, s)), p, o, s)
+# define BOOST_PP_WHILE_235(p, o, s) BOOST_PP_WHILE_235_C(BOOST_PP_BOOL(p(236, s)), p, o, s)
+# define BOOST_PP_WHILE_236(p, o, s) BOOST_PP_WHILE_236_C(BOOST_PP_BOOL(p(237, s)), p, o, s)
+# define BOOST_PP_WHILE_237(p, o, s) BOOST_PP_WHILE_237_C(BOOST_PP_BOOL(p(238, s)), p, o, s)
+# define BOOST_PP_WHILE_238(p, o, s) BOOST_PP_WHILE_238_C(BOOST_PP_BOOL(p(239, s)), p, o, s)
+# define BOOST_PP_WHILE_239(p, o, s) BOOST_PP_WHILE_239_C(BOOST_PP_BOOL(p(240, s)), p, o, s)
+# define BOOST_PP_WHILE_240(p, o, s) BOOST_PP_WHILE_240_C(BOOST_PP_BOOL(p(241, s)), p, o, s)
+# define BOOST_PP_WHILE_241(p, o, s) BOOST_PP_WHILE_241_C(BOOST_PP_BOOL(p(242, s)), p, o, s)
+# define BOOST_PP_WHILE_242(p, o, s) BOOST_PP_WHILE_242_C(BOOST_PP_BOOL(p(243, s)), p, o, s)
+# define BOOST_PP_WHILE_243(p, o, s) BOOST_PP_WHILE_243_C(BOOST_PP_BOOL(p(244, s)), p, o, s)
+# define BOOST_PP_WHILE_244(p, o, s) BOOST_PP_WHILE_244_C(BOOST_PP_BOOL(p(245, s)), p, o, s)
+# define BOOST_PP_WHILE_245(p, o, s) BOOST_PP_WHILE_245_C(BOOST_PP_BOOL(p(246, s)), p, o, s)
+# define BOOST_PP_WHILE_246(p, o, s) BOOST_PP_WHILE_246_C(BOOST_PP_BOOL(p(247, s)), p, o, s)
+# define BOOST_PP_WHILE_247(p, o, s) BOOST_PP_WHILE_247_C(BOOST_PP_BOOL(p(248, s)), p, o, s)
+# define BOOST_PP_WHILE_248(p, o, s) BOOST_PP_WHILE_248_C(BOOST_PP_BOOL(p(249, s)), p, o, s)
+# define BOOST_PP_WHILE_249(p, o, s) BOOST_PP_WHILE_249_C(BOOST_PP_BOOL(p(250, s)), p, o, s)
+# define BOOST_PP_WHILE_250(p, o, s) BOOST_PP_WHILE_250_C(BOOST_PP_BOOL(p(251, s)), p, o, s)
+# define BOOST_PP_WHILE_251(p, o, s) BOOST_PP_WHILE_251_C(BOOST_PP_BOOL(p(252, s)), p, o, s)
+# define BOOST_PP_WHILE_252(p, o, s) BOOST_PP_WHILE_252_C(BOOST_PP_BOOL(p(253, s)), p, o, s)
+# define BOOST_PP_WHILE_253(p, o, s) BOOST_PP_WHILE_253_C(BOOST_PP_BOOL(p(254, s)), p, o, s)
+# define BOOST_PP_WHILE_254(p, o, s) BOOST_PP_WHILE_254_C(BOOST_PP_BOOL(p(255, s)), p, o, s)
+# define BOOST_PP_WHILE_255(p, o, s) BOOST_PP_WHILE_255_C(BOOST_PP_BOOL(p(256, s)), p, o, s)
+# define BOOST_PP_WHILE_256(p, o, s) BOOST_PP_WHILE_256_C(BOOST_PP_BOOL(p(257, s)), p, o, s)
+#
+# define BOOST_PP_WHILE_1_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_2, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(2, s))
+# define BOOST_PP_WHILE_2_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_3, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(3, s))
+# define BOOST_PP_WHILE_3_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_4, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(4, s))
+# define BOOST_PP_WHILE_4_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_5, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(5, s))
+# define BOOST_PP_WHILE_5_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_6, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(6, s))
+# define BOOST_PP_WHILE_6_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_7, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(7, s))
+# define BOOST_PP_WHILE_7_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_8, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(8, s))
+# define BOOST_PP_WHILE_8_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_9, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(9, s))
+# define BOOST_PP_WHILE_9_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_10, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(10, s))
+# define BOOST_PP_WHILE_10_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_11, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(11, s))
+# define BOOST_PP_WHILE_11_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_12, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(12, s))
+# define BOOST_PP_WHILE_12_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_13, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(13, s))
+# define BOOST_PP_WHILE_13_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_14, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(14, s))
+# define BOOST_PP_WHILE_14_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_15, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(15, s))
+# define BOOST_PP_WHILE_15_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_16, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(16, s))
+# define BOOST_PP_WHILE_16_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_17, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(17, s))
+# define BOOST_PP_WHILE_17_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_18, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(18, s))
+# define BOOST_PP_WHILE_18_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_19, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(19, s))
+# define BOOST_PP_WHILE_19_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_20, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(20, s))
+# define BOOST_PP_WHILE_20_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_21, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(21, s))
+# define BOOST_PP_WHILE_21_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_22, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(22, s))
+# define BOOST_PP_WHILE_22_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_23, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(23, s))
+# define BOOST_PP_WHILE_23_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_24, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(24, s))
+# define BOOST_PP_WHILE_24_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_25, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(25, s))
+# define BOOST_PP_WHILE_25_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_26, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(26, s))
+# define BOOST_PP_WHILE_26_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_27, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(27, s))
+# define BOOST_PP_WHILE_27_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_28, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(28, s))
+# define BOOST_PP_WHILE_28_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_29, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(29, s))
+# define BOOST_PP_WHILE_29_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_30, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(30, s))
+# define BOOST_PP_WHILE_30_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_31, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(31, s))
+# define BOOST_PP_WHILE_31_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_32, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(32, s))
+# define BOOST_PP_WHILE_32_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_33, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(33, s))
+# define BOOST_PP_WHILE_33_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_34, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(34, s))
+# define BOOST_PP_WHILE_34_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_35, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(35, s))
+# define BOOST_PP_WHILE_35_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_36, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(36, s))
+# define BOOST_PP_WHILE_36_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_37, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(37, s))
+# define BOOST_PP_WHILE_37_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_38, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(38, s))
+# define BOOST_PP_WHILE_38_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_39, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(39, s))
+# define BOOST_PP_WHILE_39_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_40, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(40, s))
+# define BOOST_PP_WHILE_40_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_41, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(41, s))
+# define BOOST_PP_WHILE_41_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_42, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(42, s))
+# define BOOST_PP_WHILE_42_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_43, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(43, s))
+# define BOOST_PP_WHILE_43_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_44, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(44, s))
+# define BOOST_PP_WHILE_44_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_45, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(45, s))
+# define BOOST_PP_WHILE_45_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_46, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(46, s))
+# define BOOST_PP_WHILE_46_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_47, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(47, s))
+# define BOOST_PP_WHILE_47_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_48, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(48, s))
+# define BOOST_PP_WHILE_48_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_49, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(49, s))
+# define BOOST_PP_WHILE_49_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_50, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(50, s))
+# define BOOST_PP_WHILE_50_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_51, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(51, s))
+# define BOOST_PP_WHILE_51_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_52, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(52, s))
+# define BOOST_PP_WHILE_52_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_53, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(53, s))
+# define BOOST_PP_WHILE_53_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_54, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(54, s))
+# define BOOST_PP_WHILE_54_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_55, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(55, s))
+# define BOOST_PP_WHILE_55_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_56, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(56, s))
+# define BOOST_PP_WHILE_56_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_57, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(57, s))
+# define BOOST_PP_WHILE_57_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_58, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(58, s))
+# define BOOST_PP_WHILE_58_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_59, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(59, s))
+# define BOOST_PP_WHILE_59_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_60, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(60, s))
+# define BOOST_PP_WHILE_60_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_61, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(61, s))
+# define BOOST_PP_WHILE_61_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_62, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(62, s))
+# define BOOST_PP_WHILE_62_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_63, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(63, s))
+# define BOOST_PP_WHILE_63_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_64, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(64, s))
+# define BOOST_PP_WHILE_64_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_65, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(65, s))
+# define BOOST_PP_WHILE_65_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_66, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(66, s))
+# define BOOST_PP_WHILE_66_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_67, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(67, s))
+# define BOOST_PP_WHILE_67_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_68, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(68, s))
+# define BOOST_PP_WHILE_68_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_69, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(69, s))
+# define BOOST_PP_WHILE_69_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_70, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(70, s))
+# define BOOST_PP_WHILE_70_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_71, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(71, s))
+# define BOOST_PP_WHILE_71_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_72, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(72, s))
+# define BOOST_PP_WHILE_72_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_73, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(73, s))
+# define BOOST_PP_WHILE_73_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_74, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(74, s))
+# define BOOST_PP_WHILE_74_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_75, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(75, s))
+# define BOOST_PP_WHILE_75_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_76, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(76, s))
+# define BOOST_PP_WHILE_76_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_77, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(77, s))
+# define BOOST_PP_WHILE_77_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_78, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(78, s))
+# define BOOST_PP_WHILE_78_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_79, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(79, s))
+# define BOOST_PP_WHILE_79_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_80, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(80, s))
+# define BOOST_PP_WHILE_80_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_81, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(81, s))
+# define BOOST_PP_WHILE_81_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_82, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(82, s))
+# define BOOST_PP_WHILE_82_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_83, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(83, s))
+# define BOOST_PP_WHILE_83_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_84, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(84, s))
+# define BOOST_PP_WHILE_84_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_85, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(85, s))
+# define BOOST_PP_WHILE_85_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_86, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(86, s))
+# define BOOST_PP_WHILE_86_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_87, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(87, s))
+# define BOOST_PP_WHILE_87_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_88, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(88, s))
+# define BOOST_PP_WHILE_88_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_89, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(89, s))
+# define BOOST_PP_WHILE_89_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_90, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(90, s))
+# define BOOST_PP_WHILE_90_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_91, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(91, s))
+# define BOOST_PP_WHILE_91_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_92, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(92, s))
+# define BOOST_PP_WHILE_92_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_93, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(93, s))
+# define BOOST_PP_WHILE_93_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_94, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(94, s))
+# define BOOST_PP_WHILE_94_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_95, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(95, s))
+# define BOOST_PP_WHILE_95_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_96, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(96, s))
+# define BOOST_PP_WHILE_96_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_97, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(97, s))
+# define BOOST_PP_WHILE_97_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_98, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(98, s))
+# define BOOST_PP_WHILE_98_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_99, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(99, s))
+# define BOOST_PP_WHILE_99_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_100, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(100, s))
+# define BOOST_PP_WHILE_100_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_101, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(101, s))
+# define BOOST_PP_WHILE_101_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_102, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(102, s))
+# define BOOST_PP_WHILE_102_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_103, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(103, s))
+# define BOOST_PP_WHILE_103_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_104, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(104, s))
+# define BOOST_PP_WHILE_104_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_105, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(105, s))
+# define BOOST_PP_WHILE_105_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_106, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(106, s))
+# define BOOST_PP_WHILE_106_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_107, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(107, s))
+# define BOOST_PP_WHILE_107_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_108, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(108, s))
+# define BOOST_PP_WHILE_108_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_109, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(109, s))
+# define BOOST_PP_WHILE_109_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_110, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(110, s))
+# define BOOST_PP_WHILE_110_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_111, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(111, s))
+# define BOOST_PP_WHILE_111_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_112, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(112, s))
+# define BOOST_PP_WHILE_112_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_113, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(113, s))
+# define BOOST_PP_WHILE_113_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_114, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(114, s))
+# define BOOST_PP_WHILE_114_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_115, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(115, s))
+# define BOOST_PP_WHILE_115_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_116, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(116, s))
+# define BOOST_PP_WHILE_116_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_117, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(117, s))
+# define BOOST_PP_WHILE_117_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_118, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(118, s))
+# define BOOST_PP_WHILE_118_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_119, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(119, s))
+# define BOOST_PP_WHILE_119_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_120, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(120, s))
+# define BOOST_PP_WHILE_120_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_121, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(121, s))
+# define BOOST_PP_WHILE_121_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_122, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(122, s))
+# define BOOST_PP_WHILE_122_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_123, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(123, s))
+# define BOOST_PP_WHILE_123_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_124, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(124, s))
+# define BOOST_PP_WHILE_124_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_125, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(125, s))
+# define BOOST_PP_WHILE_125_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_126, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(126, s))
+# define BOOST_PP_WHILE_126_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_127, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(127, s))
+# define BOOST_PP_WHILE_127_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_128, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(128, s))
+# define BOOST_PP_WHILE_128_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_129, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(129, s))
+# define BOOST_PP_WHILE_129_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_130, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(130, s))
+# define BOOST_PP_WHILE_130_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_131, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(131, s))
+# define BOOST_PP_WHILE_131_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_132, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(132, s))
+# define BOOST_PP_WHILE_132_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_133, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(133, s))
+# define BOOST_PP_WHILE_133_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_134, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(134, s))
+# define BOOST_PP_WHILE_134_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_135, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(135, s))
+# define BOOST_PP_WHILE_135_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_136, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(136, s))
+# define BOOST_PP_WHILE_136_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_137, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(137, s))
+# define BOOST_PP_WHILE_137_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_138, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(138, s))
+# define BOOST_PP_WHILE_138_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_139, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(139, s))
+# define BOOST_PP_WHILE_139_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_140, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(140, s))
+# define BOOST_PP_WHILE_140_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_141, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(141, s))
+# define BOOST_PP_WHILE_141_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_142, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(142, s))
+# define BOOST_PP_WHILE_142_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_143, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(143, s))
+# define BOOST_PP_WHILE_143_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_144, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(144, s))
+# define BOOST_PP_WHILE_144_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_145, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(145, s))
+# define BOOST_PP_WHILE_145_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_146, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(146, s))
+# define BOOST_PP_WHILE_146_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_147, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(147, s))
+# define BOOST_PP_WHILE_147_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_148, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(148, s))
+# define BOOST_PP_WHILE_148_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_149, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(149, s))
+# define BOOST_PP_WHILE_149_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_150, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(150, s))
+# define BOOST_PP_WHILE_150_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_151, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(151, s))
+# define BOOST_PP_WHILE_151_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_152, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(152, s))
+# define BOOST_PP_WHILE_152_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_153, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(153, s))
+# define BOOST_PP_WHILE_153_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_154, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(154, s))
+# define BOOST_PP_WHILE_154_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_155, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(155, s))
+# define BOOST_PP_WHILE_155_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_156, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(156, s))
+# define BOOST_PP_WHILE_156_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_157, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(157, s))
+# define BOOST_PP_WHILE_157_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_158, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(158, s))
+# define BOOST_PP_WHILE_158_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_159, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(159, s))
+# define BOOST_PP_WHILE_159_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_160, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(160, s))
+# define BOOST_PP_WHILE_160_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_161, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(161, s))
+# define BOOST_PP_WHILE_161_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_162, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(162, s))
+# define BOOST_PP_WHILE_162_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_163, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(163, s))
+# define BOOST_PP_WHILE_163_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_164, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(164, s))
+# define BOOST_PP_WHILE_164_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_165, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(165, s))
+# define BOOST_PP_WHILE_165_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_166, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(166, s))
+# define BOOST_PP_WHILE_166_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_167, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(167, s))
+# define BOOST_PP_WHILE_167_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_168, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(168, s))
+# define BOOST_PP_WHILE_168_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_169, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(169, s))
+# define BOOST_PP_WHILE_169_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_170, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(170, s))
+# define BOOST_PP_WHILE_170_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_171, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(171, s))
+# define BOOST_PP_WHILE_171_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_172, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(172, s))
+# define BOOST_PP_WHILE_172_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_173, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(173, s))
+# define BOOST_PP_WHILE_173_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_174, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(174, s))
+# define BOOST_PP_WHILE_174_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_175, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(175, s))
+# define BOOST_PP_WHILE_175_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_176, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(176, s))
+# define BOOST_PP_WHILE_176_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_177, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(177, s))
+# define BOOST_PP_WHILE_177_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_178, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(178, s))
+# define BOOST_PP_WHILE_178_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_179, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(179, s))
+# define BOOST_PP_WHILE_179_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_180, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(180, s))
+# define BOOST_PP_WHILE_180_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_181, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(181, s))
+# define BOOST_PP_WHILE_181_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_182, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(182, s))
+# define BOOST_PP_WHILE_182_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_183, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(183, s))
+# define BOOST_PP_WHILE_183_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_184, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(184, s))
+# define BOOST_PP_WHILE_184_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_185, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(185, s))
+# define BOOST_PP_WHILE_185_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_186, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(186, s))
+# define BOOST_PP_WHILE_186_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_187, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(187, s))
+# define BOOST_PP_WHILE_187_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_188, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(188, s))
+# define BOOST_PP_WHILE_188_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_189, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(189, s))
+# define BOOST_PP_WHILE_189_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_190, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(190, s))
+# define BOOST_PP_WHILE_190_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_191, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(191, s))
+# define BOOST_PP_WHILE_191_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_192, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(192, s))
+# define BOOST_PP_WHILE_192_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_193, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(193, s))
+# define BOOST_PP_WHILE_193_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_194, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(194, s))
+# define BOOST_PP_WHILE_194_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_195, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(195, s))
+# define BOOST_PP_WHILE_195_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_196, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(196, s))
+# define BOOST_PP_WHILE_196_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_197, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(197, s))
+# define BOOST_PP_WHILE_197_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_198, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(198, s))
+# define BOOST_PP_WHILE_198_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_199, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(199, s))
+# define BOOST_PP_WHILE_199_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_200, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(200, s))
+# define BOOST_PP_WHILE_200_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_201, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(201, s))
+# define BOOST_PP_WHILE_201_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_202, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(202, s))
+# define BOOST_PP_WHILE_202_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_203, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(203, s))
+# define BOOST_PP_WHILE_203_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_204, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(204, s))
+# define BOOST_PP_WHILE_204_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_205, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(205, s))
+# define BOOST_PP_WHILE_205_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_206, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(206, s))
+# define BOOST_PP_WHILE_206_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_207, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(207, s))
+# define BOOST_PP_WHILE_207_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_208, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(208, s))
+# define BOOST_PP_WHILE_208_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_209, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(209, s))
+# define BOOST_PP_WHILE_209_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_210, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(210, s))
+# define BOOST_PP_WHILE_210_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_211, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(211, s))
+# define BOOST_PP_WHILE_211_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_212, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(212, s))
+# define BOOST_PP_WHILE_212_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_213, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(213, s))
+# define BOOST_PP_WHILE_213_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_214, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(214, s))
+# define BOOST_PP_WHILE_214_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_215, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(215, s))
+# define BOOST_PP_WHILE_215_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_216, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(216, s))
+# define BOOST_PP_WHILE_216_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_217, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(217, s))
+# define BOOST_PP_WHILE_217_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_218, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(218, s))
+# define BOOST_PP_WHILE_218_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_219, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(219, s))
+# define BOOST_PP_WHILE_219_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_220, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(220, s))
+# define BOOST_PP_WHILE_220_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_221, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(221, s))
+# define BOOST_PP_WHILE_221_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_222, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(222, s))
+# define BOOST_PP_WHILE_222_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_223, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(223, s))
+# define BOOST_PP_WHILE_223_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_224, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(224, s))
+# define BOOST_PP_WHILE_224_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_225, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(225, s))
+# define BOOST_PP_WHILE_225_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_226, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(226, s))
+# define BOOST_PP_WHILE_226_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_227, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(227, s))
+# define BOOST_PP_WHILE_227_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_228, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(228, s))
+# define BOOST_PP_WHILE_228_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_229, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(229, s))
+# define BOOST_PP_WHILE_229_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_230, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(230, s))
+# define BOOST_PP_WHILE_230_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_231, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(231, s))
+# define BOOST_PP_WHILE_231_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_232, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(232, s))
+# define BOOST_PP_WHILE_232_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_233, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(233, s))
+# define BOOST_PP_WHILE_233_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_234, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(234, s))
+# define BOOST_PP_WHILE_234_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_235, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(235, s))
+# define BOOST_PP_WHILE_235_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_236, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(236, s))
+# define BOOST_PP_WHILE_236_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_237, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(237, s))
+# define BOOST_PP_WHILE_237_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_238, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(238, s))
+# define BOOST_PP_WHILE_238_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_239, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(239, s))
+# define BOOST_PP_WHILE_239_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_240, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(240, s))
+# define BOOST_PP_WHILE_240_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_241, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(241, s))
+# define BOOST_PP_WHILE_241_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_242, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(242, s))
+# define BOOST_PP_WHILE_242_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_243, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(243, s))
+# define BOOST_PP_WHILE_243_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_244, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(244, s))
+# define BOOST_PP_WHILE_244_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_245, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(245, s))
+# define BOOST_PP_WHILE_245_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_246, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(246, s))
+# define BOOST_PP_WHILE_246_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_247, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(247, s))
+# define BOOST_PP_WHILE_247_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_248, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(248, s))
+# define BOOST_PP_WHILE_248_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_249, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(249, s))
+# define BOOST_PP_WHILE_249_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_250, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(250, s))
+# define BOOST_PP_WHILE_250_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_251, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(251, s))
+# define BOOST_PP_WHILE_251_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_252, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(252, s))
+# define BOOST_PP_WHILE_252_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_253, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(253, s))
+# define BOOST_PP_WHILE_253_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_254, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(254, s))
+# define BOOST_PP_WHILE_254_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_255, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(255, s))
+# define BOOST_PP_WHILE_255_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_256, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(256, s))
+# define BOOST_PP_WHILE_256_C(c, p, o, s) BOOST_PP_IIF(c, BOOST_PP_WHILE_257, s BOOST_PP_TUPLE_EAT_3)(p, o, BOOST_PP_IIF(c, o, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_2)(257, s))
+#
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/if.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/if.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/if.hpp	(working copy)
@@ -0,0 +1,30 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CONTROL_IF_HPP
+# define BOOST_PREPROCESSOR_CONTROL_IF_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/control/iif.hpp>
+# include <boost/preprocessor/logical/bool.hpp>
+#
+# /* BOOST_PP_IF */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_IF(cond, t, f) BOOST_PP_IIF(BOOST_PP_BOOL(cond), t, f)
+# else
+#    define BOOST_PP_IF(cond, t, f) BOOST_PP_IF_I(cond, t, f)
+#    define BOOST_PP_IF_I(cond, t, f) BOOST_PP_IIF(BOOST_PP_BOOL(cond), t, f)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/expr_iif.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/expr_iif.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/expr_iif.hpp	(working copy)
@@ -0,0 +1,31 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CONTROL_EXPR_IIF_HPP
+# define BOOST_PREPROCESSOR_CONTROL_EXPR_IIF_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_EXPR_IIF */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_EXPR_IIF(bit, expr) BOOST_PP_EXPR_IIF_I(bit, expr)
+# else
+#    define BOOST_PP_EXPR_IIF(bit, expr) BOOST_PP_EXPR_IIF_OO((bit, expr))
+#    define BOOST_PP_EXPR_IIF_OO(par) BOOST_PP_EXPR_IIF_I ## par
+# endif
+#
+# define BOOST_PP_EXPR_IIF_I(bit, expr) BOOST_PP_EXPR_IIF_ ## bit(expr)
+#
+# define BOOST_PP_EXPR_IIF_0(expr)
+# define BOOST_PP_EXPR_IIF_1(expr) expr
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/iif.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/iif.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/iif.hpp	(working copy)
@@ -0,0 +1,34 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CONTROL_IIF_HPP
+# define BOOST_PREPROCESSOR_CONTROL_IIF_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_IIF(bit, t, f) BOOST_PP_IIF_I(bit, t, f)
+# else
+#    define BOOST_PP_IIF(bit, t, f) BOOST_PP_IIF_OO((bit, t, f))
+#    define BOOST_PP_IIF_OO(par) BOOST_PP_IIF_I ## par
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_IIF_I(bit, t, f) BOOST_PP_IIF_ ## bit(t, f)
+# else
+#    define BOOST_PP_IIF_I(bit, t, f) BOOST_PP_IIF_II(BOOST_PP_IIF_ ## bit(t, f))
+#    define BOOST_PP_IIF_II(id) id
+# endif
+#
+# define BOOST_PP_IIF_0(t, f) f
+# define BOOST_PP_IIF_1(t, f) t
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/while.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/while.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/control/while.hpp	(working copy)
@@ -0,0 +1,312 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CONTROL_WHILE_HPP
+# define BOOST_PREPROCESSOR_CONTROL_WHILE_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/debug/error.hpp>
+# include <boost/preprocessor/detail/auto_rec.hpp>
+# include <boost/preprocessor/list/fold_left.hpp>
+# include <boost/preprocessor/list/fold_right.hpp>
+# include <boost/preprocessor/logical/bitand.hpp>
+#
+# /* BOOST_PP_WHILE */
+#
+# if 0
+#    define BOOST_PP_WHILE(pred, op, state)
+# endif
+#
+# define BOOST_PP_WHILE BOOST_PP_CAT(BOOST_PP_WHILE_, BOOST_PP_AUTO_REC(BOOST_PP_WHILE_P, 256))
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_WHILE_P(n) BOOST_PP_BITAND(BOOST_PP_CAT(BOOST_PP_WHILE_CHECK_, BOOST_PP_WHILE_ ## n(BOOST_PP_WHILE_F, BOOST_PP_NIL, BOOST_PP_NIL)), BOOST_PP_BITAND(BOOST_PP_CAT(BOOST_PP_LIST_FOLD_LEFT_CHECK_, BOOST_PP_LIST_FOLD_LEFT_ ## n(BOOST_PP_NIL, BOOST_PP_NIL, BOOST_PP_NIL)), BOOST_PP_CAT(BOOST_PP_LIST_FOLD_RIGHT_CHECK_, BOOST_PP_LIST_FOLD_RIGHT_ ## n(BOOST_PP_NIL, BOOST_PP_NIL, BOOST_PP_NIL))))
+# else
+#    define BOOST_PP_WHILE_P(n) BOOST_PP_BITAND(BOOST_PP_CAT(BOOST_PP_WHILE_CHECK_, BOOST_PP_WHILE_ ## n(BOOST_PP_WHILE_F, BOOST_PP_NIL, BOOST_PP_NIL)), BOOST_PP_CAT(BOOST_PP_LIST_FOLD_LEFT_CHECK_, BOOST_PP_LIST_FOLD_LEFT_ ## n(BOOST_PP_NIL, BOOST_PP_NIL, BOOST_PP_NIL)))
+# endif
+#
+# define BOOST_PP_WHILE_F(d, _) 0
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    include <boost/preprocessor/control/detail/edg/while.hpp>
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    include <boost/preprocessor/control/detail/msvc/while.hpp>
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()
+#    include <boost/preprocessor/control/detail/dmc/while.hpp>
+# else
+#    include <boost/preprocessor/control/detail/while.hpp>
+# endif
+#
+# define BOOST_PP_WHILE_257(p, o, s) BOOST_PP_ERROR(0x0001)
+#
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_NIL 1
+#
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_1(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_2(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_3(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_4(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_5(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_6(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_7(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_8(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_9(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_10(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_11(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_12(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_13(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_14(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_15(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_16(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_17(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_18(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_19(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_20(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_21(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_22(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_23(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_24(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_25(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_26(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_27(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_28(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_29(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_30(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_31(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_32(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_33(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_34(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_35(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_36(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_37(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_38(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_39(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_40(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_41(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_42(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_43(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_44(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_45(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_46(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_47(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_48(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_49(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_50(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_51(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_52(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_53(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_54(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_55(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_56(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_57(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_58(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_59(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_60(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_61(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_62(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_63(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_64(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_65(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_66(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_67(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_68(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_69(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_70(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_71(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_72(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_73(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_74(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_75(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_76(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_77(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_78(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_79(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_80(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_81(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_82(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_83(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_84(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_85(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_86(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_87(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_88(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_89(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_90(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_91(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_92(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_93(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_94(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_95(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_96(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_97(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_98(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_99(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_100(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_101(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_102(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_103(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_104(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_105(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_106(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_107(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_108(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_109(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_110(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_111(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_112(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_113(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_114(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_115(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_116(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_117(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_118(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_119(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_120(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_121(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_122(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_123(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_124(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_125(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_126(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_127(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_128(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_129(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_130(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_131(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_132(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_133(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_134(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_135(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_136(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_137(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_138(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_139(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_140(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_141(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_142(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_143(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_144(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_145(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_146(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_147(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_148(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_149(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_150(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_151(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_152(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_153(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_154(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_155(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_156(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_157(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_158(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_159(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_160(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_161(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_162(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_163(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_164(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_165(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_166(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_167(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_168(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_169(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_170(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_171(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_172(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_173(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_174(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_175(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_176(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_177(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_178(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_179(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_180(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_181(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_182(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_183(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_184(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_185(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_186(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_187(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_188(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_189(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_190(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_191(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_192(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_193(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_194(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_195(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_196(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_197(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_198(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_199(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_200(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_201(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_202(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_203(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_204(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_205(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_206(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_207(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_208(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_209(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_210(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_211(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_212(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_213(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_214(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_215(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_216(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_217(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_218(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_219(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_220(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_221(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_222(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_223(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_224(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_225(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_226(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_227(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_228(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_229(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_230(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_231(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_232(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_233(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_234(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_235(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_236(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_237(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_238(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_239(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_240(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_241(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_242(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_243(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_244(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_245(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_246(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_247(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_248(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_249(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_250(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_251(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_252(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_253(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_254(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_255(p, o, s) 0
+# define BOOST_PP_WHILE_CHECK_BOOST_PP_WHILE_256(p, o, s) 0
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/detail/def.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/detail/def.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/detail/def.hpp	(working copy)
@@ -0,0 +1,49 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SLOT_DETAIL_DEF_HPP
+# define BOOST_PREPROCESSOR_SLOT_DETAIL_DEF_HPP
+#
+# /* BOOST_PP_SLOT_OFFSET_x */
+#
+# define BOOST_PP_SLOT_OFFSET_10(x) (x) % 1000000000UL
+# define BOOST_PP_SLOT_OFFSET_9(x) BOOST_PP_SLOT_OFFSET_10(x) % 100000000UL
+# define BOOST_PP_SLOT_OFFSET_8(x) BOOST_PP_SLOT_OFFSET_9(x) % 10000000UL
+# define BOOST_PP_SLOT_OFFSET_7(x) BOOST_PP_SLOT_OFFSET_8(x) % 1000000UL
+# define BOOST_PP_SLOT_OFFSET_6(x) BOOST_PP_SLOT_OFFSET_7(x) % 100000UL
+# define BOOST_PP_SLOT_OFFSET_5(x) BOOST_PP_SLOT_OFFSET_6(x) % 10000UL
+# define BOOST_PP_SLOT_OFFSET_4(x) BOOST_PP_SLOT_OFFSET_5(x) % 1000UL
+# define BOOST_PP_SLOT_OFFSET_3(x) BOOST_PP_SLOT_OFFSET_4(x) % 100UL
+# define BOOST_PP_SLOT_OFFSET_2(x) BOOST_PP_SLOT_OFFSET_3(x) % 10UL
+#
+# /* BOOST_PP_SLOT_CC_x */
+#
+# define BOOST_PP_SLOT_CC_2(a, b) BOOST_PP_SLOT_CC_2_D(a, b)
+# define BOOST_PP_SLOT_CC_3(a, b, c) BOOST_PP_SLOT_CC_3_D(a, b, c)
+# define BOOST_PP_SLOT_CC_4(a, b, c, d) BOOST_PP_SLOT_CC_4_D(a, b, c, d)
+# define BOOST_PP_SLOT_CC_5(a, b, c, d, e) BOOST_PP_SLOT_CC_5_D(a, b, c, d, e)
+# define BOOST_PP_SLOT_CC_6(a, b, c, d, e, f) BOOST_PP_SLOT_CC_6_D(a, b, c, d, e, f)
+# define BOOST_PP_SLOT_CC_7(a, b, c, d, e, f, g) BOOST_PP_SLOT_CC_7_D(a, b, c, d, e, f, g)
+# define BOOST_PP_SLOT_CC_8(a, b, c, d, e, f, g, h) BOOST_PP_SLOT_CC_8_D(a, b, c, d, e, f, g, h)
+# define BOOST_PP_SLOT_CC_9(a, b, c, d, e, f, g, h, i) BOOST_PP_SLOT_CC_9_D(a, b, c, d, e, f, g, h, i)
+# define BOOST_PP_SLOT_CC_10(a, b, c, d, e, f, g, h, i, j) BOOST_PP_SLOT_CC_10_D(a, b, c, d, e, f, g, h, i, j)
+#
+# define BOOST_PP_SLOT_CC_2_D(a, b) a ## b
+# define BOOST_PP_SLOT_CC_3_D(a, b, c) a ## b ## c
+# define BOOST_PP_SLOT_CC_4_D(a, b, c, d) a ## b ## c ## d
+# define BOOST_PP_SLOT_CC_5_D(a, b, c, d, e) a ## b ## c ## d ## e
+# define BOOST_PP_SLOT_CC_6_D(a, b, c, d, e, f) a ## b ## c ## d ## e ## f
+# define BOOST_PP_SLOT_CC_7_D(a, b, c, d, e, f, g) a ## b ## c ## d ## e ## f ## g
+# define BOOST_PP_SLOT_CC_8_D(a, b, c, d, e, f, g, h) a ## b ## c ## d ## e ## f ## g ## h
+# define BOOST_PP_SLOT_CC_9_D(a, b, c, d, e, f, g, h, i) a ## b ## c ## d ## e ## f ## g ## h ## i
+# define BOOST_PP_SLOT_CC_10_D(a, b, c, d, e, f, g, h, i, j) a ## b ## c ## d ## e ## f ## g ## h ## i ## j
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/detail/shared.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/detail/shared.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/detail/shared.hpp	(working copy)
@@ -0,0 +1,247 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PP_VALUE
+#    error BOOST_PP_ERROR:  BOOST_PP_VALUE is not defined
+# endif
+#
+# undef BOOST_PP_SLOT_TEMP_1
+# undef BOOST_PP_SLOT_TEMP_2
+# undef BOOST_PP_SLOT_TEMP_3
+# undef BOOST_PP_SLOT_TEMP_4
+# undef BOOST_PP_SLOT_TEMP_5
+# undef BOOST_PP_SLOT_TEMP_6
+# undef BOOST_PP_SLOT_TEMP_7
+# undef BOOST_PP_SLOT_TEMP_8
+# undef BOOST_PP_SLOT_TEMP_9
+# undef BOOST_PP_SLOT_TEMP_10
+#
+# if (BOOST_PP_VALUE) / 1000000000UL == 0
+#    define BOOST_PP_SLOT_TEMP_10 0
+# elif (BOOST_PP_VALUE) / 1000000000UL == 1
+#    define BOOST_PP_SLOT_TEMP_10 1
+# elif (BOOST_PP_VALUE) / 1000000000UL == 2
+#    define BOOST_PP_SLOT_TEMP_10 2
+# elif (BOOST_PP_VALUE) / 1000000000UL == 3
+#    define BOOST_PP_SLOT_TEMP_10 3
+# elif (BOOST_PP_VALUE) / 1000000000UL == 4
+#    define BOOST_PP_SLOT_TEMP_10 4
+# elif (BOOST_PP_VALUE) / 1000000000UL == 5
+#    define BOOST_PP_SLOT_TEMP_10 5
+# elif (BOOST_PP_VALUE) / 1000000000UL == 6
+#    define BOOST_PP_SLOT_TEMP_10 6
+# elif (BOOST_PP_VALUE) / 1000000000UL == 7
+#    define BOOST_PP_SLOT_TEMP_10 7
+# elif (BOOST_PP_VALUE) / 1000000000UL == 8
+#    define BOOST_PP_SLOT_TEMP_10 8
+# elif (BOOST_PP_VALUE) / 1000000000UL == 9
+#    define BOOST_PP_SLOT_TEMP_10 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 0
+#    define BOOST_PP_SLOT_TEMP_9 0
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 1
+#    define BOOST_PP_SLOT_TEMP_9 1
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 2
+#    define BOOST_PP_SLOT_TEMP_9 2
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 3
+#    define BOOST_PP_SLOT_TEMP_9 3
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 4
+#    define BOOST_PP_SLOT_TEMP_9 4
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 5
+#    define BOOST_PP_SLOT_TEMP_9 5
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 6
+#    define BOOST_PP_SLOT_TEMP_9 6
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 7
+#    define BOOST_PP_SLOT_TEMP_9 7
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 8
+#    define BOOST_PP_SLOT_TEMP_9 8
+# elif BOOST_PP_SLOT_OFFSET_10(BOOST_PP_VALUE) / 100000000UL == 9
+#    define BOOST_PP_SLOT_TEMP_9 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 0
+#    define BOOST_PP_SLOT_TEMP_8 0
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 1
+#    define BOOST_PP_SLOT_TEMP_8 1
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 2
+#    define BOOST_PP_SLOT_TEMP_8 2
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 3
+#    define BOOST_PP_SLOT_TEMP_8 3
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 4
+#    define BOOST_PP_SLOT_TEMP_8 4
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 5
+#    define BOOST_PP_SLOT_TEMP_8 5
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 6
+#    define BOOST_PP_SLOT_TEMP_8 6
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 7
+#    define BOOST_PP_SLOT_TEMP_8 7
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 8
+#    define BOOST_PP_SLOT_TEMP_8 8
+# elif BOOST_PP_SLOT_OFFSET_9(BOOST_PP_VALUE) / 10000000UL == 9
+#    define BOOST_PP_SLOT_TEMP_8 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 0
+#    define BOOST_PP_SLOT_TEMP_7 0
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 1
+#    define BOOST_PP_SLOT_TEMP_7 1
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 2
+#    define BOOST_PP_SLOT_TEMP_7 2
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 3
+#    define BOOST_PP_SLOT_TEMP_7 3
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 4
+#    define BOOST_PP_SLOT_TEMP_7 4
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 5
+#    define BOOST_PP_SLOT_TEMP_7 5
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 6
+#    define BOOST_PP_SLOT_TEMP_7 6
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 7
+#    define BOOST_PP_SLOT_TEMP_7 7
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 8
+#    define BOOST_PP_SLOT_TEMP_7 8
+# elif BOOST_PP_SLOT_OFFSET_8(BOOST_PP_VALUE) / 1000000UL == 9
+#    define BOOST_PP_SLOT_TEMP_7 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 0
+#    define BOOST_PP_SLOT_TEMP_6 0
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 1
+#    define BOOST_PP_SLOT_TEMP_6 1
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 2
+#    define BOOST_PP_SLOT_TEMP_6 2
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 3
+#    define BOOST_PP_SLOT_TEMP_6 3
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 4
+#    define BOOST_PP_SLOT_TEMP_6 4
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 5
+#    define BOOST_PP_SLOT_TEMP_6 5
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 6
+#    define BOOST_PP_SLOT_TEMP_6 6
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 7
+#    define BOOST_PP_SLOT_TEMP_6 7
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 8
+#    define BOOST_PP_SLOT_TEMP_6 8
+# elif BOOST_PP_SLOT_OFFSET_7(BOOST_PP_VALUE) / 100000UL == 9
+#    define BOOST_PP_SLOT_TEMP_6 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 0
+#    define BOOST_PP_SLOT_TEMP_5 0
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 1
+#    define BOOST_PP_SLOT_TEMP_5 1
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 2
+#    define BOOST_PP_SLOT_TEMP_5 2
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 3
+#    define BOOST_PP_SLOT_TEMP_5 3
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 4
+#    define BOOST_PP_SLOT_TEMP_5 4
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 5
+#    define BOOST_PP_SLOT_TEMP_5 5
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 6
+#    define BOOST_PP_SLOT_TEMP_5 6
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 7
+#    define BOOST_PP_SLOT_TEMP_5 7
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 8
+#    define BOOST_PP_SLOT_TEMP_5 8
+# elif BOOST_PP_SLOT_OFFSET_6(BOOST_PP_VALUE) / 10000UL == 9
+#    define BOOST_PP_SLOT_TEMP_5 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 0
+#    define BOOST_PP_SLOT_TEMP_4 0
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 1
+#    define BOOST_PP_SLOT_TEMP_4 1
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 2
+#    define BOOST_PP_SLOT_TEMP_4 2
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 3
+#    define BOOST_PP_SLOT_TEMP_4 3
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 4
+#    define BOOST_PP_SLOT_TEMP_4 4
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 5
+#    define BOOST_PP_SLOT_TEMP_4 5
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 6
+#    define BOOST_PP_SLOT_TEMP_4 6
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 7
+#    define BOOST_PP_SLOT_TEMP_4 7
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 8
+#    define BOOST_PP_SLOT_TEMP_4 8
+# elif BOOST_PP_SLOT_OFFSET_5(BOOST_PP_VALUE) / 1000UL == 9
+#    define BOOST_PP_SLOT_TEMP_4 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 0
+#    define BOOST_PP_SLOT_TEMP_3 0
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 1
+#    define BOOST_PP_SLOT_TEMP_3 1
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 2
+#    define BOOST_PP_SLOT_TEMP_3 2
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 3
+#    define BOOST_PP_SLOT_TEMP_3 3
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 4
+#    define BOOST_PP_SLOT_TEMP_3 4
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 5
+#    define BOOST_PP_SLOT_TEMP_3 5
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 6
+#    define BOOST_PP_SLOT_TEMP_3 6
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 7
+#    define BOOST_PP_SLOT_TEMP_3 7
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 8
+#    define BOOST_PP_SLOT_TEMP_3 8
+# elif BOOST_PP_SLOT_OFFSET_4(BOOST_PP_VALUE) / 100UL == 9
+#    define BOOST_PP_SLOT_TEMP_3 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 0
+#    define BOOST_PP_SLOT_TEMP_2 0
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 1
+#    define BOOST_PP_SLOT_TEMP_2 1
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 2
+#    define BOOST_PP_SLOT_TEMP_2 2
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 3
+#    define BOOST_PP_SLOT_TEMP_2 3
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 4
+#    define BOOST_PP_SLOT_TEMP_2 4
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 5
+#    define BOOST_PP_SLOT_TEMP_2 5
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 6
+#    define BOOST_PP_SLOT_TEMP_2 6
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 7
+#    define BOOST_PP_SLOT_TEMP_2 7
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 8
+#    define BOOST_PP_SLOT_TEMP_2 8
+# elif BOOST_PP_SLOT_OFFSET_3(BOOST_PP_VALUE) / 10UL == 9
+#    define BOOST_PP_SLOT_TEMP_2 9
+# endif
+#
+# if BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 0
+#    define BOOST_PP_SLOT_TEMP_1 0
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 1
+#    define BOOST_PP_SLOT_TEMP_1 1
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 2
+#    define BOOST_PP_SLOT_TEMP_1 2
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 3
+#    define BOOST_PP_SLOT_TEMP_1 3
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 4
+#    define BOOST_PP_SLOT_TEMP_1 4
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 5
+#    define BOOST_PP_SLOT_TEMP_1 5
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 6
+#    define BOOST_PP_SLOT_TEMP_1 6
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 7
+#    define BOOST_PP_SLOT_TEMP_1 7
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 8
+#    define BOOST_PP_SLOT_TEMP_1 8
+# elif BOOST_PP_SLOT_OFFSET_2(BOOST_PP_VALUE) == 9
+#    define BOOST_PP_SLOT_TEMP_1 9
+# endif
+#
+# undef BOOST_PP_VALUE
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/slot.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/slot.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/slot/slot.hpp	(working copy)
@@ -0,0 +1,32 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SLOT_SLOT_HPP
+# define BOOST_PREPROCESSOR_SLOT_SLOT_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/slot/detail/def.hpp>
+#
+# /* BOOST_PP_ASSIGN_SLOT */
+#
+# define BOOST_PP_ASSIGN_SLOT(i) BOOST_PP_CAT(BOOST_PP_ASSIGN_SLOT_, i)
+#
+# define BOOST_PP_ASSIGN_SLOT_1 <boost/preprocessor/slot/detail/slot1.hpp>
+# define BOOST_PP_ASSIGN_SLOT_2 <boost/preprocessor/slot/detail/slot2.hpp>
+# define BOOST_PP_ASSIGN_SLOT_3 <boost/preprocessor/slot/detail/slot3.hpp>
+# define BOOST_PP_ASSIGN_SLOT_4 <boost/preprocessor/slot/detail/slot4.hpp>
+# define BOOST_PP_ASSIGN_SLOT_5 <boost/preprocessor/slot/detail/slot5.hpp>
+#
+# /* BOOST_PP_SLOT */
+#
+# define BOOST_PP_SLOT(i) BOOST_PP_CAT(BOOST_PP_SLOT_, i)()
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/empty.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/empty.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/empty.hpp	(working copy)
@@ -0,0 +1,17 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_EMPTY_HPP
+# define BOOST_PREPROCESSOR_EMPTY_HPP
+#
+# include <boost/preprocessor/facilities/empty.hpp>
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/debug/error.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/debug/error.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/debug/error.hpp	(working copy)
@@ -0,0 +1,33 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_DEBUG_ERROR_HPP
+# define BOOST_PREPROCESSOR_DEBUG_ERROR_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_ERROR */
+#
+# if BOOST_PP_CONFIG_ERRORS
+#    define BOOST_PP_ERROR(code) BOOST_PP_CAT(BOOST_PP_ERROR_, code)
+# endif
+#
+# define BOOST_PP_ERROR_0x0000 BOOST_PP_ERROR(0x0000, BOOST_PP_INDEX_OUT_OF_BOUNDS)
+# define BOOST_PP_ERROR_0x0001 BOOST_PP_ERROR(0x0001, BOOST_PP_WHILE_OVERFLOW)
+# define BOOST_PP_ERROR_0x0002 BOOST_PP_ERROR(0x0002, BOOST_PP_FOR_OVERFLOW)
+# define BOOST_PP_ERROR_0x0003 BOOST_PP_ERROR(0x0003, BOOST_PP_REPEAT_OVERFLOW)
+# define BOOST_PP_ERROR_0x0004 BOOST_PP_ERROR(0x0004, BOOST_PP_LIST_FOLD_OVERFLOW)
+# define BOOST_PP_ERROR_0x0005 BOOST_PP_ERROR(0x0005, BOOST_PP_SEQ_FOLD_OVERFLOW)
+# define BOOST_PP_ERROR_0x0006 BOOST_PP_ERROR(0x0006, BOOST_PP_ARITHMETIC_OVERFLOW)
+# define BOOST_PP_ERROR_0x0007 BOOST_PP_ERROR(0x0007, BOOST_PP_DIVISION_BY_ZERO)
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/eat.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/eat.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/eat.hpp	(working copy)
@@ -0,0 +1,57 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_TUPLE_EAT_HPP
+# define BOOST_PREPROCESSOR_TUPLE_EAT_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_TUPLE_EAT */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_TUPLE_EAT(size) BOOST_PP_TUPLE_EAT_I(size)
+# else
+#    define BOOST_PP_TUPLE_EAT(size) BOOST_PP_TUPLE_EAT_OO((size))
+#    define BOOST_PP_TUPLE_EAT_OO(par) BOOST_PP_TUPLE_EAT_I ## par
+# endif
+#
+# define BOOST_PP_TUPLE_EAT_I(size) BOOST_PP_TUPLE_EAT_ ## size
+#
+# define BOOST_PP_TUPLE_EAT_0()
+# define BOOST_PP_TUPLE_EAT_1(a)
+# define BOOST_PP_TUPLE_EAT_2(a, b)
+# define BOOST_PP_TUPLE_EAT_3(a, b, c)
+# define BOOST_PP_TUPLE_EAT_4(a, b, c, d)
+# define BOOST_PP_TUPLE_EAT_5(a, b, c, d, e)
+# define BOOST_PP_TUPLE_EAT_6(a, b, c, d, e, f)
+# define BOOST_PP_TUPLE_EAT_7(a, b, c, d, e, f, g)
+# define BOOST_PP_TUPLE_EAT_8(a, b, c, d, e, f, g, h)
+# define BOOST_PP_TUPLE_EAT_9(a, b, c, d, e, f, g, h, i)
+# define BOOST_PP_TUPLE_EAT_10(a, b, c, d, e, f, g, h, i, j)
+# define BOOST_PP_TUPLE_EAT_11(a, b, c, d, e, f, g, h, i, j, k)
+# define BOOST_PP_TUPLE_EAT_12(a, b, c, d, e, f, g, h, i, j, k, l)
+# define BOOST_PP_TUPLE_EAT_13(a, b, c, d, e, f, g, h, i, j, k, l, m)
+# define BOOST_PP_TUPLE_EAT_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n)
+# define BOOST_PP_TUPLE_EAT_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
+# define BOOST_PP_TUPLE_EAT_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
+# define BOOST_PP_TUPLE_EAT_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
+# define BOOST_PP_TUPLE_EAT_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
+# define BOOST_PP_TUPLE_EAT_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
+# define BOOST_PP_TUPLE_EAT_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
+# define BOOST_PP_TUPLE_EAT_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
+# define BOOST_PP_TUPLE_EAT_22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
+# define BOOST_PP_TUPLE_EAT_23(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
+# define BOOST_PP_TUPLE_EAT_24(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
+# define BOOST_PP_TUPLE_EAT_25(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/to_list.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/to_list.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/to_list.hpp	(working copy)
@@ -0,0 +1,62 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_TUPLE_TO_LIST_HPP
+# define BOOST_PREPROCESSOR_TUPLE_TO_LIST_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_TUPLE_TO_LIST */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_TUPLE_TO_LIST(size, tuple) BOOST_PP_TUPLE_TO_LIST_I(size, tuple)
+#    if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#        define BOOST_PP_TUPLE_TO_LIST_I(s, t) BOOST_PP_TUPLE_TO_LIST_ ## s t
+#    else
+#        define BOOST_PP_TUPLE_TO_LIST_I(s, t) BOOST_PP_TUPLE_TO_LIST_II(BOOST_PP_TUPLE_TO_LIST_ ## s t)
+#        define BOOST_PP_TUPLE_TO_LIST_II(res) res
+#    endif
+# else
+#    define BOOST_PP_TUPLE_TO_LIST(size, tuple) BOOST_PP_TUPLE_TO_LIST_OO((size, tuple))
+#    define BOOST_PP_TUPLE_TO_LIST_OO(par) BOOST_PP_TUPLE_TO_LIST_I ## par
+#    define BOOST_PP_TUPLE_TO_LIST_I(s, t) BOOST_PP_TUPLE_TO_LIST_ ## s ## t
+# endif
+#
+# define BOOST_PP_TUPLE_TO_LIST_0() BOOST_PP_NIL
+# define BOOST_PP_TUPLE_TO_LIST_1(a) (a, BOOST_PP_NIL)
+# define BOOST_PP_TUPLE_TO_LIST_2(a, b) (a, (b, BOOST_PP_NIL))
+# define BOOST_PP_TUPLE_TO_LIST_3(a, b, c) (a, (b, (c, BOOST_PP_NIL)))
+# define BOOST_PP_TUPLE_TO_LIST_4(a, b, c, d) (a, (b, (c, (d, BOOST_PP_NIL))))
+# define BOOST_PP_TUPLE_TO_LIST_5(a, b, c, d, e) (a, (b, (c, (d, (e, BOOST_PP_NIL)))))
+# define BOOST_PP_TUPLE_TO_LIST_6(a, b, c, d, e, f) (a, (b, (c, (d, (e, (f, BOOST_PP_NIL))))))
+# define BOOST_PP_TUPLE_TO_LIST_7(a, b, c, d, e, f, g) (a, (b, (c, (d, (e, (f, (g, BOOST_PP_NIL)))))))
+# define BOOST_PP_TUPLE_TO_LIST_8(a, b, c, d, e, f, g, h) (a, (b, (c, (d, (e, (f, (g, (h, BOOST_PP_NIL))))))))
+# define BOOST_PP_TUPLE_TO_LIST_9(a, b, c, d, e, f, g, h, i) (a, (b, (c, (d, (e, (f, (g, (h, (i, BOOST_PP_NIL)))))))))
+# define BOOST_PP_TUPLE_TO_LIST_10(a, b, c, d, e, f, g, h, i, j) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, BOOST_PP_NIL))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_11(a, b, c, d, e, f, g, h, i, j, k) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, BOOST_PP_NIL)))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_12(a, b, c, d, e, f, g, h, i, j, k, l) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, BOOST_PP_NIL))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_13(a, b, c, d, e, f, g, h, i, j, k, l, m) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, BOOST_PP_NIL)))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, BOOST_PP_NIL))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, BOOST_PP_NIL)))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, BOOST_PP_NIL))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, BOOST_PP_NIL)))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, BOOST_PP_NIL))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, BOOST_PP_NIL)))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, (t, BOOST_PP_NIL))))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, (t, (u, BOOST_PP_NIL)))))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, (t, (u, (v, BOOST_PP_NIL))))))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_23(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, (t, (u, (v, (w, BOOST_PP_NIL)))))))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_24(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, (t, (u, (v, (w, (x, BOOST_PP_NIL))))))))))))))))))))))))
+# define BOOST_PP_TUPLE_TO_LIST_25(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) (a, (b, (c, (d, (e, (f, (g, (h, (i, (j, (k, (l, (m, (n, (o, (p, (q, (r, (s, (t, (u, (v, (w, (x, (y, BOOST_PP_NIL)))))))))))))))))))))))))
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/elem.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/elem.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/elem.hpp	(working copy)
@@ -0,0 +1,385 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_TUPLE_ELEM_HPP
+# define BOOST_PREPROCESSOR_TUPLE_ELEM_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_TUPLE_ELEM(size, index, tuple) BOOST_PP_TUPLE_ELEM_I(size, index, tuple)
+# else
+#    define BOOST_PP_TUPLE_ELEM(size, index, tuple) BOOST_PP_TUPLE_ELEM_OO((size, index, tuple))
+#    define BOOST_PP_TUPLE_ELEM_OO(par) BOOST_PP_TUPLE_ELEM_I ## par
+# endif
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_TUPLE_ELEM_I(s, i, t) BOOST_PP_TUPLE_ELEM_ ## s ## _ ## i ## t
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_TUPLE_ELEM_I(s, i, t) BOOST_PP_TUPLE_ELEM_II(BOOST_PP_TUPLE_ELEM_ ## s ## _ ## i t)
+#    define BOOST_PP_TUPLE_ELEM_II(res) res
+# else
+#    define BOOST_PP_TUPLE_ELEM_I(s, i, t) BOOST_PP_TUPLE_ELEM_ ## s ## _ ## i t
+# endif
+#
+# define BOOST_PP_TUPLE_ELEM_1_0(a) a
+#
+# define BOOST_PP_TUPLE_ELEM_2_0(a, b) a
+# define BOOST_PP_TUPLE_ELEM_2_1(a, b) b
+#
+# define BOOST_PP_TUPLE_ELEM_3_0(a, b, c) a
+# define BOOST_PP_TUPLE_ELEM_3_1(a, b, c) b
+# define BOOST_PP_TUPLE_ELEM_3_2(a, b, c) c
+#
+# define BOOST_PP_TUPLE_ELEM_4_0(a, b, c, d) a
+# define BOOST_PP_TUPLE_ELEM_4_1(a, b, c, d) b
+# define BOOST_PP_TUPLE_ELEM_4_2(a, b, c, d) c
+# define BOOST_PP_TUPLE_ELEM_4_3(a, b, c, d) d
+#
+# define BOOST_PP_TUPLE_ELEM_5_0(a, b, c, d, e) a
+# define BOOST_PP_TUPLE_ELEM_5_1(a, b, c, d, e) b
+# define BOOST_PP_TUPLE_ELEM_5_2(a, b, c, d, e) c
+# define BOOST_PP_TUPLE_ELEM_5_3(a, b, c, d, e) d
+# define BOOST_PP_TUPLE_ELEM_5_4(a, b, c, d, e) e
+#
+# define BOOST_PP_TUPLE_ELEM_6_0(a, b, c, d, e, f) a
+# define BOOST_PP_TUPLE_ELEM_6_1(a, b, c, d, e, f) b
+# define BOOST_PP_TUPLE_ELEM_6_2(a, b, c, d, e, f) c
+# define BOOST_PP_TUPLE_ELEM_6_3(a, b, c, d, e, f) d
+# define BOOST_PP_TUPLE_ELEM_6_4(a, b, c, d, e, f) e
+# define BOOST_PP_TUPLE_ELEM_6_5(a, b, c, d, e, f) f
+#
+# define BOOST_PP_TUPLE_ELEM_7_0(a, b, c, d, e, f, g) a
+# define BOOST_PP_TUPLE_ELEM_7_1(a, b, c, d, e, f, g) b
+# define BOOST_PP_TUPLE_ELEM_7_2(a, b, c, d, e, f, g) c
+# define BOOST_PP_TUPLE_ELEM_7_3(a, b, c, d, e, f, g) d
+# define BOOST_PP_TUPLE_ELEM_7_4(a, b, c, d, e, f, g) e
+# define BOOST_PP_TUPLE_ELEM_7_5(a, b, c, d, e, f, g) f
+# define BOOST_PP_TUPLE_ELEM_7_6(a, b, c, d, e, f, g) g
+#
+# define BOOST_PP_TUPLE_ELEM_8_0(a, b, c, d, e, f, g, h) a
+# define BOOST_PP_TUPLE_ELEM_8_1(a, b, c, d, e, f, g, h) b
+# define BOOST_PP_TUPLE_ELEM_8_2(a, b, c, d, e, f, g, h) c
+# define BOOST_PP_TUPLE_ELEM_8_3(a, b, c, d, e, f, g, h) d
+# define BOOST_PP_TUPLE_ELEM_8_4(a, b, c, d, e, f, g, h) e
+# define BOOST_PP_TUPLE_ELEM_8_5(a, b, c, d, e, f, g, h) f
+# define BOOST_PP_TUPLE_ELEM_8_6(a, b, c, d, e, f, g, h) g
+# define BOOST_PP_TUPLE_ELEM_8_7(a, b, c, d, e, f, g, h) h
+#
+# define BOOST_PP_TUPLE_ELEM_9_0(a, b, c, d, e, f, g, h, i) a
+# define BOOST_PP_TUPLE_ELEM_9_1(a, b, c, d, e, f, g, h, i) b
+# define BOOST_PP_TUPLE_ELEM_9_2(a, b, c, d, e, f, g, h, i) c
+# define BOOST_PP_TUPLE_ELEM_9_3(a, b, c, d, e, f, g, h, i) d
+# define BOOST_PP_TUPLE_ELEM_9_4(a, b, c, d, e, f, g, h, i) e
+# define BOOST_PP_TUPLE_ELEM_9_5(a, b, c, d, e, f, g, h, i) f
+# define BOOST_PP_TUPLE_ELEM_9_6(a, b, c, d, e, f, g, h, i) g
+# define BOOST_PP_TUPLE_ELEM_9_7(a, b, c, d, e, f, g, h, i) h
+# define BOOST_PP_TUPLE_ELEM_9_8(a, b, c, d, e, f, g, h, i) i
+#
+# define BOOST_PP_TUPLE_ELEM_10_0(a, b, c, d, e, f, g, h, i, j) a
+# define BOOST_PP_TUPLE_ELEM_10_1(a, b, c, d, e, f, g, h, i, j) b
+# define BOOST_PP_TUPLE_ELEM_10_2(a, b, c, d, e, f, g, h, i, j) c
+# define BOOST_PP_TUPLE_ELEM_10_3(a, b, c, d, e, f, g, h, i, j) d
+# define BOOST_PP_TUPLE_ELEM_10_4(a, b, c, d, e, f, g, h, i, j) e
+# define BOOST_PP_TUPLE_ELEM_10_5(a, b, c, d, e, f, g, h, i, j) f
+# define BOOST_PP_TUPLE_ELEM_10_6(a, b, c, d, e, f, g, h, i, j) g
+# define BOOST_PP_TUPLE_ELEM_10_7(a, b, c, d, e, f, g, h, i, j) h
+# define BOOST_PP_TUPLE_ELEM_10_8(a, b, c, d, e, f, g, h, i, j) i
+# define BOOST_PP_TUPLE_ELEM_10_9(a, b, c, d, e, f, g, h, i, j) j
+#
+# define BOOST_PP_TUPLE_ELEM_11_0(a, b, c, d, e, f, g, h, i, j, k) a
+# define BOOST_PP_TUPLE_ELEM_11_1(a, b, c, d, e, f, g, h, i, j, k) b
+# define BOOST_PP_TUPLE_ELEM_11_2(a, b, c, d, e, f, g, h, i, j, k) c
+# define BOOST_PP_TUPLE_ELEM_11_3(a, b, c, d, e, f, g, h, i, j, k) d
+# define BOOST_PP_TUPLE_ELEM_11_4(a, b, c, d, e, f, g, h, i, j, k) e
+# define BOOST_PP_TUPLE_ELEM_11_5(a, b, c, d, e, f, g, h, i, j, k) f
+# define BOOST_PP_TUPLE_ELEM_11_6(a, b, c, d, e, f, g, h, i, j, k) g
+# define BOOST_PP_TUPLE_ELEM_11_7(a, b, c, d, e, f, g, h, i, j, k) h
+# define BOOST_PP_TUPLE_ELEM_11_8(a, b, c, d, e, f, g, h, i, j, k) i
+# define BOOST_PP_TUPLE_ELEM_11_9(a, b, c, d, e, f, g, h, i, j, k) j
+# define BOOST_PP_TUPLE_ELEM_11_10(a, b, c, d, e, f, g, h, i, j, k) k
+#
+# define BOOST_PP_TUPLE_ELEM_12_0(a, b, c, d, e, f, g, h, i, j, k, l) a
+# define BOOST_PP_TUPLE_ELEM_12_1(a, b, c, d, e, f, g, h, i, j, k, l) b
+# define BOOST_PP_TUPLE_ELEM_12_2(a, b, c, d, e, f, g, h, i, j, k, l) c
+# define BOOST_PP_TUPLE_ELEM_12_3(a, b, c, d, e, f, g, h, i, j, k, l) d
+# define BOOST_PP_TUPLE_ELEM_12_4(a, b, c, d, e, f, g, h, i, j, k, l) e
+# define BOOST_PP_TUPLE_ELEM_12_5(a, b, c, d, e, f, g, h, i, j, k, l) f
+# define BOOST_PP_TUPLE_ELEM_12_6(a, b, c, d, e, f, g, h, i, j, k, l) g
+# define BOOST_PP_TUPLE_ELEM_12_7(a, b, c, d, e, f, g, h, i, j, k, l) h
+# define BOOST_PP_TUPLE_ELEM_12_8(a, b, c, d, e, f, g, h, i, j, k, l) i
+# define BOOST_PP_TUPLE_ELEM_12_9(a, b, c, d, e, f, g, h, i, j, k, l) j
+# define BOOST_PP_TUPLE_ELEM_12_10(a, b, c, d, e, f, g, h, i, j, k, l) k
+# define BOOST_PP_TUPLE_ELEM_12_11(a, b, c, d, e, f, g, h, i, j, k, l) l
+#
+# define BOOST_PP_TUPLE_ELEM_13_0(a, b, c, d, e, f, g, h, i, j, k, l, m) a
+# define BOOST_PP_TUPLE_ELEM_13_1(a, b, c, d, e, f, g, h, i, j, k, l, m) b
+# define BOOST_PP_TUPLE_ELEM_13_2(a, b, c, d, e, f, g, h, i, j, k, l, m) c
+# define BOOST_PP_TUPLE_ELEM_13_3(a, b, c, d, e, f, g, h, i, j, k, l, m) d
+# define BOOST_PP_TUPLE_ELEM_13_4(a, b, c, d, e, f, g, h, i, j, k, l, m) e
+# define BOOST_PP_TUPLE_ELEM_13_5(a, b, c, d, e, f, g, h, i, j, k, l, m) f
+# define BOOST_PP_TUPLE_ELEM_13_6(a, b, c, d, e, f, g, h, i, j, k, l, m) g
+# define BOOST_PP_TUPLE_ELEM_13_7(a, b, c, d, e, f, g, h, i, j, k, l, m) h
+# define BOOST_PP_TUPLE_ELEM_13_8(a, b, c, d, e, f, g, h, i, j, k, l, m) i
+# define BOOST_PP_TUPLE_ELEM_13_9(a, b, c, d, e, f, g, h, i, j, k, l, m) j
+# define BOOST_PP_TUPLE_ELEM_13_10(a, b, c, d, e, f, g, h, i, j, k, l, m) k
+# define BOOST_PP_TUPLE_ELEM_13_11(a, b, c, d, e, f, g, h, i, j, k, l, m) l
+# define BOOST_PP_TUPLE_ELEM_13_12(a, b, c, d, e, f, g, h, i, j, k, l, m) m
+#
+# define BOOST_PP_TUPLE_ELEM_14_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n) a
+# define BOOST_PP_TUPLE_ELEM_14_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n) b
+# define BOOST_PP_TUPLE_ELEM_14_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n) c
+# define BOOST_PP_TUPLE_ELEM_14_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n) d
+# define BOOST_PP_TUPLE_ELEM_14_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n) e
+# define BOOST_PP_TUPLE_ELEM_14_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n) f
+# define BOOST_PP_TUPLE_ELEM_14_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n) g
+# define BOOST_PP_TUPLE_ELEM_14_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n) h
+# define BOOST_PP_TUPLE_ELEM_14_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n) i
+# define BOOST_PP_TUPLE_ELEM_14_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n) j
+# define BOOST_PP_TUPLE_ELEM_14_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n) k
+# define BOOST_PP_TUPLE_ELEM_14_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n) l
+# define BOOST_PP_TUPLE_ELEM_14_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n) m
+# define BOOST_PP_TUPLE_ELEM_14_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n) n
+#
+# define BOOST_PP_TUPLE_ELEM_15_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) a
+# define BOOST_PP_TUPLE_ELEM_15_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) b
+# define BOOST_PP_TUPLE_ELEM_15_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) c
+# define BOOST_PP_TUPLE_ELEM_15_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) d
+# define BOOST_PP_TUPLE_ELEM_15_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) e
+# define BOOST_PP_TUPLE_ELEM_15_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) f
+# define BOOST_PP_TUPLE_ELEM_15_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) g
+# define BOOST_PP_TUPLE_ELEM_15_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) h
+# define BOOST_PP_TUPLE_ELEM_15_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) i
+# define BOOST_PP_TUPLE_ELEM_15_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) j
+# define BOOST_PP_TUPLE_ELEM_15_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) k
+# define BOOST_PP_TUPLE_ELEM_15_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) l
+# define BOOST_PP_TUPLE_ELEM_15_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) m
+# define BOOST_PP_TUPLE_ELEM_15_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) n
+# define BOOST_PP_TUPLE_ELEM_15_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) o
+#
+# define BOOST_PP_TUPLE_ELEM_16_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) a
+# define BOOST_PP_TUPLE_ELEM_16_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) b
+# define BOOST_PP_TUPLE_ELEM_16_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) c
+# define BOOST_PP_TUPLE_ELEM_16_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) d
+# define BOOST_PP_TUPLE_ELEM_16_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) e
+# define BOOST_PP_TUPLE_ELEM_16_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) f
+# define BOOST_PP_TUPLE_ELEM_16_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) g
+# define BOOST_PP_TUPLE_ELEM_16_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) h
+# define BOOST_PP_TUPLE_ELEM_16_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) i
+# define BOOST_PP_TUPLE_ELEM_16_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) j
+# define BOOST_PP_TUPLE_ELEM_16_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) k
+# define BOOST_PP_TUPLE_ELEM_16_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) l
+# define BOOST_PP_TUPLE_ELEM_16_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) m
+# define BOOST_PP_TUPLE_ELEM_16_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) n
+# define BOOST_PP_TUPLE_ELEM_16_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) o
+# define BOOST_PP_TUPLE_ELEM_16_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) p
+#
+# define BOOST_PP_TUPLE_ELEM_17_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) a
+# define BOOST_PP_TUPLE_ELEM_17_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) b
+# define BOOST_PP_TUPLE_ELEM_17_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) c
+# define BOOST_PP_TUPLE_ELEM_17_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) d
+# define BOOST_PP_TUPLE_ELEM_17_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) e
+# define BOOST_PP_TUPLE_ELEM_17_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) f
+# define BOOST_PP_TUPLE_ELEM_17_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) g
+# define BOOST_PP_TUPLE_ELEM_17_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) h
+# define BOOST_PP_TUPLE_ELEM_17_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) i
+# define BOOST_PP_TUPLE_ELEM_17_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) j
+# define BOOST_PP_TUPLE_ELEM_17_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) k
+# define BOOST_PP_TUPLE_ELEM_17_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) l
+# define BOOST_PP_TUPLE_ELEM_17_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) m
+# define BOOST_PP_TUPLE_ELEM_17_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) n
+# define BOOST_PP_TUPLE_ELEM_17_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) o
+# define BOOST_PP_TUPLE_ELEM_17_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) p
+# define BOOST_PP_TUPLE_ELEM_17_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) q
+#
+# define BOOST_PP_TUPLE_ELEM_18_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) a
+# define BOOST_PP_TUPLE_ELEM_18_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) b
+# define BOOST_PP_TUPLE_ELEM_18_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) c
+# define BOOST_PP_TUPLE_ELEM_18_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) d
+# define BOOST_PP_TUPLE_ELEM_18_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) e
+# define BOOST_PP_TUPLE_ELEM_18_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) f
+# define BOOST_PP_TUPLE_ELEM_18_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) g
+# define BOOST_PP_TUPLE_ELEM_18_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) h
+# define BOOST_PP_TUPLE_ELEM_18_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) i
+# define BOOST_PP_TUPLE_ELEM_18_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) j
+# define BOOST_PP_TUPLE_ELEM_18_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) k
+# define BOOST_PP_TUPLE_ELEM_18_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) l
+# define BOOST_PP_TUPLE_ELEM_18_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) m
+# define BOOST_PP_TUPLE_ELEM_18_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) n
+# define BOOST_PP_TUPLE_ELEM_18_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) o
+# define BOOST_PP_TUPLE_ELEM_18_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) p
+# define BOOST_PP_TUPLE_ELEM_18_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) q
+# define BOOST_PP_TUPLE_ELEM_18_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) r
+#
+# define BOOST_PP_TUPLE_ELEM_19_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) a
+# define BOOST_PP_TUPLE_ELEM_19_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) b
+# define BOOST_PP_TUPLE_ELEM_19_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) c
+# define BOOST_PP_TUPLE_ELEM_19_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) d
+# define BOOST_PP_TUPLE_ELEM_19_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) e
+# define BOOST_PP_TUPLE_ELEM_19_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) f
+# define BOOST_PP_TUPLE_ELEM_19_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) g
+# define BOOST_PP_TUPLE_ELEM_19_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) h
+# define BOOST_PP_TUPLE_ELEM_19_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) i
+# define BOOST_PP_TUPLE_ELEM_19_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) j
+# define BOOST_PP_TUPLE_ELEM_19_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) k
+# define BOOST_PP_TUPLE_ELEM_19_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) l
+# define BOOST_PP_TUPLE_ELEM_19_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) m
+# define BOOST_PP_TUPLE_ELEM_19_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) n
+# define BOOST_PP_TUPLE_ELEM_19_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) o
+# define BOOST_PP_TUPLE_ELEM_19_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) p
+# define BOOST_PP_TUPLE_ELEM_19_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) q
+# define BOOST_PP_TUPLE_ELEM_19_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) r
+# define BOOST_PP_TUPLE_ELEM_19_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) s
+#
+# define BOOST_PP_TUPLE_ELEM_20_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) a
+# define BOOST_PP_TUPLE_ELEM_20_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) b
+# define BOOST_PP_TUPLE_ELEM_20_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) c
+# define BOOST_PP_TUPLE_ELEM_20_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) d
+# define BOOST_PP_TUPLE_ELEM_20_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) e
+# define BOOST_PP_TUPLE_ELEM_20_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) f
+# define BOOST_PP_TUPLE_ELEM_20_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) g
+# define BOOST_PP_TUPLE_ELEM_20_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) h
+# define BOOST_PP_TUPLE_ELEM_20_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) i
+# define BOOST_PP_TUPLE_ELEM_20_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) j
+# define BOOST_PP_TUPLE_ELEM_20_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) k
+# define BOOST_PP_TUPLE_ELEM_20_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) l
+# define BOOST_PP_TUPLE_ELEM_20_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) m
+# define BOOST_PP_TUPLE_ELEM_20_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) n
+# define BOOST_PP_TUPLE_ELEM_20_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) o
+# define BOOST_PP_TUPLE_ELEM_20_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) p
+# define BOOST_PP_TUPLE_ELEM_20_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) q
+# define BOOST_PP_TUPLE_ELEM_20_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) r
+# define BOOST_PP_TUPLE_ELEM_20_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) s
+# define BOOST_PP_TUPLE_ELEM_20_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) t
+#
+# define BOOST_PP_TUPLE_ELEM_21_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) a
+# define BOOST_PP_TUPLE_ELEM_21_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) b
+# define BOOST_PP_TUPLE_ELEM_21_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) c
+# define BOOST_PP_TUPLE_ELEM_21_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) d
+# define BOOST_PP_TUPLE_ELEM_21_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) e
+# define BOOST_PP_TUPLE_ELEM_21_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) f
+# define BOOST_PP_TUPLE_ELEM_21_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) g
+# define BOOST_PP_TUPLE_ELEM_21_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) h
+# define BOOST_PP_TUPLE_ELEM_21_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) i
+# define BOOST_PP_TUPLE_ELEM_21_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) j
+# define BOOST_PP_TUPLE_ELEM_21_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) k
+# define BOOST_PP_TUPLE_ELEM_21_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) l
+# define BOOST_PP_TUPLE_ELEM_21_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) m
+# define BOOST_PP_TUPLE_ELEM_21_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) n
+# define BOOST_PP_TUPLE_ELEM_21_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) o
+# define BOOST_PP_TUPLE_ELEM_21_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) p
+# define BOOST_PP_TUPLE_ELEM_21_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) q
+# define BOOST_PP_TUPLE_ELEM_21_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) r
+# define BOOST_PP_TUPLE_ELEM_21_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) s
+# define BOOST_PP_TUPLE_ELEM_21_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) t
+# define BOOST_PP_TUPLE_ELEM_21_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) u
+#
+# define BOOST_PP_TUPLE_ELEM_22_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) a
+# define BOOST_PP_TUPLE_ELEM_22_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) b
+# define BOOST_PP_TUPLE_ELEM_22_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) c
+# define BOOST_PP_TUPLE_ELEM_22_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) d
+# define BOOST_PP_TUPLE_ELEM_22_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) e
+# define BOOST_PP_TUPLE_ELEM_22_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) f
+# define BOOST_PP_TUPLE_ELEM_22_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) g
+# define BOOST_PP_TUPLE_ELEM_22_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) h
+# define BOOST_PP_TUPLE_ELEM_22_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) i
+# define BOOST_PP_TUPLE_ELEM_22_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) j
+# define BOOST_PP_TUPLE_ELEM_22_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) k
+# define BOOST_PP_TUPLE_ELEM_22_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) l
+# define BOOST_PP_TUPLE_ELEM_22_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) m
+# define BOOST_PP_TUPLE_ELEM_22_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) n
+# define BOOST_PP_TUPLE_ELEM_22_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) o
+# define BOOST_PP_TUPLE_ELEM_22_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) p
+# define BOOST_PP_TUPLE_ELEM_22_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) q
+# define BOOST_PP_TUPLE_ELEM_22_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) r
+# define BOOST_PP_TUPLE_ELEM_22_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) s
+# define BOOST_PP_TUPLE_ELEM_22_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) t
+# define BOOST_PP_TUPLE_ELEM_22_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) u
+# define BOOST_PP_TUPLE_ELEM_22_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) v
+#
+# define BOOST_PP_TUPLE_ELEM_23_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) a
+# define BOOST_PP_TUPLE_ELEM_23_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) b
+# define BOOST_PP_TUPLE_ELEM_23_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) c
+# define BOOST_PP_TUPLE_ELEM_23_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) d
+# define BOOST_PP_TUPLE_ELEM_23_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) e
+# define BOOST_PP_TUPLE_ELEM_23_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) f
+# define BOOST_PP_TUPLE_ELEM_23_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) g
+# define BOOST_PP_TUPLE_ELEM_23_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) h
+# define BOOST_PP_TUPLE_ELEM_23_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) i
+# define BOOST_PP_TUPLE_ELEM_23_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) j
+# define BOOST_PP_TUPLE_ELEM_23_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) k
+# define BOOST_PP_TUPLE_ELEM_23_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) l
+# define BOOST_PP_TUPLE_ELEM_23_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) m
+# define BOOST_PP_TUPLE_ELEM_23_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) n
+# define BOOST_PP_TUPLE_ELEM_23_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) o
+# define BOOST_PP_TUPLE_ELEM_23_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) p
+# define BOOST_PP_TUPLE_ELEM_23_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) q
+# define BOOST_PP_TUPLE_ELEM_23_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) r
+# define BOOST_PP_TUPLE_ELEM_23_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) s
+# define BOOST_PP_TUPLE_ELEM_23_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) t
+# define BOOST_PP_TUPLE_ELEM_23_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) u
+# define BOOST_PP_TUPLE_ELEM_23_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) v
+# define BOOST_PP_TUPLE_ELEM_23_22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) w
+#
+# define BOOST_PP_TUPLE_ELEM_24_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) a
+# define BOOST_PP_TUPLE_ELEM_24_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) b
+# define BOOST_PP_TUPLE_ELEM_24_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) c
+# define BOOST_PP_TUPLE_ELEM_24_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) d
+# define BOOST_PP_TUPLE_ELEM_24_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) e
+# define BOOST_PP_TUPLE_ELEM_24_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) f
+# define BOOST_PP_TUPLE_ELEM_24_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) g
+# define BOOST_PP_TUPLE_ELEM_24_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) h
+# define BOOST_PP_TUPLE_ELEM_24_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) i
+# define BOOST_PP_TUPLE_ELEM_24_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) j
+# define BOOST_PP_TUPLE_ELEM_24_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) k
+# define BOOST_PP_TUPLE_ELEM_24_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) l
+# define BOOST_PP_TUPLE_ELEM_24_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) m
+# define BOOST_PP_TUPLE_ELEM_24_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) n
+# define BOOST_PP_TUPLE_ELEM_24_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) o
+# define BOOST_PP_TUPLE_ELEM_24_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) p
+# define BOOST_PP_TUPLE_ELEM_24_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) q
+# define BOOST_PP_TUPLE_ELEM_24_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) r
+# define BOOST_PP_TUPLE_ELEM_24_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) s
+# define BOOST_PP_TUPLE_ELEM_24_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) t
+# define BOOST_PP_TUPLE_ELEM_24_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) u
+# define BOOST_PP_TUPLE_ELEM_24_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) v
+# define BOOST_PP_TUPLE_ELEM_24_22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) w
+# define BOOST_PP_TUPLE_ELEM_24_23(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) x
+#
+# define BOOST_PP_TUPLE_ELEM_25_0(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) a
+# define BOOST_PP_TUPLE_ELEM_25_1(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) b
+# define BOOST_PP_TUPLE_ELEM_25_2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) c
+# define BOOST_PP_TUPLE_ELEM_25_3(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) d
+# define BOOST_PP_TUPLE_ELEM_25_4(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) e
+# define BOOST_PP_TUPLE_ELEM_25_5(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) f
+# define BOOST_PP_TUPLE_ELEM_25_6(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) g
+# define BOOST_PP_TUPLE_ELEM_25_7(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) h
+# define BOOST_PP_TUPLE_ELEM_25_8(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) i
+# define BOOST_PP_TUPLE_ELEM_25_9(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) j
+# define BOOST_PP_TUPLE_ELEM_25_10(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) k
+# define BOOST_PP_TUPLE_ELEM_25_11(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) l
+# define BOOST_PP_TUPLE_ELEM_25_12(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) m
+# define BOOST_PP_TUPLE_ELEM_25_13(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) n
+# define BOOST_PP_TUPLE_ELEM_25_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) o
+# define BOOST_PP_TUPLE_ELEM_25_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) p
+# define BOOST_PP_TUPLE_ELEM_25_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) q
+# define BOOST_PP_TUPLE_ELEM_25_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) r
+# define BOOST_PP_TUPLE_ELEM_25_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) s
+# define BOOST_PP_TUPLE_ELEM_25_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) t
+# define BOOST_PP_TUPLE_ELEM_25_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) u
+# define BOOST_PP_TUPLE_ELEM_25_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) v
+# define BOOST_PP_TUPLE_ELEM_25_22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) w
+# define BOOST_PP_TUPLE_ELEM_25_23(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) x
+# define BOOST_PP_TUPLE_ELEM_25_24(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) y
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/rem.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/rem.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/tuple/rem.hpp	(working copy)
@@ -0,0 +1,72 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_TUPLE_REM_HPP
+# define BOOST_PREPROCESSOR_TUPLE_REM_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_TUPLE_REM */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_TUPLE_REM(size) BOOST_PP_TUPLE_REM_I(size)
+# else
+#    define BOOST_PP_TUPLE_REM(size) BOOST_PP_TUPLE_REM_OO((size))
+#    define BOOST_PP_TUPLE_REM_OO(par) BOOST_PP_TUPLE_REM_I ## par
+# endif
+#
+# define BOOST_PP_TUPLE_REM_I(size) BOOST_PP_TUPLE_REM_ ## size
+#
+# define BOOST_PP_TUPLE_REM_0()
+# define BOOST_PP_TUPLE_REM_1(a) a
+# define BOOST_PP_TUPLE_REM_2(a, b) a, b
+# define BOOST_PP_TUPLE_REM_3(a, b, c) a, b, c
+# define BOOST_PP_TUPLE_REM_4(a, b, c, d) a, b, c, d
+# define BOOST_PP_TUPLE_REM_5(a, b, c, d, e) a, b, c, d, e
+# define BOOST_PP_TUPLE_REM_6(a, b, c, d, e, f) a, b, c, d, e, f
+# define BOOST_PP_TUPLE_REM_7(a, b, c, d, e, f, g) a, b, c, d, e, f, g
+# define BOOST_PP_TUPLE_REM_8(a, b, c, d, e, f, g, h) a, b, c, d, e, f, g, h
+# define BOOST_PP_TUPLE_REM_9(a, b, c, d, e, f, g, h, i) a, b, c, d, e, f, g, h, i
+# define BOOST_PP_TUPLE_REM_10(a, b, c, d, e, f, g, h, i, j) a, b, c, d, e, f, g, h, i, j
+# define BOOST_PP_TUPLE_REM_11(a, b, c, d, e, f, g, h, i, j, k) a, b, c, d, e, f, g, h, i, j, k
+# define BOOST_PP_TUPLE_REM_12(a, b, c, d, e, f, g, h, i, j, k, l) a, b, c, d, e, f, g, h, i, j, k, l
+# define BOOST_PP_TUPLE_REM_13(a, b, c, d, e, f, g, h, i, j, k, l, m) a, b, c, d, e, f, g, h, i, j, k, l, m
+# define BOOST_PP_TUPLE_REM_14(a, b, c, d, e, f, g, h, i, j, k, l, m, n) a, b, c, d, e, f, g, h, i, j, k, l, m, n
+# define BOOST_PP_TUPLE_REM_15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o
+# define BOOST_PP_TUPLE_REM_16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p
+# define BOOST_PP_TUPLE_REM_17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q
+# define BOOST_PP_TUPLE_REM_18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r
+# define BOOST_PP_TUPLE_REM_19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s
+# define BOOST_PP_TUPLE_REM_20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t
+# define BOOST_PP_TUPLE_REM_21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u
+# define BOOST_PP_TUPLE_REM_22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v
+# define BOOST_PP_TUPLE_REM_23(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w
+# define BOOST_PP_TUPLE_REM_24(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x
+# define BOOST_PP_TUPLE_REM_25(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y
+#
+# /* BOOST_PP_TUPLE_REM_CTOR */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_TUPLE_REM_CTOR(size, tuple) BOOST_PP_TUPLE_REM_CTOR_I(BOOST_PP_TUPLE_REM(size), tuple)
+# else
+#    define BOOST_PP_TUPLE_REM_CTOR(size, tuple) BOOST_PP_TUPLE_REM_CTOR_D(size, tuple)
+#    define BOOST_PP_TUPLE_REM_CTOR_D(size, tuple) BOOST_PP_TUPLE_REM_CTOR_I(BOOST_PP_TUPLE_REM(size), tuple)
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_TUPLE_REM_CTOR_I(ext, tuple) ext tuple
+# else
+#    define BOOST_PP_TUPLE_REM_CTOR_I(ext, tuple) BOOST_PP_TUPLE_REM_CTOR_OO((ext, tuple))
+#    define BOOST_PP_TUPLE_REM_CTOR_OO(par) BOOST_PP_TUPLE_REM_CTOR_II ## par
+#    define BOOST_PP_TUPLE_REM_CTOR_II(ext, tuple) ext ## tuple
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/cat.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/cat.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/cat.hpp	(working copy)
@@ -0,0 +1,35 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CAT_HPP
+# define BOOST_PREPROCESSOR_CAT_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_CAT */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_CAT(a, b) BOOST_PP_CAT_I(a, b)
+# else
+#    define BOOST_PP_CAT(a, b) BOOST_PP_CAT_OO((a, b))
+#    define BOOST_PP_CAT_OO(par) BOOST_PP_CAT_I ## par
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_CAT_I(a, b) a ## b
+# else
+#    define BOOST_PP_CAT_I(a, b) BOOST_PP_CAT_II(a ## b)
+#    define BOOST_PP_CAT_II(res) res
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/check.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/check.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/check.hpp	(working copy)
@@ -0,0 +1,48 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_DETAIL_CHECK_HPP
+# define BOOST_PREPROCESSOR_DETAIL_CHECK_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_CHECK */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_CHECK(x, type) BOOST_PP_CHECK_D(x, type)
+# else
+#    define BOOST_PP_CHECK(x, type) BOOST_PP_CHECK_OO((x, type))
+#    define BOOST_PP_CHECK_OO(par) BOOST_PP_CHECK_D ## par
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC() && ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()
+#    define BOOST_PP_CHECK_D(x, type) BOOST_PP_CHECK_1(BOOST_PP_CAT(BOOST_PP_CHECK_RESULT_, type x))
+#    define BOOST_PP_CHECK_1(chk) BOOST_PP_CHECK_2(chk)
+#    define BOOST_PP_CHECK_2(res, _) res
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_CHECK_D(x, type) BOOST_PP_CHECK_1(type x)
+#    define BOOST_PP_CHECK_1(chk) BOOST_PP_CHECK_2(chk)
+#    define BOOST_PP_CHECK_2(chk) BOOST_PP_CHECK_3((BOOST_PP_CHECK_RESULT_ ## chk))
+#    define BOOST_PP_CHECK_3(im) BOOST_PP_CHECK_5(BOOST_PP_CHECK_4 im)
+#    define BOOST_PP_CHECK_4(res, _) res
+#    define BOOST_PP_CHECK_5(res) res
+# else /* DMC */
+#    define BOOST_PP_CHECK_D(x, type) BOOST_PP_CHECK_OO((type x))
+#    define BOOST_PP_CHECK_OO(par) BOOST_PP_CHECK_0 ## par
+#    define BOOST_PP_CHECK_0(chk) BOOST_PP_CHECK_1(BOOST_PP_CAT(BOOST_PP_CHECK_RESULT_, chk))
+#    define BOOST_PP_CHECK_1(chk) BOOST_PP_CHECK_2(chk)
+#    define BOOST_PP_CHECK_2(res, _) res
+# endif
+#
+# define BOOST_PP_CHECK_RESULT_1 1, BOOST_PP_NIL
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/is_binary.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/is_binary.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/is_binary.hpp	(working copy)
@@ -0,0 +1,30 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_DETAIL_IS_BINARY_HPP
+# define BOOST_PREPROCESSOR_DETAIL_IS_BINARY_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/detail/check.hpp>
+#
+# /* BOOST_PP_IS_BINARY */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_IS_BINARY(x) BOOST_PP_CHECK(x, BOOST_PP_IS_BINARY_CHECK)
+# else
+#    define BOOST_PP_IS_BINARY(x) BOOST_PP_IS_BINARY_I(x)
+#    define BOOST_PP_IS_BINARY_I(x) BOOST_PP_CHECK(x, BOOST_PP_IS_BINARY_CHECK)
+# endif
+#
+# define BOOST_PP_IS_BINARY_CHECK(a, b) 1
+# define BOOST_PP_CHECK_RESULT_BOOST_PP_IS_BINARY_CHECK 0, BOOST_PP_NIL
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/auto_rec.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/auto_rec.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/detail/auto_rec.hpp	(working copy)
@@ -0,0 +1,293 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()
+#     include <boost/preprocessor/detail/dmc/auto_rec.hpp>
+# else
+#
+# ifndef BOOST_PREPROCESSOR_DETAIL_AUTO_REC_HPP
+# define BOOST_PREPROCESSOR_DETAIL_AUTO_REC_HPP
+#
+# include <boost/preprocessor/control/iif.hpp>
+#
+# /* BOOST_PP_AUTO_REC */
+#
+# define BOOST_PP_AUTO_REC(pred, n) BOOST_PP_NODE_ENTRY_ ## n(pred)
+#
+# define BOOST_PP_NODE_ENTRY_256(p) BOOST_PP_NODE_128(p)(p)(p)(p)(p)(p)(p)(p)
+# define BOOST_PP_NODE_ENTRY_128(p) BOOST_PP_NODE_64(p)(p)(p)(p)(p)(p)(p)
+# define BOOST_PP_NODE_ENTRY_64(p) BOOST_PP_NODE_32(p)(p)(p)(p)(p)(p)
+# define BOOST_PP_NODE_ENTRY_32(p) BOOST_PP_NODE_16(p)(p)(p)(p)(p)
+# define BOOST_PP_NODE_ENTRY_16(p) BOOST_PP_NODE_8(p)(p)(p)(p)
+# define BOOST_PP_NODE_ENTRY_8(p) BOOST_PP_NODE_4(p)(p)(p)
+# define BOOST_PP_NODE_ENTRY_4(p) BOOST_PP_NODE_2(p)(p)
+# define BOOST_PP_NODE_ENTRY_2(p) BOOST_PP_NODE_1(p)
+#
+# define BOOST_PP_NODE_128(p) BOOST_PP_IIF(p(128), BOOST_PP_NODE_64, BOOST_PP_NODE_192)
+#    define BOOST_PP_NODE_64(p) BOOST_PP_IIF(p(64), BOOST_PP_NODE_32, BOOST_PP_NODE_96)
+#        define BOOST_PP_NODE_32(p) BOOST_PP_IIF(p(32), BOOST_PP_NODE_16, BOOST_PP_NODE_48)
+#            define BOOST_PP_NODE_16(p) BOOST_PP_IIF(p(16), BOOST_PP_NODE_8, BOOST_PP_NODE_24)
+#                define BOOST_PP_NODE_8(p) BOOST_PP_IIF(p(8), BOOST_PP_NODE_4, BOOST_PP_NODE_12)
+#                    define BOOST_PP_NODE_4(p) BOOST_PP_IIF(p(4), BOOST_PP_NODE_2, BOOST_PP_NODE_6)
+#                        define BOOST_PP_NODE_2(p) BOOST_PP_IIF(p(2), BOOST_PP_NODE_1, BOOST_PP_NODE_3)
+#                            define BOOST_PP_NODE_1(p) BOOST_PP_IIF(p(1), 1, 2)
+#                            define BOOST_PP_NODE_3(p) BOOST_PP_IIF(p(3), 3, 4)
+#                        define BOOST_PP_NODE_6(p) BOOST_PP_IIF(p(6), BOOST_PP_NODE_5, BOOST_PP_NODE_7)
+#                            define BOOST_PP_NODE_5(p) BOOST_PP_IIF(p(5), 5, 6)
+#                            define BOOST_PP_NODE_7(p) BOOST_PP_IIF(p(7), 7, 8)
+#                    define BOOST_PP_NODE_12(p) BOOST_PP_IIF(p(12), BOOST_PP_NODE_10, BOOST_PP_NODE_14)
+#                        define BOOST_PP_NODE_10(p) BOOST_PP_IIF(p(10), BOOST_PP_NODE_9, BOOST_PP_NODE_11)
+#                            define BOOST_PP_NODE_9(p) BOOST_PP_IIF(p(9), 9, 10)
+#                            define BOOST_PP_NODE_11(p) BOOST_PP_IIF(p(11), 11, 12)
+#                        define BOOST_PP_NODE_14(p) BOOST_PP_IIF(p(14), BOOST_PP_NODE_13, BOOST_PP_NODE_15)
+#                            define BOOST_PP_NODE_13(p) BOOST_PP_IIF(p(13), 13, 14)
+#                            define BOOST_PP_NODE_15(p) BOOST_PP_IIF(p(15), 15, 16)
+#                define BOOST_PP_NODE_24(p) BOOST_PP_IIF(p(24), BOOST_PP_NODE_20, BOOST_PP_NODE_28)
+#                    define BOOST_PP_NODE_20(p) BOOST_PP_IIF(p(20), BOOST_PP_NODE_18, BOOST_PP_NODE_22)
+#                        define BOOST_PP_NODE_18(p) BOOST_PP_IIF(p(18), BOOST_PP_NODE_17, BOOST_PP_NODE_19)
+#                            define BOOST_PP_NODE_17(p) BOOST_PP_IIF(p(17), 17, 18)
+#                            define BOOST_PP_NODE_19(p) BOOST_PP_IIF(p(19), 19, 20)
+#                        define BOOST_PP_NODE_22(p) BOOST_PP_IIF(p(22), BOOST_PP_NODE_21, BOOST_PP_NODE_23)
+#                            define BOOST_PP_NODE_21(p) BOOST_PP_IIF(p(21), 21, 22)
+#                            define BOOST_PP_NODE_23(p) BOOST_PP_IIF(p(23), 23, 24)
+#                    define BOOST_PP_NODE_28(p) BOOST_PP_IIF(p(28), BOOST_PP_NODE_26, BOOST_PP_NODE_30)
+#                        define BOOST_PP_NODE_26(p) BOOST_PP_IIF(p(26), BOOST_PP_NODE_25, BOOST_PP_NODE_27)
+#                            define BOOST_PP_NODE_25(p) BOOST_PP_IIF(p(25), 25, 26)
+#                            define BOOST_PP_NODE_27(p) BOOST_PP_IIF(p(27), 27, 28)
+#                        define BOOST_PP_NODE_30(p) BOOST_PP_IIF(p(30), BOOST_PP_NODE_29, BOOST_PP_NODE_31)
+#                            define BOOST_PP_NODE_29(p) BOOST_PP_IIF(p(29), 29, 30)
+#                            define BOOST_PP_NODE_31(p) BOOST_PP_IIF(p(31), 31, 32)
+#            define BOOST_PP_NODE_48(p) BOOST_PP_IIF(p(48), BOOST_PP_NODE_40, BOOST_PP_NODE_56)
+#                define BOOST_PP_NODE_40(p) BOOST_PP_IIF(p(40), BOOST_PP_NODE_36, BOOST_PP_NODE_44)
+#                    define BOOST_PP_NODE_36(p) BOOST_PP_IIF(p(36), BOOST_PP_NODE_34, BOOST_PP_NODE_38)
+#                        define BOOST_PP_NODE_34(p) BOOST_PP_IIF(p(34), BOOST_PP_NODE_33, BOOST_PP_NODE_35)
+#                            define BOOST_PP_NODE_33(p) BOOST_PP_IIF(p(33), 33, 34)
+#                            define BOOST_PP_NODE_35(p) BOOST_PP_IIF(p(35), 35, 36)
+#                        define BOOST_PP_NODE_38(p) BOOST_PP_IIF(p(38), BOOST_PP_NODE_37, BOOST_PP_NODE_39)
+#                            define BOOST_PP_NODE_37(p) BOOST_PP_IIF(p(37), 37, 38)
+#                            define BOOST_PP_NODE_39(p) BOOST_PP_IIF(p(39), 39, 40)
+#                    define BOOST_PP_NODE_44(p) BOOST_PP_IIF(p(44), BOOST_PP_NODE_42, BOOST_PP_NODE_46)
+#                        define BOOST_PP_NODE_42(p) BOOST_PP_IIF(p(42), BOOST_PP_NODE_41, BOOST_PP_NODE_43)
+#                            define BOOST_PP_NODE_41(p) BOOST_PP_IIF(p(41), 41, 42)
+#                            define BOOST_PP_NODE_43(p) BOOST_PP_IIF(p(43), 43, 44)
+#                        define BOOST_PP_NODE_46(p) BOOST_PP_IIF(p(46), BOOST_PP_NODE_45, BOOST_PP_NODE_47)
+#                            define BOOST_PP_NODE_45(p) BOOST_PP_IIF(p(45), 45, 46)
+#                            define BOOST_PP_NODE_47(p) BOOST_PP_IIF(p(47), 47, 48)
+#                define BOOST_PP_NODE_56(p) BOOST_PP_IIF(p(56), BOOST_PP_NODE_52, BOOST_PP_NODE_60)
+#                    define BOOST_PP_NODE_52(p) BOOST_PP_IIF(p(52), BOOST_PP_NODE_50, BOOST_PP_NODE_54)
+#                        define BOOST_PP_NODE_50(p) BOOST_PP_IIF(p(50), BOOST_PP_NODE_49, BOOST_PP_NODE_51)
+#                            define BOOST_PP_NODE_49(p) BOOST_PP_IIF(p(49), 49, 50)
+#                            define BOOST_PP_NODE_51(p) BOOST_PP_IIF(p(51), 51, 52)
+#                        define BOOST_PP_NODE_54(p) BOOST_PP_IIF(p(54), BOOST_PP_NODE_53, BOOST_PP_NODE_55)
+#                            define BOOST_PP_NODE_53(p) BOOST_PP_IIF(p(53), 53, 54)
+#                            define BOOST_PP_NODE_55(p) BOOST_PP_IIF(p(55), 55, 56)
+#                    define BOOST_PP_NODE_60(p) BOOST_PP_IIF(p(60), BOOST_PP_NODE_58, BOOST_PP_NODE_62)
+#                        define BOOST_PP_NODE_58(p) BOOST_PP_IIF(p(58), BOOST_PP_NODE_57, BOOST_PP_NODE_59)
+#                            define BOOST_PP_NODE_57(p) BOOST_PP_IIF(p(57), 57, 58)
+#                            define BOOST_PP_NODE_59(p) BOOST_PP_IIF(p(59), 59, 60)
+#                        define BOOST_PP_NODE_62(p) BOOST_PP_IIF(p(62), BOOST_PP_NODE_61, BOOST_PP_NODE_63)
+#                            define BOOST_PP_NODE_61(p) BOOST_PP_IIF(p(61), 61, 62)
+#                            define BOOST_PP_NODE_63(p) BOOST_PP_IIF(p(63), 63, 64)
+#        define BOOST_PP_NODE_96(p) BOOST_PP_IIF(p(96), BOOST_PP_NODE_80, BOOST_PP_NODE_112)
+#            define BOOST_PP_NODE_80(p) BOOST_PP_IIF(p(80), BOOST_PP_NODE_72, BOOST_PP_NODE_88)
+#                define BOOST_PP_NODE_72(p) BOOST_PP_IIF(p(72), BOOST_PP_NODE_68, BOOST_PP_NODE_76)
+#                    define BOOST_PP_NODE_68(p) BOOST_PP_IIF(p(68), BOOST_PP_NODE_66, BOOST_PP_NODE_70)
+#                        define BOOST_PP_NODE_66(p) BOOST_PP_IIF(p(66), BOOST_PP_NODE_65, BOOST_PP_NODE_67)
+#                            define BOOST_PP_NODE_65(p) BOOST_PP_IIF(p(65), 65, 66)
+#                            define BOOST_PP_NODE_67(p) BOOST_PP_IIF(p(67), 67, 68)
+#                        define BOOST_PP_NODE_70(p) BOOST_PP_IIF(p(70), BOOST_PP_NODE_69, BOOST_PP_NODE_71)
+#                            define BOOST_PP_NODE_69(p) BOOST_PP_IIF(p(69), 69, 70)
+#                            define BOOST_PP_NODE_71(p) BOOST_PP_IIF(p(71), 71, 72)
+#                    define BOOST_PP_NODE_76(p) BOOST_PP_IIF(p(76), BOOST_PP_NODE_74, BOOST_PP_NODE_78)
+#                        define BOOST_PP_NODE_74(p) BOOST_PP_IIF(p(74), BOOST_PP_NODE_73, BOOST_PP_NODE_75)
+#                            define BOOST_PP_NODE_73(p) BOOST_PP_IIF(p(73), 73, 74)
+#                            define BOOST_PP_NODE_75(p) BOOST_PP_IIF(p(75), 75, 76)
+#                        define BOOST_PP_NODE_78(p) BOOST_PP_IIF(p(78), BOOST_PP_NODE_77, BOOST_PP_NODE_79)
+#                            define BOOST_PP_NODE_77(p) BOOST_PP_IIF(p(77), 77, 78)
+#                            define BOOST_PP_NODE_79(p) BOOST_PP_IIF(p(79), 79, 80)
+#                define BOOST_PP_NODE_88(p) BOOST_PP_IIF(p(88), BOOST_PP_NODE_84, BOOST_PP_NODE_92)
+#                    define BOOST_PP_NODE_84(p) BOOST_PP_IIF(p(84), BOOST_PP_NODE_82, BOOST_PP_NODE_86)
+#                        define BOOST_PP_NODE_82(p) BOOST_PP_IIF(p(82), BOOST_PP_NODE_81, BOOST_PP_NODE_83)
+#                            define BOOST_PP_NODE_81(p) BOOST_PP_IIF(p(81), 81, 82)
+#                            define BOOST_PP_NODE_83(p) BOOST_PP_IIF(p(83), 83, 84)
+#                        define BOOST_PP_NODE_86(p) BOOST_PP_IIF(p(86), BOOST_PP_NODE_85, BOOST_PP_NODE_87)
+#                            define BOOST_PP_NODE_85(p) BOOST_PP_IIF(p(85), 85, 86)
+#                            define BOOST_PP_NODE_87(p) BOOST_PP_IIF(p(87), 87, 88)
+#                    define BOOST_PP_NODE_92(p) BOOST_PP_IIF(p(92), BOOST_PP_NODE_90, BOOST_PP_NODE_94)
+#                        define BOOST_PP_NODE_90(p) BOOST_PP_IIF(p(90), BOOST_PP_NODE_89, BOOST_PP_NODE_91)
+#                            define BOOST_PP_NODE_89(p) BOOST_PP_IIF(p(89), 89, 90)
+#                            define BOOST_PP_NODE_91(p) BOOST_PP_IIF(p(91), 91, 92)
+#                        define BOOST_PP_NODE_94(p) BOOST_PP_IIF(p(94), BOOST_PP_NODE_93, BOOST_PP_NODE_95)
+#                            define BOOST_PP_NODE_93(p) BOOST_PP_IIF(p(93), 93, 94)
+#                            define BOOST_PP_NODE_95(p) BOOST_PP_IIF(p(95), 95, 96)
+#            define BOOST_PP_NODE_112(p) BOOST_PP_IIF(p(112), BOOST_PP_NODE_104, BOOST_PP_NODE_120)
+#                define BOOST_PP_NODE_104(p) BOOST_PP_IIF(p(104), BOOST_PP_NODE_100, BOOST_PP_NODE_108)
+#                    define BOOST_PP_NODE_100(p) BOOST_PP_IIF(p(100), BOOST_PP_NODE_98, BOOST_PP_NODE_102)
+#                        define BOOST_PP_NODE_98(p) BOOST_PP_IIF(p(98), BOOST_PP_NODE_97, BOOST_PP_NODE_99)
+#                            define BOOST_PP_NODE_97(p) BOOST_PP_IIF(p(97), 97, 98)
+#                            define BOOST_PP_NODE_99(p) BOOST_PP_IIF(p(99), 99, 100)
+#                        define BOOST_PP_NODE_102(p) BOOST_PP_IIF(p(102), BOOST_PP_NODE_101, BOOST_PP_NODE_103)
+#                            define BOOST_PP_NODE_101(p) BOOST_PP_IIF(p(101), 101, 102)
+#                            define BOOST_PP_NODE_103(p) BOOST_PP_IIF(p(103), 103, 104)
+#                    define BOOST_PP_NODE_108(p) BOOST_PP_IIF(p(108), BOOST_PP_NODE_106, BOOST_PP_NODE_110)
+#                        define BOOST_PP_NODE_106(p) BOOST_PP_IIF(p(106), BOOST_PP_NODE_105, BOOST_PP_NODE_107)
+#                            define BOOST_PP_NODE_105(p) BOOST_PP_IIF(p(105), 105, 106)
+#                            define BOOST_PP_NODE_107(p) BOOST_PP_IIF(p(107), 107, 108)
+#                        define BOOST_PP_NODE_110(p) BOOST_PP_IIF(p(110), BOOST_PP_NODE_109, BOOST_PP_NODE_111)
+#                            define BOOST_PP_NODE_109(p) BOOST_PP_IIF(p(109), 109, 110)
+#                            define BOOST_PP_NODE_111(p) BOOST_PP_IIF(p(111), 111, 112)
+#                define BOOST_PP_NODE_120(p) BOOST_PP_IIF(p(120), BOOST_PP_NODE_116, BOOST_PP_NODE_124)
+#                    define BOOST_PP_NODE_116(p) BOOST_PP_IIF(p(116), BOOST_PP_NODE_114, BOOST_PP_NODE_118)
+#                        define BOOST_PP_NODE_114(p) BOOST_PP_IIF(p(114), BOOST_PP_NODE_113, BOOST_PP_NODE_115)
+#                            define BOOST_PP_NODE_113(p) BOOST_PP_IIF(p(113), 113, 114)
+#                            define BOOST_PP_NODE_115(p) BOOST_PP_IIF(p(115), 115, 116)
+#                        define BOOST_PP_NODE_118(p) BOOST_PP_IIF(p(118), BOOST_PP_NODE_117, BOOST_PP_NODE_119)
+#                            define BOOST_PP_NODE_117(p) BOOST_PP_IIF(p(117), 117, 118)
+#                            define BOOST_PP_NODE_119(p) BOOST_PP_IIF(p(119), 119, 120)
+#                    define BOOST_PP_NODE_124(p) BOOST_PP_IIF(p(124), BOOST_PP_NODE_122, BOOST_PP_NODE_126)
+#                        define BOOST_PP_NODE_122(p) BOOST_PP_IIF(p(122), BOOST_PP_NODE_121, BOOST_PP_NODE_123)
+#                            define BOOST_PP_NODE_121(p) BOOST_PP_IIF(p(121), 121, 122)
+#                            define BOOST_PP_NODE_123(p) BOOST_PP_IIF(p(123), 123, 124)
+#                        define BOOST_PP_NODE_126(p) BOOST_PP_IIF(p(126), BOOST_PP_NODE_125, BOOST_PP_NODE_127)
+#                            define BOOST_PP_NODE_125(p) BOOST_PP_IIF(p(125), 125, 126)
+#                            define BOOST_PP_NODE_127(p) BOOST_PP_IIF(p(127), 127, 128)
+#    define BOOST_PP_NODE_192(p) BOOST_PP_IIF(p(192), BOOST_PP_NODE_160, BOOST_PP_NODE_224)
+#        define BOOST_PP_NODE_160(p) BOOST_PP_IIF(p(160), BOOST_PP_NODE_144, BOOST_PP_NODE_176)
+#            define BOOST_PP_NODE_144(p) BOOST_PP_IIF(p(144), BOOST_PP_NODE_136, BOOST_PP_NODE_152)
+#                define BOOST_PP_NODE_136(p) BOOST_PP_IIF(p(136), BOOST_PP_NODE_132, BOOST_PP_NODE_140)
+#                    define BOOST_PP_NODE_132(p) BOOST_PP_IIF(p(132), BOOST_PP_NODE_130, BOOST_PP_NODE_134)
+#                        define BOOST_PP_NODE_130(p) BOOST_PP_IIF(p(130), BOOST_PP_NODE_129, BOOST_PP_NODE_131)
+#                            define BOOST_PP_NODE_129(p) BOOST_PP_IIF(p(129), 129, 130)
+#                            define BOOST_PP_NODE_131(p) BOOST_PP_IIF(p(131), 131, 132)
+#                        define BOOST_PP_NODE_134(p) BOOST_PP_IIF(p(134), BOOST_PP_NODE_133, BOOST_PP_NODE_135)
+#                            define BOOST_PP_NODE_133(p) BOOST_PP_IIF(p(133), 133, 134)
+#                            define BOOST_PP_NODE_135(p) BOOST_PP_IIF(p(135), 135, 136)
+#                    define BOOST_PP_NODE_140(p) BOOST_PP_IIF(p(140), BOOST_PP_NODE_138, BOOST_PP_NODE_142)
+#                        define BOOST_PP_NODE_138(p) BOOST_PP_IIF(p(138), BOOST_PP_NODE_137, BOOST_PP_NODE_139)
+#                            define BOOST_PP_NODE_137(p) BOOST_PP_IIF(p(137), 137, 138)
+#                            define BOOST_PP_NODE_139(p) BOOST_PP_IIF(p(139), 139, 140)
+#                        define BOOST_PP_NODE_142(p) BOOST_PP_IIF(p(142), BOOST_PP_NODE_141, BOOST_PP_NODE_143)
+#                            define BOOST_PP_NODE_141(p) BOOST_PP_IIF(p(141), 141, 142)
+#                            define BOOST_PP_NODE_143(p) BOOST_PP_IIF(p(143), 143, 144)
+#                define BOOST_PP_NODE_152(p) BOOST_PP_IIF(p(152), BOOST_PP_NODE_148, BOOST_PP_NODE_156)
+#                    define BOOST_PP_NODE_148(p) BOOST_PP_IIF(p(148), BOOST_PP_NODE_146, BOOST_PP_NODE_150)
+#                        define BOOST_PP_NODE_146(p) BOOST_PP_IIF(p(146), BOOST_PP_NODE_145, BOOST_PP_NODE_147)
+#                            define BOOST_PP_NODE_145(p) BOOST_PP_IIF(p(145), 145, 146)
+#                            define BOOST_PP_NODE_147(p) BOOST_PP_IIF(p(147), 147, 148)
+#                        define BOOST_PP_NODE_150(p) BOOST_PP_IIF(p(150), BOOST_PP_NODE_149, BOOST_PP_NODE_151)
+#                            define BOOST_PP_NODE_149(p) BOOST_PP_IIF(p(149), 149, 150)
+#                            define BOOST_PP_NODE_151(p) BOOST_PP_IIF(p(151), 151, 152)
+#                    define BOOST_PP_NODE_156(p) BOOST_PP_IIF(p(156), BOOST_PP_NODE_154, BOOST_PP_NODE_158)
+#                        define BOOST_PP_NODE_154(p) BOOST_PP_IIF(p(154), BOOST_PP_NODE_153, BOOST_PP_NODE_155)
+#                            define BOOST_PP_NODE_153(p) BOOST_PP_IIF(p(153), 153, 154)
+#                            define BOOST_PP_NODE_155(p) BOOST_PP_IIF(p(155), 155, 156)
+#                        define BOOST_PP_NODE_158(p) BOOST_PP_IIF(p(158), BOOST_PP_NODE_157, BOOST_PP_NODE_159)
+#                            define BOOST_PP_NODE_157(p) BOOST_PP_IIF(p(157), 157, 158)
+#                            define BOOST_PP_NODE_159(p) BOOST_PP_IIF(p(159), 159, 160)
+#            define BOOST_PP_NODE_176(p) BOOST_PP_IIF(p(176), BOOST_PP_NODE_168, BOOST_PP_NODE_184)
+#                define BOOST_PP_NODE_168(p) BOOST_PP_IIF(p(168), BOOST_PP_NODE_164, BOOST_PP_NODE_172)
+#                    define BOOST_PP_NODE_164(p) BOOST_PP_IIF(p(164), BOOST_PP_NODE_162, BOOST_PP_NODE_166)
+#                        define BOOST_PP_NODE_162(p) BOOST_PP_IIF(p(162), BOOST_PP_NODE_161, BOOST_PP_NODE_163)
+#                            define BOOST_PP_NODE_161(p) BOOST_PP_IIF(p(161), 161, 162)
+#                            define BOOST_PP_NODE_163(p) BOOST_PP_IIF(p(163), 163, 164)
+#                        define BOOST_PP_NODE_166(p) BOOST_PP_IIF(p(166), BOOST_PP_NODE_165, BOOST_PP_NODE_167)
+#                            define BOOST_PP_NODE_165(p) BOOST_PP_IIF(p(165), 165, 166)
+#                            define BOOST_PP_NODE_167(p) BOOST_PP_IIF(p(167), 167, 168)
+#                    define BOOST_PP_NODE_172(p) BOOST_PP_IIF(p(172), BOOST_PP_NODE_170, BOOST_PP_NODE_174)
+#                        define BOOST_PP_NODE_170(p) BOOST_PP_IIF(p(170), BOOST_PP_NODE_169, BOOST_PP_NODE_171)
+#                            define BOOST_PP_NODE_169(p) BOOST_PP_IIF(p(169), 169, 170)
+#                            define BOOST_PP_NODE_171(p) BOOST_PP_IIF(p(171), 171, 172)
+#                        define BOOST_PP_NODE_174(p) BOOST_PP_IIF(p(174), BOOST_PP_NODE_173, BOOST_PP_NODE_175)
+#                            define BOOST_PP_NODE_173(p) BOOST_PP_IIF(p(173), 173, 174)
+#                            define BOOST_PP_NODE_175(p) BOOST_PP_IIF(p(175), 175, 176)
+#                define BOOST_PP_NODE_184(p) BOOST_PP_IIF(p(184), BOOST_PP_NODE_180, BOOST_PP_NODE_188)
+#                    define BOOST_PP_NODE_180(p) BOOST_PP_IIF(p(180), BOOST_PP_NODE_178, BOOST_PP_NODE_182)
+#                        define BOOST_PP_NODE_178(p) BOOST_PP_IIF(p(178), BOOST_PP_NODE_177, BOOST_PP_NODE_179)
+#                            define BOOST_PP_NODE_177(p) BOOST_PP_IIF(p(177), 177, 178)
+#                            define BOOST_PP_NODE_179(p) BOOST_PP_IIF(p(179), 179, 180)
+#                        define BOOST_PP_NODE_182(p) BOOST_PP_IIF(p(182), BOOST_PP_NODE_181, BOOST_PP_NODE_183)
+#                            define BOOST_PP_NODE_181(p) BOOST_PP_IIF(p(181), 181, 182)
+#                            define BOOST_PP_NODE_183(p) BOOST_PP_IIF(p(183), 183, 184)
+#                    define BOOST_PP_NODE_188(p) BOOST_PP_IIF(p(188), BOOST_PP_NODE_186, BOOST_PP_NODE_190)
+#                        define BOOST_PP_NODE_186(p) BOOST_PP_IIF(p(186), BOOST_PP_NODE_185, BOOST_PP_NODE_187)
+#                            define BOOST_PP_NODE_185(p) BOOST_PP_IIF(p(185), 185, 186)
+#                            define BOOST_PP_NODE_187(p) BOOST_PP_IIF(p(187), 187, 188)
+#                        define BOOST_PP_NODE_190(p) BOOST_PP_IIF(p(190), BOOST_PP_NODE_189, BOOST_PP_NODE_191)
+#                            define BOOST_PP_NODE_189(p) BOOST_PP_IIF(p(189), 189, 190)
+#                            define BOOST_PP_NODE_191(p) BOOST_PP_IIF(p(191), 191, 192)
+#        define BOOST_PP_NODE_224(p) BOOST_PP_IIF(p(224), BOOST_PP_NODE_208, BOOST_PP_NODE_240)
+#            define BOOST_PP_NODE_208(p) BOOST_PP_IIF(p(208), BOOST_PP_NODE_200, BOOST_PP_NODE_216)
+#                define BOOST_PP_NODE_200(p) BOOST_PP_IIF(p(200), BOOST_PP_NODE_196, BOOST_PP_NODE_204)
+#                    define BOOST_PP_NODE_196(p) BOOST_PP_IIF(p(196), BOOST_PP_NODE_194, BOOST_PP_NODE_198)
+#                        define BOOST_PP_NODE_194(p) BOOST_PP_IIF(p(194), BOOST_PP_NODE_193, BOOST_PP_NODE_195)
+#                            define BOOST_PP_NODE_193(p) BOOST_PP_IIF(p(193), 193, 194)
+#                            define BOOST_PP_NODE_195(p) BOOST_PP_IIF(p(195), 195, 196)
+#                        define BOOST_PP_NODE_198(p) BOOST_PP_IIF(p(198), BOOST_PP_NODE_197, BOOST_PP_NODE_199)
+#                            define BOOST_PP_NODE_197(p) BOOST_PP_IIF(p(197), 197, 198)
+#                            define BOOST_PP_NODE_199(p) BOOST_PP_IIF(p(199), 199, 200)
+#                    define BOOST_PP_NODE_204(p) BOOST_PP_IIF(p(204), BOOST_PP_NODE_202, BOOST_PP_NODE_206)
+#                        define BOOST_PP_NODE_202(p) BOOST_PP_IIF(p(202), BOOST_PP_NODE_201, BOOST_PP_NODE_203)
+#                            define BOOST_PP_NODE_201(p) BOOST_PP_IIF(p(201), 201, 202)
+#                            define BOOST_PP_NODE_203(p) BOOST_PP_IIF(p(203), 203, 204)
+#                        define BOOST_PP_NODE_206(p) BOOST_PP_IIF(p(206), BOOST_PP_NODE_205, BOOST_PP_NODE_207)
+#                            define BOOST_PP_NODE_205(p) BOOST_PP_IIF(p(205), 205, 206)
+#                            define BOOST_PP_NODE_207(p) BOOST_PP_IIF(p(207), 207, 208)
+#                define BOOST_PP_NODE_216(p) BOOST_PP_IIF(p(216), BOOST_PP_NODE_212, BOOST_PP_NODE_220)
+#                    define BOOST_PP_NODE_212(p) BOOST_PP_IIF(p(212), BOOST_PP_NODE_210, BOOST_PP_NODE_214)
+#                        define BOOST_PP_NODE_210(p) BOOST_PP_IIF(p(210), BOOST_PP_NODE_209, BOOST_PP_NODE_211)
+#                            define BOOST_PP_NODE_209(p) BOOST_PP_IIF(p(209), 209, 210)
+#                            define BOOST_PP_NODE_211(p) BOOST_PP_IIF(p(211), 211, 212)
+#                        define BOOST_PP_NODE_214(p) BOOST_PP_IIF(p(214), BOOST_PP_NODE_213, BOOST_PP_NODE_215)
+#                            define BOOST_PP_NODE_213(p) BOOST_PP_IIF(p(213), 213, 214)
+#                            define BOOST_PP_NODE_215(p) BOOST_PP_IIF(p(215), 215, 216)
+#                    define BOOST_PP_NODE_220(p) BOOST_PP_IIF(p(220), BOOST_PP_NODE_218, BOOST_PP_NODE_222)
+#                        define BOOST_PP_NODE_218(p) BOOST_PP_IIF(p(218), BOOST_PP_NODE_217, BOOST_PP_NODE_219)
+#                            define BOOST_PP_NODE_217(p) BOOST_PP_IIF(p(217), 217, 218)
+#                            define BOOST_PP_NODE_219(p) BOOST_PP_IIF(p(219), 219, 220)
+#                        define BOOST_PP_NODE_222(p) BOOST_PP_IIF(p(222), BOOST_PP_NODE_221, BOOST_PP_NODE_223)
+#                            define BOOST_PP_NODE_221(p) BOOST_PP_IIF(p(221), 221, 222)
+#                            define BOOST_PP_NODE_223(p) BOOST_PP_IIF(p(223), 223, 224)
+#            define BOOST_PP_NODE_240(p) BOOST_PP_IIF(p(240), BOOST_PP_NODE_232, BOOST_PP_NODE_248)
+#                define BOOST_PP_NODE_232(p) BOOST_PP_IIF(p(232), BOOST_PP_NODE_228, BOOST_PP_NODE_236)
+#                    define BOOST_PP_NODE_228(p) BOOST_PP_IIF(p(228), BOOST_PP_NODE_226, BOOST_PP_NODE_230)
+#                        define BOOST_PP_NODE_226(p) BOOST_PP_IIF(p(226), BOOST_PP_NODE_225, BOOST_PP_NODE_227)
+#                            define BOOST_PP_NODE_225(p) BOOST_PP_IIF(p(225), 225, 226)
+#                            define BOOST_PP_NODE_227(p) BOOST_PP_IIF(p(227), 227, 228)
+#                        define BOOST_PP_NODE_230(p) BOOST_PP_IIF(p(230), BOOST_PP_NODE_229, BOOST_PP_NODE_231)
+#                            define BOOST_PP_NODE_229(p) BOOST_PP_IIF(p(229), 229, 230)
+#                            define BOOST_PP_NODE_231(p) BOOST_PP_IIF(p(231), 231, 232)
+#                    define BOOST_PP_NODE_236(p) BOOST_PP_IIF(p(236), BOOST_PP_NODE_234, BOOST_PP_NODE_238)
+#                        define BOOST_PP_NODE_234(p) BOOST_PP_IIF(p(234), BOOST_PP_NODE_233, BOOST_PP_NODE_235)
+#                            define BOOST_PP_NODE_233(p) BOOST_PP_IIF(p(233), 233, 234)
+#                            define BOOST_PP_NODE_235(p) BOOST_PP_IIF(p(235), 235, 236)
+#                        define BOOST_PP_NODE_238(p) BOOST_PP_IIF(p(238), BOOST_PP_NODE_237, BOOST_PP_NODE_239)
+#                            define BOOST_PP_NODE_237(p) BOOST_PP_IIF(p(237), 237, 238)
+#                            define BOOST_PP_NODE_239(p) BOOST_PP_IIF(p(239), 239, 240)
+#                define BOOST_PP_NODE_248(p) BOOST_PP_IIF(p(248), BOOST_PP_NODE_244, BOOST_PP_NODE_252)
+#                    define BOOST_PP_NODE_244(p) BOOST_PP_IIF(p(244), BOOST_PP_NODE_242, BOOST_PP_NODE_246)
+#                        define BOOST_PP_NODE_242(p) BOOST_PP_IIF(p(242), BOOST_PP_NODE_241, BOOST_PP_NODE_243)
+#                            define BOOST_PP_NODE_241(p) BOOST_PP_IIF(p(241), 241, 242)
+#                            define BOOST_PP_NODE_243(p) BOOST_PP_IIF(p(243), 243, 244)
+#                        define BOOST_PP_NODE_246(p) BOOST_PP_IIF(p(246), BOOST_PP_NODE_245, BOOST_PP_NODE_247)
+#                            define BOOST_PP_NODE_245(p) BOOST_PP_IIF(p(245), 245, 246)
+#                            define BOOST_PP_NODE_247(p) BOOST_PP_IIF(p(247), 247, 248)
+#                    define BOOST_PP_NODE_252(p) BOOST_PP_IIF(p(252), BOOST_PP_NODE_250, BOOST_PP_NODE_254)
+#                        define BOOST_PP_NODE_250(p) BOOST_PP_IIF(p(250), BOOST_PP_NODE_249, BOOST_PP_NODE_251)
+#                            define BOOST_PP_NODE_249(p) BOOST_PP_IIF(p(249), 249, 250)
+#                            define BOOST_PP_NODE_251(p) BOOST_PP_IIF(p(251), 251, 252)
+#                        define BOOST_PP_NODE_254(p) BOOST_PP_IIF(p(254), BOOST_PP_NODE_253, BOOST_PP_NODE_255)
+#                            define BOOST_PP_NODE_253(p) BOOST_PP_IIF(p(253), 253, 254)
+#                            define BOOST_PP_NODE_255(p) BOOST_PP_IIF(p(255), 255, 256)
+#
+# endif
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/stringize.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/stringize.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/stringize.hpp	(working copy)
@@ -0,0 +1,33 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_STRINGIZE_HPP
+# define BOOST_PREPROCESSOR_STRINGIZE_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_STRINGIZE */
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_STRINGIZE(text) BOOST_PP_STRINGIZE_A((text))
+#    define BOOST_PP_STRINGIZE_A(arg) BOOST_PP_STRINGIZE_I arg
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_STRINGIZE(text) BOOST_PP_STRINGIZE_OO((text))
+#    define BOOST_PP_STRINGIZE_OO(par) BOOST_PP_STRINGIZE_I ## par
+# else
+#    define BOOST_PP_STRINGIZE(text) BOOST_PP_STRINGIZE_I(text)
+# endif
+#
+# define BOOST_PP_STRINGIZE_I(text) #text
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repeat.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repeat.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repeat.hpp	(working copy)
@@ -0,0 +1,17 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPEAT_HPP
+# define BOOST_PREPROCESSOR_REPEAT_HPP
+#
+# include <boost/preprocessor/repetition/repeat.hpp>
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/fold_left.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/fold_left.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/fold_left.hpp	(working copy)
@@ -0,0 +1,303 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_FOLD_LEFT_HPP
+# define BOOST_PREPROCESSOR_LIST_FOLD_LEFT_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/control/while.hpp>
+# include <boost/preprocessor/debug/error.hpp>
+# include <boost/preprocessor/detail/auto_rec.hpp>
+#
+# /* BOOST_PP_LIST_FOLD_LEFT */
+#
+# if 0
+#    define BOOST_PP_LIST_FOLD_LEFT(op, state, list)
+# endif
+#
+# define BOOST_PP_LIST_FOLD_LEFT BOOST_PP_CAT(BOOST_PP_LIST_FOLD_LEFT_, BOOST_PP_AUTO_REC(BOOST_PP_WHILE_P, 256))
+#
+# define BOOST_PP_LIST_FOLD_LEFT_257(o, s, l) BOOST_PP_ERROR(0x0004)
+#
+# define BOOST_PP_LIST_FOLD_LEFT_D(d, o, s, l) BOOST_PP_LIST_FOLD_LEFT_ ## d(o, s, l)
+# define BOOST_PP_LIST_FOLD_LEFT_2ND BOOST_PP_LIST_FOLD_LEFT
+# define BOOST_PP_LIST_FOLD_LEFT_2ND_D BOOST_PP_LIST_FOLD_LEFT_D
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    include <boost/preprocessor/list/detail/edg/fold_left.hpp>
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()
+#    include <boost/preprocessor/list/detail/dmc/fold_left.hpp>
+# else
+#    include <boost/preprocessor/list/detail/fold_left.hpp>
+# endif
+#
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_NIL 1
+#
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_1(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_2(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_3(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_4(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_5(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_6(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_7(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_8(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_9(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_10(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_11(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_12(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_13(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_14(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_15(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_16(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_17(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_18(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_19(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_20(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_21(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_22(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_23(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_24(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_25(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_26(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_27(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_28(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_29(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_30(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_31(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_32(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_33(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_34(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_35(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_36(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_37(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_38(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_39(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_40(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_41(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_42(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_43(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_44(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_45(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_46(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_47(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_48(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_49(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_50(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_51(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_52(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_53(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_54(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_55(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_56(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_57(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_58(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_59(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_60(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_61(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_62(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_63(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_64(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_65(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_66(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_67(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_68(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_69(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_70(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_71(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_72(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_73(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_74(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_75(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_76(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_77(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_78(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_79(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_80(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_81(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_82(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_83(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_84(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_85(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_86(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_87(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_88(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_89(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_90(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_91(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_92(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_93(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_94(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_95(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_96(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_97(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_98(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_99(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_100(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_101(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_102(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_103(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_104(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_105(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_106(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_107(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_108(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_109(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_110(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_111(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_112(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_113(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_114(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_115(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_116(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_117(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_118(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_119(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_120(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_121(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_122(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_123(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_124(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_125(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_126(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_127(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_128(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_129(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_130(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_131(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_132(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_133(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_134(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_135(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_136(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_137(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_138(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_139(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_140(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_141(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_142(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_143(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_144(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_145(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_146(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_147(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_148(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_149(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_150(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_151(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_152(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_153(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_154(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_155(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_156(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_157(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_158(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_159(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_160(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_161(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_162(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_163(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_164(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_165(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_166(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_167(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_168(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_169(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_170(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_171(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_172(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_173(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_174(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_175(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_176(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_177(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_178(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_179(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_180(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_181(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_182(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_183(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_184(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_185(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_186(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_187(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_188(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_189(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_190(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_191(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_192(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_193(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_194(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_195(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_196(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_197(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_198(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_199(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_200(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_201(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_202(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_203(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_204(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_205(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_206(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_207(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_208(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_209(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_210(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_211(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_212(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_213(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_214(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_215(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_216(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_217(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_218(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_219(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_220(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_221(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_222(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_223(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_224(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_225(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_226(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_227(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_228(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_229(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_230(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_231(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_232(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_233(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_234(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_235(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_236(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_237(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_238(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_239(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_240(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_241(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_242(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_243(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_244(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_245(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_246(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_247(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_248(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_249(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_250(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_251(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_252(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_253(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_254(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_255(o, s, l) 0
+# define BOOST_PP_LIST_FOLD_LEFT_CHECK_BOOST_PP_LIST_FOLD_LEFT_256(o, s, l) 0
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/append.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/append.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/append.hpp	(working copy)
@@ -0,0 +1,40 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_APPEND_HPP
+# define BOOST_PREPROCESSOR_LIST_APPEND_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/list/fold_right.hpp>
+#
+# /* BOOST_PP_LIST_APPEND */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_APPEND(a, b) BOOST_PP_LIST_FOLD_RIGHT(BOOST_PP_LIST_APPEND_O, b, a)
+# else
+#    define BOOST_PP_LIST_APPEND(a, b) BOOST_PP_LIST_APPEND_I(a, b)
+#    define BOOST_PP_LIST_APPEND_I(a, b) BOOST_PP_LIST_FOLD_RIGHT(BOOST_PP_LIST_APPEND_O, b, a)
+# endif
+#
+# define BOOST_PP_LIST_APPEND_O(d, s, x) (x, s)
+#
+# /* BOOST_PP_LIST_APPEND_D */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_APPEND_D(d, a, b) BOOST_PP_LIST_FOLD_RIGHT_ ## d(BOOST_PP_LIST_APPEND_O, b, a)
+# else
+#    define BOOST_PP_LIST_APPEND_D(d, a, b) BOOST_PP_LIST_APPEND_D_I(d, a, b)
+#    define BOOST_PP_LIST_APPEND_D_I(d, a, b) BOOST_PP_LIST_FOLD_RIGHT_ ## d(BOOST_PP_LIST_APPEND_O, b, a)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/adt.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/adt.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/adt.hpp	(working copy)
@@ -0,0 +1,73 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  *
+#  * See http://www.boost.org for most recent version.
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_ADT_HPP
+# define BOOST_PREPROCESSOR_LIST_ADT_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/detail/is_binary.hpp>
+# include <boost/preprocessor/logical/compl.hpp>
+# include <boost/preprocessor/tuple/eat.hpp>
+#
+# /* BOOST_PP_LIST_CONS */
+#
+# define BOOST_PP_LIST_CONS(head, tail) (head, tail)
+#
+# /* BOOST_PP_LIST_NIL */
+#
+# define BOOST_PP_LIST_NIL BOOST_PP_NIL
+#
+# /* BOOST_PP_LIST_FIRST */
+#
+# define BOOST_PP_LIST_FIRST(list) BOOST_PP_LIST_FIRST_D(list)
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_LIST_FIRST_D(list) BOOST_PP_LIST_FIRST_I list
+# else
+#    define BOOST_PP_LIST_FIRST_D(list) BOOST_PP_LIST_FIRST_I ## list
+# endif
+#
+# define BOOST_PP_LIST_FIRST_I(head, tail) head
+#
+# /* BOOST_PP_LIST_REST */
+#
+# define BOOST_PP_LIST_REST(list) BOOST_PP_LIST_REST_D(list)
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_LIST_REST_D(list) BOOST_PP_LIST_REST_I list
+# else
+#    define BOOST_PP_LIST_REST_D(list) BOOST_PP_LIST_REST_I ## list
+# endif
+#
+# define BOOST_PP_LIST_REST_I(head, tail) tail
+#
+# /* BOOST_PP_LIST_IS_CONS */
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_BCC()
+#    define BOOST_PP_LIST_IS_CONS(list) BOOST_PP_LIST_IS_CONS_D(list)
+#    define BOOST_PP_LIST_IS_CONS_D(list) BOOST_PP_LIST_IS_CONS_ ## list
+#    define BOOST_PP_LIST_IS_CONS_(head, tail) 1
+#    define BOOST_PP_LIST_IS_CONS_BOOST_PP_NIL 0
+# else
+#    define BOOST_PP_LIST_IS_CONS(list) BOOST_PP_IS_BINARY(list)
+# endif
+#
+# /* BOOST_PP_LIST_IS_NIL */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_BCC()
+#    define BOOST_PP_LIST_IS_NIL(list) BOOST_PP_COMPL(BOOST_PP_IS_BINARY(list))
+# else
+#    define BOOST_PP_LIST_IS_NIL(list) BOOST_PP_COMPL(BOOST_PP_LIST_IS_CONS(list))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/transform.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/transform.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/transform.hpp	(working copy)
@@ -0,0 +1,49 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_TRANSFORM_HPP
+# define BOOST_PREPROCESSOR_LIST_TRANSFORM_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/list/fold_right.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+# include <boost/preprocessor/tuple/rem.hpp>
+#
+# /* BOOST_PP_LIST_TRANSFORM */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_TRANSFORM(op, data, list) BOOST_PP_TUPLE_ELEM(3, 2, BOOST_PP_LIST_FOLD_RIGHT(BOOST_PP_LIST_TRANSFORM_O, (op, data, BOOST_PP_NIL), list))
+# else
+#    define BOOST_PP_LIST_TRANSFORM(op, data, list) BOOST_PP_LIST_TRANSFORM_I(op, data, list)
+#    define BOOST_PP_LIST_TRANSFORM_I(op, data, list) BOOST_PP_TUPLE_ELEM(3, 2, BOOST_PP_LIST_FOLD_RIGHT(BOOST_PP_LIST_TRANSFORM_O, (op, data, BOOST_PP_NIL), list))
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_TRANSFORM_O(d, odr, elem) BOOST_PP_LIST_TRANSFORM_O_D(d, BOOST_PP_TUPLE_ELEM(3, 0, odr), BOOST_PP_TUPLE_ELEM(3, 1, odr), BOOST_PP_TUPLE_ELEM(3, 2, odr), elem)
+# else
+#    define BOOST_PP_LIST_TRANSFORM_O(d, odr, elem) BOOST_PP_LIST_TRANSFORM_O_I(d, BOOST_PP_TUPLE_REM_3 odr, elem)
+#    define BOOST_PP_LIST_TRANSFORM_O_I(d, im, elem) BOOST_PP_LIST_TRANSFORM_O_D(d, im, elem)
+# endif
+#
+# define BOOST_PP_LIST_TRANSFORM_O_D(d, op, data, res, elem) (op, data, (op(d, data, elem), res))
+#
+# /* BOOST_PP_LIST_TRANSFORM_D */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_TRANSFORM_D(d, op, data, list) BOOST_PP_TUPLE_ELEM(3, 2, BOOST_PP_LIST_FOLD_RIGHT_ ## d(BOOST_PP_LIST_TRANSFORM_O, (op, data, BOOST_PP_NIL), list))
+# else
+#    define BOOST_PP_LIST_TRANSFORM_D(d, op, data, list) BOOST_PP_LIST_TRANSFORM_D_I(d, op, data, list)
+#    define BOOST_PP_LIST_TRANSFORM_D_I(d, op, data, list) BOOST_PP_TUPLE_ELEM(3, 2, BOOST_PP_LIST_FOLD_RIGHT_ ## d(BOOST_PP_LIST_TRANSFORM_O, (op, data, BOOST_PP_NIL), list))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/reverse.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/reverse.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/reverse.hpp	(working copy)
@@ -0,0 +1,40 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_REVERSE_HPP
+# define BOOST_PREPROCESSOR_LIST_REVERSE_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/list/fold_left.hpp>
+#
+# /* BOOST_PP_LIST_REVERSE */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_REVERSE(list) BOOST_PP_LIST_FOLD_LEFT(BOOST_PP_LIST_REVERSE_O, BOOST_PP_NIL, list)
+# else
+#    define BOOST_PP_LIST_REVERSE(list) BOOST_PP_LIST_REVERSE_I(list)
+#    define BOOST_PP_LIST_REVERSE_I(list) BOOST_PP_LIST_FOLD_LEFT(BOOST_PP_LIST_REVERSE_O, BOOST_PP_NIL, list)
+# endif
+#
+# define BOOST_PP_LIST_REVERSE_O(d, s, x) (x, s)
+#
+# /* BOOST_PP_LIST_REVERSE_D */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_REVERSE_D(d, list) BOOST_PP_LIST_FOLD_LEFT_ ## d(BOOST_PP_LIST_REVERSE_O, BOOST_PP_NIL, list)
+# else
+#    define BOOST_PP_LIST_REVERSE_D(d, list) BOOST_PP_LIST_REVERSE_D_I(d, list)
+#    define BOOST_PP_LIST_REVERSE_D_I(d, list) BOOST_PP_LIST_FOLD_LEFT_ ## d(BOOST_PP_LIST_REVERSE_O, BOOST_PP_NIL, list)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/detail/fold_left.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/detail/fold_left.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/detail/fold_left.hpp	(working copy)
@@ -0,0 +1,279 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_DETAIL_FOLD_LEFT_HPP
+# define BOOST_PREPROCESSOR_LIST_DETAIL_FOLD_LEFT_HPP
+#
+# include <boost/preprocessor/control/expr_iif.hpp>
+# include <boost/preprocessor/control/iif.hpp>
+# include <boost/preprocessor/list/adt.hpp>
+# include <boost/preprocessor/tuple/eat.hpp>
+#
+# define BOOST_PP_LIST_FOLD_LEFT_1(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_2, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(2, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_2(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_3, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(3, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_3(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_4, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(4, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_4(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_5, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(5, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_5(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_6, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(6, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_6(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_7, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(7, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_7(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_8, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(8, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_8(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_9, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(9, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_9(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_10, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(10, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_10(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_11, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(11, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_11(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_12, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(12, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_12(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_13, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(13, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_13(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_14, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(14, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_14(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_15, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(15, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_15(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_16, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(16, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_16(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_17, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(17, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_17(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_18, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(18, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_18(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_19, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(19, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_19(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_20, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(20, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_20(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_21, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(21, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_21(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_22, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(22, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_22(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_23, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(23, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_23(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_24, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(24, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_24(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_25, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(25, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_25(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_26, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(26, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_26(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_27, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(27, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_27(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_28, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(28, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_28(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_29, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(29, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_29(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_30, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(30, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_30(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_31, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(31, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_31(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_32, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(32, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_32(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_33, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(33, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_33(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_34, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(34, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_34(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_35, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(35, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_35(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_36, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(36, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_36(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_37, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(37, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_37(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_38, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(38, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_38(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_39, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(39, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_39(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_40, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(40, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_40(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_41, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(41, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_41(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_42, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(42, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_42(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_43, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(43, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_43(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_44, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(44, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_44(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_45, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(45, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_45(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_46, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(46, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_46(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_47, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(47, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_47(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_48, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(48, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_48(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_49, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(49, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_49(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_50, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(50, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_50(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_51, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(51, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_51(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_52, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(52, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_52(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_53, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(53, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_53(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_54, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(54, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_54(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_55, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(55, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_55(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_56, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(56, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_56(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_57, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(57, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_57(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_58, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(58, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_58(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_59, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(59, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_59(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_60, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(60, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_60(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_61, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(61, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_61(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_62, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(62, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_62(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_63, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(63, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_63(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_64, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(64, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_64(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_65, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(65, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_65(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_66, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(66, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_66(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_67, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(67, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_67(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_68, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(68, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_68(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_69, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(69, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_69(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_70, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(70, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_70(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_71, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(71, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_71(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_72, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(72, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_72(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_73, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(73, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_73(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_74, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(74, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_74(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_75, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(75, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_75(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_76, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(76, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_76(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_77, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(77, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_77(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_78, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(78, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_78(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_79, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(79, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_79(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_80, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(80, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_80(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_81, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(81, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_81(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_82, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(82, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_82(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_83, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(83, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_83(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_84, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(84, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_84(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_85, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(85, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_85(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_86, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(86, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_86(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_87, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(87, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_87(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_88, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(88, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_88(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_89, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(89, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_89(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_90, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(90, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_90(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_91, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(91, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_91(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_92, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(92, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_92(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_93, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(93, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_93(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_94, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(94, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_94(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_95, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(95, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_95(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_96, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(96, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_96(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_97, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(97, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_97(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_98, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(98, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_98(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_99, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(99, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_99(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_100, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(100, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_100(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_101, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(101, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_101(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_102, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(102, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_102(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_103, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(103, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_103(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_104, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(104, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_104(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_105, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(105, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_105(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_106, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(106, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_106(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_107, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(107, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_107(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_108, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(108, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_108(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_109, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(109, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_109(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_110, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(110, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_110(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_111, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(111, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_111(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_112, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(112, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_112(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_113, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(113, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_113(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_114, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(114, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_114(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_115, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(115, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_115(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_116, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(116, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_116(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_117, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(117, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_117(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_118, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(118, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_118(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_119, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(119, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_119(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_120, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(120, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_120(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_121, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(121, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_121(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_122, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(122, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_122(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_123, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(123, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_123(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_124, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(124, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_124(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_125, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(125, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_125(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_126, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(126, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_126(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_127, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(127, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_127(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_128, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(128, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_128(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_129, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(129, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_129(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_130, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(130, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_130(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_131, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(131, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_131(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_132, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(132, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_132(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_133, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(133, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_133(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_134, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(134, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_134(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_135, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(135, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_135(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_136, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(136, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_136(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_137, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(137, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_137(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_138, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(138, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_138(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_139, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(139, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_139(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_140, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(140, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_140(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_141, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(141, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_141(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_142, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(142, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_142(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_143, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(143, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_143(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_144, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(144, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_144(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_145, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(145, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_145(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_146, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(146, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_146(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_147, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(147, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_147(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_148, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(148, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_148(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_149, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(149, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_149(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_150, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(150, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_150(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_151, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(151, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_151(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_152, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(152, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_152(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_153, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(153, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_153(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_154, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(154, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_154(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_155, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(155, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_155(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_156, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(156, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_156(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_157, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(157, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_157(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_158, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(158, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_158(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_159, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(159, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_159(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_160, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(160, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_160(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_161, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(161, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_161(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_162, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(162, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_162(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_163, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(163, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_163(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_164, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(164, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_164(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_165, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(165, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_165(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_166, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(166, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_166(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_167, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(167, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_167(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_168, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(168, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_168(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_169, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(169, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_169(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_170, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(170, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_170(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_171, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(171, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_171(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_172, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(172, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_172(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_173, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(173, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_173(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_174, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(174, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_174(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_175, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(175, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_175(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_176, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(176, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_176(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_177, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(177, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_177(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_178, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(178, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_178(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_179, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(179, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_179(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_180, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(180, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_180(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_181, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(181, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_181(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_182, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(182, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_182(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_183, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(183, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_183(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_184, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(184, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_184(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_185, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(185, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_185(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_186, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(186, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_186(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_187, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(187, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_187(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_188, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(188, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_188(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_189, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(189, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_189(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_190, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(190, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_190(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_191, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(191, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_191(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_192, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(192, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_192(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_193, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(193, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_193(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_194, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(194, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_194(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_195, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(195, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_195(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_196, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(196, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_196(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_197, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(197, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_197(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_198, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(198, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_198(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_199, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(199, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_199(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_200, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(200, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_200(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_201, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(201, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_201(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_202, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(202, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_202(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_203, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(203, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_203(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_204, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(204, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_204(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_205, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(205, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_205(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_206, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(206, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_206(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_207, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(207, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_207(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_208, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(208, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_208(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_209, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(209, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_209(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_210, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(210, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_210(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_211, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(211, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_211(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_212, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(212, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_212(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_213, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(213, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_213(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_214, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(214, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_214(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_215, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(215, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_215(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_216, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(216, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_216(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_217, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(217, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_217(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_218, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(218, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_218(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_219, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(219, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_219(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_220, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(220, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_220(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_221, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(221, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_221(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_222, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(222, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_222(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_223, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(223, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_223(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_224, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(224, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_224(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_225, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(225, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_225(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_226, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(226, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_226(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_227, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(227, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_227(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_228, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(228, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_228(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_229, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(229, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_229(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_230, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(230, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_230(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_231, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(231, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_231(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_232, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(232, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_232(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_233, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(233, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_233(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_234, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(234, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_234(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_235, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(235, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_235(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_236, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(236, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_236(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_237, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(237, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_237(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_238, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(238, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_238(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_239, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(239, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_239(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_240, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(240, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_240(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_241, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(241, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_241(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_242, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(242, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_242(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_243, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(243, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_243(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_244, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(244, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_244(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_245, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(245, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_245(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_246, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(246, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_246(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_247, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(247, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_247(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_248, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(248, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_248(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_249, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(249, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_249(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_250, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(250, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_250(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_251, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(251, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_251(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_252, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(252, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_252(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_253, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(253, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_253(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_254, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(254, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_254(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_255, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(255, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_255(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_256, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(256, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+# define BOOST_PP_LIST_FOLD_LEFT_256(o, s, l) BOOST_PP_IIF(BOOST_PP_LIST_IS_CONS(l), BOOST_PP_LIST_FOLD_LEFT_257, s BOOST_PP_TUPLE_EAT_3)(o, BOOST_PP_EXPR_IIF(BOOST_PP_LIST_IS_CONS(l), o)(257, s, BOOST_PP_LIST_FIRST(l)), BOOST_PP_LIST_REST(l))
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/detail/fold_right.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/detail/fold_right.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/detail/fold_right.hpp	(working copy)
@@ -0,0 +1,277 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_DETAIL_FOLD_RIGHT_HPP
+# define BOOST_PREPROCESSOR_LIST_DETAIL_FOLD_RIGHT_HPP
+#
+# include <boost/preprocessor/list/fold_left.hpp>
+# include <boost/preprocessor/list/reverse.hpp>
+#
+# define BOOST_PP_LIST_FOLD_RIGHT_1(o, s, l) BOOST_PP_LIST_FOLD_LEFT_1(o, s, BOOST_PP_LIST_REVERSE_D(1, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_2(o, s, l) BOOST_PP_LIST_FOLD_LEFT_2(o, s, BOOST_PP_LIST_REVERSE_D(2, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_3(o, s, l) BOOST_PP_LIST_FOLD_LEFT_3(o, s, BOOST_PP_LIST_REVERSE_D(3, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_4(o, s, l) BOOST_PP_LIST_FOLD_LEFT_4(o, s, BOOST_PP_LIST_REVERSE_D(4, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_5(o, s, l) BOOST_PP_LIST_FOLD_LEFT_5(o, s, BOOST_PP_LIST_REVERSE_D(5, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_6(o, s, l) BOOST_PP_LIST_FOLD_LEFT_6(o, s, BOOST_PP_LIST_REVERSE_D(6, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_7(o, s, l) BOOST_PP_LIST_FOLD_LEFT_7(o, s, BOOST_PP_LIST_REVERSE_D(7, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_8(o, s, l) BOOST_PP_LIST_FOLD_LEFT_8(o, s, BOOST_PP_LIST_REVERSE_D(8, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_9(o, s, l) BOOST_PP_LIST_FOLD_LEFT_9(o, s, BOOST_PP_LIST_REVERSE_D(9, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_10(o, s, l) BOOST_PP_LIST_FOLD_LEFT_10(o, s, BOOST_PP_LIST_REVERSE_D(10, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_11(o, s, l) BOOST_PP_LIST_FOLD_LEFT_11(o, s, BOOST_PP_LIST_REVERSE_D(11, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_12(o, s, l) BOOST_PP_LIST_FOLD_LEFT_12(o, s, BOOST_PP_LIST_REVERSE_D(12, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_13(o, s, l) BOOST_PP_LIST_FOLD_LEFT_13(o, s, BOOST_PP_LIST_REVERSE_D(13, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_14(o, s, l) BOOST_PP_LIST_FOLD_LEFT_14(o, s, BOOST_PP_LIST_REVERSE_D(14, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_15(o, s, l) BOOST_PP_LIST_FOLD_LEFT_15(o, s, BOOST_PP_LIST_REVERSE_D(15, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_16(o, s, l) BOOST_PP_LIST_FOLD_LEFT_16(o, s, BOOST_PP_LIST_REVERSE_D(16, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_17(o, s, l) BOOST_PP_LIST_FOLD_LEFT_17(o, s, BOOST_PP_LIST_REVERSE_D(17, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_18(o, s, l) BOOST_PP_LIST_FOLD_LEFT_18(o, s, BOOST_PP_LIST_REVERSE_D(18, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_19(o, s, l) BOOST_PP_LIST_FOLD_LEFT_19(o, s, BOOST_PP_LIST_REVERSE_D(19, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_20(o, s, l) BOOST_PP_LIST_FOLD_LEFT_20(o, s, BOOST_PP_LIST_REVERSE_D(20, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_21(o, s, l) BOOST_PP_LIST_FOLD_LEFT_21(o, s, BOOST_PP_LIST_REVERSE_D(21, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_22(o, s, l) BOOST_PP_LIST_FOLD_LEFT_22(o, s, BOOST_PP_LIST_REVERSE_D(22, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_23(o, s, l) BOOST_PP_LIST_FOLD_LEFT_23(o, s, BOOST_PP_LIST_REVERSE_D(23, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_24(o, s, l) BOOST_PP_LIST_FOLD_LEFT_24(o, s, BOOST_PP_LIST_REVERSE_D(24, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_25(o, s, l) BOOST_PP_LIST_FOLD_LEFT_25(o, s, BOOST_PP_LIST_REVERSE_D(25, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_26(o, s, l) BOOST_PP_LIST_FOLD_LEFT_26(o, s, BOOST_PP_LIST_REVERSE_D(26, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_27(o, s, l) BOOST_PP_LIST_FOLD_LEFT_27(o, s, BOOST_PP_LIST_REVERSE_D(27, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_28(o, s, l) BOOST_PP_LIST_FOLD_LEFT_28(o, s, BOOST_PP_LIST_REVERSE_D(28, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_29(o, s, l) BOOST_PP_LIST_FOLD_LEFT_29(o, s, BOOST_PP_LIST_REVERSE_D(29, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_30(o, s, l) BOOST_PP_LIST_FOLD_LEFT_30(o, s, BOOST_PP_LIST_REVERSE_D(30, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_31(o, s, l) BOOST_PP_LIST_FOLD_LEFT_31(o, s, BOOST_PP_LIST_REVERSE_D(31, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_32(o, s, l) BOOST_PP_LIST_FOLD_LEFT_32(o, s, BOOST_PP_LIST_REVERSE_D(32, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_33(o, s, l) BOOST_PP_LIST_FOLD_LEFT_33(o, s, BOOST_PP_LIST_REVERSE_D(33, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_34(o, s, l) BOOST_PP_LIST_FOLD_LEFT_34(o, s, BOOST_PP_LIST_REVERSE_D(34, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_35(o, s, l) BOOST_PP_LIST_FOLD_LEFT_35(o, s, BOOST_PP_LIST_REVERSE_D(35, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_36(o, s, l) BOOST_PP_LIST_FOLD_LEFT_36(o, s, BOOST_PP_LIST_REVERSE_D(36, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_37(o, s, l) BOOST_PP_LIST_FOLD_LEFT_37(o, s, BOOST_PP_LIST_REVERSE_D(37, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_38(o, s, l) BOOST_PP_LIST_FOLD_LEFT_38(o, s, BOOST_PP_LIST_REVERSE_D(38, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_39(o, s, l) BOOST_PP_LIST_FOLD_LEFT_39(o, s, BOOST_PP_LIST_REVERSE_D(39, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_40(o, s, l) BOOST_PP_LIST_FOLD_LEFT_40(o, s, BOOST_PP_LIST_REVERSE_D(40, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_41(o, s, l) BOOST_PP_LIST_FOLD_LEFT_41(o, s, BOOST_PP_LIST_REVERSE_D(41, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_42(o, s, l) BOOST_PP_LIST_FOLD_LEFT_42(o, s, BOOST_PP_LIST_REVERSE_D(42, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_43(o, s, l) BOOST_PP_LIST_FOLD_LEFT_43(o, s, BOOST_PP_LIST_REVERSE_D(43, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_44(o, s, l) BOOST_PP_LIST_FOLD_LEFT_44(o, s, BOOST_PP_LIST_REVERSE_D(44, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_45(o, s, l) BOOST_PP_LIST_FOLD_LEFT_45(o, s, BOOST_PP_LIST_REVERSE_D(45, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_46(o, s, l) BOOST_PP_LIST_FOLD_LEFT_46(o, s, BOOST_PP_LIST_REVERSE_D(46, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_47(o, s, l) BOOST_PP_LIST_FOLD_LEFT_47(o, s, BOOST_PP_LIST_REVERSE_D(47, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_48(o, s, l) BOOST_PP_LIST_FOLD_LEFT_48(o, s, BOOST_PP_LIST_REVERSE_D(48, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_49(o, s, l) BOOST_PP_LIST_FOLD_LEFT_49(o, s, BOOST_PP_LIST_REVERSE_D(49, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_50(o, s, l) BOOST_PP_LIST_FOLD_LEFT_50(o, s, BOOST_PP_LIST_REVERSE_D(50, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_51(o, s, l) BOOST_PP_LIST_FOLD_LEFT_51(o, s, BOOST_PP_LIST_REVERSE_D(51, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_52(o, s, l) BOOST_PP_LIST_FOLD_LEFT_52(o, s, BOOST_PP_LIST_REVERSE_D(52, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_53(o, s, l) BOOST_PP_LIST_FOLD_LEFT_53(o, s, BOOST_PP_LIST_REVERSE_D(53, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_54(o, s, l) BOOST_PP_LIST_FOLD_LEFT_54(o, s, BOOST_PP_LIST_REVERSE_D(54, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_55(o, s, l) BOOST_PP_LIST_FOLD_LEFT_55(o, s, BOOST_PP_LIST_REVERSE_D(55, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_56(o, s, l) BOOST_PP_LIST_FOLD_LEFT_56(o, s, BOOST_PP_LIST_REVERSE_D(56, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_57(o, s, l) BOOST_PP_LIST_FOLD_LEFT_57(o, s, BOOST_PP_LIST_REVERSE_D(57, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_58(o, s, l) BOOST_PP_LIST_FOLD_LEFT_58(o, s, BOOST_PP_LIST_REVERSE_D(58, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_59(o, s, l) BOOST_PP_LIST_FOLD_LEFT_59(o, s, BOOST_PP_LIST_REVERSE_D(59, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_60(o, s, l) BOOST_PP_LIST_FOLD_LEFT_60(o, s, BOOST_PP_LIST_REVERSE_D(60, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_61(o, s, l) BOOST_PP_LIST_FOLD_LEFT_61(o, s, BOOST_PP_LIST_REVERSE_D(61, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_62(o, s, l) BOOST_PP_LIST_FOLD_LEFT_62(o, s, BOOST_PP_LIST_REVERSE_D(62, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_63(o, s, l) BOOST_PP_LIST_FOLD_LEFT_63(o, s, BOOST_PP_LIST_REVERSE_D(63, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_64(o, s, l) BOOST_PP_LIST_FOLD_LEFT_64(o, s, BOOST_PP_LIST_REVERSE_D(64, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_65(o, s, l) BOOST_PP_LIST_FOLD_LEFT_65(o, s, BOOST_PP_LIST_REVERSE_D(65, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_66(o, s, l) BOOST_PP_LIST_FOLD_LEFT_66(o, s, BOOST_PP_LIST_REVERSE_D(66, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_67(o, s, l) BOOST_PP_LIST_FOLD_LEFT_67(o, s, BOOST_PP_LIST_REVERSE_D(67, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_68(o, s, l) BOOST_PP_LIST_FOLD_LEFT_68(o, s, BOOST_PP_LIST_REVERSE_D(68, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_69(o, s, l) BOOST_PP_LIST_FOLD_LEFT_69(o, s, BOOST_PP_LIST_REVERSE_D(69, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_70(o, s, l) BOOST_PP_LIST_FOLD_LEFT_70(o, s, BOOST_PP_LIST_REVERSE_D(70, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_71(o, s, l) BOOST_PP_LIST_FOLD_LEFT_71(o, s, BOOST_PP_LIST_REVERSE_D(71, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_72(o, s, l) BOOST_PP_LIST_FOLD_LEFT_72(o, s, BOOST_PP_LIST_REVERSE_D(72, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_73(o, s, l) BOOST_PP_LIST_FOLD_LEFT_73(o, s, BOOST_PP_LIST_REVERSE_D(73, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_74(o, s, l) BOOST_PP_LIST_FOLD_LEFT_74(o, s, BOOST_PP_LIST_REVERSE_D(74, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_75(o, s, l) BOOST_PP_LIST_FOLD_LEFT_75(o, s, BOOST_PP_LIST_REVERSE_D(75, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_76(o, s, l) BOOST_PP_LIST_FOLD_LEFT_76(o, s, BOOST_PP_LIST_REVERSE_D(76, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_77(o, s, l) BOOST_PP_LIST_FOLD_LEFT_77(o, s, BOOST_PP_LIST_REVERSE_D(77, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_78(o, s, l) BOOST_PP_LIST_FOLD_LEFT_78(o, s, BOOST_PP_LIST_REVERSE_D(78, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_79(o, s, l) BOOST_PP_LIST_FOLD_LEFT_79(o, s, BOOST_PP_LIST_REVERSE_D(79, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_80(o, s, l) BOOST_PP_LIST_FOLD_LEFT_80(o, s, BOOST_PP_LIST_REVERSE_D(80, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_81(o, s, l) BOOST_PP_LIST_FOLD_LEFT_81(o, s, BOOST_PP_LIST_REVERSE_D(81, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_82(o, s, l) BOOST_PP_LIST_FOLD_LEFT_82(o, s, BOOST_PP_LIST_REVERSE_D(82, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_83(o, s, l) BOOST_PP_LIST_FOLD_LEFT_83(o, s, BOOST_PP_LIST_REVERSE_D(83, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_84(o, s, l) BOOST_PP_LIST_FOLD_LEFT_84(o, s, BOOST_PP_LIST_REVERSE_D(84, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_85(o, s, l) BOOST_PP_LIST_FOLD_LEFT_85(o, s, BOOST_PP_LIST_REVERSE_D(85, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_86(o, s, l) BOOST_PP_LIST_FOLD_LEFT_86(o, s, BOOST_PP_LIST_REVERSE_D(86, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_87(o, s, l) BOOST_PP_LIST_FOLD_LEFT_87(o, s, BOOST_PP_LIST_REVERSE_D(87, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_88(o, s, l) BOOST_PP_LIST_FOLD_LEFT_88(o, s, BOOST_PP_LIST_REVERSE_D(88, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_89(o, s, l) BOOST_PP_LIST_FOLD_LEFT_89(o, s, BOOST_PP_LIST_REVERSE_D(89, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_90(o, s, l) BOOST_PP_LIST_FOLD_LEFT_90(o, s, BOOST_PP_LIST_REVERSE_D(90, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_91(o, s, l) BOOST_PP_LIST_FOLD_LEFT_91(o, s, BOOST_PP_LIST_REVERSE_D(91, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_92(o, s, l) BOOST_PP_LIST_FOLD_LEFT_92(o, s, BOOST_PP_LIST_REVERSE_D(92, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_93(o, s, l) BOOST_PP_LIST_FOLD_LEFT_93(o, s, BOOST_PP_LIST_REVERSE_D(93, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_94(o, s, l) BOOST_PP_LIST_FOLD_LEFT_94(o, s, BOOST_PP_LIST_REVERSE_D(94, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_95(o, s, l) BOOST_PP_LIST_FOLD_LEFT_95(o, s, BOOST_PP_LIST_REVERSE_D(95, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_96(o, s, l) BOOST_PP_LIST_FOLD_LEFT_96(o, s, BOOST_PP_LIST_REVERSE_D(96, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_97(o, s, l) BOOST_PP_LIST_FOLD_LEFT_97(o, s, BOOST_PP_LIST_REVERSE_D(97, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_98(o, s, l) BOOST_PP_LIST_FOLD_LEFT_98(o, s, BOOST_PP_LIST_REVERSE_D(98, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_99(o, s, l) BOOST_PP_LIST_FOLD_LEFT_99(o, s, BOOST_PP_LIST_REVERSE_D(99, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_100(o, s, l) BOOST_PP_LIST_FOLD_LEFT_100(o, s, BOOST_PP_LIST_REVERSE_D(100, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_101(o, s, l) BOOST_PP_LIST_FOLD_LEFT_101(o, s, BOOST_PP_LIST_REVERSE_D(101, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_102(o, s, l) BOOST_PP_LIST_FOLD_LEFT_102(o, s, BOOST_PP_LIST_REVERSE_D(102, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_103(o, s, l) BOOST_PP_LIST_FOLD_LEFT_103(o, s, BOOST_PP_LIST_REVERSE_D(103, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_104(o, s, l) BOOST_PP_LIST_FOLD_LEFT_104(o, s, BOOST_PP_LIST_REVERSE_D(104, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_105(o, s, l) BOOST_PP_LIST_FOLD_LEFT_105(o, s, BOOST_PP_LIST_REVERSE_D(105, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_106(o, s, l) BOOST_PP_LIST_FOLD_LEFT_106(o, s, BOOST_PP_LIST_REVERSE_D(106, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_107(o, s, l) BOOST_PP_LIST_FOLD_LEFT_107(o, s, BOOST_PP_LIST_REVERSE_D(107, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_108(o, s, l) BOOST_PP_LIST_FOLD_LEFT_108(o, s, BOOST_PP_LIST_REVERSE_D(108, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_109(o, s, l) BOOST_PP_LIST_FOLD_LEFT_109(o, s, BOOST_PP_LIST_REVERSE_D(109, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_110(o, s, l) BOOST_PP_LIST_FOLD_LEFT_110(o, s, BOOST_PP_LIST_REVERSE_D(110, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_111(o, s, l) BOOST_PP_LIST_FOLD_LEFT_111(o, s, BOOST_PP_LIST_REVERSE_D(111, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_112(o, s, l) BOOST_PP_LIST_FOLD_LEFT_112(o, s, BOOST_PP_LIST_REVERSE_D(112, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_113(o, s, l) BOOST_PP_LIST_FOLD_LEFT_113(o, s, BOOST_PP_LIST_REVERSE_D(113, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_114(o, s, l) BOOST_PP_LIST_FOLD_LEFT_114(o, s, BOOST_PP_LIST_REVERSE_D(114, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_115(o, s, l) BOOST_PP_LIST_FOLD_LEFT_115(o, s, BOOST_PP_LIST_REVERSE_D(115, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_116(o, s, l) BOOST_PP_LIST_FOLD_LEFT_116(o, s, BOOST_PP_LIST_REVERSE_D(116, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_117(o, s, l) BOOST_PP_LIST_FOLD_LEFT_117(o, s, BOOST_PP_LIST_REVERSE_D(117, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_118(o, s, l) BOOST_PP_LIST_FOLD_LEFT_118(o, s, BOOST_PP_LIST_REVERSE_D(118, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_119(o, s, l) BOOST_PP_LIST_FOLD_LEFT_119(o, s, BOOST_PP_LIST_REVERSE_D(119, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_120(o, s, l) BOOST_PP_LIST_FOLD_LEFT_120(o, s, BOOST_PP_LIST_REVERSE_D(120, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_121(o, s, l) BOOST_PP_LIST_FOLD_LEFT_121(o, s, BOOST_PP_LIST_REVERSE_D(121, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_122(o, s, l) BOOST_PP_LIST_FOLD_LEFT_122(o, s, BOOST_PP_LIST_REVERSE_D(122, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_123(o, s, l) BOOST_PP_LIST_FOLD_LEFT_123(o, s, BOOST_PP_LIST_REVERSE_D(123, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_124(o, s, l) BOOST_PP_LIST_FOLD_LEFT_124(o, s, BOOST_PP_LIST_REVERSE_D(124, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_125(o, s, l) BOOST_PP_LIST_FOLD_LEFT_125(o, s, BOOST_PP_LIST_REVERSE_D(125, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_126(o, s, l) BOOST_PP_LIST_FOLD_LEFT_126(o, s, BOOST_PP_LIST_REVERSE_D(126, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_127(o, s, l) BOOST_PP_LIST_FOLD_LEFT_127(o, s, BOOST_PP_LIST_REVERSE_D(127, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_128(o, s, l) BOOST_PP_LIST_FOLD_LEFT_128(o, s, BOOST_PP_LIST_REVERSE_D(128, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_129(o, s, l) BOOST_PP_LIST_FOLD_LEFT_129(o, s, BOOST_PP_LIST_REVERSE_D(129, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_130(o, s, l) BOOST_PP_LIST_FOLD_LEFT_130(o, s, BOOST_PP_LIST_REVERSE_D(130, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_131(o, s, l) BOOST_PP_LIST_FOLD_LEFT_131(o, s, BOOST_PP_LIST_REVERSE_D(131, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_132(o, s, l) BOOST_PP_LIST_FOLD_LEFT_132(o, s, BOOST_PP_LIST_REVERSE_D(132, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_133(o, s, l) BOOST_PP_LIST_FOLD_LEFT_133(o, s, BOOST_PP_LIST_REVERSE_D(133, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_134(o, s, l) BOOST_PP_LIST_FOLD_LEFT_134(o, s, BOOST_PP_LIST_REVERSE_D(134, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_135(o, s, l) BOOST_PP_LIST_FOLD_LEFT_135(o, s, BOOST_PP_LIST_REVERSE_D(135, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_136(o, s, l) BOOST_PP_LIST_FOLD_LEFT_136(o, s, BOOST_PP_LIST_REVERSE_D(136, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_137(o, s, l) BOOST_PP_LIST_FOLD_LEFT_137(o, s, BOOST_PP_LIST_REVERSE_D(137, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_138(o, s, l) BOOST_PP_LIST_FOLD_LEFT_138(o, s, BOOST_PP_LIST_REVERSE_D(138, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_139(o, s, l) BOOST_PP_LIST_FOLD_LEFT_139(o, s, BOOST_PP_LIST_REVERSE_D(139, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_140(o, s, l) BOOST_PP_LIST_FOLD_LEFT_140(o, s, BOOST_PP_LIST_REVERSE_D(140, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_141(o, s, l) BOOST_PP_LIST_FOLD_LEFT_141(o, s, BOOST_PP_LIST_REVERSE_D(141, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_142(o, s, l) BOOST_PP_LIST_FOLD_LEFT_142(o, s, BOOST_PP_LIST_REVERSE_D(142, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_143(o, s, l) BOOST_PP_LIST_FOLD_LEFT_143(o, s, BOOST_PP_LIST_REVERSE_D(143, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_144(o, s, l) BOOST_PP_LIST_FOLD_LEFT_144(o, s, BOOST_PP_LIST_REVERSE_D(144, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_145(o, s, l) BOOST_PP_LIST_FOLD_LEFT_145(o, s, BOOST_PP_LIST_REVERSE_D(145, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_146(o, s, l) BOOST_PP_LIST_FOLD_LEFT_146(o, s, BOOST_PP_LIST_REVERSE_D(146, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_147(o, s, l) BOOST_PP_LIST_FOLD_LEFT_147(o, s, BOOST_PP_LIST_REVERSE_D(147, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_148(o, s, l) BOOST_PP_LIST_FOLD_LEFT_148(o, s, BOOST_PP_LIST_REVERSE_D(148, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_149(o, s, l) BOOST_PP_LIST_FOLD_LEFT_149(o, s, BOOST_PP_LIST_REVERSE_D(149, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_150(o, s, l) BOOST_PP_LIST_FOLD_LEFT_150(o, s, BOOST_PP_LIST_REVERSE_D(150, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_151(o, s, l) BOOST_PP_LIST_FOLD_LEFT_151(o, s, BOOST_PP_LIST_REVERSE_D(151, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_152(o, s, l) BOOST_PP_LIST_FOLD_LEFT_152(o, s, BOOST_PP_LIST_REVERSE_D(152, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_153(o, s, l) BOOST_PP_LIST_FOLD_LEFT_153(o, s, BOOST_PP_LIST_REVERSE_D(153, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_154(o, s, l) BOOST_PP_LIST_FOLD_LEFT_154(o, s, BOOST_PP_LIST_REVERSE_D(154, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_155(o, s, l) BOOST_PP_LIST_FOLD_LEFT_155(o, s, BOOST_PP_LIST_REVERSE_D(155, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_156(o, s, l) BOOST_PP_LIST_FOLD_LEFT_156(o, s, BOOST_PP_LIST_REVERSE_D(156, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_157(o, s, l) BOOST_PP_LIST_FOLD_LEFT_157(o, s, BOOST_PP_LIST_REVERSE_D(157, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_158(o, s, l) BOOST_PP_LIST_FOLD_LEFT_158(o, s, BOOST_PP_LIST_REVERSE_D(158, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_159(o, s, l) BOOST_PP_LIST_FOLD_LEFT_159(o, s, BOOST_PP_LIST_REVERSE_D(159, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_160(o, s, l) BOOST_PP_LIST_FOLD_LEFT_160(o, s, BOOST_PP_LIST_REVERSE_D(160, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_161(o, s, l) BOOST_PP_LIST_FOLD_LEFT_161(o, s, BOOST_PP_LIST_REVERSE_D(161, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_162(o, s, l) BOOST_PP_LIST_FOLD_LEFT_162(o, s, BOOST_PP_LIST_REVERSE_D(162, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_163(o, s, l) BOOST_PP_LIST_FOLD_LEFT_163(o, s, BOOST_PP_LIST_REVERSE_D(163, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_164(o, s, l) BOOST_PP_LIST_FOLD_LEFT_164(o, s, BOOST_PP_LIST_REVERSE_D(164, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_165(o, s, l) BOOST_PP_LIST_FOLD_LEFT_165(o, s, BOOST_PP_LIST_REVERSE_D(165, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_166(o, s, l) BOOST_PP_LIST_FOLD_LEFT_166(o, s, BOOST_PP_LIST_REVERSE_D(166, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_167(o, s, l) BOOST_PP_LIST_FOLD_LEFT_167(o, s, BOOST_PP_LIST_REVERSE_D(167, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_168(o, s, l) BOOST_PP_LIST_FOLD_LEFT_168(o, s, BOOST_PP_LIST_REVERSE_D(168, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_169(o, s, l) BOOST_PP_LIST_FOLD_LEFT_169(o, s, BOOST_PP_LIST_REVERSE_D(169, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_170(o, s, l) BOOST_PP_LIST_FOLD_LEFT_170(o, s, BOOST_PP_LIST_REVERSE_D(170, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_171(o, s, l) BOOST_PP_LIST_FOLD_LEFT_171(o, s, BOOST_PP_LIST_REVERSE_D(171, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_172(o, s, l) BOOST_PP_LIST_FOLD_LEFT_172(o, s, BOOST_PP_LIST_REVERSE_D(172, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_173(o, s, l) BOOST_PP_LIST_FOLD_LEFT_173(o, s, BOOST_PP_LIST_REVERSE_D(173, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_174(o, s, l) BOOST_PP_LIST_FOLD_LEFT_174(o, s, BOOST_PP_LIST_REVERSE_D(174, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_175(o, s, l) BOOST_PP_LIST_FOLD_LEFT_175(o, s, BOOST_PP_LIST_REVERSE_D(175, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_176(o, s, l) BOOST_PP_LIST_FOLD_LEFT_176(o, s, BOOST_PP_LIST_REVERSE_D(176, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_177(o, s, l) BOOST_PP_LIST_FOLD_LEFT_177(o, s, BOOST_PP_LIST_REVERSE_D(177, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_178(o, s, l) BOOST_PP_LIST_FOLD_LEFT_178(o, s, BOOST_PP_LIST_REVERSE_D(178, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_179(o, s, l) BOOST_PP_LIST_FOLD_LEFT_179(o, s, BOOST_PP_LIST_REVERSE_D(179, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_180(o, s, l) BOOST_PP_LIST_FOLD_LEFT_180(o, s, BOOST_PP_LIST_REVERSE_D(180, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_181(o, s, l) BOOST_PP_LIST_FOLD_LEFT_181(o, s, BOOST_PP_LIST_REVERSE_D(181, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_182(o, s, l) BOOST_PP_LIST_FOLD_LEFT_182(o, s, BOOST_PP_LIST_REVERSE_D(182, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_183(o, s, l) BOOST_PP_LIST_FOLD_LEFT_183(o, s, BOOST_PP_LIST_REVERSE_D(183, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_184(o, s, l) BOOST_PP_LIST_FOLD_LEFT_184(o, s, BOOST_PP_LIST_REVERSE_D(184, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_185(o, s, l) BOOST_PP_LIST_FOLD_LEFT_185(o, s, BOOST_PP_LIST_REVERSE_D(185, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_186(o, s, l) BOOST_PP_LIST_FOLD_LEFT_186(o, s, BOOST_PP_LIST_REVERSE_D(186, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_187(o, s, l) BOOST_PP_LIST_FOLD_LEFT_187(o, s, BOOST_PP_LIST_REVERSE_D(187, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_188(o, s, l) BOOST_PP_LIST_FOLD_LEFT_188(o, s, BOOST_PP_LIST_REVERSE_D(188, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_189(o, s, l) BOOST_PP_LIST_FOLD_LEFT_189(o, s, BOOST_PP_LIST_REVERSE_D(189, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_190(o, s, l) BOOST_PP_LIST_FOLD_LEFT_190(o, s, BOOST_PP_LIST_REVERSE_D(190, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_191(o, s, l) BOOST_PP_LIST_FOLD_LEFT_191(o, s, BOOST_PP_LIST_REVERSE_D(191, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_192(o, s, l) BOOST_PP_LIST_FOLD_LEFT_192(o, s, BOOST_PP_LIST_REVERSE_D(192, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_193(o, s, l) BOOST_PP_LIST_FOLD_LEFT_193(o, s, BOOST_PP_LIST_REVERSE_D(193, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_194(o, s, l) BOOST_PP_LIST_FOLD_LEFT_194(o, s, BOOST_PP_LIST_REVERSE_D(194, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_195(o, s, l) BOOST_PP_LIST_FOLD_LEFT_195(o, s, BOOST_PP_LIST_REVERSE_D(195, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_196(o, s, l) BOOST_PP_LIST_FOLD_LEFT_196(o, s, BOOST_PP_LIST_REVERSE_D(196, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_197(o, s, l) BOOST_PP_LIST_FOLD_LEFT_197(o, s, BOOST_PP_LIST_REVERSE_D(197, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_198(o, s, l) BOOST_PP_LIST_FOLD_LEFT_198(o, s, BOOST_PP_LIST_REVERSE_D(198, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_199(o, s, l) BOOST_PP_LIST_FOLD_LEFT_199(o, s, BOOST_PP_LIST_REVERSE_D(199, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_200(o, s, l) BOOST_PP_LIST_FOLD_LEFT_200(o, s, BOOST_PP_LIST_REVERSE_D(200, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_201(o, s, l) BOOST_PP_LIST_FOLD_LEFT_201(o, s, BOOST_PP_LIST_REVERSE_D(201, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_202(o, s, l) BOOST_PP_LIST_FOLD_LEFT_202(o, s, BOOST_PP_LIST_REVERSE_D(202, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_203(o, s, l) BOOST_PP_LIST_FOLD_LEFT_203(o, s, BOOST_PP_LIST_REVERSE_D(203, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_204(o, s, l) BOOST_PP_LIST_FOLD_LEFT_204(o, s, BOOST_PP_LIST_REVERSE_D(204, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_205(o, s, l) BOOST_PP_LIST_FOLD_LEFT_205(o, s, BOOST_PP_LIST_REVERSE_D(205, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_206(o, s, l) BOOST_PP_LIST_FOLD_LEFT_206(o, s, BOOST_PP_LIST_REVERSE_D(206, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_207(o, s, l) BOOST_PP_LIST_FOLD_LEFT_207(o, s, BOOST_PP_LIST_REVERSE_D(207, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_208(o, s, l) BOOST_PP_LIST_FOLD_LEFT_208(o, s, BOOST_PP_LIST_REVERSE_D(208, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_209(o, s, l) BOOST_PP_LIST_FOLD_LEFT_209(o, s, BOOST_PP_LIST_REVERSE_D(209, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_210(o, s, l) BOOST_PP_LIST_FOLD_LEFT_210(o, s, BOOST_PP_LIST_REVERSE_D(210, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_211(o, s, l) BOOST_PP_LIST_FOLD_LEFT_211(o, s, BOOST_PP_LIST_REVERSE_D(211, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_212(o, s, l) BOOST_PP_LIST_FOLD_LEFT_212(o, s, BOOST_PP_LIST_REVERSE_D(212, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_213(o, s, l) BOOST_PP_LIST_FOLD_LEFT_213(o, s, BOOST_PP_LIST_REVERSE_D(213, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_214(o, s, l) BOOST_PP_LIST_FOLD_LEFT_214(o, s, BOOST_PP_LIST_REVERSE_D(214, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_215(o, s, l) BOOST_PP_LIST_FOLD_LEFT_215(o, s, BOOST_PP_LIST_REVERSE_D(215, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_216(o, s, l) BOOST_PP_LIST_FOLD_LEFT_216(o, s, BOOST_PP_LIST_REVERSE_D(216, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_217(o, s, l) BOOST_PP_LIST_FOLD_LEFT_217(o, s, BOOST_PP_LIST_REVERSE_D(217, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_218(o, s, l) BOOST_PP_LIST_FOLD_LEFT_218(o, s, BOOST_PP_LIST_REVERSE_D(218, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_219(o, s, l) BOOST_PP_LIST_FOLD_LEFT_219(o, s, BOOST_PP_LIST_REVERSE_D(219, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_220(o, s, l) BOOST_PP_LIST_FOLD_LEFT_220(o, s, BOOST_PP_LIST_REVERSE_D(220, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_221(o, s, l) BOOST_PP_LIST_FOLD_LEFT_221(o, s, BOOST_PP_LIST_REVERSE_D(221, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_222(o, s, l) BOOST_PP_LIST_FOLD_LEFT_222(o, s, BOOST_PP_LIST_REVERSE_D(222, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_223(o, s, l) BOOST_PP_LIST_FOLD_LEFT_223(o, s, BOOST_PP_LIST_REVERSE_D(223, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_224(o, s, l) BOOST_PP_LIST_FOLD_LEFT_224(o, s, BOOST_PP_LIST_REVERSE_D(224, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_225(o, s, l) BOOST_PP_LIST_FOLD_LEFT_225(o, s, BOOST_PP_LIST_REVERSE_D(225, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_226(o, s, l) BOOST_PP_LIST_FOLD_LEFT_226(o, s, BOOST_PP_LIST_REVERSE_D(226, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_227(o, s, l) BOOST_PP_LIST_FOLD_LEFT_227(o, s, BOOST_PP_LIST_REVERSE_D(227, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_228(o, s, l) BOOST_PP_LIST_FOLD_LEFT_228(o, s, BOOST_PP_LIST_REVERSE_D(228, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_229(o, s, l) BOOST_PP_LIST_FOLD_LEFT_229(o, s, BOOST_PP_LIST_REVERSE_D(229, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_230(o, s, l) BOOST_PP_LIST_FOLD_LEFT_230(o, s, BOOST_PP_LIST_REVERSE_D(230, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_231(o, s, l) BOOST_PP_LIST_FOLD_LEFT_231(o, s, BOOST_PP_LIST_REVERSE_D(231, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_232(o, s, l) BOOST_PP_LIST_FOLD_LEFT_232(o, s, BOOST_PP_LIST_REVERSE_D(232, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_233(o, s, l) BOOST_PP_LIST_FOLD_LEFT_233(o, s, BOOST_PP_LIST_REVERSE_D(233, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_234(o, s, l) BOOST_PP_LIST_FOLD_LEFT_234(o, s, BOOST_PP_LIST_REVERSE_D(234, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_235(o, s, l) BOOST_PP_LIST_FOLD_LEFT_235(o, s, BOOST_PP_LIST_REVERSE_D(235, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_236(o, s, l) BOOST_PP_LIST_FOLD_LEFT_236(o, s, BOOST_PP_LIST_REVERSE_D(236, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_237(o, s, l) BOOST_PP_LIST_FOLD_LEFT_237(o, s, BOOST_PP_LIST_REVERSE_D(237, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_238(o, s, l) BOOST_PP_LIST_FOLD_LEFT_238(o, s, BOOST_PP_LIST_REVERSE_D(238, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_239(o, s, l) BOOST_PP_LIST_FOLD_LEFT_239(o, s, BOOST_PP_LIST_REVERSE_D(239, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_240(o, s, l) BOOST_PP_LIST_FOLD_LEFT_240(o, s, BOOST_PP_LIST_REVERSE_D(240, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_241(o, s, l) BOOST_PP_LIST_FOLD_LEFT_241(o, s, BOOST_PP_LIST_REVERSE_D(241, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_242(o, s, l) BOOST_PP_LIST_FOLD_LEFT_242(o, s, BOOST_PP_LIST_REVERSE_D(242, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_243(o, s, l) BOOST_PP_LIST_FOLD_LEFT_243(o, s, BOOST_PP_LIST_REVERSE_D(243, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_244(o, s, l) BOOST_PP_LIST_FOLD_LEFT_244(o, s, BOOST_PP_LIST_REVERSE_D(244, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_245(o, s, l) BOOST_PP_LIST_FOLD_LEFT_245(o, s, BOOST_PP_LIST_REVERSE_D(245, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_246(o, s, l) BOOST_PP_LIST_FOLD_LEFT_246(o, s, BOOST_PP_LIST_REVERSE_D(246, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_247(o, s, l) BOOST_PP_LIST_FOLD_LEFT_247(o, s, BOOST_PP_LIST_REVERSE_D(247, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_248(o, s, l) BOOST_PP_LIST_FOLD_LEFT_248(o, s, BOOST_PP_LIST_REVERSE_D(248, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_249(o, s, l) BOOST_PP_LIST_FOLD_LEFT_249(o, s, BOOST_PP_LIST_REVERSE_D(249, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_250(o, s, l) BOOST_PP_LIST_FOLD_LEFT_250(o, s, BOOST_PP_LIST_REVERSE_D(250, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_251(o, s, l) BOOST_PP_LIST_FOLD_LEFT_251(o, s, BOOST_PP_LIST_REVERSE_D(251, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_252(o, s, l) BOOST_PP_LIST_FOLD_LEFT_252(o, s, BOOST_PP_LIST_REVERSE_D(252, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_253(o, s, l) BOOST_PP_LIST_FOLD_LEFT_253(o, s, BOOST_PP_LIST_REVERSE_D(253, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_254(o, s, l) BOOST_PP_LIST_FOLD_LEFT_254(o, s, BOOST_PP_LIST_REVERSE_D(254, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_255(o, s, l) BOOST_PP_LIST_FOLD_LEFT_255(o, s, BOOST_PP_LIST_REVERSE_D(255, l))
+# define BOOST_PP_LIST_FOLD_RIGHT_256(o, s, l) BOOST_PP_LIST_FOLD_LEFT_256(o, s, BOOST_PP_LIST_REVERSE_D(256, l))
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/for_each_i.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/for_each_i.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/for_each_i.hpp	(working copy)
@@ -0,0 +1,65 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_LIST_FOR_EACH_I_HPP
+# define BOOST_PREPROCESSOR_LIST_LIST_FOR_EACH_I_HPP
+#
+# include <boost/preprocessor/arithmetic/inc.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/list/adt.hpp>
+# include <boost/preprocessor/repetition/for.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+# include <boost/preprocessor/tuple/rem.hpp>
+#
+# /* BOOST_PP_LIST_FOR_EACH_I */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG() && ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_LIST_FOR_EACH_I(macro, data, list) BOOST_PP_FOR((macro, data, list, 0), BOOST_PP_LIST_FOR_EACH_I_P, BOOST_PP_LIST_FOR_EACH_I_O, BOOST_PP_LIST_FOR_EACH_I_M)
+# else
+#    define BOOST_PP_LIST_FOR_EACH_I(macro, data, list) BOOST_PP_LIST_FOR_EACH_I_I(macro, data, list)
+#    define BOOST_PP_LIST_FOR_EACH_I_I(macro, data, list) BOOST_PP_FOR((macro, data, list, 0), BOOST_PP_LIST_FOR_EACH_I_P, BOOST_PP_LIST_FOR_EACH_I_O, BOOST_PP_LIST_FOR_EACH_I_M)
+# endif
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_STRICT()
+#    define BOOST_PP_LIST_FOR_EACH_I_P(r, x) BOOST_PP_LIST_FOR_EACH_I_P_D x
+#    define BOOST_PP_LIST_FOR_EACH_I_P_D(m, d, l, i) BOOST_PP_LIST_IS_CONS(l)
+# else
+#    define BOOST_PP_LIST_FOR_EACH_I_P(r, x) BOOST_PP_LIST_IS_CONS(BOOST_PP_TUPLE_ELEM(4, 2, x))
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_LIST_FOR_EACH_I_O(r, x) BOOST_PP_LIST_FOR_EACH_I_O_D x
+#    define BOOST_PP_LIST_FOR_EACH_I_O_D(m, d, l, i) (m, d, BOOST_PP_LIST_REST(l), BOOST_PP_INC(i))
+# else
+#    define BOOST_PP_LIST_FOR_EACH_I_O(r, x) (BOOST_PP_TUPLE_ELEM(4, 0, x), BOOST_PP_TUPLE_ELEM(4, 1, x), BOOST_PP_LIST_REST(BOOST_PP_TUPLE_ELEM(4, 2, x)), BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(4, 3, x)))
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_FOR_EACH_I_M(r, x) BOOST_PP_LIST_FOR_EACH_I_M_D(r, BOOST_PP_TUPLE_ELEM(4, 0, x), BOOST_PP_TUPLE_ELEM(4, 1, x), BOOST_PP_TUPLE_ELEM(4, 2, x), BOOST_PP_TUPLE_ELEM(4, 3, x))
+# else
+#    define BOOST_PP_LIST_FOR_EACH_I_M(r, x) BOOST_PP_LIST_FOR_EACH_I_M_I(r, BOOST_PP_TUPLE_REM_4 x)
+#    define BOOST_PP_LIST_FOR_EACH_I_M_I(r, x_e) BOOST_PP_LIST_FOR_EACH_I_M_D(r, x_e)
+# endif
+#
+# define BOOST_PP_LIST_FOR_EACH_I_M_D(r, m, d, l, i) m(r, d, i, BOOST_PP_LIST_FIRST(l))
+#
+# /* BOOST_PP_LIST_FOR_EACH_I_R */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_LIST_FOR_EACH_I_R(r, macro, data, list) BOOST_PP_FOR_ ## r((macro, data, list, 0), BOOST_PP_LIST_FOR_EACH_I_P, BOOST_PP_LIST_FOR_EACH_I_O, BOOST_PP_LIST_FOR_EACH_I_M)
+# else
+#    define BOOST_PP_LIST_FOR_EACH_I_R(r, macro, data, list) BOOST_PP_LIST_FOR_EACH_I_R_I(r, macro, data, list)
+#    define BOOST_PP_LIST_FOR_EACH_I_R_I(r, macro, data, list) BOOST_PP_FOR_ ## r((macro, data, list, 0), BOOST_PP_LIST_FOR_EACH_I_P, BOOST_PP_LIST_FOR_EACH_I_O, BOOST_PP_LIST_FOR_EACH_I_M)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/fold_right.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/fold_right.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/list/fold_right.hpp	(working copy)
@@ -0,0 +1,40 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LIST_FOLD_RIGHT_HPP
+# define BOOST_PREPROCESSOR_LIST_FOLD_RIGHT_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/control/while.hpp>
+# include <boost/preprocessor/debug/error.hpp>
+# include <boost/preprocessor/detail/auto_rec.hpp>
+#
+# if 0
+#    define BOOST_PP_LIST_FOLD_RIGHT(op, state, list)
+# endif
+#
+# define BOOST_PP_LIST_FOLD_RIGHT BOOST_PP_CAT(BOOST_PP_LIST_FOLD_RIGHT_, BOOST_PP_AUTO_REC(BOOST_PP_WHILE_P, 256))
+#
+# define BOOST_PP_LIST_FOLD_RIGHT_257(o, s, l) BOOST_PP_ERROR(0x0004)
+#
+# define BOOST_PP_LIST_FOLD_RIGHT_D(d, o, s, l) BOOST_PP_LIST_FOLD_RIGHT_ ## d(o, s, l)
+# define BOOST_PP_LIST_FOLD_RIGHT_2ND BOOST_PP_LIST_FOLD_RIGHT
+# define BOOST_PP_LIST_FOLD_RIGHT_2ND_D BOOST_PP_LIST_FOLD_RIGHT_D
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    include <boost/preprocessor/list/detail/edg/fold_right.hpp>
+# else
+#    include <boost/preprocessor/list/detail/fold_right.hpp>
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/facilities/identity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/facilities/identity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/facilities/identity.hpp	(working copy)
@@ -0,0 +1,23 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_FACILITIES_IDENTITY_HPP
+# define BOOST_PREPROCESSOR_FACILITIES_IDENTITY_HPP
+#
+# include <boost/preprocessor/facilities/empty.hpp>
+#
+# /* BOOST_PP_IDENTITY */
+#
+# define BOOST_PP_IDENTITY(item) item BOOST_PP_EMPTY
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/facilities/empty.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/facilities/empty.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/facilities/empty.hpp	(working copy)
@@ -0,0 +1,21 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_FACILITIES_EMPTY_HPP
+# define BOOST_PREPROCESSOR_FACILITIES_EMPTY_HPP
+#
+# /* BOOST_PP_EMPTY */
+#
+# define BOOST_PP_EMPTY()
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/identity.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/identity.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/identity.hpp	(working copy)
@@ -0,0 +1,17 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_IDENTITY_HPP
+# define BOOST_PREPROCESSOR_IDENTITY_HPP
+#
+# include <boost/preprocessor/facilities/identity.hpp>
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_binary_params.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_binary_params.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_binary_params.hpp	(working copy)
@@ -0,0 +1,54 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_ENUM_BINARY_PARAMS_HPP
+# define BOOST_PREPROCESSOR_REPETITION_ENUM_BINARY_PARAMS_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/punctuation/comma_if.hpp>
+# include <boost/preprocessor/repetition/repeat.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+# include <boost/preprocessor/tuple/rem.hpp>
+#
+# /* BOOST_PP_ENUM_BINARY_PARAMS */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_BINARY_PARAMS(count, p1, p2) BOOST_PP_REPEAT(count, BOOST_PP_ENUM_BINARY_PARAMS_M, (p1, p2))
+# else
+#    define BOOST_PP_ENUM_BINARY_PARAMS(count, p1, p2) BOOST_PP_ENUM_BINARY_PARAMS_I(count, p1, p2)
+#    define BOOST_PP_ENUM_BINARY_PARAMS_I(count, p1, p2) BOOST_PP_REPEAT(count, BOOST_PP_ENUM_BINARY_PARAMS_M, (p1, p2))
+# endif
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_STRICT()
+#    define BOOST_PP_ENUM_BINARY_PARAMS_M(z, n, pp) BOOST_PP_ENUM_BINARY_PARAMS_M_IM(z, n, BOOST_PP_TUPLE_REM_2 pp)
+#    define BOOST_PP_ENUM_BINARY_PARAMS_M_IM(z, n, im) BOOST_PP_ENUM_BINARY_PARAMS_M_I(z, n, im)
+# else
+#    define BOOST_PP_ENUM_BINARY_PARAMS_M(z, n, pp) BOOST_PP_ENUM_BINARY_PARAMS_M_I(z, n, BOOST_PP_TUPLE_ELEM(2, 0, pp), BOOST_PP_TUPLE_ELEM(2, 1, pp))
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_ENUM_BINARY_PARAMS_M_I(z, n, p1, p2) BOOST_PP_ENUM_BINARY_PARAMS_M_II(z, n, p1, p2)
+#    define BOOST_PP_ENUM_BINARY_PARAMS_M_II(z, n, p1, p2) BOOST_PP_COMMA_IF(n) p1 ## n p2 ## n
+# else
+#    define BOOST_PP_ENUM_BINARY_PARAMS_M_I(z, n, p1, p2) BOOST_PP_COMMA_IF(n) BOOST_PP_CAT(p1, n) BOOST_PP_CAT(p2, n)
+# endif
+#
+# /* BOOST_PP_ENUM_BINARY_PARAMS_Z */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_BINARY_PARAMS_Z(z, count, p1, p2) BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_BINARY_PARAMS_M, (p1, p2))
+# else
+#    define BOOST_PP_ENUM_BINARY_PARAMS_Z(z, count, p1, p2) BOOST_PP_ENUM_BINARY_PARAMS_Z_I(z, count, p1, p2)
+#    define BOOST_PP_ENUM_BINARY_PARAMS_Z_I(z, count, p1, p2) BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_BINARY_PARAMS_M, (p1, p2))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/detail/for.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/detail/for.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/detail/for.hpp	(working copy)
@@ -0,0 +1,536 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_DETAIL_FOR_HPP
+# define BOOST_PREPROCESSOR_REPETITION_DETAIL_FOR_HPP
+#
+# include <boost/preprocessor/control/expr_iif.hpp>
+# include <boost/preprocessor/control/iif.hpp>
+# include <boost/preprocessor/logical/bool.hpp>
+# include <boost/preprocessor/tuple/eat.hpp>
+#
+# define BOOST_PP_FOR_1(s, p, o, m) BOOST_PP_FOR_1_C(BOOST_PP_BOOL(p(2, s)), s, p, o, m)
+# define BOOST_PP_FOR_2(s, p, o, m) BOOST_PP_FOR_2_C(BOOST_PP_BOOL(p(3, s)), s, p, o, m)
+# define BOOST_PP_FOR_3(s, p, o, m) BOOST_PP_FOR_3_C(BOOST_PP_BOOL(p(4, s)), s, p, o, m)
+# define BOOST_PP_FOR_4(s, p, o, m) BOOST_PP_FOR_4_C(BOOST_PP_BOOL(p(5, s)), s, p, o, m)
+# define BOOST_PP_FOR_5(s, p, o, m) BOOST_PP_FOR_5_C(BOOST_PP_BOOL(p(6, s)), s, p, o, m)
+# define BOOST_PP_FOR_6(s, p, o, m) BOOST_PP_FOR_6_C(BOOST_PP_BOOL(p(7, s)), s, p, o, m)
+# define BOOST_PP_FOR_7(s, p, o, m) BOOST_PP_FOR_7_C(BOOST_PP_BOOL(p(8, s)), s, p, o, m)
+# define BOOST_PP_FOR_8(s, p, o, m) BOOST_PP_FOR_8_C(BOOST_PP_BOOL(p(9, s)), s, p, o, m)
+# define BOOST_PP_FOR_9(s, p, o, m) BOOST_PP_FOR_9_C(BOOST_PP_BOOL(p(10, s)), s, p, o, m)
+# define BOOST_PP_FOR_10(s, p, o, m) BOOST_PP_FOR_10_C(BOOST_PP_BOOL(p(11, s)), s, p, o, m)
+# define BOOST_PP_FOR_11(s, p, o, m) BOOST_PP_FOR_11_C(BOOST_PP_BOOL(p(12, s)), s, p, o, m)
+# define BOOST_PP_FOR_12(s, p, o, m) BOOST_PP_FOR_12_C(BOOST_PP_BOOL(p(13, s)), s, p, o, m)
+# define BOOST_PP_FOR_13(s, p, o, m) BOOST_PP_FOR_13_C(BOOST_PP_BOOL(p(14, s)), s, p, o, m)
+# define BOOST_PP_FOR_14(s, p, o, m) BOOST_PP_FOR_14_C(BOOST_PP_BOOL(p(15, s)), s, p, o, m)
+# define BOOST_PP_FOR_15(s, p, o, m) BOOST_PP_FOR_15_C(BOOST_PP_BOOL(p(16, s)), s, p, o, m)
+# define BOOST_PP_FOR_16(s, p, o, m) BOOST_PP_FOR_16_C(BOOST_PP_BOOL(p(17, s)), s, p, o, m)
+# define BOOST_PP_FOR_17(s, p, o, m) BOOST_PP_FOR_17_C(BOOST_PP_BOOL(p(18, s)), s, p, o, m)
+# define BOOST_PP_FOR_18(s, p, o, m) BOOST_PP_FOR_18_C(BOOST_PP_BOOL(p(19, s)), s, p, o, m)
+# define BOOST_PP_FOR_19(s, p, o, m) BOOST_PP_FOR_19_C(BOOST_PP_BOOL(p(20, s)), s, p, o, m)
+# define BOOST_PP_FOR_20(s, p, o, m) BOOST_PP_FOR_20_C(BOOST_PP_BOOL(p(21, s)), s, p, o, m)
+# define BOOST_PP_FOR_21(s, p, o, m) BOOST_PP_FOR_21_C(BOOST_PP_BOOL(p(22, s)), s, p, o, m)
+# define BOOST_PP_FOR_22(s, p, o, m) BOOST_PP_FOR_22_C(BOOST_PP_BOOL(p(23, s)), s, p, o, m)
+# define BOOST_PP_FOR_23(s, p, o, m) BOOST_PP_FOR_23_C(BOOST_PP_BOOL(p(24, s)), s, p, o, m)
+# define BOOST_PP_FOR_24(s, p, o, m) BOOST_PP_FOR_24_C(BOOST_PP_BOOL(p(25, s)), s, p, o, m)
+# define BOOST_PP_FOR_25(s, p, o, m) BOOST_PP_FOR_25_C(BOOST_PP_BOOL(p(26, s)), s, p, o, m)
+# define BOOST_PP_FOR_26(s, p, o, m) BOOST_PP_FOR_26_C(BOOST_PP_BOOL(p(27, s)), s, p, o, m)
+# define BOOST_PP_FOR_27(s, p, o, m) BOOST_PP_FOR_27_C(BOOST_PP_BOOL(p(28, s)), s, p, o, m)
+# define BOOST_PP_FOR_28(s, p, o, m) BOOST_PP_FOR_28_C(BOOST_PP_BOOL(p(29, s)), s, p, o, m)
+# define BOOST_PP_FOR_29(s, p, o, m) BOOST_PP_FOR_29_C(BOOST_PP_BOOL(p(30, s)), s, p, o, m)
+# define BOOST_PP_FOR_30(s, p, o, m) BOOST_PP_FOR_30_C(BOOST_PP_BOOL(p(31, s)), s, p, o, m)
+# define BOOST_PP_FOR_31(s, p, o, m) BOOST_PP_FOR_31_C(BOOST_PP_BOOL(p(32, s)), s, p, o, m)
+# define BOOST_PP_FOR_32(s, p, o, m) BOOST_PP_FOR_32_C(BOOST_PP_BOOL(p(33, s)), s, p, o, m)
+# define BOOST_PP_FOR_33(s, p, o, m) BOOST_PP_FOR_33_C(BOOST_PP_BOOL(p(34, s)), s, p, o, m)
+# define BOOST_PP_FOR_34(s, p, o, m) BOOST_PP_FOR_34_C(BOOST_PP_BOOL(p(35, s)), s, p, o, m)
+# define BOOST_PP_FOR_35(s, p, o, m) BOOST_PP_FOR_35_C(BOOST_PP_BOOL(p(36, s)), s, p, o, m)
+# define BOOST_PP_FOR_36(s, p, o, m) BOOST_PP_FOR_36_C(BOOST_PP_BOOL(p(37, s)), s, p, o, m)
+# define BOOST_PP_FOR_37(s, p, o, m) BOOST_PP_FOR_37_C(BOOST_PP_BOOL(p(38, s)), s, p, o, m)
+# define BOOST_PP_FOR_38(s, p, o, m) BOOST_PP_FOR_38_C(BOOST_PP_BOOL(p(39, s)), s, p, o, m)
+# define BOOST_PP_FOR_39(s, p, o, m) BOOST_PP_FOR_39_C(BOOST_PP_BOOL(p(40, s)), s, p, o, m)
+# define BOOST_PP_FOR_40(s, p, o, m) BOOST_PP_FOR_40_C(BOOST_PP_BOOL(p(41, s)), s, p, o, m)
+# define BOOST_PP_FOR_41(s, p, o, m) BOOST_PP_FOR_41_C(BOOST_PP_BOOL(p(42, s)), s, p, o, m)
+# define BOOST_PP_FOR_42(s, p, o, m) BOOST_PP_FOR_42_C(BOOST_PP_BOOL(p(43, s)), s, p, o, m)
+# define BOOST_PP_FOR_43(s, p, o, m) BOOST_PP_FOR_43_C(BOOST_PP_BOOL(p(44, s)), s, p, o, m)
+# define BOOST_PP_FOR_44(s, p, o, m) BOOST_PP_FOR_44_C(BOOST_PP_BOOL(p(45, s)), s, p, o, m)
+# define BOOST_PP_FOR_45(s, p, o, m) BOOST_PP_FOR_45_C(BOOST_PP_BOOL(p(46, s)), s, p, o, m)
+# define BOOST_PP_FOR_46(s, p, o, m) BOOST_PP_FOR_46_C(BOOST_PP_BOOL(p(47, s)), s, p, o, m)
+# define BOOST_PP_FOR_47(s, p, o, m) BOOST_PP_FOR_47_C(BOOST_PP_BOOL(p(48, s)), s, p, o, m)
+# define BOOST_PP_FOR_48(s, p, o, m) BOOST_PP_FOR_48_C(BOOST_PP_BOOL(p(49, s)), s, p, o, m)
+# define BOOST_PP_FOR_49(s, p, o, m) BOOST_PP_FOR_49_C(BOOST_PP_BOOL(p(50, s)), s, p, o, m)
+# define BOOST_PP_FOR_50(s, p, o, m) BOOST_PP_FOR_50_C(BOOST_PP_BOOL(p(51, s)), s, p, o, m)
+# define BOOST_PP_FOR_51(s, p, o, m) BOOST_PP_FOR_51_C(BOOST_PP_BOOL(p(52, s)), s, p, o, m)
+# define BOOST_PP_FOR_52(s, p, o, m) BOOST_PP_FOR_52_C(BOOST_PP_BOOL(p(53, s)), s, p, o, m)
+# define BOOST_PP_FOR_53(s, p, o, m) BOOST_PP_FOR_53_C(BOOST_PP_BOOL(p(54, s)), s, p, o, m)
+# define BOOST_PP_FOR_54(s, p, o, m) BOOST_PP_FOR_54_C(BOOST_PP_BOOL(p(55, s)), s, p, o, m)
+# define BOOST_PP_FOR_55(s, p, o, m) BOOST_PP_FOR_55_C(BOOST_PP_BOOL(p(56, s)), s, p, o, m)
+# define BOOST_PP_FOR_56(s, p, o, m) BOOST_PP_FOR_56_C(BOOST_PP_BOOL(p(57, s)), s, p, o, m)
+# define BOOST_PP_FOR_57(s, p, o, m) BOOST_PP_FOR_57_C(BOOST_PP_BOOL(p(58, s)), s, p, o, m)
+# define BOOST_PP_FOR_58(s, p, o, m) BOOST_PP_FOR_58_C(BOOST_PP_BOOL(p(59, s)), s, p, o, m)
+# define BOOST_PP_FOR_59(s, p, o, m) BOOST_PP_FOR_59_C(BOOST_PP_BOOL(p(60, s)), s, p, o, m)
+# define BOOST_PP_FOR_60(s, p, o, m) BOOST_PP_FOR_60_C(BOOST_PP_BOOL(p(61, s)), s, p, o, m)
+# define BOOST_PP_FOR_61(s, p, o, m) BOOST_PP_FOR_61_C(BOOST_PP_BOOL(p(62, s)), s, p, o, m)
+# define BOOST_PP_FOR_62(s, p, o, m) BOOST_PP_FOR_62_C(BOOST_PP_BOOL(p(63, s)), s, p, o, m)
+# define BOOST_PP_FOR_63(s, p, o, m) BOOST_PP_FOR_63_C(BOOST_PP_BOOL(p(64, s)), s, p, o, m)
+# define BOOST_PP_FOR_64(s, p, o, m) BOOST_PP_FOR_64_C(BOOST_PP_BOOL(p(65, s)), s, p, o, m)
+# define BOOST_PP_FOR_65(s, p, o, m) BOOST_PP_FOR_65_C(BOOST_PP_BOOL(p(66, s)), s, p, o, m)
+# define BOOST_PP_FOR_66(s, p, o, m) BOOST_PP_FOR_66_C(BOOST_PP_BOOL(p(67, s)), s, p, o, m)
+# define BOOST_PP_FOR_67(s, p, o, m) BOOST_PP_FOR_67_C(BOOST_PP_BOOL(p(68, s)), s, p, o, m)
+# define BOOST_PP_FOR_68(s, p, o, m) BOOST_PP_FOR_68_C(BOOST_PP_BOOL(p(69, s)), s, p, o, m)
+# define BOOST_PP_FOR_69(s, p, o, m) BOOST_PP_FOR_69_C(BOOST_PP_BOOL(p(70, s)), s, p, o, m)
+# define BOOST_PP_FOR_70(s, p, o, m) BOOST_PP_FOR_70_C(BOOST_PP_BOOL(p(71, s)), s, p, o, m)
+# define BOOST_PP_FOR_71(s, p, o, m) BOOST_PP_FOR_71_C(BOOST_PP_BOOL(p(72, s)), s, p, o, m)
+# define BOOST_PP_FOR_72(s, p, o, m) BOOST_PP_FOR_72_C(BOOST_PP_BOOL(p(73, s)), s, p, o, m)
+# define BOOST_PP_FOR_73(s, p, o, m) BOOST_PP_FOR_73_C(BOOST_PP_BOOL(p(74, s)), s, p, o, m)
+# define BOOST_PP_FOR_74(s, p, o, m) BOOST_PP_FOR_74_C(BOOST_PP_BOOL(p(75, s)), s, p, o, m)
+# define BOOST_PP_FOR_75(s, p, o, m) BOOST_PP_FOR_75_C(BOOST_PP_BOOL(p(76, s)), s, p, o, m)
+# define BOOST_PP_FOR_76(s, p, o, m) BOOST_PP_FOR_76_C(BOOST_PP_BOOL(p(77, s)), s, p, o, m)
+# define BOOST_PP_FOR_77(s, p, o, m) BOOST_PP_FOR_77_C(BOOST_PP_BOOL(p(78, s)), s, p, o, m)
+# define BOOST_PP_FOR_78(s, p, o, m) BOOST_PP_FOR_78_C(BOOST_PP_BOOL(p(79, s)), s, p, o, m)
+# define BOOST_PP_FOR_79(s, p, o, m) BOOST_PP_FOR_79_C(BOOST_PP_BOOL(p(80, s)), s, p, o, m)
+# define BOOST_PP_FOR_80(s, p, o, m) BOOST_PP_FOR_80_C(BOOST_PP_BOOL(p(81, s)), s, p, o, m)
+# define BOOST_PP_FOR_81(s, p, o, m) BOOST_PP_FOR_81_C(BOOST_PP_BOOL(p(82, s)), s, p, o, m)
+# define BOOST_PP_FOR_82(s, p, o, m) BOOST_PP_FOR_82_C(BOOST_PP_BOOL(p(83, s)), s, p, o, m)
+# define BOOST_PP_FOR_83(s, p, o, m) BOOST_PP_FOR_83_C(BOOST_PP_BOOL(p(84, s)), s, p, o, m)
+# define BOOST_PP_FOR_84(s, p, o, m) BOOST_PP_FOR_84_C(BOOST_PP_BOOL(p(85, s)), s, p, o, m)
+# define BOOST_PP_FOR_85(s, p, o, m) BOOST_PP_FOR_85_C(BOOST_PP_BOOL(p(86, s)), s, p, o, m)
+# define BOOST_PP_FOR_86(s, p, o, m) BOOST_PP_FOR_86_C(BOOST_PP_BOOL(p(87, s)), s, p, o, m)
+# define BOOST_PP_FOR_87(s, p, o, m) BOOST_PP_FOR_87_C(BOOST_PP_BOOL(p(88, s)), s, p, o, m)
+# define BOOST_PP_FOR_88(s, p, o, m) BOOST_PP_FOR_88_C(BOOST_PP_BOOL(p(89, s)), s, p, o, m)
+# define BOOST_PP_FOR_89(s, p, o, m) BOOST_PP_FOR_89_C(BOOST_PP_BOOL(p(90, s)), s, p, o, m)
+# define BOOST_PP_FOR_90(s, p, o, m) BOOST_PP_FOR_90_C(BOOST_PP_BOOL(p(91, s)), s, p, o, m)
+# define BOOST_PP_FOR_91(s, p, o, m) BOOST_PP_FOR_91_C(BOOST_PP_BOOL(p(92, s)), s, p, o, m)
+# define BOOST_PP_FOR_92(s, p, o, m) BOOST_PP_FOR_92_C(BOOST_PP_BOOL(p(93, s)), s, p, o, m)
+# define BOOST_PP_FOR_93(s, p, o, m) BOOST_PP_FOR_93_C(BOOST_PP_BOOL(p(94, s)), s, p, o, m)
+# define BOOST_PP_FOR_94(s, p, o, m) BOOST_PP_FOR_94_C(BOOST_PP_BOOL(p(95, s)), s, p, o, m)
+# define BOOST_PP_FOR_95(s, p, o, m) BOOST_PP_FOR_95_C(BOOST_PP_BOOL(p(96, s)), s, p, o, m)
+# define BOOST_PP_FOR_96(s, p, o, m) BOOST_PP_FOR_96_C(BOOST_PP_BOOL(p(97, s)), s, p, o, m)
+# define BOOST_PP_FOR_97(s, p, o, m) BOOST_PP_FOR_97_C(BOOST_PP_BOOL(p(98, s)), s, p, o, m)
+# define BOOST_PP_FOR_98(s, p, o, m) BOOST_PP_FOR_98_C(BOOST_PP_BOOL(p(99, s)), s, p, o, m)
+# define BOOST_PP_FOR_99(s, p, o, m) BOOST_PP_FOR_99_C(BOOST_PP_BOOL(p(100, s)), s, p, o, m)
+# define BOOST_PP_FOR_100(s, p, o, m) BOOST_PP_FOR_100_C(BOOST_PP_BOOL(p(101, s)), s, p, o, m)
+# define BOOST_PP_FOR_101(s, p, o, m) BOOST_PP_FOR_101_C(BOOST_PP_BOOL(p(102, s)), s, p, o, m)
+# define BOOST_PP_FOR_102(s, p, o, m) BOOST_PP_FOR_102_C(BOOST_PP_BOOL(p(103, s)), s, p, o, m)
+# define BOOST_PP_FOR_103(s, p, o, m) BOOST_PP_FOR_103_C(BOOST_PP_BOOL(p(104, s)), s, p, o, m)
+# define BOOST_PP_FOR_104(s, p, o, m) BOOST_PP_FOR_104_C(BOOST_PP_BOOL(p(105, s)), s, p, o, m)
+# define BOOST_PP_FOR_105(s, p, o, m) BOOST_PP_FOR_105_C(BOOST_PP_BOOL(p(106, s)), s, p, o, m)
+# define BOOST_PP_FOR_106(s, p, o, m) BOOST_PP_FOR_106_C(BOOST_PP_BOOL(p(107, s)), s, p, o, m)
+# define BOOST_PP_FOR_107(s, p, o, m) BOOST_PP_FOR_107_C(BOOST_PP_BOOL(p(108, s)), s, p, o, m)
+# define BOOST_PP_FOR_108(s, p, o, m) BOOST_PP_FOR_108_C(BOOST_PP_BOOL(p(109, s)), s, p, o, m)
+# define BOOST_PP_FOR_109(s, p, o, m) BOOST_PP_FOR_109_C(BOOST_PP_BOOL(p(110, s)), s, p, o, m)
+# define BOOST_PP_FOR_110(s, p, o, m) BOOST_PP_FOR_110_C(BOOST_PP_BOOL(p(111, s)), s, p, o, m)
+# define BOOST_PP_FOR_111(s, p, o, m) BOOST_PP_FOR_111_C(BOOST_PP_BOOL(p(112, s)), s, p, o, m)
+# define BOOST_PP_FOR_112(s, p, o, m) BOOST_PP_FOR_112_C(BOOST_PP_BOOL(p(113, s)), s, p, o, m)
+# define BOOST_PP_FOR_113(s, p, o, m) BOOST_PP_FOR_113_C(BOOST_PP_BOOL(p(114, s)), s, p, o, m)
+# define BOOST_PP_FOR_114(s, p, o, m) BOOST_PP_FOR_114_C(BOOST_PP_BOOL(p(115, s)), s, p, o, m)
+# define BOOST_PP_FOR_115(s, p, o, m) BOOST_PP_FOR_115_C(BOOST_PP_BOOL(p(116, s)), s, p, o, m)
+# define BOOST_PP_FOR_116(s, p, o, m) BOOST_PP_FOR_116_C(BOOST_PP_BOOL(p(117, s)), s, p, o, m)
+# define BOOST_PP_FOR_117(s, p, o, m) BOOST_PP_FOR_117_C(BOOST_PP_BOOL(p(118, s)), s, p, o, m)
+# define BOOST_PP_FOR_118(s, p, o, m) BOOST_PP_FOR_118_C(BOOST_PP_BOOL(p(119, s)), s, p, o, m)
+# define BOOST_PP_FOR_119(s, p, o, m) BOOST_PP_FOR_119_C(BOOST_PP_BOOL(p(120, s)), s, p, o, m)
+# define BOOST_PP_FOR_120(s, p, o, m) BOOST_PP_FOR_120_C(BOOST_PP_BOOL(p(121, s)), s, p, o, m)
+# define BOOST_PP_FOR_121(s, p, o, m) BOOST_PP_FOR_121_C(BOOST_PP_BOOL(p(122, s)), s, p, o, m)
+# define BOOST_PP_FOR_122(s, p, o, m) BOOST_PP_FOR_122_C(BOOST_PP_BOOL(p(123, s)), s, p, o, m)
+# define BOOST_PP_FOR_123(s, p, o, m) BOOST_PP_FOR_123_C(BOOST_PP_BOOL(p(124, s)), s, p, o, m)
+# define BOOST_PP_FOR_124(s, p, o, m) BOOST_PP_FOR_124_C(BOOST_PP_BOOL(p(125, s)), s, p, o, m)
+# define BOOST_PP_FOR_125(s, p, o, m) BOOST_PP_FOR_125_C(BOOST_PP_BOOL(p(126, s)), s, p, o, m)
+# define BOOST_PP_FOR_126(s, p, o, m) BOOST_PP_FOR_126_C(BOOST_PP_BOOL(p(127, s)), s, p, o, m)
+# define BOOST_PP_FOR_127(s, p, o, m) BOOST_PP_FOR_127_C(BOOST_PP_BOOL(p(128, s)), s, p, o, m)
+# define BOOST_PP_FOR_128(s, p, o, m) BOOST_PP_FOR_128_C(BOOST_PP_BOOL(p(129, s)), s, p, o, m)
+# define BOOST_PP_FOR_129(s, p, o, m) BOOST_PP_FOR_129_C(BOOST_PP_BOOL(p(130, s)), s, p, o, m)
+# define BOOST_PP_FOR_130(s, p, o, m) BOOST_PP_FOR_130_C(BOOST_PP_BOOL(p(131, s)), s, p, o, m)
+# define BOOST_PP_FOR_131(s, p, o, m) BOOST_PP_FOR_131_C(BOOST_PP_BOOL(p(132, s)), s, p, o, m)
+# define BOOST_PP_FOR_132(s, p, o, m) BOOST_PP_FOR_132_C(BOOST_PP_BOOL(p(133, s)), s, p, o, m)
+# define BOOST_PP_FOR_133(s, p, o, m) BOOST_PP_FOR_133_C(BOOST_PP_BOOL(p(134, s)), s, p, o, m)
+# define BOOST_PP_FOR_134(s, p, o, m) BOOST_PP_FOR_134_C(BOOST_PP_BOOL(p(135, s)), s, p, o, m)
+# define BOOST_PP_FOR_135(s, p, o, m) BOOST_PP_FOR_135_C(BOOST_PP_BOOL(p(136, s)), s, p, o, m)
+# define BOOST_PP_FOR_136(s, p, o, m) BOOST_PP_FOR_136_C(BOOST_PP_BOOL(p(137, s)), s, p, o, m)
+# define BOOST_PP_FOR_137(s, p, o, m) BOOST_PP_FOR_137_C(BOOST_PP_BOOL(p(138, s)), s, p, o, m)
+# define BOOST_PP_FOR_138(s, p, o, m) BOOST_PP_FOR_138_C(BOOST_PP_BOOL(p(139, s)), s, p, o, m)
+# define BOOST_PP_FOR_139(s, p, o, m) BOOST_PP_FOR_139_C(BOOST_PP_BOOL(p(140, s)), s, p, o, m)
+# define BOOST_PP_FOR_140(s, p, o, m) BOOST_PP_FOR_140_C(BOOST_PP_BOOL(p(141, s)), s, p, o, m)
+# define BOOST_PP_FOR_141(s, p, o, m) BOOST_PP_FOR_141_C(BOOST_PP_BOOL(p(142, s)), s, p, o, m)
+# define BOOST_PP_FOR_142(s, p, o, m) BOOST_PP_FOR_142_C(BOOST_PP_BOOL(p(143, s)), s, p, o, m)
+# define BOOST_PP_FOR_143(s, p, o, m) BOOST_PP_FOR_143_C(BOOST_PP_BOOL(p(144, s)), s, p, o, m)
+# define BOOST_PP_FOR_144(s, p, o, m) BOOST_PP_FOR_144_C(BOOST_PP_BOOL(p(145, s)), s, p, o, m)
+# define BOOST_PP_FOR_145(s, p, o, m) BOOST_PP_FOR_145_C(BOOST_PP_BOOL(p(146, s)), s, p, o, m)
+# define BOOST_PP_FOR_146(s, p, o, m) BOOST_PP_FOR_146_C(BOOST_PP_BOOL(p(147, s)), s, p, o, m)
+# define BOOST_PP_FOR_147(s, p, o, m) BOOST_PP_FOR_147_C(BOOST_PP_BOOL(p(148, s)), s, p, o, m)
+# define BOOST_PP_FOR_148(s, p, o, m) BOOST_PP_FOR_148_C(BOOST_PP_BOOL(p(149, s)), s, p, o, m)
+# define BOOST_PP_FOR_149(s, p, o, m) BOOST_PP_FOR_149_C(BOOST_PP_BOOL(p(150, s)), s, p, o, m)
+# define BOOST_PP_FOR_150(s, p, o, m) BOOST_PP_FOR_150_C(BOOST_PP_BOOL(p(151, s)), s, p, o, m)
+# define BOOST_PP_FOR_151(s, p, o, m) BOOST_PP_FOR_151_C(BOOST_PP_BOOL(p(152, s)), s, p, o, m)
+# define BOOST_PP_FOR_152(s, p, o, m) BOOST_PP_FOR_152_C(BOOST_PP_BOOL(p(153, s)), s, p, o, m)
+# define BOOST_PP_FOR_153(s, p, o, m) BOOST_PP_FOR_153_C(BOOST_PP_BOOL(p(154, s)), s, p, o, m)
+# define BOOST_PP_FOR_154(s, p, o, m) BOOST_PP_FOR_154_C(BOOST_PP_BOOL(p(155, s)), s, p, o, m)
+# define BOOST_PP_FOR_155(s, p, o, m) BOOST_PP_FOR_155_C(BOOST_PP_BOOL(p(156, s)), s, p, o, m)
+# define BOOST_PP_FOR_156(s, p, o, m) BOOST_PP_FOR_156_C(BOOST_PP_BOOL(p(157, s)), s, p, o, m)
+# define BOOST_PP_FOR_157(s, p, o, m) BOOST_PP_FOR_157_C(BOOST_PP_BOOL(p(158, s)), s, p, o, m)
+# define BOOST_PP_FOR_158(s, p, o, m) BOOST_PP_FOR_158_C(BOOST_PP_BOOL(p(159, s)), s, p, o, m)
+# define BOOST_PP_FOR_159(s, p, o, m) BOOST_PP_FOR_159_C(BOOST_PP_BOOL(p(160, s)), s, p, o, m)
+# define BOOST_PP_FOR_160(s, p, o, m) BOOST_PP_FOR_160_C(BOOST_PP_BOOL(p(161, s)), s, p, o, m)
+# define BOOST_PP_FOR_161(s, p, o, m) BOOST_PP_FOR_161_C(BOOST_PP_BOOL(p(162, s)), s, p, o, m)
+# define BOOST_PP_FOR_162(s, p, o, m) BOOST_PP_FOR_162_C(BOOST_PP_BOOL(p(163, s)), s, p, o, m)
+# define BOOST_PP_FOR_163(s, p, o, m) BOOST_PP_FOR_163_C(BOOST_PP_BOOL(p(164, s)), s, p, o, m)
+# define BOOST_PP_FOR_164(s, p, o, m) BOOST_PP_FOR_164_C(BOOST_PP_BOOL(p(165, s)), s, p, o, m)
+# define BOOST_PP_FOR_165(s, p, o, m) BOOST_PP_FOR_165_C(BOOST_PP_BOOL(p(166, s)), s, p, o, m)
+# define BOOST_PP_FOR_166(s, p, o, m) BOOST_PP_FOR_166_C(BOOST_PP_BOOL(p(167, s)), s, p, o, m)
+# define BOOST_PP_FOR_167(s, p, o, m) BOOST_PP_FOR_167_C(BOOST_PP_BOOL(p(168, s)), s, p, o, m)
+# define BOOST_PP_FOR_168(s, p, o, m) BOOST_PP_FOR_168_C(BOOST_PP_BOOL(p(169, s)), s, p, o, m)
+# define BOOST_PP_FOR_169(s, p, o, m) BOOST_PP_FOR_169_C(BOOST_PP_BOOL(p(170, s)), s, p, o, m)
+# define BOOST_PP_FOR_170(s, p, o, m) BOOST_PP_FOR_170_C(BOOST_PP_BOOL(p(171, s)), s, p, o, m)
+# define BOOST_PP_FOR_171(s, p, o, m) BOOST_PP_FOR_171_C(BOOST_PP_BOOL(p(172, s)), s, p, o, m)
+# define BOOST_PP_FOR_172(s, p, o, m) BOOST_PP_FOR_172_C(BOOST_PP_BOOL(p(173, s)), s, p, o, m)
+# define BOOST_PP_FOR_173(s, p, o, m) BOOST_PP_FOR_173_C(BOOST_PP_BOOL(p(174, s)), s, p, o, m)
+# define BOOST_PP_FOR_174(s, p, o, m) BOOST_PP_FOR_174_C(BOOST_PP_BOOL(p(175, s)), s, p, o, m)
+# define BOOST_PP_FOR_175(s, p, o, m) BOOST_PP_FOR_175_C(BOOST_PP_BOOL(p(176, s)), s, p, o, m)
+# define BOOST_PP_FOR_176(s, p, o, m) BOOST_PP_FOR_176_C(BOOST_PP_BOOL(p(177, s)), s, p, o, m)
+# define BOOST_PP_FOR_177(s, p, o, m) BOOST_PP_FOR_177_C(BOOST_PP_BOOL(p(178, s)), s, p, o, m)
+# define BOOST_PP_FOR_178(s, p, o, m) BOOST_PP_FOR_178_C(BOOST_PP_BOOL(p(179, s)), s, p, o, m)
+# define BOOST_PP_FOR_179(s, p, o, m) BOOST_PP_FOR_179_C(BOOST_PP_BOOL(p(180, s)), s, p, o, m)
+# define BOOST_PP_FOR_180(s, p, o, m) BOOST_PP_FOR_180_C(BOOST_PP_BOOL(p(181, s)), s, p, o, m)
+# define BOOST_PP_FOR_181(s, p, o, m) BOOST_PP_FOR_181_C(BOOST_PP_BOOL(p(182, s)), s, p, o, m)
+# define BOOST_PP_FOR_182(s, p, o, m) BOOST_PP_FOR_182_C(BOOST_PP_BOOL(p(183, s)), s, p, o, m)
+# define BOOST_PP_FOR_183(s, p, o, m) BOOST_PP_FOR_183_C(BOOST_PP_BOOL(p(184, s)), s, p, o, m)
+# define BOOST_PP_FOR_184(s, p, o, m) BOOST_PP_FOR_184_C(BOOST_PP_BOOL(p(185, s)), s, p, o, m)
+# define BOOST_PP_FOR_185(s, p, o, m) BOOST_PP_FOR_185_C(BOOST_PP_BOOL(p(186, s)), s, p, o, m)
+# define BOOST_PP_FOR_186(s, p, o, m) BOOST_PP_FOR_186_C(BOOST_PP_BOOL(p(187, s)), s, p, o, m)
+# define BOOST_PP_FOR_187(s, p, o, m) BOOST_PP_FOR_187_C(BOOST_PP_BOOL(p(188, s)), s, p, o, m)
+# define BOOST_PP_FOR_188(s, p, o, m) BOOST_PP_FOR_188_C(BOOST_PP_BOOL(p(189, s)), s, p, o, m)
+# define BOOST_PP_FOR_189(s, p, o, m) BOOST_PP_FOR_189_C(BOOST_PP_BOOL(p(190, s)), s, p, o, m)
+# define BOOST_PP_FOR_190(s, p, o, m) BOOST_PP_FOR_190_C(BOOST_PP_BOOL(p(191, s)), s, p, o, m)
+# define BOOST_PP_FOR_191(s, p, o, m) BOOST_PP_FOR_191_C(BOOST_PP_BOOL(p(192, s)), s, p, o, m)
+# define BOOST_PP_FOR_192(s, p, o, m) BOOST_PP_FOR_192_C(BOOST_PP_BOOL(p(193, s)), s, p, o, m)
+# define BOOST_PP_FOR_193(s, p, o, m) BOOST_PP_FOR_193_C(BOOST_PP_BOOL(p(194, s)), s, p, o, m)
+# define BOOST_PP_FOR_194(s, p, o, m) BOOST_PP_FOR_194_C(BOOST_PP_BOOL(p(195, s)), s, p, o, m)
+# define BOOST_PP_FOR_195(s, p, o, m) BOOST_PP_FOR_195_C(BOOST_PP_BOOL(p(196, s)), s, p, o, m)
+# define BOOST_PP_FOR_196(s, p, o, m) BOOST_PP_FOR_196_C(BOOST_PP_BOOL(p(197, s)), s, p, o, m)
+# define BOOST_PP_FOR_197(s, p, o, m) BOOST_PP_FOR_197_C(BOOST_PP_BOOL(p(198, s)), s, p, o, m)
+# define BOOST_PP_FOR_198(s, p, o, m) BOOST_PP_FOR_198_C(BOOST_PP_BOOL(p(199, s)), s, p, o, m)
+# define BOOST_PP_FOR_199(s, p, o, m) BOOST_PP_FOR_199_C(BOOST_PP_BOOL(p(200, s)), s, p, o, m)
+# define BOOST_PP_FOR_200(s, p, o, m) BOOST_PP_FOR_200_C(BOOST_PP_BOOL(p(201, s)), s, p, o, m)
+# define BOOST_PP_FOR_201(s, p, o, m) BOOST_PP_FOR_201_C(BOOST_PP_BOOL(p(202, s)), s, p, o, m)
+# define BOOST_PP_FOR_202(s, p, o, m) BOOST_PP_FOR_202_C(BOOST_PP_BOOL(p(203, s)), s, p, o, m)
+# define BOOST_PP_FOR_203(s, p, o, m) BOOST_PP_FOR_203_C(BOOST_PP_BOOL(p(204, s)), s, p, o, m)
+# define BOOST_PP_FOR_204(s, p, o, m) BOOST_PP_FOR_204_C(BOOST_PP_BOOL(p(205, s)), s, p, o, m)
+# define BOOST_PP_FOR_205(s, p, o, m) BOOST_PP_FOR_205_C(BOOST_PP_BOOL(p(206, s)), s, p, o, m)
+# define BOOST_PP_FOR_206(s, p, o, m) BOOST_PP_FOR_206_C(BOOST_PP_BOOL(p(207, s)), s, p, o, m)
+# define BOOST_PP_FOR_207(s, p, o, m) BOOST_PP_FOR_207_C(BOOST_PP_BOOL(p(208, s)), s, p, o, m)
+# define BOOST_PP_FOR_208(s, p, o, m) BOOST_PP_FOR_208_C(BOOST_PP_BOOL(p(209, s)), s, p, o, m)
+# define BOOST_PP_FOR_209(s, p, o, m) BOOST_PP_FOR_209_C(BOOST_PP_BOOL(p(210, s)), s, p, o, m)
+# define BOOST_PP_FOR_210(s, p, o, m) BOOST_PP_FOR_210_C(BOOST_PP_BOOL(p(211, s)), s, p, o, m)
+# define BOOST_PP_FOR_211(s, p, o, m) BOOST_PP_FOR_211_C(BOOST_PP_BOOL(p(212, s)), s, p, o, m)
+# define BOOST_PP_FOR_212(s, p, o, m) BOOST_PP_FOR_212_C(BOOST_PP_BOOL(p(213, s)), s, p, o, m)
+# define BOOST_PP_FOR_213(s, p, o, m) BOOST_PP_FOR_213_C(BOOST_PP_BOOL(p(214, s)), s, p, o, m)
+# define BOOST_PP_FOR_214(s, p, o, m) BOOST_PP_FOR_214_C(BOOST_PP_BOOL(p(215, s)), s, p, o, m)
+# define BOOST_PP_FOR_215(s, p, o, m) BOOST_PP_FOR_215_C(BOOST_PP_BOOL(p(216, s)), s, p, o, m)
+# define BOOST_PP_FOR_216(s, p, o, m) BOOST_PP_FOR_216_C(BOOST_PP_BOOL(p(217, s)), s, p, o, m)
+# define BOOST_PP_FOR_217(s, p, o, m) BOOST_PP_FOR_217_C(BOOST_PP_BOOL(p(218, s)), s, p, o, m)
+# define BOOST_PP_FOR_218(s, p, o, m) BOOST_PP_FOR_218_C(BOOST_PP_BOOL(p(219, s)), s, p, o, m)
+# define BOOST_PP_FOR_219(s, p, o, m) BOOST_PP_FOR_219_C(BOOST_PP_BOOL(p(220, s)), s, p, o, m)
+# define BOOST_PP_FOR_220(s, p, o, m) BOOST_PP_FOR_220_C(BOOST_PP_BOOL(p(221, s)), s, p, o, m)
+# define BOOST_PP_FOR_221(s, p, o, m) BOOST_PP_FOR_221_C(BOOST_PP_BOOL(p(222, s)), s, p, o, m)
+# define BOOST_PP_FOR_222(s, p, o, m) BOOST_PP_FOR_222_C(BOOST_PP_BOOL(p(223, s)), s, p, o, m)
+# define BOOST_PP_FOR_223(s, p, o, m) BOOST_PP_FOR_223_C(BOOST_PP_BOOL(p(224, s)), s, p, o, m)
+# define BOOST_PP_FOR_224(s, p, o, m) BOOST_PP_FOR_224_C(BOOST_PP_BOOL(p(225, s)), s, p, o, m)
+# define BOOST_PP_FOR_225(s, p, o, m) BOOST_PP_FOR_225_C(BOOST_PP_BOOL(p(226, s)), s, p, o, m)
+# define BOOST_PP_FOR_226(s, p, o, m) BOOST_PP_FOR_226_C(BOOST_PP_BOOL(p(227, s)), s, p, o, m)
+# define BOOST_PP_FOR_227(s, p, o, m) BOOST_PP_FOR_227_C(BOOST_PP_BOOL(p(228, s)), s, p, o, m)
+# define BOOST_PP_FOR_228(s, p, o, m) BOOST_PP_FOR_228_C(BOOST_PP_BOOL(p(229, s)), s, p, o, m)
+# define BOOST_PP_FOR_229(s, p, o, m) BOOST_PP_FOR_229_C(BOOST_PP_BOOL(p(230, s)), s, p, o, m)
+# define BOOST_PP_FOR_230(s, p, o, m) BOOST_PP_FOR_230_C(BOOST_PP_BOOL(p(231, s)), s, p, o, m)
+# define BOOST_PP_FOR_231(s, p, o, m) BOOST_PP_FOR_231_C(BOOST_PP_BOOL(p(232, s)), s, p, o, m)
+# define BOOST_PP_FOR_232(s, p, o, m) BOOST_PP_FOR_232_C(BOOST_PP_BOOL(p(233, s)), s, p, o, m)
+# define BOOST_PP_FOR_233(s, p, o, m) BOOST_PP_FOR_233_C(BOOST_PP_BOOL(p(234, s)), s, p, o, m)
+# define BOOST_PP_FOR_234(s, p, o, m) BOOST_PP_FOR_234_C(BOOST_PP_BOOL(p(235, s)), s, p, o, m)
+# define BOOST_PP_FOR_235(s, p, o, m) BOOST_PP_FOR_235_C(BOOST_PP_BOOL(p(236, s)), s, p, o, m)
+# define BOOST_PP_FOR_236(s, p, o, m) BOOST_PP_FOR_236_C(BOOST_PP_BOOL(p(237, s)), s, p, o, m)
+# define BOOST_PP_FOR_237(s, p, o, m) BOOST_PP_FOR_237_C(BOOST_PP_BOOL(p(238, s)), s, p, o, m)
+# define BOOST_PP_FOR_238(s, p, o, m) BOOST_PP_FOR_238_C(BOOST_PP_BOOL(p(239, s)), s, p, o, m)
+# define BOOST_PP_FOR_239(s, p, o, m) BOOST_PP_FOR_239_C(BOOST_PP_BOOL(p(240, s)), s, p, o, m)
+# define BOOST_PP_FOR_240(s, p, o, m) BOOST_PP_FOR_240_C(BOOST_PP_BOOL(p(241, s)), s, p, o, m)
+# define BOOST_PP_FOR_241(s, p, o, m) BOOST_PP_FOR_241_C(BOOST_PP_BOOL(p(242, s)), s, p, o, m)
+# define BOOST_PP_FOR_242(s, p, o, m) BOOST_PP_FOR_242_C(BOOST_PP_BOOL(p(243, s)), s, p, o, m)
+# define BOOST_PP_FOR_243(s, p, o, m) BOOST_PP_FOR_243_C(BOOST_PP_BOOL(p(244, s)), s, p, o, m)
+# define BOOST_PP_FOR_244(s, p, o, m) BOOST_PP_FOR_244_C(BOOST_PP_BOOL(p(245, s)), s, p, o, m)
+# define BOOST_PP_FOR_245(s, p, o, m) BOOST_PP_FOR_245_C(BOOST_PP_BOOL(p(246, s)), s, p, o, m)
+# define BOOST_PP_FOR_246(s, p, o, m) BOOST_PP_FOR_246_C(BOOST_PP_BOOL(p(247, s)), s, p, o, m)
+# define BOOST_PP_FOR_247(s, p, o, m) BOOST_PP_FOR_247_C(BOOST_PP_BOOL(p(248, s)), s, p, o, m)
+# define BOOST_PP_FOR_248(s, p, o, m) BOOST_PP_FOR_248_C(BOOST_PP_BOOL(p(249, s)), s, p, o, m)
+# define BOOST_PP_FOR_249(s, p, o, m) BOOST_PP_FOR_249_C(BOOST_PP_BOOL(p(250, s)), s, p, o, m)
+# define BOOST_PP_FOR_250(s, p, o, m) BOOST_PP_FOR_250_C(BOOST_PP_BOOL(p(251, s)), s, p, o, m)
+# define BOOST_PP_FOR_251(s, p, o, m) BOOST_PP_FOR_251_C(BOOST_PP_BOOL(p(252, s)), s, p, o, m)
+# define BOOST_PP_FOR_252(s, p, o, m) BOOST_PP_FOR_252_C(BOOST_PP_BOOL(p(253, s)), s, p, o, m)
+# define BOOST_PP_FOR_253(s, p, o, m) BOOST_PP_FOR_253_C(BOOST_PP_BOOL(p(254, s)), s, p, o, m)
+# define BOOST_PP_FOR_254(s, p, o, m) BOOST_PP_FOR_254_C(BOOST_PP_BOOL(p(255, s)), s, p, o, m)
+# define BOOST_PP_FOR_255(s, p, o, m) BOOST_PP_FOR_255_C(BOOST_PP_BOOL(p(256, s)), s, p, o, m)
+# define BOOST_PP_FOR_256(s, p, o, m) BOOST_PP_FOR_256_C(BOOST_PP_BOOL(p(257, s)), s, p, o, m)
+#
+# define BOOST_PP_FOR_1_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(2, s) BOOST_PP_IIF(c, BOOST_PP_FOR_2, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(2, s), p, o, m)
+# define BOOST_PP_FOR_2_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(3, s) BOOST_PP_IIF(c, BOOST_PP_FOR_3, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(3, s), p, o, m)
+# define BOOST_PP_FOR_3_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(4, s) BOOST_PP_IIF(c, BOOST_PP_FOR_4, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(4, s), p, o, m)
+# define BOOST_PP_FOR_4_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(5, s) BOOST_PP_IIF(c, BOOST_PP_FOR_5, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(5, s), p, o, m)
+# define BOOST_PP_FOR_5_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(6, s) BOOST_PP_IIF(c, BOOST_PP_FOR_6, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(6, s), p, o, m)
+# define BOOST_PP_FOR_6_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(7, s) BOOST_PP_IIF(c, BOOST_PP_FOR_7, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(7, s), p, o, m)
+# define BOOST_PP_FOR_7_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(8, s) BOOST_PP_IIF(c, BOOST_PP_FOR_8, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(8, s), p, o, m)
+# define BOOST_PP_FOR_8_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(9, s) BOOST_PP_IIF(c, BOOST_PP_FOR_9, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(9, s), p, o, m)
+# define BOOST_PP_FOR_9_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(10, s) BOOST_PP_IIF(c, BOOST_PP_FOR_10, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(10, s), p, o, m)
+# define BOOST_PP_FOR_10_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(11, s) BOOST_PP_IIF(c, BOOST_PP_FOR_11, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(11, s), p, o, m)
+# define BOOST_PP_FOR_11_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(12, s) BOOST_PP_IIF(c, BOOST_PP_FOR_12, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(12, s), p, o, m)
+# define BOOST_PP_FOR_12_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(13, s) BOOST_PP_IIF(c, BOOST_PP_FOR_13, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(13, s), p, o, m)
+# define BOOST_PP_FOR_13_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(14, s) BOOST_PP_IIF(c, BOOST_PP_FOR_14, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(14, s), p, o, m)
+# define BOOST_PP_FOR_14_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(15, s) BOOST_PP_IIF(c, BOOST_PP_FOR_15, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(15, s), p, o, m)
+# define BOOST_PP_FOR_15_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(16, s) BOOST_PP_IIF(c, BOOST_PP_FOR_16, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(16, s), p, o, m)
+# define BOOST_PP_FOR_16_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(17, s) BOOST_PP_IIF(c, BOOST_PP_FOR_17, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(17, s), p, o, m)
+# define BOOST_PP_FOR_17_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(18, s) BOOST_PP_IIF(c, BOOST_PP_FOR_18, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(18, s), p, o, m)
+# define BOOST_PP_FOR_18_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(19, s) BOOST_PP_IIF(c, BOOST_PP_FOR_19, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(19, s), p, o, m)
+# define BOOST_PP_FOR_19_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(20, s) BOOST_PP_IIF(c, BOOST_PP_FOR_20, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(20, s), p, o, m)
+# define BOOST_PP_FOR_20_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(21, s) BOOST_PP_IIF(c, BOOST_PP_FOR_21, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(21, s), p, o, m)
+# define BOOST_PP_FOR_21_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(22, s) BOOST_PP_IIF(c, BOOST_PP_FOR_22, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(22, s), p, o, m)
+# define BOOST_PP_FOR_22_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(23, s) BOOST_PP_IIF(c, BOOST_PP_FOR_23, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(23, s), p, o, m)
+# define BOOST_PP_FOR_23_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(24, s) BOOST_PP_IIF(c, BOOST_PP_FOR_24, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(24, s), p, o, m)
+# define BOOST_PP_FOR_24_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(25, s) BOOST_PP_IIF(c, BOOST_PP_FOR_25, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(25, s), p, o, m)
+# define BOOST_PP_FOR_25_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(26, s) BOOST_PP_IIF(c, BOOST_PP_FOR_26, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(26, s), p, o, m)
+# define BOOST_PP_FOR_26_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(27, s) BOOST_PP_IIF(c, BOOST_PP_FOR_27, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(27, s), p, o, m)
+# define BOOST_PP_FOR_27_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(28, s) BOOST_PP_IIF(c, BOOST_PP_FOR_28, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(28, s), p, o, m)
+# define BOOST_PP_FOR_28_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(29, s) BOOST_PP_IIF(c, BOOST_PP_FOR_29, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(29, s), p, o, m)
+# define BOOST_PP_FOR_29_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(30, s) BOOST_PP_IIF(c, BOOST_PP_FOR_30, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(30, s), p, o, m)
+# define BOOST_PP_FOR_30_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(31, s) BOOST_PP_IIF(c, BOOST_PP_FOR_31, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(31, s), p, o, m)
+# define BOOST_PP_FOR_31_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(32, s) BOOST_PP_IIF(c, BOOST_PP_FOR_32, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(32, s), p, o, m)
+# define BOOST_PP_FOR_32_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(33, s) BOOST_PP_IIF(c, BOOST_PP_FOR_33, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(33, s), p, o, m)
+# define BOOST_PP_FOR_33_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(34, s) BOOST_PP_IIF(c, BOOST_PP_FOR_34, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(34, s), p, o, m)
+# define BOOST_PP_FOR_34_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(35, s) BOOST_PP_IIF(c, BOOST_PP_FOR_35, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(35, s), p, o, m)
+# define BOOST_PP_FOR_35_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(36, s) BOOST_PP_IIF(c, BOOST_PP_FOR_36, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(36, s), p, o, m)
+# define BOOST_PP_FOR_36_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(37, s) BOOST_PP_IIF(c, BOOST_PP_FOR_37, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(37, s), p, o, m)
+# define BOOST_PP_FOR_37_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(38, s) BOOST_PP_IIF(c, BOOST_PP_FOR_38, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(38, s), p, o, m)
+# define BOOST_PP_FOR_38_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(39, s) BOOST_PP_IIF(c, BOOST_PP_FOR_39, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(39, s), p, o, m)
+# define BOOST_PP_FOR_39_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(40, s) BOOST_PP_IIF(c, BOOST_PP_FOR_40, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(40, s), p, o, m)
+# define BOOST_PP_FOR_40_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(41, s) BOOST_PP_IIF(c, BOOST_PP_FOR_41, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(41, s), p, o, m)
+# define BOOST_PP_FOR_41_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(42, s) BOOST_PP_IIF(c, BOOST_PP_FOR_42, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(42, s), p, o, m)
+# define BOOST_PP_FOR_42_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(43, s) BOOST_PP_IIF(c, BOOST_PP_FOR_43, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(43, s), p, o, m)
+# define BOOST_PP_FOR_43_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(44, s) BOOST_PP_IIF(c, BOOST_PP_FOR_44, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(44, s), p, o, m)
+# define BOOST_PP_FOR_44_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(45, s) BOOST_PP_IIF(c, BOOST_PP_FOR_45, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(45, s), p, o, m)
+# define BOOST_PP_FOR_45_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(46, s) BOOST_PP_IIF(c, BOOST_PP_FOR_46, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(46, s), p, o, m)
+# define BOOST_PP_FOR_46_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(47, s) BOOST_PP_IIF(c, BOOST_PP_FOR_47, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(47, s), p, o, m)
+# define BOOST_PP_FOR_47_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(48, s) BOOST_PP_IIF(c, BOOST_PP_FOR_48, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(48, s), p, o, m)
+# define BOOST_PP_FOR_48_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(49, s) BOOST_PP_IIF(c, BOOST_PP_FOR_49, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(49, s), p, o, m)
+# define BOOST_PP_FOR_49_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(50, s) BOOST_PP_IIF(c, BOOST_PP_FOR_50, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(50, s), p, o, m)
+# define BOOST_PP_FOR_50_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(51, s) BOOST_PP_IIF(c, BOOST_PP_FOR_51, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(51, s), p, o, m)
+# define BOOST_PP_FOR_51_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(52, s) BOOST_PP_IIF(c, BOOST_PP_FOR_52, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(52, s), p, o, m)
+# define BOOST_PP_FOR_52_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(53, s) BOOST_PP_IIF(c, BOOST_PP_FOR_53, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(53, s), p, o, m)
+# define BOOST_PP_FOR_53_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(54, s) BOOST_PP_IIF(c, BOOST_PP_FOR_54, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(54, s), p, o, m)
+# define BOOST_PP_FOR_54_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(55, s) BOOST_PP_IIF(c, BOOST_PP_FOR_55, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(55, s), p, o, m)
+# define BOOST_PP_FOR_55_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(56, s) BOOST_PP_IIF(c, BOOST_PP_FOR_56, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(56, s), p, o, m)
+# define BOOST_PP_FOR_56_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(57, s) BOOST_PP_IIF(c, BOOST_PP_FOR_57, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(57, s), p, o, m)
+# define BOOST_PP_FOR_57_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(58, s) BOOST_PP_IIF(c, BOOST_PP_FOR_58, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(58, s), p, o, m)
+# define BOOST_PP_FOR_58_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(59, s) BOOST_PP_IIF(c, BOOST_PP_FOR_59, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(59, s), p, o, m)
+# define BOOST_PP_FOR_59_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(60, s) BOOST_PP_IIF(c, BOOST_PP_FOR_60, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(60, s), p, o, m)
+# define BOOST_PP_FOR_60_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(61, s) BOOST_PP_IIF(c, BOOST_PP_FOR_61, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(61, s), p, o, m)
+# define BOOST_PP_FOR_61_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(62, s) BOOST_PP_IIF(c, BOOST_PP_FOR_62, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(62, s), p, o, m)
+# define BOOST_PP_FOR_62_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(63, s) BOOST_PP_IIF(c, BOOST_PP_FOR_63, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(63, s), p, o, m)
+# define BOOST_PP_FOR_63_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(64, s) BOOST_PP_IIF(c, BOOST_PP_FOR_64, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(64, s), p, o, m)
+# define BOOST_PP_FOR_64_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(65, s) BOOST_PP_IIF(c, BOOST_PP_FOR_65, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(65, s), p, o, m)
+# define BOOST_PP_FOR_65_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(66, s) BOOST_PP_IIF(c, BOOST_PP_FOR_66, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(66, s), p, o, m)
+# define BOOST_PP_FOR_66_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(67, s) BOOST_PP_IIF(c, BOOST_PP_FOR_67, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(67, s), p, o, m)
+# define BOOST_PP_FOR_67_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(68, s) BOOST_PP_IIF(c, BOOST_PP_FOR_68, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(68, s), p, o, m)
+# define BOOST_PP_FOR_68_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(69, s) BOOST_PP_IIF(c, BOOST_PP_FOR_69, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(69, s), p, o, m)
+# define BOOST_PP_FOR_69_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(70, s) BOOST_PP_IIF(c, BOOST_PP_FOR_70, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(70, s), p, o, m)
+# define BOOST_PP_FOR_70_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(71, s) BOOST_PP_IIF(c, BOOST_PP_FOR_71, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(71, s), p, o, m)
+# define BOOST_PP_FOR_71_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(72, s) BOOST_PP_IIF(c, BOOST_PP_FOR_72, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(72, s), p, o, m)
+# define BOOST_PP_FOR_72_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(73, s) BOOST_PP_IIF(c, BOOST_PP_FOR_73, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(73, s), p, o, m)
+# define BOOST_PP_FOR_73_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(74, s) BOOST_PP_IIF(c, BOOST_PP_FOR_74, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(74, s), p, o, m)
+# define BOOST_PP_FOR_74_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(75, s) BOOST_PP_IIF(c, BOOST_PP_FOR_75, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(75, s), p, o, m)
+# define BOOST_PP_FOR_75_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(76, s) BOOST_PP_IIF(c, BOOST_PP_FOR_76, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(76, s), p, o, m)
+# define BOOST_PP_FOR_76_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(77, s) BOOST_PP_IIF(c, BOOST_PP_FOR_77, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(77, s), p, o, m)
+# define BOOST_PP_FOR_77_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(78, s) BOOST_PP_IIF(c, BOOST_PP_FOR_78, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(78, s), p, o, m)
+# define BOOST_PP_FOR_78_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(79, s) BOOST_PP_IIF(c, BOOST_PP_FOR_79, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(79, s), p, o, m)
+# define BOOST_PP_FOR_79_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(80, s) BOOST_PP_IIF(c, BOOST_PP_FOR_80, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(80, s), p, o, m)
+# define BOOST_PP_FOR_80_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(81, s) BOOST_PP_IIF(c, BOOST_PP_FOR_81, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(81, s), p, o, m)
+# define BOOST_PP_FOR_81_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(82, s) BOOST_PP_IIF(c, BOOST_PP_FOR_82, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(82, s), p, o, m)
+# define BOOST_PP_FOR_82_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(83, s) BOOST_PP_IIF(c, BOOST_PP_FOR_83, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(83, s), p, o, m)
+# define BOOST_PP_FOR_83_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(84, s) BOOST_PP_IIF(c, BOOST_PP_FOR_84, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(84, s), p, o, m)
+# define BOOST_PP_FOR_84_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(85, s) BOOST_PP_IIF(c, BOOST_PP_FOR_85, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(85, s), p, o, m)
+# define BOOST_PP_FOR_85_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(86, s) BOOST_PP_IIF(c, BOOST_PP_FOR_86, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(86, s), p, o, m)
+# define BOOST_PP_FOR_86_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(87, s) BOOST_PP_IIF(c, BOOST_PP_FOR_87, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(87, s), p, o, m)
+# define BOOST_PP_FOR_87_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(88, s) BOOST_PP_IIF(c, BOOST_PP_FOR_88, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(88, s), p, o, m)
+# define BOOST_PP_FOR_88_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(89, s) BOOST_PP_IIF(c, BOOST_PP_FOR_89, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(89, s), p, o, m)
+# define BOOST_PP_FOR_89_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(90, s) BOOST_PP_IIF(c, BOOST_PP_FOR_90, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(90, s), p, o, m)
+# define BOOST_PP_FOR_90_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(91, s) BOOST_PP_IIF(c, BOOST_PP_FOR_91, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(91, s), p, o, m)
+# define BOOST_PP_FOR_91_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(92, s) BOOST_PP_IIF(c, BOOST_PP_FOR_92, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(92, s), p, o, m)
+# define BOOST_PP_FOR_92_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(93, s) BOOST_PP_IIF(c, BOOST_PP_FOR_93, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(93, s), p, o, m)
+# define BOOST_PP_FOR_93_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(94, s) BOOST_PP_IIF(c, BOOST_PP_FOR_94, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(94, s), p, o, m)
+# define BOOST_PP_FOR_94_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(95, s) BOOST_PP_IIF(c, BOOST_PP_FOR_95, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(95, s), p, o, m)
+# define BOOST_PP_FOR_95_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(96, s) BOOST_PP_IIF(c, BOOST_PP_FOR_96, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(96, s), p, o, m)
+# define BOOST_PP_FOR_96_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(97, s) BOOST_PP_IIF(c, BOOST_PP_FOR_97, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(97, s), p, o, m)
+# define BOOST_PP_FOR_97_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(98, s) BOOST_PP_IIF(c, BOOST_PP_FOR_98, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(98, s), p, o, m)
+# define BOOST_PP_FOR_98_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(99, s) BOOST_PP_IIF(c, BOOST_PP_FOR_99, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(99, s), p, o, m)
+# define BOOST_PP_FOR_99_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(100, s) BOOST_PP_IIF(c, BOOST_PP_FOR_100, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(100, s), p, o, m)
+# define BOOST_PP_FOR_100_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(101, s) BOOST_PP_IIF(c, BOOST_PP_FOR_101, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(101, s), p, o, m)
+# define BOOST_PP_FOR_101_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(102, s) BOOST_PP_IIF(c, BOOST_PP_FOR_102, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(102, s), p, o, m)
+# define BOOST_PP_FOR_102_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(103, s) BOOST_PP_IIF(c, BOOST_PP_FOR_103, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(103, s), p, o, m)
+# define BOOST_PP_FOR_103_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(104, s) BOOST_PP_IIF(c, BOOST_PP_FOR_104, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(104, s), p, o, m)
+# define BOOST_PP_FOR_104_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(105, s) BOOST_PP_IIF(c, BOOST_PP_FOR_105, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(105, s), p, o, m)
+# define BOOST_PP_FOR_105_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(106, s) BOOST_PP_IIF(c, BOOST_PP_FOR_106, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(106, s), p, o, m)
+# define BOOST_PP_FOR_106_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(107, s) BOOST_PP_IIF(c, BOOST_PP_FOR_107, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(107, s), p, o, m)
+# define BOOST_PP_FOR_107_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(108, s) BOOST_PP_IIF(c, BOOST_PP_FOR_108, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(108, s), p, o, m)
+# define BOOST_PP_FOR_108_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(109, s) BOOST_PP_IIF(c, BOOST_PP_FOR_109, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(109, s), p, o, m)
+# define BOOST_PP_FOR_109_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(110, s) BOOST_PP_IIF(c, BOOST_PP_FOR_110, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(110, s), p, o, m)
+# define BOOST_PP_FOR_110_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(111, s) BOOST_PP_IIF(c, BOOST_PP_FOR_111, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(111, s), p, o, m)
+# define BOOST_PP_FOR_111_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(112, s) BOOST_PP_IIF(c, BOOST_PP_FOR_112, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(112, s), p, o, m)
+# define BOOST_PP_FOR_112_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(113, s) BOOST_PP_IIF(c, BOOST_PP_FOR_113, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(113, s), p, o, m)
+# define BOOST_PP_FOR_113_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(114, s) BOOST_PP_IIF(c, BOOST_PP_FOR_114, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(114, s), p, o, m)
+# define BOOST_PP_FOR_114_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(115, s) BOOST_PP_IIF(c, BOOST_PP_FOR_115, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(115, s), p, o, m)
+# define BOOST_PP_FOR_115_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(116, s) BOOST_PP_IIF(c, BOOST_PP_FOR_116, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(116, s), p, o, m)
+# define BOOST_PP_FOR_116_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(117, s) BOOST_PP_IIF(c, BOOST_PP_FOR_117, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(117, s), p, o, m)
+# define BOOST_PP_FOR_117_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(118, s) BOOST_PP_IIF(c, BOOST_PP_FOR_118, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(118, s), p, o, m)
+# define BOOST_PP_FOR_118_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(119, s) BOOST_PP_IIF(c, BOOST_PP_FOR_119, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(119, s), p, o, m)
+# define BOOST_PP_FOR_119_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(120, s) BOOST_PP_IIF(c, BOOST_PP_FOR_120, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(120, s), p, o, m)
+# define BOOST_PP_FOR_120_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(121, s) BOOST_PP_IIF(c, BOOST_PP_FOR_121, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(121, s), p, o, m)
+# define BOOST_PP_FOR_121_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(122, s) BOOST_PP_IIF(c, BOOST_PP_FOR_122, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(122, s), p, o, m)
+# define BOOST_PP_FOR_122_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(123, s) BOOST_PP_IIF(c, BOOST_PP_FOR_123, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(123, s), p, o, m)
+# define BOOST_PP_FOR_123_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(124, s) BOOST_PP_IIF(c, BOOST_PP_FOR_124, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(124, s), p, o, m)
+# define BOOST_PP_FOR_124_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(125, s) BOOST_PP_IIF(c, BOOST_PP_FOR_125, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(125, s), p, o, m)
+# define BOOST_PP_FOR_125_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(126, s) BOOST_PP_IIF(c, BOOST_PP_FOR_126, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(126, s), p, o, m)
+# define BOOST_PP_FOR_126_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(127, s) BOOST_PP_IIF(c, BOOST_PP_FOR_127, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(127, s), p, o, m)
+# define BOOST_PP_FOR_127_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(128, s) BOOST_PP_IIF(c, BOOST_PP_FOR_128, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(128, s), p, o, m)
+# define BOOST_PP_FOR_128_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(129, s) BOOST_PP_IIF(c, BOOST_PP_FOR_129, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(129, s), p, o, m)
+# define BOOST_PP_FOR_129_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(130, s) BOOST_PP_IIF(c, BOOST_PP_FOR_130, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(130, s), p, o, m)
+# define BOOST_PP_FOR_130_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(131, s) BOOST_PP_IIF(c, BOOST_PP_FOR_131, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(131, s), p, o, m)
+# define BOOST_PP_FOR_131_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(132, s) BOOST_PP_IIF(c, BOOST_PP_FOR_132, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(132, s), p, o, m)
+# define BOOST_PP_FOR_132_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(133, s) BOOST_PP_IIF(c, BOOST_PP_FOR_133, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(133, s), p, o, m)
+# define BOOST_PP_FOR_133_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(134, s) BOOST_PP_IIF(c, BOOST_PP_FOR_134, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(134, s), p, o, m)
+# define BOOST_PP_FOR_134_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(135, s) BOOST_PP_IIF(c, BOOST_PP_FOR_135, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(135, s), p, o, m)
+# define BOOST_PP_FOR_135_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(136, s) BOOST_PP_IIF(c, BOOST_PP_FOR_136, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(136, s), p, o, m)
+# define BOOST_PP_FOR_136_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(137, s) BOOST_PP_IIF(c, BOOST_PP_FOR_137, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(137, s), p, o, m)
+# define BOOST_PP_FOR_137_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(138, s) BOOST_PP_IIF(c, BOOST_PP_FOR_138, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(138, s), p, o, m)
+# define BOOST_PP_FOR_138_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(139, s) BOOST_PP_IIF(c, BOOST_PP_FOR_139, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(139, s), p, o, m)
+# define BOOST_PP_FOR_139_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(140, s) BOOST_PP_IIF(c, BOOST_PP_FOR_140, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(140, s), p, o, m)
+# define BOOST_PP_FOR_140_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(141, s) BOOST_PP_IIF(c, BOOST_PP_FOR_141, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(141, s), p, o, m)
+# define BOOST_PP_FOR_141_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(142, s) BOOST_PP_IIF(c, BOOST_PP_FOR_142, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(142, s), p, o, m)
+# define BOOST_PP_FOR_142_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(143, s) BOOST_PP_IIF(c, BOOST_PP_FOR_143, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(143, s), p, o, m)
+# define BOOST_PP_FOR_143_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(144, s) BOOST_PP_IIF(c, BOOST_PP_FOR_144, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(144, s), p, o, m)
+# define BOOST_PP_FOR_144_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(145, s) BOOST_PP_IIF(c, BOOST_PP_FOR_145, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(145, s), p, o, m)
+# define BOOST_PP_FOR_145_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(146, s) BOOST_PP_IIF(c, BOOST_PP_FOR_146, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(146, s), p, o, m)
+# define BOOST_PP_FOR_146_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(147, s) BOOST_PP_IIF(c, BOOST_PP_FOR_147, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(147, s), p, o, m)
+# define BOOST_PP_FOR_147_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(148, s) BOOST_PP_IIF(c, BOOST_PP_FOR_148, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(148, s), p, o, m)
+# define BOOST_PP_FOR_148_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(149, s) BOOST_PP_IIF(c, BOOST_PP_FOR_149, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(149, s), p, o, m)
+# define BOOST_PP_FOR_149_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(150, s) BOOST_PP_IIF(c, BOOST_PP_FOR_150, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(150, s), p, o, m)
+# define BOOST_PP_FOR_150_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(151, s) BOOST_PP_IIF(c, BOOST_PP_FOR_151, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(151, s), p, o, m)
+# define BOOST_PP_FOR_151_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(152, s) BOOST_PP_IIF(c, BOOST_PP_FOR_152, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(152, s), p, o, m)
+# define BOOST_PP_FOR_152_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(153, s) BOOST_PP_IIF(c, BOOST_PP_FOR_153, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(153, s), p, o, m)
+# define BOOST_PP_FOR_153_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(154, s) BOOST_PP_IIF(c, BOOST_PP_FOR_154, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(154, s), p, o, m)
+# define BOOST_PP_FOR_154_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(155, s) BOOST_PP_IIF(c, BOOST_PP_FOR_155, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(155, s), p, o, m)
+# define BOOST_PP_FOR_155_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(156, s) BOOST_PP_IIF(c, BOOST_PP_FOR_156, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(156, s), p, o, m)
+# define BOOST_PP_FOR_156_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(157, s) BOOST_PP_IIF(c, BOOST_PP_FOR_157, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(157, s), p, o, m)
+# define BOOST_PP_FOR_157_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(158, s) BOOST_PP_IIF(c, BOOST_PP_FOR_158, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(158, s), p, o, m)
+# define BOOST_PP_FOR_158_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(159, s) BOOST_PP_IIF(c, BOOST_PP_FOR_159, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(159, s), p, o, m)
+# define BOOST_PP_FOR_159_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(160, s) BOOST_PP_IIF(c, BOOST_PP_FOR_160, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(160, s), p, o, m)
+# define BOOST_PP_FOR_160_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(161, s) BOOST_PP_IIF(c, BOOST_PP_FOR_161, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(161, s), p, o, m)
+# define BOOST_PP_FOR_161_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(162, s) BOOST_PP_IIF(c, BOOST_PP_FOR_162, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(162, s), p, o, m)
+# define BOOST_PP_FOR_162_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(163, s) BOOST_PP_IIF(c, BOOST_PP_FOR_163, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(163, s), p, o, m)
+# define BOOST_PP_FOR_163_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(164, s) BOOST_PP_IIF(c, BOOST_PP_FOR_164, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(164, s), p, o, m)
+# define BOOST_PP_FOR_164_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(165, s) BOOST_PP_IIF(c, BOOST_PP_FOR_165, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(165, s), p, o, m)
+# define BOOST_PP_FOR_165_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(166, s) BOOST_PP_IIF(c, BOOST_PP_FOR_166, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(166, s), p, o, m)
+# define BOOST_PP_FOR_166_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(167, s) BOOST_PP_IIF(c, BOOST_PP_FOR_167, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(167, s), p, o, m)
+# define BOOST_PP_FOR_167_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(168, s) BOOST_PP_IIF(c, BOOST_PP_FOR_168, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(168, s), p, o, m)
+# define BOOST_PP_FOR_168_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(169, s) BOOST_PP_IIF(c, BOOST_PP_FOR_169, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(169, s), p, o, m)
+# define BOOST_PP_FOR_169_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(170, s) BOOST_PP_IIF(c, BOOST_PP_FOR_170, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(170, s), p, o, m)
+# define BOOST_PP_FOR_170_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(171, s) BOOST_PP_IIF(c, BOOST_PP_FOR_171, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(171, s), p, o, m)
+# define BOOST_PP_FOR_171_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(172, s) BOOST_PP_IIF(c, BOOST_PP_FOR_172, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(172, s), p, o, m)
+# define BOOST_PP_FOR_172_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(173, s) BOOST_PP_IIF(c, BOOST_PP_FOR_173, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(173, s), p, o, m)
+# define BOOST_PP_FOR_173_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(174, s) BOOST_PP_IIF(c, BOOST_PP_FOR_174, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(174, s), p, o, m)
+# define BOOST_PP_FOR_174_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(175, s) BOOST_PP_IIF(c, BOOST_PP_FOR_175, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(175, s), p, o, m)
+# define BOOST_PP_FOR_175_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(176, s) BOOST_PP_IIF(c, BOOST_PP_FOR_176, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(176, s), p, o, m)
+# define BOOST_PP_FOR_176_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(177, s) BOOST_PP_IIF(c, BOOST_PP_FOR_177, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(177, s), p, o, m)
+# define BOOST_PP_FOR_177_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(178, s) BOOST_PP_IIF(c, BOOST_PP_FOR_178, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(178, s), p, o, m)
+# define BOOST_PP_FOR_178_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(179, s) BOOST_PP_IIF(c, BOOST_PP_FOR_179, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(179, s), p, o, m)
+# define BOOST_PP_FOR_179_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(180, s) BOOST_PP_IIF(c, BOOST_PP_FOR_180, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(180, s), p, o, m)
+# define BOOST_PP_FOR_180_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(181, s) BOOST_PP_IIF(c, BOOST_PP_FOR_181, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(181, s), p, o, m)
+# define BOOST_PP_FOR_181_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(182, s) BOOST_PP_IIF(c, BOOST_PP_FOR_182, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(182, s), p, o, m)
+# define BOOST_PP_FOR_182_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(183, s) BOOST_PP_IIF(c, BOOST_PP_FOR_183, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(183, s), p, o, m)
+# define BOOST_PP_FOR_183_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(184, s) BOOST_PP_IIF(c, BOOST_PP_FOR_184, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(184, s), p, o, m)
+# define BOOST_PP_FOR_184_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(185, s) BOOST_PP_IIF(c, BOOST_PP_FOR_185, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(185, s), p, o, m)
+# define BOOST_PP_FOR_185_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(186, s) BOOST_PP_IIF(c, BOOST_PP_FOR_186, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(186, s), p, o, m)
+# define BOOST_PP_FOR_186_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(187, s) BOOST_PP_IIF(c, BOOST_PP_FOR_187, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(187, s), p, o, m)
+# define BOOST_PP_FOR_187_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(188, s) BOOST_PP_IIF(c, BOOST_PP_FOR_188, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(188, s), p, o, m)
+# define BOOST_PP_FOR_188_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(189, s) BOOST_PP_IIF(c, BOOST_PP_FOR_189, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(189, s), p, o, m)
+# define BOOST_PP_FOR_189_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(190, s) BOOST_PP_IIF(c, BOOST_PP_FOR_190, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(190, s), p, o, m)
+# define BOOST_PP_FOR_190_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(191, s) BOOST_PP_IIF(c, BOOST_PP_FOR_191, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(191, s), p, o, m)
+# define BOOST_PP_FOR_191_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(192, s) BOOST_PP_IIF(c, BOOST_PP_FOR_192, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(192, s), p, o, m)
+# define BOOST_PP_FOR_192_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(193, s) BOOST_PP_IIF(c, BOOST_PP_FOR_193, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(193, s), p, o, m)
+# define BOOST_PP_FOR_193_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(194, s) BOOST_PP_IIF(c, BOOST_PP_FOR_194, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(194, s), p, o, m)
+# define BOOST_PP_FOR_194_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(195, s) BOOST_PP_IIF(c, BOOST_PP_FOR_195, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(195, s), p, o, m)
+# define BOOST_PP_FOR_195_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(196, s) BOOST_PP_IIF(c, BOOST_PP_FOR_196, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(196, s), p, o, m)
+# define BOOST_PP_FOR_196_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(197, s) BOOST_PP_IIF(c, BOOST_PP_FOR_197, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(197, s), p, o, m)
+# define BOOST_PP_FOR_197_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(198, s) BOOST_PP_IIF(c, BOOST_PP_FOR_198, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(198, s), p, o, m)
+# define BOOST_PP_FOR_198_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(199, s) BOOST_PP_IIF(c, BOOST_PP_FOR_199, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(199, s), p, o, m)
+# define BOOST_PP_FOR_199_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(200, s) BOOST_PP_IIF(c, BOOST_PP_FOR_200, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(200, s), p, o, m)
+# define BOOST_PP_FOR_200_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(201, s) BOOST_PP_IIF(c, BOOST_PP_FOR_201, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(201, s), p, o, m)
+# define BOOST_PP_FOR_201_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(202, s) BOOST_PP_IIF(c, BOOST_PP_FOR_202, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(202, s), p, o, m)
+# define BOOST_PP_FOR_202_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(203, s) BOOST_PP_IIF(c, BOOST_PP_FOR_203, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(203, s), p, o, m)
+# define BOOST_PP_FOR_203_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(204, s) BOOST_PP_IIF(c, BOOST_PP_FOR_204, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(204, s), p, o, m)
+# define BOOST_PP_FOR_204_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(205, s) BOOST_PP_IIF(c, BOOST_PP_FOR_205, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(205, s), p, o, m)
+# define BOOST_PP_FOR_205_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(206, s) BOOST_PP_IIF(c, BOOST_PP_FOR_206, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(206, s), p, o, m)
+# define BOOST_PP_FOR_206_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(207, s) BOOST_PP_IIF(c, BOOST_PP_FOR_207, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(207, s), p, o, m)
+# define BOOST_PP_FOR_207_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(208, s) BOOST_PP_IIF(c, BOOST_PP_FOR_208, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(208, s), p, o, m)
+# define BOOST_PP_FOR_208_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(209, s) BOOST_PP_IIF(c, BOOST_PP_FOR_209, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(209, s), p, o, m)
+# define BOOST_PP_FOR_209_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(210, s) BOOST_PP_IIF(c, BOOST_PP_FOR_210, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(210, s), p, o, m)
+# define BOOST_PP_FOR_210_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(211, s) BOOST_PP_IIF(c, BOOST_PP_FOR_211, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(211, s), p, o, m)
+# define BOOST_PP_FOR_211_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(212, s) BOOST_PP_IIF(c, BOOST_PP_FOR_212, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(212, s), p, o, m)
+# define BOOST_PP_FOR_212_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(213, s) BOOST_PP_IIF(c, BOOST_PP_FOR_213, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(213, s), p, o, m)
+# define BOOST_PP_FOR_213_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(214, s) BOOST_PP_IIF(c, BOOST_PP_FOR_214, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(214, s), p, o, m)
+# define BOOST_PP_FOR_214_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(215, s) BOOST_PP_IIF(c, BOOST_PP_FOR_215, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(215, s), p, o, m)
+# define BOOST_PP_FOR_215_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(216, s) BOOST_PP_IIF(c, BOOST_PP_FOR_216, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(216, s), p, o, m)
+# define BOOST_PP_FOR_216_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(217, s) BOOST_PP_IIF(c, BOOST_PP_FOR_217, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(217, s), p, o, m)
+# define BOOST_PP_FOR_217_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(218, s) BOOST_PP_IIF(c, BOOST_PP_FOR_218, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(218, s), p, o, m)
+# define BOOST_PP_FOR_218_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(219, s) BOOST_PP_IIF(c, BOOST_PP_FOR_219, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(219, s), p, o, m)
+# define BOOST_PP_FOR_219_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(220, s) BOOST_PP_IIF(c, BOOST_PP_FOR_220, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(220, s), p, o, m)
+# define BOOST_PP_FOR_220_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(221, s) BOOST_PP_IIF(c, BOOST_PP_FOR_221, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(221, s), p, o, m)
+# define BOOST_PP_FOR_221_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(222, s) BOOST_PP_IIF(c, BOOST_PP_FOR_222, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(222, s), p, o, m)
+# define BOOST_PP_FOR_222_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(223, s) BOOST_PP_IIF(c, BOOST_PP_FOR_223, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(223, s), p, o, m)
+# define BOOST_PP_FOR_223_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(224, s) BOOST_PP_IIF(c, BOOST_PP_FOR_224, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(224, s), p, o, m)
+# define BOOST_PP_FOR_224_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(225, s) BOOST_PP_IIF(c, BOOST_PP_FOR_225, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(225, s), p, o, m)
+# define BOOST_PP_FOR_225_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(226, s) BOOST_PP_IIF(c, BOOST_PP_FOR_226, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(226, s), p, o, m)
+# define BOOST_PP_FOR_226_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(227, s) BOOST_PP_IIF(c, BOOST_PP_FOR_227, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(227, s), p, o, m)
+# define BOOST_PP_FOR_227_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(228, s) BOOST_PP_IIF(c, BOOST_PP_FOR_228, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(228, s), p, o, m)
+# define BOOST_PP_FOR_228_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(229, s) BOOST_PP_IIF(c, BOOST_PP_FOR_229, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(229, s), p, o, m)
+# define BOOST_PP_FOR_229_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(230, s) BOOST_PP_IIF(c, BOOST_PP_FOR_230, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(230, s), p, o, m)
+# define BOOST_PP_FOR_230_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(231, s) BOOST_PP_IIF(c, BOOST_PP_FOR_231, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(231, s), p, o, m)
+# define BOOST_PP_FOR_231_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(232, s) BOOST_PP_IIF(c, BOOST_PP_FOR_232, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(232, s), p, o, m)
+# define BOOST_PP_FOR_232_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(233, s) BOOST_PP_IIF(c, BOOST_PP_FOR_233, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(233, s), p, o, m)
+# define BOOST_PP_FOR_233_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(234, s) BOOST_PP_IIF(c, BOOST_PP_FOR_234, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(234, s), p, o, m)
+# define BOOST_PP_FOR_234_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(235, s) BOOST_PP_IIF(c, BOOST_PP_FOR_235, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(235, s), p, o, m)
+# define BOOST_PP_FOR_235_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(236, s) BOOST_PP_IIF(c, BOOST_PP_FOR_236, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(236, s), p, o, m)
+# define BOOST_PP_FOR_236_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(237, s) BOOST_PP_IIF(c, BOOST_PP_FOR_237, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(237, s), p, o, m)
+# define BOOST_PP_FOR_237_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(238, s) BOOST_PP_IIF(c, BOOST_PP_FOR_238, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(238, s), p, o, m)
+# define BOOST_PP_FOR_238_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(239, s) BOOST_PP_IIF(c, BOOST_PP_FOR_239, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(239, s), p, o, m)
+# define BOOST_PP_FOR_239_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(240, s) BOOST_PP_IIF(c, BOOST_PP_FOR_240, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(240, s), p, o, m)
+# define BOOST_PP_FOR_240_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(241, s) BOOST_PP_IIF(c, BOOST_PP_FOR_241, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(241, s), p, o, m)
+# define BOOST_PP_FOR_241_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(242, s) BOOST_PP_IIF(c, BOOST_PP_FOR_242, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(242, s), p, o, m)
+# define BOOST_PP_FOR_242_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(243, s) BOOST_PP_IIF(c, BOOST_PP_FOR_243, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(243, s), p, o, m)
+# define BOOST_PP_FOR_243_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(244, s) BOOST_PP_IIF(c, BOOST_PP_FOR_244, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(244, s), p, o, m)
+# define BOOST_PP_FOR_244_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(245, s) BOOST_PP_IIF(c, BOOST_PP_FOR_245, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(245, s), p, o, m)
+# define BOOST_PP_FOR_245_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(246, s) BOOST_PP_IIF(c, BOOST_PP_FOR_246, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(246, s), p, o, m)
+# define BOOST_PP_FOR_246_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(247, s) BOOST_PP_IIF(c, BOOST_PP_FOR_247, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(247, s), p, o, m)
+# define BOOST_PP_FOR_247_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(248, s) BOOST_PP_IIF(c, BOOST_PP_FOR_248, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(248, s), p, o, m)
+# define BOOST_PP_FOR_248_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(249, s) BOOST_PP_IIF(c, BOOST_PP_FOR_249, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(249, s), p, o, m)
+# define BOOST_PP_FOR_249_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(250, s) BOOST_PP_IIF(c, BOOST_PP_FOR_250, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(250, s), p, o, m)
+# define BOOST_PP_FOR_250_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(251, s) BOOST_PP_IIF(c, BOOST_PP_FOR_251, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(251, s), p, o, m)
+# define BOOST_PP_FOR_251_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(252, s) BOOST_PP_IIF(c, BOOST_PP_FOR_252, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(252, s), p, o, m)
+# define BOOST_PP_FOR_252_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(253, s) BOOST_PP_IIF(c, BOOST_PP_FOR_253, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(253, s), p, o, m)
+# define BOOST_PP_FOR_253_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(254, s) BOOST_PP_IIF(c, BOOST_PP_FOR_254, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(254, s), p, o, m)
+# define BOOST_PP_FOR_254_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(255, s) BOOST_PP_IIF(c, BOOST_PP_FOR_255, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(255, s), p, o, m)
+# define BOOST_PP_FOR_255_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(256, s) BOOST_PP_IIF(c, BOOST_PP_FOR_256, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(256, s), p, o, m)
+# define BOOST_PP_FOR_256_C(c, s, p, o, m) BOOST_PP_IIF(c, m, BOOST_PP_TUPLE_EAT_2)(257, s) BOOST_PP_IIF(c, BOOST_PP_FOR_257, BOOST_PP_TUPLE_EAT_4)(BOOST_PP_EXPR_IIF(c, o)(257, s), p, o, m)
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/repeat.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/repeat.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/repeat.hpp	(working copy)
@@ -0,0 +1,825 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_REPEAT_HPP
+# define BOOST_PREPROCESSOR_REPETITION_REPEAT_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/debug/error.hpp>
+# include <boost/preprocessor/detail/auto_rec.hpp>
+# include <boost/preprocessor/tuple/eat.hpp>
+#
+# /* BOOST_PP_REPEAT */
+#
+# if 0
+#    define BOOST_PP_REPEAT(count, macro, data)
+# endif
+#
+# define BOOST_PP_REPEAT BOOST_PP_CAT(BOOST_PP_REPEAT_, BOOST_PP_AUTO_REC(BOOST_PP_REPEAT_P, 4))
+#
+# define BOOST_PP_REPEAT_P(n) BOOST_PP_CAT(BOOST_PP_REPEAT_CHECK_, BOOST_PP_REPEAT_ ## n(1, BOOST_PP_NIL BOOST_PP_TUPLE_EAT_3, BOOST_PP_NIL))
+#
+# define BOOST_PP_REPEAT_CHECK_BOOST_PP_NIL 1
+# define BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_1(c, m, d) 0
+# define BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_2(c, m, d) 0
+# define BOOST_PP_REPEAT_CHECK_BOOST_PP_REPEAT_3(c, m, d) 0
+#
+# define BOOST_PP_REPEAT_1(c, m, d) BOOST_PP_REPEAT_1_I(c, m, d)
+# define BOOST_PP_REPEAT_2(c, m, d) BOOST_PP_REPEAT_2_I(c, m, d)
+# define BOOST_PP_REPEAT_3(c, m, d) BOOST_PP_REPEAT_3_I(c, m, d)
+# define BOOST_PP_REPEAT_4(c, m, d) BOOST_PP_ERROR(0x0003)
+#
+# define BOOST_PP_REPEAT_1_I(c, m, d) BOOST_PP_REPEAT_1_ ## c(m, d)
+# define BOOST_PP_REPEAT_2_I(c, m, d) BOOST_PP_REPEAT_2_ ## c(m, d)
+# define BOOST_PP_REPEAT_3_I(c, m, d) BOOST_PP_REPEAT_3_ ## c(m, d)
+#
+# define BOOST_PP_REPEAT_1ST BOOST_PP_REPEAT_1
+# define BOOST_PP_REPEAT_2ND BOOST_PP_REPEAT_2
+# define BOOST_PP_REPEAT_3RD BOOST_PP_REPEAT_3
+#
+# define BOOST_PP_REPEAT_1_0(m, d)
+# define BOOST_PP_REPEAT_1_1(m, d) m(2, 0, d)
+# define BOOST_PP_REPEAT_1_2(m, d) BOOST_PP_REPEAT_1_1(m, d) m(2, 1, d)
+# define BOOST_PP_REPEAT_1_3(m, d) BOOST_PP_REPEAT_1_2(m, d) m(2, 2, d)
+# define BOOST_PP_REPEAT_1_4(m, d) BOOST_PP_REPEAT_1_3(m, d) m(2, 3, d)
+# define BOOST_PP_REPEAT_1_5(m, d) BOOST_PP_REPEAT_1_4(m, d) m(2, 4, d)
+# define BOOST_PP_REPEAT_1_6(m, d) BOOST_PP_REPEAT_1_5(m, d) m(2, 5, d)
+# define BOOST_PP_REPEAT_1_7(m, d) BOOST_PP_REPEAT_1_6(m, d) m(2, 6, d)
+# define BOOST_PP_REPEAT_1_8(m, d) BOOST_PP_REPEAT_1_7(m, d) m(2, 7, d)
+# define BOOST_PP_REPEAT_1_9(m, d) BOOST_PP_REPEAT_1_8(m, d) m(2, 8, d)
+# define BOOST_PP_REPEAT_1_10(m, d) BOOST_PP_REPEAT_1_9(m, d) m(2, 9, d)
+# define BOOST_PP_REPEAT_1_11(m, d) BOOST_PP_REPEAT_1_10(m, d) m(2, 10, d)
+# define BOOST_PP_REPEAT_1_12(m, d) BOOST_PP_REPEAT_1_11(m, d) m(2, 11, d)
+# define BOOST_PP_REPEAT_1_13(m, d) BOOST_PP_REPEAT_1_12(m, d) m(2, 12, d)
+# define BOOST_PP_REPEAT_1_14(m, d) BOOST_PP_REPEAT_1_13(m, d) m(2, 13, d)
+# define BOOST_PP_REPEAT_1_15(m, d) BOOST_PP_REPEAT_1_14(m, d) m(2, 14, d)
+# define BOOST_PP_REPEAT_1_16(m, d) BOOST_PP_REPEAT_1_15(m, d) m(2, 15, d)
+# define BOOST_PP_REPEAT_1_17(m, d) BOOST_PP_REPEAT_1_16(m, d) m(2, 16, d)
+# define BOOST_PP_REPEAT_1_18(m, d) BOOST_PP_REPEAT_1_17(m, d) m(2, 17, d)
+# define BOOST_PP_REPEAT_1_19(m, d) BOOST_PP_REPEAT_1_18(m, d) m(2, 18, d)
+# define BOOST_PP_REPEAT_1_20(m, d) BOOST_PP_REPEAT_1_19(m, d) m(2, 19, d)
+# define BOOST_PP_REPEAT_1_21(m, d) BOOST_PP_REPEAT_1_20(m, d) m(2, 20, d)
+# define BOOST_PP_REPEAT_1_22(m, d) BOOST_PP_REPEAT_1_21(m, d) m(2, 21, d)
+# define BOOST_PP_REPEAT_1_23(m, d) BOOST_PP_REPEAT_1_22(m, d) m(2, 22, d)
+# define BOOST_PP_REPEAT_1_24(m, d) BOOST_PP_REPEAT_1_23(m, d) m(2, 23, d)
+# define BOOST_PP_REPEAT_1_25(m, d) BOOST_PP_REPEAT_1_24(m, d) m(2, 24, d)
+# define BOOST_PP_REPEAT_1_26(m, d) BOOST_PP_REPEAT_1_25(m, d) m(2, 25, d)
+# define BOOST_PP_REPEAT_1_27(m, d) BOOST_PP_REPEAT_1_26(m, d) m(2, 26, d)
+# define BOOST_PP_REPEAT_1_28(m, d) BOOST_PP_REPEAT_1_27(m, d) m(2, 27, d)
+# define BOOST_PP_REPEAT_1_29(m, d) BOOST_PP_REPEAT_1_28(m, d) m(2, 28, d)
+# define BOOST_PP_REPEAT_1_30(m, d) BOOST_PP_REPEAT_1_29(m, d) m(2, 29, d)
+# define BOOST_PP_REPEAT_1_31(m, d) BOOST_PP_REPEAT_1_30(m, d) m(2, 30, d)
+# define BOOST_PP_REPEAT_1_32(m, d) BOOST_PP_REPEAT_1_31(m, d) m(2, 31, d)
+# define BOOST_PP_REPEAT_1_33(m, d) BOOST_PP_REPEAT_1_32(m, d) m(2, 32, d)
+# define BOOST_PP_REPEAT_1_34(m, d) BOOST_PP_REPEAT_1_33(m, d) m(2, 33, d)
+# define BOOST_PP_REPEAT_1_35(m, d) BOOST_PP_REPEAT_1_34(m, d) m(2, 34, d)
+# define BOOST_PP_REPEAT_1_36(m, d) BOOST_PP_REPEAT_1_35(m, d) m(2, 35, d)
+# define BOOST_PP_REPEAT_1_37(m, d) BOOST_PP_REPEAT_1_36(m, d) m(2, 36, d)
+# define BOOST_PP_REPEAT_1_38(m, d) BOOST_PP_REPEAT_1_37(m, d) m(2, 37, d)
+# define BOOST_PP_REPEAT_1_39(m, d) BOOST_PP_REPEAT_1_38(m, d) m(2, 38, d)
+# define BOOST_PP_REPEAT_1_40(m, d) BOOST_PP_REPEAT_1_39(m, d) m(2, 39, d)
+# define BOOST_PP_REPEAT_1_41(m, d) BOOST_PP_REPEAT_1_40(m, d) m(2, 40, d)
+# define BOOST_PP_REPEAT_1_42(m, d) BOOST_PP_REPEAT_1_41(m, d) m(2, 41, d)
+# define BOOST_PP_REPEAT_1_43(m, d) BOOST_PP_REPEAT_1_42(m, d) m(2, 42, d)
+# define BOOST_PP_REPEAT_1_44(m, d) BOOST_PP_REPEAT_1_43(m, d) m(2, 43, d)
+# define BOOST_PP_REPEAT_1_45(m, d) BOOST_PP_REPEAT_1_44(m, d) m(2, 44, d)
+# define BOOST_PP_REPEAT_1_46(m, d) BOOST_PP_REPEAT_1_45(m, d) m(2, 45, d)
+# define BOOST_PP_REPEAT_1_47(m, d) BOOST_PP_REPEAT_1_46(m, d) m(2, 46, d)
+# define BOOST_PP_REPEAT_1_48(m, d) BOOST_PP_REPEAT_1_47(m, d) m(2, 47, d)
+# define BOOST_PP_REPEAT_1_49(m, d) BOOST_PP_REPEAT_1_48(m, d) m(2, 48, d)
+# define BOOST_PP_REPEAT_1_50(m, d) BOOST_PP_REPEAT_1_49(m, d) m(2, 49, d)
+# define BOOST_PP_REPEAT_1_51(m, d) BOOST_PP_REPEAT_1_50(m, d) m(2, 50, d)
+# define BOOST_PP_REPEAT_1_52(m, d) BOOST_PP_REPEAT_1_51(m, d) m(2, 51, d)
+# define BOOST_PP_REPEAT_1_53(m, d) BOOST_PP_REPEAT_1_52(m, d) m(2, 52, d)
+# define BOOST_PP_REPEAT_1_54(m, d) BOOST_PP_REPEAT_1_53(m, d) m(2, 53, d)
+# define BOOST_PP_REPEAT_1_55(m, d) BOOST_PP_REPEAT_1_54(m, d) m(2, 54, d)
+# define BOOST_PP_REPEAT_1_56(m, d) BOOST_PP_REPEAT_1_55(m, d) m(2, 55, d)
+# define BOOST_PP_REPEAT_1_57(m, d) BOOST_PP_REPEAT_1_56(m, d) m(2, 56, d)
+# define BOOST_PP_REPEAT_1_58(m, d) BOOST_PP_REPEAT_1_57(m, d) m(2, 57, d)
+# define BOOST_PP_REPEAT_1_59(m, d) BOOST_PP_REPEAT_1_58(m, d) m(2, 58, d)
+# define BOOST_PP_REPEAT_1_60(m, d) BOOST_PP_REPEAT_1_59(m, d) m(2, 59, d)
+# define BOOST_PP_REPEAT_1_61(m, d) BOOST_PP_REPEAT_1_60(m, d) m(2, 60, d)
+# define BOOST_PP_REPEAT_1_62(m, d) BOOST_PP_REPEAT_1_61(m, d) m(2, 61, d)
+# define BOOST_PP_REPEAT_1_63(m, d) BOOST_PP_REPEAT_1_62(m, d) m(2, 62, d)
+# define BOOST_PP_REPEAT_1_64(m, d) BOOST_PP_REPEAT_1_63(m, d) m(2, 63, d)
+# define BOOST_PP_REPEAT_1_65(m, d) BOOST_PP_REPEAT_1_64(m, d) m(2, 64, d)
+# define BOOST_PP_REPEAT_1_66(m, d) BOOST_PP_REPEAT_1_65(m, d) m(2, 65, d)
+# define BOOST_PP_REPEAT_1_67(m, d) BOOST_PP_REPEAT_1_66(m, d) m(2, 66, d)
+# define BOOST_PP_REPEAT_1_68(m, d) BOOST_PP_REPEAT_1_67(m, d) m(2, 67, d)
+# define BOOST_PP_REPEAT_1_69(m, d) BOOST_PP_REPEAT_1_68(m, d) m(2, 68, d)
+# define BOOST_PP_REPEAT_1_70(m, d) BOOST_PP_REPEAT_1_69(m, d) m(2, 69, d)
+# define BOOST_PP_REPEAT_1_71(m, d) BOOST_PP_REPEAT_1_70(m, d) m(2, 70, d)
+# define BOOST_PP_REPEAT_1_72(m, d) BOOST_PP_REPEAT_1_71(m, d) m(2, 71, d)
+# define BOOST_PP_REPEAT_1_73(m, d) BOOST_PP_REPEAT_1_72(m, d) m(2, 72, d)
+# define BOOST_PP_REPEAT_1_74(m, d) BOOST_PP_REPEAT_1_73(m, d) m(2, 73, d)
+# define BOOST_PP_REPEAT_1_75(m, d) BOOST_PP_REPEAT_1_74(m, d) m(2, 74, d)
+# define BOOST_PP_REPEAT_1_76(m, d) BOOST_PP_REPEAT_1_75(m, d) m(2, 75, d)
+# define BOOST_PP_REPEAT_1_77(m, d) BOOST_PP_REPEAT_1_76(m, d) m(2, 76, d)
+# define BOOST_PP_REPEAT_1_78(m, d) BOOST_PP_REPEAT_1_77(m, d) m(2, 77, d)
+# define BOOST_PP_REPEAT_1_79(m, d) BOOST_PP_REPEAT_1_78(m, d) m(2, 78, d)
+# define BOOST_PP_REPEAT_1_80(m, d) BOOST_PP_REPEAT_1_79(m, d) m(2, 79, d)
+# define BOOST_PP_REPEAT_1_81(m, d) BOOST_PP_REPEAT_1_80(m, d) m(2, 80, d)
+# define BOOST_PP_REPEAT_1_82(m, d) BOOST_PP_REPEAT_1_81(m, d) m(2, 81, d)
+# define BOOST_PP_REPEAT_1_83(m, d) BOOST_PP_REPEAT_1_82(m, d) m(2, 82, d)
+# define BOOST_PP_REPEAT_1_84(m, d) BOOST_PP_REPEAT_1_83(m, d) m(2, 83, d)
+# define BOOST_PP_REPEAT_1_85(m, d) BOOST_PP_REPEAT_1_84(m, d) m(2, 84, d)
+# define BOOST_PP_REPEAT_1_86(m, d) BOOST_PP_REPEAT_1_85(m, d) m(2, 85, d)
+# define BOOST_PP_REPEAT_1_87(m, d) BOOST_PP_REPEAT_1_86(m, d) m(2, 86, d)
+# define BOOST_PP_REPEAT_1_88(m, d) BOOST_PP_REPEAT_1_87(m, d) m(2, 87, d)
+# define BOOST_PP_REPEAT_1_89(m, d) BOOST_PP_REPEAT_1_88(m, d) m(2, 88, d)
+# define BOOST_PP_REPEAT_1_90(m, d) BOOST_PP_REPEAT_1_89(m, d) m(2, 89, d)
+# define BOOST_PP_REPEAT_1_91(m, d) BOOST_PP_REPEAT_1_90(m, d) m(2, 90, d)
+# define BOOST_PP_REPEAT_1_92(m, d) BOOST_PP_REPEAT_1_91(m, d) m(2, 91, d)
+# define BOOST_PP_REPEAT_1_93(m, d) BOOST_PP_REPEAT_1_92(m, d) m(2, 92, d)
+# define BOOST_PP_REPEAT_1_94(m, d) BOOST_PP_REPEAT_1_93(m, d) m(2, 93, d)
+# define BOOST_PP_REPEAT_1_95(m, d) BOOST_PP_REPEAT_1_94(m, d) m(2, 94, d)
+# define BOOST_PP_REPEAT_1_96(m, d) BOOST_PP_REPEAT_1_95(m, d) m(2, 95, d)
+# define BOOST_PP_REPEAT_1_97(m, d) BOOST_PP_REPEAT_1_96(m, d) m(2, 96, d)
+# define BOOST_PP_REPEAT_1_98(m, d) BOOST_PP_REPEAT_1_97(m, d) m(2, 97, d)
+# define BOOST_PP_REPEAT_1_99(m, d) BOOST_PP_REPEAT_1_98(m, d) m(2, 98, d)
+# define BOOST_PP_REPEAT_1_100(m, d) BOOST_PP_REPEAT_1_99(m, d) m(2, 99, d)
+# define BOOST_PP_REPEAT_1_101(m, d) BOOST_PP_REPEAT_1_100(m, d) m(2, 100, d)
+# define BOOST_PP_REPEAT_1_102(m, d) BOOST_PP_REPEAT_1_101(m, d) m(2, 101, d)
+# define BOOST_PP_REPEAT_1_103(m, d) BOOST_PP_REPEAT_1_102(m, d) m(2, 102, d)
+# define BOOST_PP_REPEAT_1_104(m, d) BOOST_PP_REPEAT_1_103(m, d) m(2, 103, d)
+# define BOOST_PP_REPEAT_1_105(m, d) BOOST_PP_REPEAT_1_104(m, d) m(2, 104, d)
+# define BOOST_PP_REPEAT_1_106(m, d) BOOST_PP_REPEAT_1_105(m, d) m(2, 105, d)
+# define BOOST_PP_REPEAT_1_107(m, d) BOOST_PP_REPEAT_1_106(m, d) m(2, 106, d)
+# define BOOST_PP_REPEAT_1_108(m, d) BOOST_PP_REPEAT_1_107(m, d) m(2, 107, d)
+# define BOOST_PP_REPEAT_1_109(m, d) BOOST_PP_REPEAT_1_108(m, d) m(2, 108, d)
+# define BOOST_PP_REPEAT_1_110(m, d) BOOST_PP_REPEAT_1_109(m, d) m(2, 109, d)
+# define BOOST_PP_REPEAT_1_111(m, d) BOOST_PP_REPEAT_1_110(m, d) m(2, 110, d)
+# define BOOST_PP_REPEAT_1_112(m, d) BOOST_PP_REPEAT_1_111(m, d) m(2, 111, d)
+# define BOOST_PP_REPEAT_1_113(m, d) BOOST_PP_REPEAT_1_112(m, d) m(2, 112, d)
+# define BOOST_PP_REPEAT_1_114(m, d) BOOST_PP_REPEAT_1_113(m, d) m(2, 113, d)
+# define BOOST_PP_REPEAT_1_115(m, d) BOOST_PP_REPEAT_1_114(m, d) m(2, 114, d)
+# define BOOST_PP_REPEAT_1_116(m, d) BOOST_PP_REPEAT_1_115(m, d) m(2, 115, d)
+# define BOOST_PP_REPEAT_1_117(m, d) BOOST_PP_REPEAT_1_116(m, d) m(2, 116, d)
+# define BOOST_PP_REPEAT_1_118(m, d) BOOST_PP_REPEAT_1_117(m, d) m(2, 117, d)
+# define BOOST_PP_REPEAT_1_119(m, d) BOOST_PP_REPEAT_1_118(m, d) m(2, 118, d)
+# define BOOST_PP_REPEAT_1_120(m, d) BOOST_PP_REPEAT_1_119(m, d) m(2, 119, d)
+# define BOOST_PP_REPEAT_1_121(m, d) BOOST_PP_REPEAT_1_120(m, d) m(2, 120, d)
+# define BOOST_PP_REPEAT_1_122(m, d) BOOST_PP_REPEAT_1_121(m, d) m(2, 121, d)
+# define BOOST_PP_REPEAT_1_123(m, d) BOOST_PP_REPEAT_1_122(m, d) m(2, 122, d)
+# define BOOST_PP_REPEAT_1_124(m, d) BOOST_PP_REPEAT_1_123(m, d) m(2, 123, d)
+# define BOOST_PP_REPEAT_1_125(m, d) BOOST_PP_REPEAT_1_124(m, d) m(2, 124, d)
+# define BOOST_PP_REPEAT_1_126(m, d) BOOST_PP_REPEAT_1_125(m, d) m(2, 125, d)
+# define BOOST_PP_REPEAT_1_127(m, d) BOOST_PP_REPEAT_1_126(m, d) m(2, 126, d)
+# define BOOST_PP_REPEAT_1_128(m, d) BOOST_PP_REPEAT_1_127(m, d) m(2, 127, d)
+# define BOOST_PP_REPEAT_1_129(m, d) BOOST_PP_REPEAT_1_128(m, d) m(2, 128, d)
+# define BOOST_PP_REPEAT_1_130(m, d) BOOST_PP_REPEAT_1_129(m, d) m(2, 129, d)
+# define BOOST_PP_REPEAT_1_131(m, d) BOOST_PP_REPEAT_1_130(m, d) m(2, 130, d)
+# define BOOST_PP_REPEAT_1_132(m, d) BOOST_PP_REPEAT_1_131(m, d) m(2, 131, d)
+# define BOOST_PP_REPEAT_1_133(m, d) BOOST_PP_REPEAT_1_132(m, d) m(2, 132, d)
+# define BOOST_PP_REPEAT_1_134(m, d) BOOST_PP_REPEAT_1_133(m, d) m(2, 133, d)
+# define BOOST_PP_REPEAT_1_135(m, d) BOOST_PP_REPEAT_1_134(m, d) m(2, 134, d)
+# define BOOST_PP_REPEAT_1_136(m, d) BOOST_PP_REPEAT_1_135(m, d) m(2, 135, d)
+# define BOOST_PP_REPEAT_1_137(m, d) BOOST_PP_REPEAT_1_136(m, d) m(2, 136, d)
+# define BOOST_PP_REPEAT_1_138(m, d) BOOST_PP_REPEAT_1_137(m, d) m(2, 137, d)
+# define BOOST_PP_REPEAT_1_139(m, d) BOOST_PP_REPEAT_1_138(m, d) m(2, 138, d)
+# define BOOST_PP_REPEAT_1_140(m, d) BOOST_PP_REPEAT_1_139(m, d) m(2, 139, d)
+# define BOOST_PP_REPEAT_1_141(m, d) BOOST_PP_REPEAT_1_140(m, d) m(2, 140, d)
+# define BOOST_PP_REPEAT_1_142(m, d) BOOST_PP_REPEAT_1_141(m, d) m(2, 141, d)
+# define BOOST_PP_REPEAT_1_143(m, d) BOOST_PP_REPEAT_1_142(m, d) m(2, 142, d)
+# define BOOST_PP_REPEAT_1_144(m, d) BOOST_PP_REPEAT_1_143(m, d) m(2, 143, d)
+# define BOOST_PP_REPEAT_1_145(m, d) BOOST_PP_REPEAT_1_144(m, d) m(2, 144, d)
+# define BOOST_PP_REPEAT_1_146(m, d) BOOST_PP_REPEAT_1_145(m, d) m(2, 145, d)
+# define BOOST_PP_REPEAT_1_147(m, d) BOOST_PP_REPEAT_1_146(m, d) m(2, 146, d)
+# define BOOST_PP_REPEAT_1_148(m, d) BOOST_PP_REPEAT_1_147(m, d) m(2, 147, d)
+# define BOOST_PP_REPEAT_1_149(m, d) BOOST_PP_REPEAT_1_148(m, d) m(2, 148, d)
+# define BOOST_PP_REPEAT_1_150(m, d) BOOST_PP_REPEAT_1_149(m, d) m(2, 149, d)
+# define BOOST_PP_REPEAT_1_151(m, d) BOOST_PP_REPEAT_1_150(m, d) m(2, 150, d)
+# define BOOST_PP_REPEAT_1_152(m, d) BOOST_PP_REPEAT_1_151(m, d) m(2, 151, d)
+# define BOOST_PP_REPEAT_1_153(m, d) BOOST_PP_REPEAT_1_152(m, d) m(2, 152, d)
+# define BOOST_PP_REPEAT_1_154(m, d) BOOST_PP_REPEAT_1_153(m, d) m(2, 153, d)
+# define BOOST_PP_REPEAT_1_155(m, d) BOOST_PP_REPEAT_1_154(m, d) m(2, 154, d)
+# define BOOST_PP_REPEAT_1_156(m, d) BOOST_PP_REPEAT_1_155(m, d) m(2, 155, d)
+# define BOOST_PP_REPEAT_1_157(m, d) BOOST_PP_REPEAT_1_156(m, d) m(2, 156, d)
+# define BOOST_PP_REPEAT_1_158(m, d) BOOST_PP_REPEAT_1_157(m, d) m(2, 157, d)
+# define BOOST_PP_REPEAT_1_159(m, d) BOOST_PP_REPEAT_1_158(m, d) m(2, 158, d)
+# define BOOST_PP_REPEAT_1_160(m, d) BOOST_PP_REPEAT_1_159(m, d) m(2, 159, d)
+# define BOOST_PP_REPEAT_1_161(m, d) BOOST_PP_REPEAT_1_160(m, d) m(2, 160, d)
+# define BOOST_PP_REPEAT_1_162(m, d) BOOST_PP_REPEAT_1_161(m, d) m(2, 161, d)
+# define BOOST_PP_REPEAT_1_163(m, d) BOOST_PP_REPEAT_1_162(m, d) m(2, 162, d)
+# define BOOST_PP_REPEAT_1_164(m, d) BOOST_PP_REPEAT_1_163(m, d) m(2, 163, d)
+# define BOOST_PP_REPEAT_1_165(m, d) BOOST_PP_REPEAT_1_164(m, d) m(2, 164, d)
+# define BOOST_PP_REPEAT_1_166(m, d) BOOST_PP_REPEAT_1_165(m, d) m(2, 165, d)
+# define BOOST_PP_REPEAT_1_167(m, d) BOOST_PP_REPEAT_1_166(m, d) m(2, 166, d)
+# define BOOST_PP_REPEAT_1_168(m, d) BOOST_PP_REPEAT_1_167(m, d) m(2, 167, d)
+# define BOOST_PP_REPEAT_1_169(m, d) BOOST_PP_REPEAT_1_168(m, d) m(2, 168, d)
+# define BOOST_PP_REPEAT_1_170(m, d) BOOST_PP_REPEAT_1_169(m, d) m(2, 169, d)
+# define BOOST_PP_REPEAT_1_171(m, d) BOOST_PP_REPEAT_1_170(m, d) m(2, 170, d)
+# define BOOST_PP_REPEAT_1_172(m, d) BOOST_PP_REPEAT_1_171(m, d) m(2, 171, d)
+# define BOOST_PP_REPEAT_1_173(m, d) BOOST_PP_REPEAT_1_172(m, d) m(2, 172, d)
+# define BOOST_PP_REPEAT_1_174(m, d) BOOST_PP_REPEAT_1_173(m, d) m(2, 173, d)
+# define BOOST_PP_REPEAT_1_175(m, d) BOOST_PP_REPEAT_1_174(m, d) m(2, 174, d)
+# define BOOST_PP_REPEAT_1_176(m, d) BOOST_PP_REPEAT_1_175(m, d) m(2, 175, d)
+# define BOOST_PP_REPEAT_1_177(m, d) BOOST_PP_REPEAT_1_176(m, d) m(2, 176, d)
+# define BOOST_PP_REPEAT_1_178(m, d) BOOST_PP_REPEAT_1_177(m, d) m(2, 177, d)
+# define BOOST_PP_REPEAT_1_179(m, d) BOOST_PP_REPEAT_1_178(m, d) m(2, 178, d)
+# define BOOST_PP_REPEAT_1_180(m, d) BOOST_PP_REPEAT_1_179(m, d) m(2, 179, d)
+# define BOOST_PP_REPEAT_1_181(m, d) BOOST_PP_REPEAT_1_180(m, d) m(2, 180, d)
+# define BOOST_PP_REPEAT_1_182(m, d) BOOST_PP_REPEAT_1_181(m, d) m(2, 181, d)
+# define BOOST_PP_REPEAT_1_183(m, d) BOOST_PP_REPEAT_1_182(m, d) m(2, 182, d)
+# define BOOST_PP_REPEAT_1_184(m, d) BOOST_PP_REPEAT_1_183(m, d) m(2, 183, d)
+# define BOOST_PP_REPEAT_1_185(m, d) BOOST_PP_REPEAT_1_184(m, d) m(2, 184, d)
+# define BOOST_PP_REPEAT_1_186(m, d) BOOST_PP_REPEAT_1_185(m, d) m(2, 185, d)
+# define BOOST_PP_REPEAT_1_187(m, d) BOOST_PP_REPEAT_1_186(m, d) m(2, 186, d)
+# define BOOST_PP_REPEAT_1_188(m, d) BOOST_PP_REPEAT_1_187(m, d) m(2, 187, d)
+# define BOOST_PP_REPEAT_1_189(m, d) BOOST_PP_REPEAT_1_188(m, d) m(2, 188, d)
+# define BOOST_PP_REPEAT_1_190(m, d) BOOST_PP_REPEAT_1_189(m, d) m(2, 189, d)
+# define BOOST_PP_REPEAT_1_191(m, d) BOOST_PP_REPEAT_1_190(m, d) m(2, 190, d)
+# define BOOST_PP_REPEAT_1_192(m, d) BOOST_PP_REPEAT_1_191(m, d) m(2, 191, d)
+# define BOOST_PP_REPEAT_1_193(m, d) BOOST_PP_REPEAT_1_192(m, d) m(2, 192, d)
+# define BOOST_PP_REPEAT_1_194(m, d) BOOST_PP_REPEAT_1_193(m, d) m(2, 193, d)
+# define BOOST_PP_REPEAT_1_195(m, d) BOOST_PP_REPEAT_1_194(m, d) m(2, 194, d)
+# define BOOST_PP_REPEAT_1_196(m, d) BOOST_PP_REPEAT_1_195(m, d) m(2, 195, d)
+# define BOOST_PP_REPEAT_1_197(m, d) BOOST_PP_REPEAT_1_196(m, d) m(2, 196, d)
+# define BOOST_PP_REPEAT_1_198(m, d) BOOST_PP_REPEAT_1_197(m, d) m(2, 197, d)
+# define BOOST_PP_REPEAT_1_199(m, d) BOOST_PP_REPEAT_1_198(m, d) m(2, 198, d)
+# define BOOST_PP_REPEAT_1_200(m, d) BOOST_PP_REPEAT_1_199(m, d) m(2, 199, d)
+# define BOOST_PP_REPEAT_1_201(m, d) BOOST_PP_REPEAT_1_200(m, d) m(2, 200, d)
+# define BOOST_PP_REPEAT_1_202(m, d) BOOST_PP_REPEAT_1_201(m, d) m(2, 201, d)
+# define BOOST_PP_REPEAT_1_203(m, d) BOOST_PP_REPEAT_1_202(m, d) m(2, 202, d)
+# define BOOST_PP_REPEAT_1_204(m, d) BOOST_PP_REPEAT_1_203(m, d) m(2, 203, d)
+# define BOOST_PP_REPEAT_1_205(m, d) BOOST_PP_REPEAT_1_204(m, d) m(2, 204, d)
+# define BOOST_PP_REPEAT_1_206(m, d) BOOST_PP_REPEAT_1_205(m, d) m(2, 205, d)
+# define BOOST_PP_REPEAT_1_207(m, d) BOOST_PP_REPEAT_1_206(m, d) m(2, 206, d)
+# define BOOST_PP_REPEAT_1_208(m, d) BOOST_PP_REPEAT_1_207(m, d) m(2, 207, d)
+# define BOOST_PP_REPEAT_1_209(m, d) BOOST_PP_REPEAT_1_208(m, d) m(2, 208, d)
+# define BOOST_PP_REPEAT_1_210(m, d) BOOST_PP_REPEAT_1_209(m, d) m(2, 209, d)
+# define BOOST_PP_REPEAT_1_211(m, d) BOOST_PP_REPEAT_1_210(m, d) m(2, 210, d)
+# define BOOST_PP_REPEAT_1_212(m, d) BOOST_PP_REPEAT_1_211(m, d) m(2, 211, d)
+# define BOOST_PP_REPEAT_1_213(m, d) BOOST_PP_REPEAT_1_212(m, d) m(2, 212, d)
+# define BOOST_PP_REPEAT_1_214(m, d) BOOST_PP_REPEAT_1_213(m, d) m(2, 213, d)
+# define BOOST_PP_REPEAT_1_215(m, d) BOOST_PP_REPEAT_1_214(m, d) m(2, 214, d)
+# define BOOST_PP_REPEAT_1_216(m, d) BOOST_PP_REPEAT_1_215(m, d) m(2, 215, d)
+# define BOOST_PP_REPEAT_1_217(m, d) BOOST_PP_REPEAT_1_216(m, d) m(2, 216, d)
+# define BOOST_PP_REPEAT_1_218(m, d) BOOST_PP_REPEAT_1_217(m, d) m(2, 217, d)
+# define BOOST_PP_REPEAT_1_219(m, d) BOOST_PP_REPEAT_1_218(m, d) m(2, 218, d)
+# define BOOST_PP_REPEAT_1_220(m, d) BOOST_PP_REPEAT_1_219(m, d) m(2, 219, d)
+# define BOOST_PP_REPEAT_1_221(m, d) BOOST_PP_REPEAT_1_220(m, d) m(2, 220, d)
+# define BOOST_PP_REPEAT_1_222(m, d) BOOST_PP_REPEAT_1_221(m, d) m(2, 221, d)
+# define BOOST_PP_REPEAT_1_223(m, d) BOOST_PP_REPEAT_1_222(m, d) m(2, 222, d)
+# define BOOST_PP_REPEAT_1_224(m, d) BOOST_PP_REPEAT_1_223(m, d) m(2, 223, d)
+# define BOOST_PP_REPEAT_1_225(m, d) BOOST_PP_REPEAT_1_224(m, d) m(2, 224, d)
+# define BOOST_PP_REPEAT_1_226(m, d) BOOST_PP_REPEAT_1_225(m, d) m(2, 225, d)
+# define BOOST_PP_REPEAT_1_227(m, d) BOOST_PP_REPEAT_1_226(m, d) m(2, 226, d)
+# define BOOST_PP_REPEAT_1_228(m, d) BOOST_PP_REPEAT_1_227(m, d) m(2, 227, d)
+# define BOOST_PP_REPEAT_1_229(m, d) BOOST_PP_REPEAT_1_228(m, d) m(2, 228, d)
+# define BOOST_PP_REPEAT_1_230(m, d) BOOST_PP_REPEAT_1_229(m, d) m(2, 229, d)
+# define BOOST_PP_REPEAT_1_231(m, d) BOOST_PP_REPEAT_1_230(m, d) m(2, 230, d)
+# define BOOST_PP_REPEAT_1_232(m, d) BOOST_PP_REPEAT_1_231(m, d) m(2, 231, d)
+# define BOOST_PP_REPEAT_1_233(m, d) BOOST_PP_REPEAT_1_232(m, d) m(2, 232, d)
+# define BOOST_PP_REPEAT_1_234(m, d) BOOST_PP_REPEAT_1_233(m, d) m(2, 233, d)
+# define BOOST_PP_REPEAT_1_235(m, d) BOOST_PP_REPEAT_1_234(m, d) m(2, 234, d)
+# define BOOST_PP_REPEAT_1_236(m, d) BOOST_PP_REPEAT_1_235(m, d) m(2, 235, d)
+# define BOOST_PP_REPEAT_1_237(m, d) BOOST_PP_REPEAT_1_236(m, d) m(2, 236, d)
+# define BOOST_PP_REPEAT_1_238(m, d) BOOST_PP_REPEAT_1_237(m, d) m(2, 237, d)
+# define BOOST_PP_REPEAT_1_239(m, d) BOOST_PP_REPEAT_1_238(m, d) m(2, 238, d)
+# define BOOST_PP_REPEAT_1_240(m, d) BOOST_PP_REPEAT_1_239(m, d) m(2, 239, d)
+# define BOOST_PP_REPEAT_1_241(m, d) BOOST_PP_REPEAT_1_240(m, d) m(2, 240, d)
+# define BOOST_PP_REPEAT_1_242(m, d) BOOST_PP_REPEAT_1_241(m, d) m(2, 241, d)
+# define BOOST_PP_REPEAT_1_243(m, d) BOOST_PP_REPEAT_1_242(m, d) m(2, 242, d)
+# define BOOST_PP_REPEAT_1_244(m, d) BOOST_PP_REPEAT_1_243(m, d) m(2, 243, d)
+# define BOOST_PP_REPEAT_1_245(m, d) BOOST_PP_REPEAT_1_244(m, d) m(2, 244, d)
+# define BOOST_PP_REPEAT_1_246(m, d) BOOST_PP_REPEAT_1_245(m, d) m(2, 245, d)
+# define BOOST_PP_REPEAT_1_247(m, d) BOOST_PP_REPEAT_1_246(m, d) m(2, 246, d)
+# define BOOST_PP_REPEAT_1_248(m, d) BOOST_PP_REPEAT_1_247(m, d) m(2, 247, d)
+# define BOOST_PP_REPEAT_1_249(m, d) BOOST_PP_REPEAT_1_248(m, d) m(2, 248, d)
+# define BOOST_PP_REPEAT_1_250(m, d) BOOST_PP_REPEAT_1_249(m, d) m(2, 249, d)
+# define BOOST_PP_REPEAT_1_251(m, d) BOOST_PP_REPEAT_1_250(m, d) m(2, 250, d)
+# define BOOST_PP_REPEAT_1_252(m, d) BOOST_PP_REPEAT_1_251(m, d) m(2, 251, d)
+# define BOOST_PP_REPEAT_1_253(m, d) BOOST_PP_REPEAT_1_252(m, d) m(2, 252, d)
+# define BOOST_PP_REPEAT_1_254(m, d) BOOST_PP_REPEAT_1_253(m, d) m(2, 253, d)
+# define BOOST_PP_REPEAT_1_255(m, d) BOOST_PP_REPEAT_1_254(m, d) m(2, 254, d)
+# define BOOST_PP_REPEAT_1_256(m, d) BOOST_PP_REPEAT_1_255(m, d) m(2, 255, d)
+#
+# define BOOST_PP_REPEAT_2_0(m, d)
+# define BOOST_PP_REPEAT_2_1(m, d) m(3, 0, d)
+# define BOOST_PP_REPEAT_2_2(m, d) BOOST_PP_REPEAT_2_1(m, d) m(3, 1, d)
+# define BOOST_PP_REPEAT_2_3(m, d) BOOST_PP_REPEAT_2_2(m, d) m(3, 2, d)
+# define BOOST_PP_REPEAT_2_4(m, d) BOOST_PP_REPEAT_2_3(m, d) m(3, 3, d)
+# define BOOST_PP_REPEAT_2_5(m, d) BOOST_PP_REPEAT_2_4(m, d) m(3, 4, d)
+# define BOOST_PP_REPEAT_2_6(m, d) BOOST_PP_REPEAT_2_5(m, d) m(3, 5, d)
+# define BOOST_PP_REPEAT_2_7(m, d) BOOST_PP_REPEAT_2_6(m, d) m(3, 6, d)
+# define BOOST_PP_REPEAT_2_8(m, d) BOOST_PP_REPEAT_2_7(m, d) m(3, 7, d)
+# define BOOST_PP_REPEAT_2_9(m, d) BOOST_PP_REPEAT_2_8(m, d) m(3, 8, d)
+# define BOOST_PP_REPEAT_2_10(m, d) BOOST_PP_REPEAT_2_9(m, d) m(3, 9, d)
+# define BOOST_PP_REPEAT_2_11(m, d) BOOST_PP_REPEAT_2_10(m, d) m(3, 10, d)
+# define BOOST_PP_REPEAT_2_12(m, d) BOOST_PP_REPEAT_2_11(m, d) m(3, 11, d)
+# define BOOST_PP_REPEAT_2_13(m, d) BOOST_PP_REPEAT_2_12(m, d) m(3, 12, d)
+# define BOOST_PP_REPEAT_2_14(m, d) BOOST_PP_REPEAT_2_13(m, d) m(3, 13, d)
+# define BOOST_PP_REPEAT_2_15(m, d) BOOST_PP_REPEAT_2_14(m, d) m(3, 14, d)
+# define BOOST_PP_REPEAT_2_16(m, d) BOOST_PP_REPEAT_2_15(m, d) m(3, 15, d)
+# define BOOST_PP_REPEAT_2_17(m, d) BOOST_PP_REPEAT_2_16(m, d) m(3, 16, d)
+# define BOOST_PP_REPEAT_2_18(m, d) BOOST_PP_REPEAT_2_17(m, d) m(3, 17, d)
+# define BOOST_PP_REPEAT_2_19(m, d) BOOST_PP_REPEAT_2_18(m, d) m(3, 18, d)
+# define BOOST_PP_REPEAT_2_20(m, d) BOOST_PP_REPEAT_2_19(m, d) m(3, 19, d)
+# define BOOST_PP_REPEAT_2_21(m, d) BOOST_PP_REPEAT_2_20(m, d) m(3, 20, d)
+# define BOOST_PP_REPEAT_2_22(m, d) BOOST_PP_REPEAT_2_21(m, d) m(3, 21, d)
+# define BOOST_PP_REPEAT_2_23(m, d) BOOST_PP_REPEAT_2_22(m, d) m(3, 22, d)
+# define BOOST_PP_REPEAT_2_24(m, d) BOOST_PP_REPEAT_2_23(m, d) m(3, 23, d)
+# define BOOST_PP_REPEAT_2_25(m, d) BOOST_PP_REPEAT_2_24(m, d) m(3, 24, d)
+# define BOOST_PP_REPEAT_2_26(m, d) BOOST_PP_REPEAT_2_25(m, d) m(3, 25, d)
+# define BOOST_PP_REPEAT_2_27(m, d) BOOST_PP_REPEAT_2_26(m, d) m(3, 26, d)
+# define BOOST_PP_REPEAT_2_28(m, d) BOOST_PP_REPEAT_2_27(m, d) m(3, 27, d)
+# define BOOST_PP_REPEAT_2_29(m, d) BOOST_PP_REPEAT_2_28(m, d) m(3, 28, d)
+# define BOOST_PP_REPEAT_2_30(m, d) BOOST_PP_REPEAT_2_29(m, d) m(3, 29, d)
+# define BOOST_PP_REPEAT_2_31(m, d) BOOST_PP_REPEAT_2_30(m, d) m(3, 30, d)
+# define BOOST_PP_REPEAT_2_32(m, d) BOOST_PP_REPEAT_2_31(m, d) m(3, 31, d)
+# define BOOST_PP_REPEAT_2_33(m, d) BOOST_PP_REPEAT_2_32(m, d) m(3, 32, d)
+# define BOOST_PP_REPEAT_2_34(m, d) BOOST_PP_REPEAT_2_33(m, d) m(3, 33, d)
+# define BOOST_PP_REPEAT_2_35(m, d) BOOST_PP_REPEAT_2_34(m, d) m(3, 34, d)
+# define BOOST_PP_REPEAT_2_36(m, d) BOOST_PP_REPEAT_2_35(m, d) m(3, 35, d)
+# define BOOST_PP_REPEAT_2_37(m, d) BOOST_PP_REPEAT_2_36(m, d) m(3, 36, d)
+# define BOOST_PP_REPEAT_2_38(m, d) BOOST_PP_REPEAT_2_37(m, d) m(3, 37, d)
+# define BOOST_PP_REPEAT_2_39(m, d) BOOST_PP_REPEAT_2_38(m, d) m(3, 38, d)
+# define BOOST_PP_REPEAT_2_40(m, d) BOOST_PP_REPEAT_2_39(m, d) m(3, 39, d)
+# define BOOST_PP_REPEAT_2_41(m, d) BOOST_PP_REPEAT_2_40(m, d) m(3, 40, d)
+# define BOOST_PP_REPEAT_2_42(m, d) BOOST_PP_REPEAT_2_41(m, d) m(3, 41, d)
+# define BOOST_PP_REPEAT_2_43(m, d) BOOST_PP_REPEAT_2_42(m, d) m(3, 42, d)
+# define BOOST_PP_REPEAT_2_44(m, d) BOOST_PP_REPEAT_2_43(m, d) m(3, 43, d)
+# define BOOST_PP_REPEAT_2_45(m, d) BOOST_PP_REPEAT_2_44(m, d) m(3, 44, d)
+# define BOOST_PP_REPEAT_2_46(m, d) BOOST_PP_REPEAT_2_45(m, d) m(3, 45, d)
+# define BOOST_PP_REPEAT_2_47(m, d) BOOST_PP_REPEAT_2_46(m, d) m(3, 46, d)
+# define BOOST_PP_REPEAT_2_48(m, d) BOOST_PP_REPEAT_2_47(m, d) m(3, 47, d)
+# define BOOST_PP_REPEAT_2_49(m, d) BOOST_PP_REPEAT_2_48(m, d) m(3, 48, d)
+# define BOOST_PP_REPEAT_2_50(m, d) BOOST_PP_REPEAT_2_49(m, d) m(3, 49, d)
+# define BOOST_PP_REPEAT_2_51(m, d) BOOST_PP_REPEAT_2_50(m, d) m(3, 50, d)
+# define BOOST_PP_REPEAT_2_52(m, d) BOOST_PP_REPEAT_2_51(m, d) m(3, 51, d)
+# define BOOST_PP_REPEAT_2_53(m, d) BOOST_PP_REPEAT_2_52(m, d) m(3, 52, d)
+# define BOOST_PP_REPEAT_2_54(m, d) BOOST_PP_REPEAT_2_53(m, d) m(3, 53, d)
+# define BOOST_PP_REPEAT_2_55(m, d) BOOST_PP_REPEAT_2_54(m, d) m(3, 54, d)
+# define BOOST_PP_REPEAT_2_56(m, d) BOOST_PP_REPEAT_2_55(m, d) m(3, 55, d)
+# define BOOST_PP_REPEAT_2_57(m, d) BOOST_PP_REPEAT_2_56(m, d) m(3, 56, d)
+# define BOOST_PP_REPEAT_2_58(m, d) BOOST_PP_REPEAT_2_57(m, d) m(3, 57, d)
+# define BOOST_PP_REPEAT_2_59(m, d) BOOST_PP_REPEAT_2_58(m, d) m(3, 58, d)
+# define BOOST_PP_REPEAT_2_60(m, d) BOOST_PP_REPEAT_2_59(m, d) m(3, 59, d)
+# define BOOST_PP_REPEAT_2_61(m, d) BOOST_PP_REPEAT_2_60(m, d) m(3, 60, d)
+# define BOOST_PP_REPEAT_2_62(m, d) BOOST_PP_REPEAT_2_61(m, d) m(3, 61, d)
+# define BOOST_PP_REPEAT_2_63(m, d) BOOST_PP_REPEAT_2_62(m, d) m(3, 62, d)
+# define BOOST_PP_REPEAT_2_64(m, d) BOOST_PP_REPEAT_2_63(m, d) m(3, 63, d)
+# define BOOST_PP_REPEAT_2_65(m, d) BOOST_PP_REPEAT_2_64(m, d) m(3, 64, d)
+# define BOOST_PP_REPEAT_2_66(m, d) BOOST_PP_REPEAT_2_65(m, d) m(3, 65, d)
+# define BOOST_PP_REPEAT_2_67(m, d) BOOST_PP_REPEAT_2_66(m, d) m(3, 66, d)
+# define BOOST_PP_REPEAT_2_68(m, d) BOOST_PP_REPEAT_2_67(m, d) m(3, 67, d)
+# define BOOST_PP_REPEAT_2_69(m, d) BOOST_PP_REPEAT_2_68(m, d) m(3, 68, d)
+# define BOOST_PP_REPEAT_2_70(m, d) BOOST_PP_REPEAT_2_69(m, d) m(3, 69, d)
+# define BOOST_PP_REPEAT_2_71(m, d) BOOST_PP_REPEAT_2_70(m, d) m(3, 70, d)
+# define BOOST_PP_REPEAT_2_72(m, d) BOOST_PP_REPEAT_2_71(m, d) m(3, 71, d)
+# define BOOST_PP_REPEAT_2_73(m, d) BOOST_PP_REPEAT_2_72(m, d) m(3, 72, d)
+# define BOOST_PP_REPEAT_2_74(m, d) BOOST_PP_REPEAT_2_73(m, d) m(3, 73, d)
+# define BOOST_PP_REPEAT_2_75(m, d) BOOST_PP_REPEAT_2_74(m, d) m(3, 74, d)
+# define BOOST_PP_REPEAT_2_76(m, d) BOOST_PP_REPEAT_2_75(m, d) m(3, 75, d)
+# define BOOST_PP_REPEAT_2_77(m, d) BOOST_PP_REPEAT_2_76(m, d) m(3, 76, d)
+# define BOOST_PP_REPEAT_2_78(m, d) BOOST_PP_REPEAT_2_77(m, d) m(3, 77, d)
+# define BOOST_PP_REPEAT_2_79(m, d) BOOST_PP_REPEAT_2_78(m, d) m(3, 78, d)
+# define BOOST_PP_REPEAT_2_80(m, d) BOOST_PP_REPEAT_2_79(m, d) m(3, 79, d)
+# define BOOST_PP_REPEAT_2_81(m, d) BOOST_PP_REPEAT_2_80(m, d) m(3, 80, d)
+# define BOOST_PP_REPEAT_2_82(m, d) BOOST_PP_REPEAT_2_81(m, d) m(3, 81, d)
+# define BOOST_PP_REPEAT_2_83(m, d) BOOST_PP_REPEAT_2_82(m, d) m(3, 82, d)
+# define BOOST_PP_REPEAT_2_84(m, d) BOOST_PP_REPEAT_2_83(m, d) m(3, 83, d)
+# define BOOST_PP_REPEAT_2_85(m, d) BOOST_PP_REPEAT_2_84(m, d) m(3, 84, d)
+# define BOOST_PP_REPEAT_2_86(m, d) BOOST_PP_REPEAT_2_85(m, d) m(3, 85, d)
+# define BOOST_PP_REPEAT_2_87(m, d) BOOST_PP_REPEAT_2_86(m, d) m(3, 86, d)
+# define BOOST_PP_REPEAT_2_88(m, d) BOOST_PP_REPEAT_2_87(m, d) m(3, 87, d)
+# define BOOST_PP_REPEAT_2_89(m, d) BOOST_PP_REPEAT_2_88(m, d) m(3, 88, d)
+# define BOOST_PP_REPEAT_2_90(m, d) BOOST_PP_REPEAT_2_89(m, d) m(3, 89, d)
+# define BOOST_PP_REPEAT_2_91(m, d) BOOST_PP_REPEAT_2_90(m, d) m(3, 90, d)
+# define BOOST_PP_REPEAT_2_92(m, d) BOOST_PP_REPEAT_2_91(m, d) m(3, 91, d)
+# define BOOST_PP_REPEAT_2_93(m, d) BOOST_PP_REPEAT_2_92(m, d) m(3, 92, d)
+# define BOOST_PP_REPEAT_2_94(m, d) BOOST_PP_REPEAT_2_93(m, d) m(3, 93, d)
+# define BOOST_PP_REPEAT_2_95(m, d) BOOST_PP_REPEAT_2_94(m, d) m(3, 94, d)
+# define BOOST_PP_REPEAT_2_96(m, d) BOOST_PP_REPEAT_2_95(m, d) m(3, 95, d)
+# define BOOST_PP_REPEAT_2_97(m, d) BOOST_PP_REPEAT_2_96(m, d) m(3, 96, d)
+# define BOOST_PP_REPEAT_2_98(m, d) BOOST_PP_REPEAT_2_97(m, d) m(3, 97, d)
+# define BOOST_PP_REPEAT_2_99(m, d) BOOST_PP_REPEAT_2_98(m, d) m(3, 98, d)
+# define BOOST_PP_REPEAT_2_100(m, d) BOOST_PP_REPEAT_2_99(m, d) m(3, 99, d)
+# define BOOST_PP_REPEAT_2_101(m, d) BOOST_PP_REPEAT_2_100(m, d) m(3, 100, d)
+# define BOOST_PP_REPEAT_2_102(m, d) BOOST_PP_REPEAT_2_101(m, d) m(3, 101, d)
+# define BOOST_PP_REPEAT_2_103(m, d) BOOST_PP_REPEAT_2_102(m, d) m(3, 102, d)
+# define BOOST_PP_REPEAT_2_104(m, d) BOOST_PP_REPEAT_2_103(m, d) m(3, 103, d)
+# define BOOST_PP_REPEAT_2_105(m, d) BOOST_PP_REPEAT_2_104(m, d) m(3, 104, d)
+# define BOOST_PP_REPEAT_2_106(m, d) BOOST_PP_REPEAT_2_105(m, d) m(3, 105, d)
+# define BOOST_PP_REPEAT_2_107(m, d) BOOST_PP_REPEAT_2_106(m, d) m(3, 106, d)
+# define BOOST_PP_REPEAT_2_108(m, d) BOOST_PP_REPEAT_2_107(m, d) m(3, 107, d)
+# define BOOST_PP_REPEAT_2_109(m, d) BOOST_PP_REPEAT_2_108(m, d) m(3, 108, d)
+# define BOOST_PP_REPEAT_2_110(m, d) BOOST_PP_REPEAT_2_109(m, d) m(3, 109, d)
+# define BOOST_PP_REPEAT_2_111(m, d) BOOST_PP_REPEAT_2_110(m, d) m(3, 110, d)
+# define BOOST_PP_REPEAT_2_112(m, d) BOOST_PP_REPEAT_2_111(m, d) m(3, 111, d)
+# define BOOST_PP_REPEAT_2_113(m, d) BOOST_PP_REPEAT_2_112(m, d) m(3, 112, d)
+# define BOOST_PP_REPEAT_2_114(m, d) BOOST_PP_REPEAT_2_113(m, d) m(3, 113, d)
+# define BOOST_PP_REPEAT_2_115(m, d) BOOST_PP_REPEAT_2_114(m, d) m(3, 114, d)
+# define BOOST_PP_REPEAT_2_116(m, d) BOOST_PP_REPEAT_2_115(m, d) m(3, 115, d)
+# define BOOST_PP_REPEAT_2_117(m, d) BOOST_PP_REPEAT_2_116(m, d) m(3, 116, d)
+# define BOOST_PP_REPEAT_2_118(m, d) BOOST_PP_REPEAT_2_117(m, d) m(3, 117, d)
+# define BOOST_PP_REPEAT_2_119(m, d) BOOST_PP_REPEAT_2_118(m, d) m(3, 118, d)
+# define BOOST_PP_REPEAT_2_120(m, d) BOOST_PP_REPEAT_2_119(m, d) m(3, 119, d)
+# define BOOST_PP_REPEAT_2_121(m, d) BOOST_PP_REPEAT_2_120(m, d) m(3, 120, d)
+# define BOOST_PP_REPEAT_2_122(m, d) BOOST_PP_REPEAT_2_121(m, d) m(3, 121, d)
+# define BOOST_PP_REPEAT_2_123(m, d) BOOST_PP_REPEAT_2_122(m, d) m(3, 122, d)
+# define BOOST_PP_REPEAT_2_124(m, d) BOOST_PP_REPEAT_2_123(m, d) m(3, 123, d)
+# define BOOST_PP_REPEAT_2_125(m, d) BOOST_PP_REPEAT_2_124(m, d) m(3, 124, d)
+# define BOOST_PP_REPEAT_2_126(m, d) BOOST_PP_REPEAT_2_125(m, d) m(3, 125, d)
+# define BOOST_PP_REPEAT_2_127(m, d) BOOST_PP_REPEAT_2_126(m, d) m(3, 126, d)
+# define BOOST_PP_REPEAT_2_128(m, d) BOOST_PP_REPEAT_2_127(m, d) m(3, 127, d)
+# define BOOST_PP_REPEAT_2_129(m, d) BOOST_PP_REPEAT_2_128(m, d) m(3, 128, d)
+# define BOOST_PP_REPEAT_2_130(m, d) BOOST_PP_REPEAT_2_129(m, d) m(3, 129, d)
+# define BOOST_PP_REPEAT_2_131(m, d) BOOST_PP_REPEAT_2_130(m, d) m(3, 130, d)
+# define BOOST_PP_REPEAT_2_132(m, d) BOOST_PP_REPEAT_2_131(m, d) m(3, 131, d)
+# define BOOST_PP_REPEAT_2_133(m, d) BOOST_PP_REPEAT_2_132(m, d) m(3, 132, d)
+# define BOOST_PP_REPEAT_2_134(m, d) BOOST_PP_REPEAT_2_133(m, d) m(3, 133, d)
+# define BOOST_PP_REPEAT_2_135(m, d) BOOST_PP_REPEAT_2_134(m, d) m(3, 134, d)
+# define BOOST_PP_REPEAT_2_136(m, d) BOOST_PP_REPEAT_2_135(m, d) m(3, 135, d)
+# define BOOST_PP_REPEAT_2_137(m, d) BOOST_PP_REPEAT_2_136(m, d) m(3, 136, d)
+# define BOOST_PP_REPEAT_2_138(m, d) BOOST_PP_REPEAT_2_137(m, d) m(3, 137, d)
+# define BOOST_PP_REPEAT_2_139(m, d) BOOST_PP_REPEAT_2_138(m, d) m(3, 138, d)
+# define BOOST_PP_REPEAT_2_140(m, d) BOOST_PP_REPEAT_2_139(m, d) m(3, 139, d)
+# define BOOST_PP_REPEAT_2_141(m, d) BOOST_PP_REPEAT_2_140(m, d) m(3, 140, d)
+# define BOOST_PP_REPEAT_2_142(m, d) BOOST_PP_REPEAT_2_141(m, d) m(3, 141, d)
+# define BOOST_PP_REPEAT_2_143(m, d) BOOST_PP_REPEAT_2_142(m, d) m(3, 142, d)
+# define BOOST_PP_REPEAT_2_144(m, d) BOOST_PP_REPEAT_2_143(m, d) m(3, 143, d)
+# define BOOST_PP_REPEAT_2_145(m, d) BOOST_PP_REPEAT_2_144(m, d) m(3, 144, d)
+# define BOOST_PP_REPEAT_2_146(m, d) BOOST_PP_REPEAT_2_145(m, d) m(3, 145, d)
+# define BOOST_PP_REPEAT_2_147(m, d) BOOST_PP_REPEAT_2_146(m, d) m(3, 146, d)
+# define BOOST_PP_REPEAT_2_148(m, d) BOOST_PP_REPEAT_2_147(m, d) m(3, 147, d)
+# define BOOST_PP_REPEAT_2_149(m, d) BOOST_PP_REPEAT_2_148(m, d) m(3, 148, d)
+# define BOOST_PP_REPEAT_2_150(m, d) BOOST_PP_REPEAT_2_149(m, d) m(3, 149, d)
+# define BOOST_PP_REPEAT_2_151(m, d) BOOST_PP_REPEAT_2_150(m, d) m(3, 150, d)
+# define BOOST_PP_REPEAT_2_152(m, d) BOOST_PP_REPEAT_2_151(m, d) m(3, 151, d)
+# define BOOST_PP_REPEAT_2_153(m, d) BOOST_PP_REPEAT_2_152(m, d) m(3, 152, d)
+# define BOOST_PP_REPEAT_2_154(m, d) BOOST_PP_REPEAT_2_153(m, d) m(3, 153, d)
+# define BOOST_PP_REPEAT_2_155(m, d) BOOST_PP_REPEAT_2_154(m, d) m(3, 154, d)
+# define BOOST_PP_REPEAT_2_156(m, d) BOOST_PP_REPEAT_2_155(m, d) m(3, 155, d)
+# define BOOST_PP_REPEAT_2_157(m, d) BOOST_PP_REPEAT_2_156(m, d) m(3, 156, d)
+# define BOOST_PP_REPEAT_2_158(m, d) BOOST_PP_REPEAT_2_157(m, d) m(3, 157, d)
+# define BOOST_PP_REPEAT_2_159(m, d) BOOST_PP_REPEAT_2_158(m, d) m(3, 158, d)
+# define BOOST_PP_REPEAT_2_160(m, d) BOOST_PP_REPEAT_2_159(m, d) m(3, 159, d)
+# define BOOST_PP_REPEAT_2_161(m, d) BOOST_PP_REPEAT_2_160(m, d) m(3, 160, d)
+# define BOOST_PP_REPEAT_2_162(m, d) BOOST_PP_REPEAT_2_161(m, d) m(3, 161, d)
+# define BOOST_PP_REPEAT_2_163(m, d) BOOST_PP_REPEAT_2_162(m, d) m(3, 162, d)
+# define BOOST_PP_REPEAT_2_164(m, d) BOOST_PP_REPEAT_2_163(m, d) m(3, 163, d)
+# define BOOST_PP_REPEAT_2_165(m, d) BOOST_PP_REPEAT_2_164(m, d) m(3, 164, d)
+# define BOOST_PP_REPEAT_2_166(m, d) BOOST_PP_REPEAT_2_165(m, d) m(3, 165, d)
+# define BOOST_PP_REPEAT_2_167(m, d) BOOST_PP_REPEAT_2_166(m, d) m(3, 166, d)
+# define BOOST_PP_REPEAT_2_168(m, d) BOOST_PP_REPEAT_2_167(m, d) m(3, 167, d)
+# define BOOST_PP_REPEAT_2_169(m, d) BOOST_PP_REPEAT_2_168(m, d) m(3, 168, d)
+# define BOOST_PP_REPEAT_2_170(m, d) BOOST_PP_REPEAT_2_169(m, d) m(3, 169, d)
+# define BOOST_PP_REPEAT_2_171(m, d) BOOST_PP_REPEAT_2_170(m, d) m(3, 170, d)
+# define BOOST_PP_REPEAT_2_172(m, d) BOOST_PP_REPEAT_2_171(m, d) m(3, 171, d)
+# define BOOST_PP_REPEAT_2_173(m, d) BOOST_PP_REPEAT_2_172(m, d) m(3, 172, d)
+# define BOOST_PP_REPEAT_2_174(m, d) BOOST_PP_REPEAT_2_173(m, d) m(3, 173, d)
+# define BOOST_PP_REPEAT_2_175(m, d) BOOST_PP_REPEAT_2_174(m, d) m(3, 174, d)
+# define BOOST_PP_REPEAT_2_176(m, d) BOOST_PP_REPEAT_2_175(m, d) m(3, 175, d)
+# define BOOST_PP_REPEAT_2_177(m, d) BOOST_PP_REPEAT_2_176(m, d) m(3, 176, d)
+# define BOOST_PP_REPEAT_2_178(m, d) BOOST_PP_REPEAT_2_177(m, d) m(3, 177, d)
+# define BOOST_PP_REPEAT_2_179(m, d) BOOST_PP_REPEAT_2_178(m, d) m(3, 178, d)
+# define BOOST_PP_REPEAT_2_180(m, d) BOOST_PP_REPEAT_2_179(m, d) m(3, 179, d)
+# define BOOST_PP_REPEAT_2_181(m, d) BOOST_PP_REPEAT_2_180(m, d) m(3, 180, d)
+# define BOOST_PP_REPEAT_2_182(m, d) BOOST_PP_REPEAT_2_181(m, d) m(3, 181, d)
+# define BOOST_PP_REPEAT_2_183(m, d) BOOST_PP_REPEAT_2_182(m, d) m(3, 182, d)
+# define BOOST_PP_REPEAT_2_184(m, d) BOOST_PP_REPEAT_2_183(m, d) m(3, 183, d)
+# define BOOST_PP_REPEAT_2_185(m, d) BOOST_PP_REPEAT_2_184(m, d) m(3, 184, d)
+# define BOOST_PP_REPEAT_2_186(m, d) BOOST_PP_REPEAT_2_185(m, d) m(3, 185, d)
+# define BOOST_PP_REPEAT_2_187(m, d) BOOST_PP_REPEAT_2_186(m, d) m(3, 186, d)
+# define BOOST_PP_REPEAT_2_188(m, d) BOOST_PP_REPEAT_2_187(m, d) m(3, 187, d)
+# define BOOST_PP_REPEAT_2_189(m, d) BOOST_PP_REPEAT_2_188(m, d) m(3, 188, d)
+# define BOOST_PP_REPEAT_2_190(m, d) BOOST_PP_REPEAT_2_189(m, d) m(3, 189, d)
+# define BOOST_PP_REPEAT_2_191(m, d) BOOST_PP_REPEAT_2_190(m, d) m(3, 190, d)
+# define BOOST_PP_REPEAT_2_192(m, d) BOOST_PP_REPEAT_2_191(m, d) m(3, 191, d)
+# define BOOST_PP_REPEAT_2_193(m, d) BOOST_PP_REPEAT_2_192(m, d) m(3, 192, d)
+# define BOOST_PP_REPEAT_2_194(m, d) BOOST_PP_REPEAT_2_193(m, d) m(3, 193, d)
+# define BOOST_PP_REPEAT_2_195(m, d) BOOST_PP_REPEAT_2_194(m, d) m(3, 194, d)
+# define BOOST_PP_REPEAT_2_196(m, d) BOOST_PP_REPEAT_2_195(m, d) m(3, 195, d)
+# define BOOST_PP_REPEAT_2_197(m, d) BOOST_PP_REPEAT_2_196(m, d) m(3, 196, d)
+# define BOOST_PP_REPEAT_2_198(m, d) BOOST_PP_REPEAT_2_197(m, d) m(3, 197, d)
+# define BOOST_PP_REPEAT_2_199(m, d) BOOST_PP_REPEAT_2_198(m, d) m(3, 198, d)
+# define BOOST_PP_REPEAT_2_200(m, d) BOOST_PP_REPEAT_2_199(m, d) m(3, 199, d)
+# define BOOST_PP_REPEAT_2_201(m, d) BOOST_PP_REPEAT_2_200(m, d) m(3, 200, d)
+# define BOOST_PP_REPEAT_2_202(m, d) BOOST_PP_REPEAT_2_201(m, d) m(3, 201, d)
+# define BOOST_PP_REPEAT_2_203(m, d) BOOST_PP_REPEAT_2_202(m, d) m(3, 202, d)
+# define BOOST_PP_REPEAT_2_204(m, d) BOOST_PP_REPEAT_2_203(m, d) m(3, 203, d)
+# define BOOST_PP_REPEAT_2_205(m, d) BOOST_PP_REPEAT_2_204(m, d) m(3, 204, d)
+# define BOOST_PP_REPEAT_2_206(m, d) BOOST_PP_REPEAT_2_205(m, d) m(3, 205, d)
+# define BOOST_PP_REPEAT_2_207(m, d) BOOST_PP_REPEAT_2_206(m, d) m(3, 206, d)
+# define BOOST_PP_REPEAT_2_208(m, d) BOOST_PP_REPEAT_2_207(m, d) m(3, 207, d)
+# define BOOST_PP_REPEAT_2_209(m, d) BOOST_PP_REPEAT_2_208(m, d) m(3, 208, d)
+# define BOOST_PP_REPEAT_2_210(m, d) BOOST_PP_REPEAT_2_209(m, d) m(3, 209, d)
+# define BOOST_PP_REPEAT_2_211(m, d) BOOST_PP_REPEAT_2_210(m, d) m(3, 210, d)
+# define BOOST_PP_REPEAT_2_212(m, d) BOOST_PP_REPEAT_2_211(m, d) m(3, 211, d)
+# define BOOST_PP_REPEAT_2_213(m, d) BOOST_PP_REPEAT_2_212(m, d) m(3, 212, d)
+# define BOOST_PP_REPEAT_2_214(m, d) BOOST_PP_REPEAT_2_213(m, d) m(3, 213, d)
+# define BOOST_PP_REPEAT_2_215(m, d) BOOST_PP_REPEAT_2_214(m, d) m(3, 214, d)
+# define BOOST_PP_REPEAT_2_216(m, d) BOOST_PP_REPEAT_2_215(m, d) m(3, 215, d)
+# define BOOST_PP_REPEAT_2_217(m, d) BOOST_PP_REPEAT_2_216(m, d) m(3, 216, d)
+# define BOOST_PP_REPEAT_2_218(m, d) BOOST_PP_REPEAT_2_217(m, d) m(3, 217, d)
+# define BOOST_PP_REPEAT_2_219(m, d) BOOST_PP_REPEAT_2_218(m, d) m(3, 218, d)
+# define BOOST_PP_REPEAT_2_220(m, d) BOOST_PP_REPEAT_2_219(m, d) m(3, 219, d)
+# define BOOST_PP_REPEAT_2_221(m, d) BOOST_PP_REPEAT_2_220(m, d) m(3, 220, d)
+# define BOOST_PP_REPEAT_2_222(m, d) BOOST_PP_REPEAT_2_221(m, d) m(3, 221, d)
+# define BOOST_PP_REPEAT_2_223(m, d) BOOST_PP_REPEAT_2_222(m, d) m(3, 222, d)
+# define BOOST_PP_REPEAT_2_224(m, d) BOOST_PP_REPEAT_2_223(m, d) m(3, 223, d)
+# define BOOST_PP_REPEAT_2_225(m, d) BOOST_PP_REPEAT_2_224(m, d) m(3, 224, d)
+# define BOOST_PP_REPEAT_2_226(m, d) BOOST_PP_REPEAT_2_225(m, d) m(3, 225, d)
+# define BOOST_PP_REPEAT_2_227(m, d) BOOST_PP_REPEAT_2_226(m, d) m(3, 226, d)
+# define BOOST_PP_REPEAT_2_228(m, d) BOOST_PP_REPEAT_2_227(m, d) m(3, 227, d)
+# define BOOST_PP_REPEAT_2_229(m, d) BOOST_PP_REPEAT_2_228(m, d) m(3, 228, d)
+# define BOOST_PP_REPEAT_2_230(m, d) BOOST_PP_REPEAT_2_229(m, d) m(3, 229, d)
+# define BOOST_PP_REPEAT_2_231(m, d) BOOST_PP_REPEAT_2_230(m, d) m(3, 230, d)
+# define BOOST_PP_REPEAT_2_232(m, d) BOOST_PP_REPEAT_2_231(m, d) m(3, 231, d)
+# define BOOST_PP_REPEAT_2_233(m, d) BOOST_PP_REPEAT_2_232(m, d) m(3, 232, d)
+# define BOOST_PP_REPEAT_2_234(m, d) BOOST_PP_REPEAT_2_233(m, d) m(3, 233, d)
+# define BOOST_PP_REPEAT_2_235(m, d) BOOST_PP_REPEAT_2_234(m, d) m(3, 234, d)
+# define BOOST_PP_REPEAT_2_236(m, d) BOOST_PP_REPEAT_2_235(m, d) m(3, 235, d)
+# define BOOST_PP_REPEAT_2_237(m, d) BOOST_PP_REPEAT_2_236(m, d) m(3, 236, d)
+# define BOOST_PP_REPEAT_2_238(m, d) BOOST_PP_REPEAT_2_237(m, d) m(3, 237, d)
+# define BOOST_PP_REPEAT_2_239(m, d) BOOST_PP_REPEAT_2_238(m, d) m(3, 238, d)
+# define BOOST_PP_REPEAT_2_240(m, d) BOOST_PP_REPEAT_2_239(m, d) m(3, 239, d)
+# define BOOST_PP_REPEAT_2_241(m, d) BOOST_PP_REPEAT_2_240(m, d) m(3, 240, d)
+# define BOOST_PP_REPEAT_2_242(m, d) BOOST_PP_REPEAT_2_241(m, d) m(3, 241, d)
+# define BOOST_PP_REPEAT_2_243(m, d) BOOST_PP_REPEAT_2_242(m, d) m(3, 242, d)
+# define BOOST_PP_REPEAT_2_244(m, d) BOOST_PP_REPEAT_2_243(m, d) m(3, 243, d)
+# define BOOST_PP_REPEAT_2_245(m, d) BOOST_PP_REPEAT_2_244(m, d) m(3, 244, d)
+# define BOOST_PP_REPEAT_2_246(m, d) BOOST_PP_REPEAT_2_245(m, d) m(3, 245, d)
+# define BOOST_PP_REPEAT_2_247(m, d) BOOST_PP_REPEAT_2_246(m, d) m(3, 246, d)
+# define BOOST_PP_REPEAT_2_248(m, d) BOOST_PP_REPEAT_2_247(m, d) m(3, 247, d)
+# define BOOST_PP_REPEAT_2_249(m, d) BOOST_PP_REPEAT_2_248(m, d) m(3, 248, d)
+# define BOOST_PP_REPEAT_2_250(m, d) BOOST_PP_REPEAT_2_249(m, d) m(3, 249, d)
+# define BOOST_PP_REPEAT_2_251(m, d) BOOST_PP_REPEAT_2_250(m, d) m(3, 250, d)
+# define BOOST_PP_REPEAT_2_252(m, d) BOOST_PP_REPEAT_2_251(m, d) m(3, 251, d)
+# define BOOST_PP_REPEAT_2_253(m, d) BOOST_PP_REPEAT_2_252(m, d) m(3, 252, d)
+# define BOOST_PP_REPEAT_2_254(m, d) BOOST_PP_REPEAT_2_253(m, d) m(3, 253, d)
+# define BOOST_PP_REPEAT_2_255(m, d) BOOST_PP_REPEAT_2_254(m, d) m(3, 254, d)
+# define BOOST_PP_REPEAT_2_256(m, d) BOOST_PP_REPEAT_2_255(m, d) m(3, 255, d)
+#
+# define BOOST_PP_REPEAT_3_0(m, d)
+# define BOOST_PP_REPEAT_3_1(m, d) m(4, 0, d)
+# define BOOST_PP_REPEAT_3_2(m, d) BOOST_PP_REPEAT_3_1(m, d) m(4, 1, d)
+# define BOOST_PP_REPEAT_3_3(m, d) BOOST_PP_REPEAT_3_2(m, d) m(4, 2, d)
+# define BOOST_PP_REPEAT_3_4(m, d) BOOST_PP_REPEAT_3_3(m, d) m(4, 3, d)
+# define BOOST_PP_REPEAT_3_5(m, d) BOOST_PP_REPEAT_3_4(m, d) m(4, 4, d)
+# define BOOST_PP_REPEAT_3_6(m, d) BOOST_PP_REPEAT_3_5(m, d) m(4, 5, d)
+# define BOOST_PP_REPEAT_3_7(m, d) BOOST_PP_REPEAT_3_6(m, d) m(4, 6, d)
+# define BOOST_PP_REPEAT_3_8(m, d) BOOST_PP_REPEAT_3_7(m, d) m(4, 7, d)
+# define BOOST_PP_REPEAT_3_9(m, d) BOOST_PP_REPEAT_3_8(m, d) m(4, 8, d)
+# define BOOST_PP_REPEAT_3_10(m, d) BOOST_PP_REPEAT_3_9(m, d) m(4, 9, d)
+# define BOOST_PP_REPEAT_3_11(m, d) BOOST_PP_REPEAT_3_10(m, d) m(4, 10, d)
+# define BOOST_PP_REPEAT_3_12(m, d) BOOST_PP_REPEAT_3_11(m, d) m(4, 11, d)
+# define BOOST_PP_REPEAT_3_13(m, d) BOOST_PP_REPEAT_3_12(m, d) m(4, 12, d)
+# define BOOST_PP_REPEAT_3_14(m, d) BOOST_PP_REPEAT_3_13(m, d) m(4, 13, d)
+# define BOOST_PP_REPEAT_3_15(m, d) BOOST_PP_REPEAT_3_14(m, d) m(4, 14, d)
+# define BOOST_PP_REPEAT_3_16(m, d) BOOST_PP_REPEAT_3_15(m, d) m(4, 15, d)
+# define BOOST_PP_REPEAT_3_17(m, d) BOOST_PP_REPEAT_3_16(m, d) m(4, 16, d)
+# define BOOST_PP_REPEAT_3_18(m, d) BOOST_PP_REPEAT_3_17(m, d) m(4, 17, d)
+# define BOOST_PP_REPEAT_3_19(m, d) BOOST_PP_REPEAT_3_18(m, d) m(4, 18, d)
+# define BOOST_PP_REPEAT_3_20(m, d) BOOST_PP_REPEAT_3_19(m, d) m(4, 19, d)
+# define BOOST_PP_REPEAT_3_21(m, d) BOOST_PP_REPEAT_3_20(m, d) m(4, 20, d)
+# define BOOST_PP_REPEAT_3_22(m, d) BOOST_PP_REPEAT_3_21(m, d) m(4, 21, d)
+# define BOOST_PP_REPEAT_3_23(m, d) BOOST_PP_REPEAT_3_22(m, d) m(4, 22, d)
+# define BOOST_PP_REPEAT_3_24(m, d) BOOST_PP_REPEAT_3_23(m, d) m(4, 23, d)
+# define BOOST_PP_REPEAT_3_25(m, d) BOOST_PP_REPEAT_3_24(m, d) m(4, 24, d)
+# define BOOST_PP_REPEAT_3_26(m, d) BOOST_PP_REPEAT_3_25(m, d) m(4, 25, d)
+# define BOOST_PP_REPEAT_3_27(m, d) BOOST_PP_REPEAT_3_26(m, d) m(4, 26, d)
+# define BOOST_PP_REPEAT_3_28(m, d) BOOST_PP_REPEAT_3_27(m, d) m(4, 27, d)
+# define BOOST_PP_REPEAT_3_29(m, d) BOOST_PP_REPEAT_3_28(m, d) m(4, 28, d)
+# define BOOST_PP_REPEAT_3_30(m, d) BOOST_PP_REPEAT_3_29(m, d) m(4, 29, d)
+# define BOOST_PP_REPEAT_3_31(m, d) BOOST_PP_REPEAT_3_30(m, d) m(4, 30, d)
+# define BOOST_PP_REPEAT_3_32(m, d) BOOST_PP_REPEAT_3_31(m, d) m(4, 31, d)
+# define BOOST_PP_REPEAT_3_33(m, d) BOOST_PP_REPEAT_3_32(m, d) m(4, 32, d)
+# define BOOST_PP_REPEAT_3_34(m, d) BOOST_PP_REPEAT_3_33(m, d) m(4, 33, d)
+# define BOOST_PP_REPEAT_3_35(m, d) BOOST_PP_REPEAT_3_34(m, d) m(4, 34, d)
+# define BOOST_PP_REPEAT_3_36(m, d) BOOST_PP_REPEAT_3_35(m, d) m(4, 35, d)
+# define BOOST_PP_REPEAT_3_37(m, d) BOOST_PP_REPEAT_3_36(m, d) m(4, 36, d)
+# define BOOST_PP_REPEAT_3_38(m, d) BOOST_PP_REPEAT_3_37(m, d) m(4, 37, d)
+# define BOOST_PP_REPEAT_3_39(m, d) BOOST_PP_REPEAT_3_38(m, d) m(4, 38, d)
+# define BOOST_PP_REPEAT_3_40(m, d) BOOST_PP_REPEAT_3_39(m, d) m(4, 39, d)
+# define BOOST_PP_REPEAT_3_41(m, d) BOOST_PP_REPEAT_3_40(m, d) m(4, 40, d)
+# define BOOST_PP_REPEAT_3_42(m, d) BOOST_PP_REPEAT_3_41(m, d) m(4, 41, d)
+# define BOOST_PP_REPEAT_3_43(m, d) BOOST_PP_REPEAT_3_42(m, d) m(4, 42, d)
+# define BOOST_PP_REPEAT_3_44(m, d) BOOST_PP_REPEAT_3_43(m, d) m(4, 43, d)
+# define BOOST_PP_REPEAT_3_45(m, d) BOOST_PP_REPEAT_3_44(m, d) m(4, 44, d)
+# define BOOST_PP_REPEAT_3_46(m, d) BOOST_PP_REPEAT_3_45(m, d) m(4, 45, d)
+# define BOOST_PP_REPEAT_3_47(m, d) BOOST_PP_REPEAT_3_46(m, d) m(4, 46, d)
+# define BOOST_PP_REPEAT_3_48(m, d) BOOST_PP_REPEAT_3_47(m, d) m(4, 47, d)
+# define BOOST_PP_REPEAT_3_49(m, d) BOOST_PP_REPEAT_3_48(m, d) m(4, 48, d)
+# define BOOST_PP_REPEAT_3_50(m, d) BOOST_PP_REPEAT_3_49(m, d) m(4, 49, d)
+# define BOOST_PP_REPEAT_3_51(m, d) BOOST_PP_REPEAT_3_50(m, d) m(4, 50, d)
+# define BOOST_PP_REPEAT_3_52(m, d) BOOST_PP_REPEAT_3_51(m, d) m(4, 51, d)
+# define BOOST_PP_REPEAT_3_53(m, d) BOOST_PP_REPEAT_3_52(m, d) m(4, 52, d)
+# define BOOST_PP_REPEAT_3_54(m, d) BOOST_PP_REPEAT_3_53(m, d) m(4, 53, d)
+# define BOOST_PP_REPEAT_3_55(m, d) BOOST_PP_REPEAT_3_54(m, d) m(4, 54, d)
+# define BOOST_PP_REPEAT_3_56(m, d) BOOST_PP_REPEAT_3_55(m, d) m(4, 55, d)
+# define BOOST_PP_REPEAT_3_57(m, d) BOOST_PP_REPEAT_3_56(m, d) m(4, 56, d)
+# define BOOST_PP_REPEAT_3_58(m, d) BOOST_PP_REPEAT_3_57(m, d) m(4, 57, d)
+# define BOOST_PP_REPEAT_3_59(m, d) BOOST_PP_REPEAT_3_58(m, d) m(4, 58, d)
+# define BOOST_PP_REPEAT_3_60(m, d) BOOST_PP_REPEAT_3_59(m, d) m(4, 59, d)
+# define BOOST_PP_REPEAT_3_61(m, d) BOOST_PP_REPEAT_3_60(m, d) m(4, 60, d)
+# define BOOST_PP_REPEAT_3_62(m, d) BOOST_PP_REPEAT_3_61(m, d) m(4, 61, d)
+# define BOOST_PP_REPEAT_3_63(m, d) BOOST_PP_REPEAT_3_62(m, d) m(4, 62, d)
+# define BOOST_PP_REPEAT_3_64(m, d) BOOST_PP_REPEAT_3_63(m, d) m(4, 63, d)
+# define BOOST_PP_REPEAT_3_65(m, d) BOOST_PP_REPEAT_3_64(m, d) m(4, 64, d)
+# define BOOST_PP_REPEAT_3_66(m, d) BOOST_PP_REPEAT_3_65(m, d) m(4, 65, d)
+# define BOOST_PP_REPEAT_3_67(m, d) BOOST_PP_REPEAT_3_66(m, d) m(4, 66, d)
+# define BOOST_PP_REPEAT_3_68(m, d) BOOST_PP_REPEAT_3_67(m, d) m(4, 67, d)
+# define BOOST_PP_REPEAT_3_69(m, d) BOOST_PP_REPEAT_3_68(m, d) m(4, 68, d)
+# define BOOST_PP_REPEAT_3_70(m, d) BOOST_PP_REPEAT_3_69(m, d) m(4, 69, d)
+# define BOOST_PP_REPEAT_3_71(m, d) BOOST_PP_REPEAT_3_70(m, d) m(4, 70, d)
+# define BOOST_PP_REPEAT_3_72(m, d) BOOST_PP_REPEAT_3_71(m, d) m(4, 71, d)
+# define BOOST_PP_REPEAT_3_73(m, d) BOOST_PP_REPEAT_3_72(m, d) m(4, 72, d)
+# define BOOST_PP_REPEAT_3_74(m, d) BOOST_PP_REPEAT_3_73(m, d) m(4, 73, d)
+# define BOOST_PP_REPEAT_3_75(m, d) BOOST_PP_REPEAT_3_74(m, d) m(4, 74, d)
+# define BOOST_PP_REPEAT_3_76(m, d) BOOST_PP_REPEAT_3_75(m, d) m(4, 75, d)
+# define BOOST_PP_REPEAT_3_77(m, d) BOOST_PP_REPEAT_3_76(m, d) m(4, 76, d)
+# define BOOST_PP_REPEAT_3_78(m, d) BOOST_PP_REPEAT_3_77(m, d) m(4, 77, d)
+# define BOOST_PP_REPEAT_3_79(m, d) BOOST_PP_REPEAT_3_78(m, d) m(4, 78, d)
+# define BOOST_PP_REPEAT_3_80(m, d) BOOST_PP_REPEAT_3_79(m, d) m(4, 79, d)
+# define BOOST_PP_REPEAT_3_81(m, d) BOOST_PP_REPEAT_3_80(m, d) m(4, 80, d)
+# define BOOST_PP_REPEAT_3_82(m, d) BOOST_PP_REPEAT_3_81(m, d) m(4, 81, d)
+# define BOOST_PP_REPEAT_3_83(m, d) BOOST_PP_REPEAT_3_82(m, d) m(4, 82, d)
+# define BOOST_PP_REPEAT_3_84(m, d) BOOST_PP_REPEAT_3_83(m, d) m(4, 83, d)
+# define BOOST_PP_REPEAT_3_85(m, d) BOOST_PP_REPEAT_3_84(m, d) m(4, 84, d)
+# define BOOST_PP_REPEAT_3_86(m, d) BOOST_PP_REPEAT_3_85(m, d) m(4, 85, d)
+# define BOOST_PP_REPEAT_3_87(m, d) BOOST_PP_REPEAT_3_86(m, d) m(4, 86, d)
+# define BOOST_PP_REPEAT_3_88(m, d) BOOST_PP_REPEAT_3_87(m, d) m(4, 87, d)
+# define BOOST_PP_REPEAT_3_89(m, d) BOOST_PP_REPEAT_3_88(m, d) m(4, 88, d)
+# define BOOST_PP_REPEAT_3_90(m, d) BOOST_PP_REPEAT_3_89(m, d) m(4, 89, d)
+# define BOOST_PP_REPEAT_3_91(m, d) BOOST_PP_REPEAT_3_90(m, d) m(4, 90, d)
+# define BOOST_PP_REPEAT_3_92(m, d) BOOST_PP_REPEAT_3_91(m, d) m(4, 91, d)
+# define BOOST_PP_REPEAT_3_93(m, d) BOOST_PP_REPEAT_3_92(m, d) m(4, 92, d)
+# define BOOST_PP_REPEAT_3_94(m, d) BOOST_PP_REPEAT_3_93(m, d) m(4, 93, d)
+# define BOOST_PP_REPEAT_3_95(m, d) BOOST_PP_REPEAT_3_94(m, d) m(4, 94, d)
+# define BOOST_PP_REPEAT_3_96(m, d) BOOST_PP_REPEAT_3_95(m, d) m(4, 95, d)
+# define BOOST_PP_REPEAT_3_97(m, d) BOOST_PP_REPEAT_3_96(m, d) m(4, 96, d)
+# define BOOST_PP_REPEAT_3_98(m, d) BOOST_PP_REPEAT_3_97(m, d) m(4, 97, d)
+# define BOOST_PP_REPEAT_3_99(m, d) BOOST_PP_REPEAT_3_98(m, d) m(4, 98, d)
+# define BOOST_PP_REPEAT_3_100(m, d) BOOST_PP_REPEAT_3_99(m, d) m(4, 99, d)
+# define BOOST_PP_REPEAT_3_101(m, d) BOOST_PP_REPEAT_3_100(m, d) m(4, 100, d)
+# define BOOST_PP_REPEAT_3_102(m, d) BOOST_PP_REPEAT_3_101(m, d) m(4, 101, d)
+# define BOOST_PP_REPEAT_3_103(m, d) BOOST_PP_REPEAT_3_102(m, d) m(4, 102, d)
+# define BOOST_PP_REPEAT_3_104(m, d) BOOST_PP_REPEAT_3_103(m, d) m(4, 103, d)
+# define BOOST_PP_REPEAT_3_105(m, d) BOOST_PP_REPEAT_3_104(m, d) m(4, 104, d)
+# define BOOST_PP_REPEAT_3_106(m, d) BOOST_PP_REPEAT_3_105(m, d) m(4, 105, d)
+# define BOOST_PP_REPEAT_3_107(m, d) BOOST_PP_REPEAT_3_106(m, d) m(4, 106, d)
+# define BOOST_PP_REPEAT_3_108(m, d) BOOST_PP_REPEAT_3_107(m, d) m(4, 107, d)
+# define BOOST_PP_REPEAT_3_109(m, d) BOOST_PP_REPEAT_3_108(m, d) m(4, 108, d)
+# define BOOST_PP_REPEAT_3_110(m, d) BOOST_PP_REPEAT_3_109(m, d) m(4, 109, d)
+# define BOOST_PP_REPEAT_3_111(m, d) BOOST_PP_REPEAT_3_110(m, d) m(4, 110, d)
+# define BOOST_PP_REPEAT_3_112(m, d) BOOST_PP_REPEAT_3_111(m, d) m(4, 111, d)
+# define BOOST_PP_REPEAT_3_113(m, d) BOOST_PP_REPEAT_3_112(m, d) m(4, 112, d)
+# define BOOST_PP_REPEAT_3_114(m, d) BOOST_PP_REPEAT_3_113(m, d) m(4, 113, d)
+# define BOOST_PP_REPEAT_3_115(m, d) BOOST_PP_REPEAT_3_114(m, d) m(4, 114, d)
+# define BOOST_PP_REPEAT_3_116(m, d) BOOST_PP_REPEAT_3_115(m, d) m(4, 115, d)
+# define BOOST_PP_REPEAT_3_117(m, d) BOOST_PP_REPEAT_3_116(m, d) m(4, 116, d)
+# define BOOST_PP_REPEAT_3_118(m, d) BOOST_PP_REPEAT_3_117(m, d) m(4, 117, d)
+# define BOOST_PP_REPEAT_3_119(m, d) BOOST_PP_REPEAT_3_118(m, d) m(4, 118, d)
+# define BOOST_PP_REPEAT_3_120(m, d) BOOST_PP_REPEAT_3_119(m, d) m(4, 119, d)
+# define BOOST_PP_REPEAT_3_121(m, d) BOOST_PP_REPEAT_3_120(m, d) m(4, 120, d)
+# define BOOST_PP_REPEAT_3_122(m, d) BOOST_PP_REPEAT_3_121(m, d) m(4, 121, d)
+# define BOOST_PP_REPEAT_3_123(m, d) BOOST_PP_REPEAT_3_122(m, d) m(4, 122, d)
+# define BOOST_PP_REPEAT_3_124(m, d) BOOST_PP_REPEAT_3_123(m, d) m(4, 123, d)
+# define BOOST_PP_REPEAT_3_125(m, d) BOOST_PP_REPEAT_3_124(m, d) m(4, 124, d)
+# define BOOST_PP_REPEAT_3_126(m, d) BOOST_PP_REPEAT_3_125(m, d) m(4, 125, d)
+# define BOOST_PP_REPEAT_3_127(m, d) BOOST_PP_REPEAT_3_126(m, d) m(4, 126, d)
+# define BOOST_PP_REPEAT_3_128(m, d) BOOST_PP_REPEAT_3_127(m, d) m(4, 127, d)
+# define BOOST_PP_REPEAT_3_129(m, d) BOOST_PP_REPEAT_3_128(m, d) m(4, 128, d)
+# define BOOST_PP_REPEAT_3_130(m, d) BOOST_PP_REPEAT_3_129(m, d) m(4, 129, d)
+# define BOOST_PP_REPEAT_3_131(m, d) BOOST_PP_REPEAT_3_130(m, d) m(4, 130, d)
+# define BOOST_PP_REPEAT_3_132(m, d) BOOST_PP_REPEAT_3_131(m, d) m(4, 131, d)
+# define BOOST_PP_REPEAT_3_133(m, d) BOOST_PP_REPEAT_3_132(m, d) m(4, 132, d)
+# define BOOST_PP_REPEAT_3_134(m, d) BOOST_PP_REPEAT_3_133(m, d) m(4, 133, d)
+# define BOOST_PP_REPEAT_3_135(m, d) BOOST_PP_REPEAT_3_134(m, d) m(4, 134, d)
+# define BOOST_PP_REPEAT_3_136(m, d) BOOST_PP_REPEAT_3_135(m, d) m(4, 135, d)
+# define BOOST_PP_REPEAT_3_137(m, d) BOOST_PP_REPEAT_3_136(m, d) m(4, 136, d)
+# define BOOST_PP_REPEAT_3_138(m, d) BOOST_PP_REPEAT_3_137(m, d) m(4, 137, d)
+# define BOOST_PP_REPEAT_3_139(m, d) BOOST_PP_REPEAT_3_138(m, d) m(4, 138, d)
+# define BOOST_PP_REPEAT_3_140(m, d) BOOST_PP_REPEAT_3_139(m, d) m(4, 139, d)
+# define BOOST_PP_REPEAT_3_141(m, d) BOOST_PP_REPEAT_3_140(m, d) m(4, 140, d)
+# define BOOST_PP_REPEAT_3_142(m, d) BOOST_PP_REPEAT_3_141(m, d) m(4, 141, d)
+# define BOOST_PP_REPEAT_3_143(m, d) BOOST_PP_REPEAT_3_142(m, d) m(4, 142, d)
+# define BOOST_PP_REPEAT_3_144(m, d) BOOST_PP_REPEAT_3_143(m, d) m(4, 143, d)
+# define BOOST_PP_REPEAT_3_145(m, d) BOOST_PP_REPEAT_3_144(m, d) m(4, 144, d)
+# define BOOST_PP_REPEAT_3_146(m, d) BOOST_PP_REPEAT_3_145(m, d) m(4, 145, d)
+# define BOOST_PP_REPEAT_3_147(m, d) BOOST_PP_REPEAT_3_146(m, d) m(4, 146, d)
+# define BOOST_PP_REPEAT_3_148(m, d) BOOST_PP_REPEAT_3_147(m, d) m(4, 147, d)
+# define BOOST_PP_REPEAT_3_149(m, d) BOOST_PP_REPEAT_3_148(m, d) m(4, 148, d)
+# define BOOST_PP_REPEAT_3_150(m, d) BOOST_PP_REPEAT_3_149(m, d) m(4, 149, d)
+# define BOOST_PP_REPEAT_3_151(m, d) BOOST_PP_REPEAT_3_150(m, d) m(4, 150, d)
+# define BOOST_PP_REPEAT_3_152(m, d) BOOST_PP_REPEAT_3_151(m, d) m(4, 151, d)
+# define BOOST_PP_REPEAT_3_153(m, d) BOOST_PP_REPEAT_3_152(m, d) m(4, 152, d)
+# define BOOST_PP_REPEAT_3_154(m, d) BOOST_PP_REPEAT_3_153(m, d) m(4, 153, d)
+# define BOOST_PP_REPEAT_3_155(m, d) BOOST_PP_REPEAT_3_154(m, d) m(4, 154, d)
+# define BOOST_PP_REPEAT_3_156(m, d) BOOST_PP_REPEAT_3_155(m, d) m(4, 155, d)
+# define BOOST_PP_REPEAT_3_157(m, d) BOOST_PP_REPEAT_3_156(m, d) m(4, 156, d)
+# define BOOST_PP_REPEAT_3_158(m, d) BOOST_PP_REPEAT_3_157(m, d) m(4, 157, d)
+# define BOOST_PP_REPEAT_3_159(m, d) BOOST_PP_REPEAT_3_158(m, d) m(4, 158, d)
+# define BOOST_PP_REPEAT_3_160(m, d) BOOST_PP_REPEAT_3_159(m, d) m(4, 159, d)
+# define BOOST_PP_REPEAT_3_161(m, d) BOOST_PP_REPEAT_3_160(m, d) m(4, 160, d)
+# define BOOST_PP_REPEAT_3_162(m, d) BOOST_PP_REPEAT_3_161(m, d) m(4, 161, d)
+# define BOOST_PP_REPEAT_3_163(m, d) BOOST_PP_REPEAT_3_162(m, d) m(4, 162, d)
+# define BOOST_PP_REPEAT_3_164(m, d) BOOST_PP_REPEAT_3_163(m, d) m(4, 163, d)
+# define BOOST_PP_REPEAT_3_165(m, d) BOOST_PP_REPEAT_3_164(m, d) m(4, 164, d)
+# define BOOST_PP_REPEAT_3_166(m, d) BOOST_PP_REPEAT_3_165(m, d) m(4, 165, d)
+# define BOOST_PP_REPEAT_3_167(m, d) BOOST_PP_REPEAT_3_166(m, d) m(4, 166, d)
+# define BOOST_PP_REPEAT_3_168(m, d) BOOST_PP_REPEAT_3_167(m, d) m(4, 167, d)
+# define BOOST_PP_REPEAT_3_169(m, d) BOOST_PP_REPEAT_3_168(m, d) m(4, 168, d)
+# define BOOST_PP_REPEAT_3_170(m, d) BOOST_PP_REPEAT_3_169(m, d) m(4, 169, d)
+# define BOOST_PP_REPEAT_3_171(m, d) BOOST_PP_REPEAT_3_170(m, d) m(4, 170, d)
+# define BOOST_PP_REPEAT_3_172(m, d) BOOST_PP_REPEAT_3_171(m, d) m(4, 171, d)
+# define BOOST_PP_REPEAT_3_173(m, d) BOOST_PP_REPEAT_3_172(m, d) m(4, 172, d)
+# define BOOST_PP_REPEAT_3_174(m, d) BOOST_PP_REPEAT_3_173(m, d) m(4, 173, d)
+# define BOOST_PP_REPEAT_3_175(m, d) BOOST_PP_REPEAT_3_174(m, d) m(4, 174, d)
+# define BOOST_PP_REPEAT_3_176(m, d) BOOST_PP_REPEAT_3_175(m, d) m(4, 175, d)
+# define BOOST_PP_REPEAT_3_177(m, d) BOOST_PP_REPEAT_3_176(m, d) m(4, 176, d)
+# define BOOST_PP_REPEAT_3_178(m, d) BOOST_PP_REPEAT_3_177(m, d) m(4, 177, d)
+# define BOOST_PP_REPEAT_3_179(m, d) BOOST_PP_REPEAT_3_178(m, d) m(4, 178, d)
+# define BOOST_PP_REPEAT_3_180(m, d) BOOST_PP_REPEAT_3_179(m, d) m(4, 179, d)
+# define BOOST_PP_REPEAT_3_181(m, d) BOOST_PP_REPEAT_3_180(m, d) m(4, 180, d)
+# define BOOST_PP_REPEAT_3_182(m, d) BOOST_PP_REPEAT_3_181(m, d) m(4, 181, d)
+# define BOOST_PP_REPEAT_3_183(m, d) BOOST_PP_REPEAT_3_182(m, d) m(4, 182, d)
+# define BOOST_PP_REPEAT_3_184(m, d) BOOST_PP_REPEAT_3_183(m, d) m(4, 183, d)
+# define BOOST_PP_REPEAT_3_185(m, d) BOOST_PP_REPEAT_3_184(m, d) m(4, 184, d)
+# define BOOST_PP_REPEAT_3_186(m, d) BOOST_PP_REPEAT_3_185(m, d) m(4, 185, d)
+# define BOOST_PP_REPEAT_3_187(m, d) BOOST_PP_REPEAT_3_186(m, d) m(4, 186, d)
+# define BOOST_PP_REPEAT_3_188(m, d) BOOST_PP_REPEAT_3_187(m, d) m(4, 187, d)
+# define BOOST_PP_REPEAT_3_189(m, d) BOOST_PP_REPEAT_3_188(m, d) m(4, 188, d)
+# define BOOST_PP_REPEAT_3_190(m, d) BOOST_PP_REPEAT_3_189(m, d) m(4, 189, d)
+# define BOOST_PP_REPEAT_3_191(m, d) BOOST_PP_REPEAT_3_190(m, d) m(4, 190, d)
+# define BOOST_PP_REPEAT_3_192(m, d) BOOST_PP_REPEAT_3_191(m, d) m(4, 191, d)
+# define BOOST_PP_REPEAT_3_193(m, d) BOOST_PP_REPEAT_3_192(m, d) m(4, 192, d)
+# define BOOST_PP_REPEAT_3_194(m, d) BOOST_PP_REPEAT_3_193(m, d) m(4, 193, d)
+# define BOOST_PP_REPEAT_3_195(m, d) BOOST_PP_REPEAT_3_194(m, d) m(4, 194, d)
+# define BOOST_PP_REPEAT_3_196(m, d) BOOST_PP_REPEAT_3_195(m, d) m(4, 195, d)
+# define BOOST_PP_REPEAT_3_197(m, d) BOOST_PP_REPEAT_3_196(m, d) m(4, 196, d)
+# define BOOST_PP_REPEAT_3_198(m, d) BOOST_PP_REPEAT_3_197(m, d) m(4, 197, d)
+# define BOOST_PP_REPEAT_3_199(m, d) BOOST_PP_REPEAT_3_198(m, d) m(4, 198, d)
+# define BOOST_PP_REPEAT_3_200(m, d) BOOST_PP_REPEAT_3_199(m, d) m(4, 199, d)
+# define BOOST_PP_REPEAT_3_201(m, d) BOOST_PP_REPEAT_3_200(m, d) m(4, 200, d)
+# define BOOST_PP_REPEAT_3_202(m, d) BOOST_PP_REPEAT_3_201(m, d) m(4, 201, d)
+# define BOOST_PP_REPEAT_3_203(m, d) BOOST_PP_REPEAT_3_202(m, d) m(4, 202, d)
+# define BOOST_PP_REPEAT_3_204(m, d) BOOST_PP_REPEAT_3_203(m, d) m(4, 203, d)
+# define BOOST_PP_REPEAT_3_205(m, d) BOOST_PP_REPEAT_3_204(m, d) m(4, 204, d)
+# define BOOST_PP_REPEAT_3_206(m, d) BOOST_PP_REPEAT_3_205(m, d) m(4, 205, d)
+# define BOOST_PP_REPEAT_3_207(m, d) BOOST_PP_REPEAT_3_206(m, d) m(4, 206, d)
+# define BOOST_PP_REPEAT_3_208(m, d) BOOST_PP_REPEAT_3_207(m, d) m(4, 207, d)
+# define BOOST_PP_REPEAT_3_209(m, d) BOOST_PP_REPEAT_3_208(m, d) m(4, 208, d)
+# define BOOST_PP_REPEAT_3_210(m, d) BOOST_PP_REPEAT_3_209(m, d) m(4, 209, d)
+# define BOOST_PP_REPEAT_3_211(m, d) BOOST_PP_REPEAT_3_210(m, d) m(4, 210, d)
+# define BOOST_PP_REPEAT_3_212(m, d) BOOST_PP_REPEAT_3_211(m, d) m(4, 211, d)
+# define BOOST_PP_REPEAT_3_213(m, d) BOOST_PP_REPEAT_3_212(m, d) m(4, 212, d)
+# define BOOST_PP_REPEAT_3_214(m, d) BOOST_PP_REPEAT_3_213(m, d) m(4, 213, d)
+# define BOOST_PP_REPEAT_3_215(m, d) BOOST_PP_REPEAT_3_214(m, d) m(4, 214, d)
+# define BOOST_PP_REPEAT_3_216(m, d) BOOST_PP_REPEAT_3_215(m, d) m(4, 215, d)
+# define BOOST_PP_REPEAT_3_217(m, d) BOOST_PP_REPEAT_3_216(m, d) m(4, 216, d)
+# define BOOST_PP_REPEAT_3_218(m, d) BOOST_PP_REPEAT_3_217(m, d) m(4, 217, d)
+# define BOOST_PP_REPEAT_3_219(m, d) BOOST_PP_REPEAT_3_218(m, d) m(4, 218, d)
+# define BOOST_PP_REPEAT_3_220(m, d) BOOST_PP_REPEAT_3_219(m, d) m(4, 219, d)
+# define BOOST_PP_REPEAT_3_221(m, d) BOOST_PP_REPEAT_3_220(m, d) m(4, 220, d)
+# define BOOST_PP_REPEAT_3_222(m, d) BOOST_PP_REPEAT_3_221(m, d) m(4, 221, d)
+# define BOOST_PP_REPEAT_3_223(m, d) BOOST_PP_REPEAT_3_222(m, d) m(4, 222, d)
+# define BOOST_PP_REPEAT_3_224(m, d) BOOST_PP_REPEAT_3_223(m, d) m(4, 223, d)
+# define BOOST_PP_REPEAT_3_225(m, d) BOOST_PP_REPEAT_3_224(m, d) m(4, 224, d)
+# define BOOST_PP_REPEAT_3_226(m, d) BOOST_PP_REPEAT_3_225(m, d) m(4, 225, d)
+# define BOOST_PP_REPEAT_3_227(m, d) BOOST_PP_REPEAT_3_226(m, d) m(4, 226, d)
+# define BOOST_PP_REPEAT_3_228(m, d) BOOST_PP_REPEAT_3_227(m, d) m(4, 227, d)
+# define BOOST_PP_REPEAT_3_229(m, d) BOOST_PP_REPEAT_3_228(m, d) m(4, 228, d)
+# define BOOST_PP_REPEAT_3_230(m, d) BOOST_PP_REPEAT_3_229(m, d) m(4, 229, d)
+# define BOOST_PP_REPEAT_3_231(m, d) BOOST_PP_REPEAT_3_230(m, d) m(4, 230, d)
+# define BOOST_PP_REPEAT_3_232(m, d) BOOST_PP_REPEAT_3_231(m, d) m(4, 231, d)
+# define BOOST_PP_REPEAT_3_233(m, d) BOOST_PP_REPEAT_3_232(m, d) m(4, 232, d)
+# define BOOST_PP_REPEAT_3_234(m, d) BOOST_PP_REPEAT_3_233(m, d) m(4, 233, d)
+# define BOOST_PP_REPEAT_3_235(m, d) BOOST_PP_REPEAT_3_234(m, d) m(4, 234, d)
+# define BOOST_PP_REPEAT_3_236(m, d) BOOST_PP_REPEAT_3_235(m, d) m(4, 235, d)
+# define BOOST_PP_REPEAT_3_237(m, d) BOOST_PP_REPEAT_3_236(m, d) m(4, 236, d)
+# define BOOST_PP_REPEAT_3_238(m, d) BOOST_PP_REPEAT_3_237(m, d) m(4, 237, d)
+# define BOOST_PP_REPEAT_3_239(m, d) BOOST_PP_REPEAT_3_238(m, d) m(4, 238, d)
+# define BOOST_PP_REPEAT_3_240(m, d) BOOST_PP_REPEAT_3_239(m, d) m(4, 239, d)
+# define BOOST_PP_REPEAT_3_241(m, d) BOOST_PP_REPEAT_3_240(m, d) m(4, 240, d)
+# define BOOST_PP_REPEAT_3_242(m, d) BOOST_PP_REPEAT_3_241(m, d) m(4, 241, d)
+# define BOOST_PP_REPEAT_3_243(m, d) BOOST_PP_REPEAT_3_242(m, d) m(4, 242, d)
+# define BOOST_PP_REPEAT_3_244(m, d) BOOST_PP_REPEAT_3_243(m, d) m(4, 243, d)
+# define BOOST_PP_REPEAT_3_245(m, d) BOOST_PP_REPEAT_3_244(m, d) m(4, 244, d)
+# define BOOST_PP_REPEAT_3_246(m, d) BOOST_PP_REPEAT_3_245(m, d) m(4, 245, d)
+# define BOOST_PP_REPEAT_3_247(m, d) BOOST_PP_REPEAT_3_246(m, d) m(4, 246, d)
+# define BOOST_PP_REPEAT_3_248(m, d) BOOST_PP_REPEAT_3_247(m, d) m(4, 247, d)
+# define BOOST_PP_REPEAT_3_249(m, d) BOOST_PP_REPEAT_3_248(m, d) m(4, 248, d)
+# define BOOST_PP_REPEAT_3_250(m, d) BOOST_PP_REPEAT_3_249(m, d) m(4, 249, d)
+# define BOOST_PP_REPEAT_3_251(m, d) BOOST_PP_REPEAT_3_250(m, d) m(4, 250, d)
+# define BOOST_PP_REPEAT_3_252(m, d) BOOST_PP_REPEAT_3_251(m, d) m(4, 251, d)
+# define BOOST_PP_REPEAT_3_253(m, d) BOOST_PP_REPEAT_3_252(m, d) m(4, 252, d)
+# define BOOST_PP_REPEAT_3_254(m, d) BOOST_PP_REPEAT_3_253(m, d) m(4, 253, d)
+# define BOOST_PP_REPEAT_3_255(m, d) BOOST_PP_REPEAT_3_254(m, d) m(4, 254, d)
+# define BOOST_PP_REPEAT_3_256(m, d) BOOST_PP_REPEAT_3_255(m, d) m(4, 255, d)
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_trailing_params.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_trailing_params.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_trailing_params.hpp	(working copy)
@@ -0,0 +1,38 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_ENUM_TRAILING_PARAMS_HPP
+# define BOOST_PREPROCESSOR_REPETITION_ENUM_TRAILING_PARAMS_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/repetition/repeat.hpp>
+#
+# /* BOOST_PP_ENUM_TRAILING_PARAMS */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_TRAILING_PARAMS(count, param) BOOST_PP_REPEAT(count, BOOST_PP_ENUM_TRAILING_PARAMS_M, param)
+# else
+#    define BOOST_PP_ENUM_TRAILING_PARAMS(count, param) BOOST_PP_ENUM_TRAILING_PARAMS_I(count, param)
+#    define BOOST_PP_ENUM_TRAILING_PARAMS_I(count, param) BOOST_PP_REPEAT(count, BOOST_PP_ENUM_TRAILING_PARAMS_M, param)
+# endif
+#
+# define BOOST_PP_ENUM_TRAILING_PARAMS_M(z, n, param) , param ## n
+#
+# /* BOOST_PP_ENUM_TRAILING_PARAMS_Z */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, count, param) BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_TRAILING_PARAMS_M, param)
+# else
+#    define BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, count, param) BOOST_PP_ENUM_TRAILING_PARAMS_Z_I(z, count, param)
+#    define BOOST_PP_ENUM_TRAILING_PARAMS_Z_I(z, count, param) BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_TRAILING_PARAMS_M, param)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum.hpp	(working copy)
@@ -0,0 +1,66 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_ENUM_HPP
+# define BOOST_PREPROCESSOR_REPETITION_ENUM_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/debug/error.hpp>
+# include <boost/preprocessor/detail/auto_rec.hpp>
+# include <boost/preprocessor/punctuation/comma_if.hpp>
+# include <boost/preprocessor/repetition/repeat.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+# include <boost/preprocessor/tuple/rem.hpp>
+#
+# /* BOOST_PP_ENUM */
+#
+# if 0
+#    define BOOST_PP_ENUM(count, macro, data)
+# endif
+#
+# define BOOST_PP_ENUM BOOST_PP_CAT(BOOST_PP_ENUM_, BOOST_PP_AUTO_REC(BOOST_PP_REPEAT_P, 4))
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_1(c, m, d) BOOST_PP_REPEAT_1(c, BOOST_PP_ENUM_M_1, (m, d))
+#    define BOOST_PP_ENUM_2(c, m, d) BOOST_PP_REPEAT_2(c, BOOST_PP_ENUM_M_2, (m, d))
+#    define BOOST_PP_ENUM_3(c, m, d) BOOST_PP_REPEAT_3(c, BOOST_PP_ENUM_M_3, (m, d))
+# else
+#    define BOOST_PP_ENUM_1(c, m, d) BOOST_PP_ENUM_1_I(c, m, d)
+#    define BOOST_PP_ENUM_2(c, m, d) BOOST_PP_ENUM_2_I(c, m, d)
+#    define BOOST_PP_ENUM_3(c, m, d) BOOST_PP_ENUM_3_I(c, m, d)
+#    define BOOST_PP_ENUM_1_I(c, m, d) BOOST_PP_REPEAT_1(c, BOOST_PP_ENUM_M_1, (m, d))
+#    define BOOST_PP_ENUM_2_I(c, m, d) BOOST_PP_REPEAT_2(c, BOOST_PP_ENUM_M_2, (m, d))
+#    define BOOST_PP_ENUM_3_I(c, m, d) BOOST_PP_REPEAT_3(c, BOOST_PP_ENUM_M_3, (m, d))
+# endif
+#
+# define BOOST_PP_ENUM_4(c, m, d) BOOST_PP_ERROR(0x0003)
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_STRICT()
+#    define BOOST_PP_ENUM_M_1(z, n, md) BOOST_PP_ENUM_M_1_IM(z, n, BOOST_PP_TUPLE_REM_2 md)
+#    define BOOST_PP_ENUM_M_2(z, n, md) BOOST_PP_ENUM_M_2_IM(z, n, BOOST_PP_TUPLE_REM_2 md)
+#    define BOOST_PP_ENUM_M_3(z, n, md) BOOST_PP_ENUM_M_3_IM(z, n, BOOST_PP_TUPLE_REM_2 md)
+#    define BOOST_PP_ENUM_M_1_IM(z, n, im) BOOST_PP_ENUM_M_1_I(z, n, im)
+#    define BOOST_PP_ENUM_M_2_IM(z, n, im) BOOST_PP_ENUM_M_2_I(z, n, im)
+#    define BOOST_PP_ENUM_M_3_IM(z, n, im) BOOST_PP_ENUM_M_3_I(z, n, im)
+# else
+#    define BOOST_PP_ENUM_M_1(z, n, md) BOOST_PP_ENUM_M_1_I(z, n, BOOST_PP_TUPLE_ELEM(2, 0, md), BOOST_PP_TUPLE_ELEM(2, 1, md))
+#    define BOOST_PP_ENUM_M_2(z, n, md) BOOST_PP_ENUM_M_2_I(z, n, BOOST_PP_TUPLE_ELEM(2, 0, md), BOOST_PP_TUPLE_ELEM(2, 1, md))
+#    define BOOST_PP_ENUM_M_3(z, n, md) BOOST_PP_ENUM_M_3_I(z, n, BOOST_PP_TUPLE_ELEM(2, 0, md), BOOST_PP_TUPLE_ELEM(2, 1, md))
+# endif
+#
+# define BOOST_PP_ENUM_M_1_I(z, n, m, d) BOOST_PP_COMMA_IF(n) m(z, n, d)
+# define BOOST_PP_ENUM_M_2_I(z, n, m, d) BOOST_PP_COMMA_IF(n) m(z, n, d)
+# define BOOST_PP_ENUM_M_3_I(z, n, m, d) BOOST_PP_COMMA_IF(n) m(z, n, d)
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/for.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/for.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/for.hpp	(working copy)
@@ -0,0 +1,306 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_FOR_HPP
+# define BOOST_PREPROCESSOR_REPETITION_FOR_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/debug/error.hpp>
+# include <boost/preprocessor/detail/auto_rec.hpp>
+#
+# /* BOOST_PP_FOR */
+#
+# if 0
+#    define BOOST_PP_FOR(state, pred, op, macro)
+# endif
+#
+# define BOOST_PP_FOR BOOST_PP_CAT(BOOST_PP_FOR_, BOOST_PP_AUTO_REC(BOOST_PP_FOR_P, 256))
+#
+# define BOOST_PP_FOR_P(n) BOOST_PP_CAT(BOOST_PP_FOR_CHECK_, BOOST_PP_FOR_ ## n(1, BOOST_PP_FOR_SR_P, BOOST_PP_FOR_SR_O, BOOST_PP_FOR_SR_M))
+#
+# define BOOST_PP_FOR_SR_P(r, s) s
+# define BOOST_PP_FOR_SR_O(r, s) 0
+# define BOOST_PP_FOR_SR_M(r, s) BOOST_PP_NIL
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    include <boost/preprocessor/repetition/detail/edg/for.hpp>
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    include <boost/preprocessor/repetition/detail/msvc/for.hpp>
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_DMC()
+#    include <boost/preprocessor/repetition/detail/dmc/for.hpp>
+# else
+#    include <boost/preprocessor/repetition/detail/for.hpp>
+# endif
+#
+# define BOOST_PP_FOR_257(s, p, o, m) BOOST_PP_ERROR(0x0002)
+#
+# define BOOST_PP_FOR_CHECK_BOOST_PP_NIL 1
+#
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_1(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_2(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_3(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_4(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_5(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_6(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_7(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_8(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_9(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_10(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_11(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_12(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_13(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_14(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_15(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_16(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_17(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_18(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_19(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_20(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_21(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_22(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_23(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_24(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_25(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_26(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_27(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_28(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_29(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_30(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_31(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_32(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_33(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_34(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_35(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_36(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_37(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_38(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_39(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_40(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_41(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_42(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_43(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_44(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_45(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_46(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_47(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_48(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_49(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_50(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_51(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_52(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_53(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_54(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_55(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_56(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_57(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_58(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_59(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_60(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_61(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_62(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_63(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_64(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_65(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_66(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_67(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_68(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_69(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_70(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_71(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_72(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_73(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_74(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_75(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_76(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_77(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_78(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_79(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_80(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_81(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_82(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_83(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_84(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_85(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_86(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_87(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_88(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_89(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_90(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_91(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_92(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_93(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_94(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_95(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_96(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_97(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_98(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_99(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_100(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_101(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_102(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_103(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_104(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_105(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_106(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_107(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_108(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_109(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_110(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_111(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_112(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_113(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_114(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_115(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_116(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_117(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_118(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_119(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_120(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_121(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_122(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_123(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_124(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_125(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_126(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_127(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_128(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_129(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_130(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_131(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_132(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_133(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_134(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_135(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_136(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_137(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_138(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_139(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_140(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_141(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_142(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_143(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_144(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_145(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_146(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_147(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_148(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_149(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_150(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_151(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_152(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_153(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_154(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_155(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_156(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_157(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_158(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_159(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_160(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_161(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_162(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_163(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_164(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_165(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_166(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_167(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_168(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_169(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_170(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_171(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_172(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_173(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_174(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_175(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_176(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_177(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_178(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_179(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_180(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_181(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_182(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_183(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_184(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_185(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_186(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_187(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_188(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_189(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_190(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_191(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_192(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_193(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_194(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_195(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_196(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_197(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_198(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_199(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_200(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_201(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_202(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_203(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_204(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_205(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_206(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_207(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_208(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_209(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_210(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_211(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_212(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_213(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_214(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_215(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_216(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_217(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_218(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_219(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_220(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_221(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_222(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_223(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_224(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_225(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_226(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_227(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_228(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_229(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_230(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_231(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_232(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_233(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_234(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_235(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_236(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_237(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_238(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_239(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_240(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_241(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_242(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_243(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_244(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_245(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_246(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_247(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_248(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_249(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_250(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_251(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_252(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_253(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_254(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_255(s, p, o, m) 0
+# define BOOST_PP_FOR_CHECK_BOOST_PP_FOR_256(s, p, o, m) 0
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_params.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_params.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/repetition/enum_params.hpp	(working copy)
@@ -0,0 +1,41 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_REPETITION_ENUM_PARAMS_HPP
+# define BOOST_PREPROCESSOR_REPETITION_ENUM_PARAMS_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/punctuation/comma_if.hpp>
+# include <boost/preprocessor/repetition/repeat.hpp>
+#
+# /* BOOST_PP_ENUM_PARAMS */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_PARAMS(count, param) BOOST_PP_REPEAT(count, BOOST_PP_ENUM_PARAMS_M, param)
+# else
+#    define BOOST_PP_ENUM_PARAMS(count, param) BOOST_PP_ENUM_PARAMS_I(count, param)
+#    define BOOST_PP_ENUM_PARAMS_I(count, param) BOOST_PP_REPEAT(count, BOOST_PP_ENUM_PARAMS_M, param)
+# endif
+#
+# define BOOST_PP_ENUM_PARAMS_M(z, n, param) BOOST_PP_COMMA_IF(n) param ## n
+#
+# /* BOOST_PP_ENUM_PARAMS_Z */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ENUM_PARAMS_Z(z, count, param) BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_PARAMS_M, param)
+# else
+#    define BOOST_PP_ENUM_PARAMS_Z(z, count, param) BOOST_PP_ENUM_PARAMS_Z_I(z, count, param)
+#    define BOOST_PP_ENUM_PARAMS_Z_I(z, count, param) BOOST_PP_REPEAT_ ## z(count, BOOST_PP_ENUM_PARAMS_M, param)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/size.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/size.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/size.hpp	(working copy)
@@ -0,0 +1,547 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SEQ_SIZE_HPP
+# define BOOST_PREPROCESSOR_SEQ_SIZE_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_SEQ_SIZE(seq) BOOST_PP_SEQ_SIZE_I((seq))
+#    define BOOST_PP_SEQ_SIZE_I(par) BOOST_PP_SEQ_SIZE_II ## par
+#    define BOOST_PP_SEQ_SIZE_II(seq) BOOST_PP_CAT(BOOST_PP_SEQ_SIZE_, BOOST_PP_SEQ_SIZE_0 ## seq)
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG() || BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_SEQ_SIZE(seq) BOOST_PP_SEQ_SIZE_I(seq)
+#    define BOOST_PP_SEQ_SIZE_I(seq) BOOST_PP_CAT(BOOST_PP_SEQ_SIZE_, BOOST_PP_SEQ_SIZE_0 seq)
+# elif defined(__IBMC__) || defined(__IBMCPP__)
+#    define BOOST_PP_SEQ_SIZE(seq) BOOST_PP_CAT(BOOST_PP_SEQ_SIZE_, BOOST_PP_CAT(BOOST_PP_SEQ_SIZE_0, seq))
+# else
+#    define BOOST_PP_SEQ_SIZE(seq) BOOST_PP_CAT(BOOST_PP_SEQ_SIZE_, BOOST_PP_SEQ_SIZE_0 seq)
+# endif
+#
+# define BOOST_PP_SEQ_SIZE_0(_) BOOST_PP_SEQ_SIZE_1
+# define BOOST_PP_SEQ_SIZE_1(_) BOOST_PP_SEQ_SIZE_2
+# define BOOST_PP_SEQ_SIZE_2(_) BOOST_PP_SEQ_SIZE_3
+# define BOOST_PP_SEQ_SIZE_3(_) BOOST_PP_SEQ_SIZE_4
+# define BOOST_PP_SEQ_SIZE_4(_) BOOST_PP_SEQ_SIZE_5
+# define BOOST_PP_SEQ_SIZE_5(_) BOOST_PP_SEQ_SIZE_6
+# define BOOST_PP_SEQ_SIZE_6(_) BOOST_PP_SEQ_SIZE_7
+# define BOOST_PP_SEQ_SIZE_7(_) BOOST_PP_SEQ_SIZE_8
+# define BOOST_PP_SEQ_SIZE_8(_) BOOST_PP_SEQ_SIZE_9
+# define BOOST_PP_SEQ_SIZE_9(_) BOOST_PP_SEQ_SIZE_10
+# define BOOST_PP_SEQ_SIZE_10(_) BOOST_PP_SEQ_SIZE_11
+# define BOOST_PP_SEQ_SIZE_11(_) BOOST_PP_SEQ_SIZE_12
+# define BOOST_PP_SEQ_SIZE_12(_) BOOST_PP_SEQ_SIZE_13
+# define BOOST_PP_SEQ_SIZE_13(_) BOOST_PP_SEQ_SIZE_14
+# define BOOST_PP_SEQ_SIZE_14(_) BOOST_PP_SEQ_SIZE_15
+# define BOOST_PP_SEQ_SIZE_15(_) BOOST_PP_SEQ_SIZE_16
+# define BOOST_PP_SEQ_SIZE_16(_) BOOST_PP_SEQ_SIZE_17
+# define BOOST_PP_SEQ_SIZE_17(_) BOOST_PP_SEQ_SIZE_18
+# define BOOST_PP_SEQ_SIZE_18(_) BOOST_PP_SEQ_SIZE_19
+# define BOOST_PP_SEQ_SIZE_19(_) BOOST_PP_SEQ_SIZE_20
+# define BOOST_PP_SEQ_SIZE_20(_) BOOST_PP_SEQ_SIZE_21
+# define BOOST_PP_SEQ_SIZE_21(_) BOOST_PP_SEQ_SIZE_22
+# define BOOST_PP_SEQ_SIZE_22(_) BOOST_PP_SEQ_SIZE_23
+# define BOOST_PP_SEQ_SIZE_23(_) BOOST_PP_SEQ_SIZE_24
+# define BOOST_PP_SEQ_SIZE_24(_) BOOST_PP_SEQ_SIZE_25
+# define BOOST_PP_SEQ_SIZE_25(_) BOOST_PP_SEQ_SIZE_26
+# define BOOST_PP_SEQ_SIZE_26(_) BOOST_PP_SEQ_SIZE_27
+# define BOOST_PP_SEQ_SIZE_27(_) BOOST_PP_SEQ_SIZE_28
+# define BOOST_PP_SEQ_SIZE_28(_) BOOST_PP_SEQ_SIZE_29
+# define BOOST_PP_SEQ_SIZE_29(_) BOOST_PP_SEQ_SIZE_30
+# define BOOST_PP_SEQ_SIZE_30(_) BOOST_PP_SEQ_SIZE_31
+# define BOOST_PP_SEQ_SIZE_31(_) BOOST_PP_SEQ_SIZE_32
+# define BOOST_PP_SEQ_SIZE_32(_) BOOST_PP_SEQ_SIZE_33
+# define BOOST_PP_SEQ_SIZE_33(_) BOOST_PP_SEQ_SIZE_34
+# define BOOST_PP_SEQ_SIZE_34(_) BOOST_PP_SEQ_SIZE_35
+# define BOOST_PP_SEQ_SIZE_35(_) BOOST_PP_SEQ_SIZE_36
+# define BOOST_PP_SEQ_SIZE_36(_) BOOST_PP_SEQ_SIZE_37
+# define BOOST_PP_SEQ_SIZE_37(_) BOOST_PP_SEQ_SIZE_38
+# define BOOST_PP_SEQ_SIZE_38(_) BOOST_PP_SEQ_SIZE_39
+# define BOOST_PP_SEQ_SIZE_39(_) BOOST_PP_SEQ_SIZE_40
+# define BOOST_PP_SEQ_SIZE_40(_) BOOST_PP_SEQ_SIZE_41
+# define BOOST_PP_SEQ_SIZE_41(_) BOOST_PP_SEQ_SIZE_42
+# define BOOST_PP_SEQ_SIZE_42(_) BOOST_PP_SEQ_SIZE_43
+# define BOOST_PP_SEQ_SIZE_43(_) BOOST_PP_SEQ_SIZE_44
+# define BOOST_PP_SEQ_SIZE_44(_) BOOST_PP_SEQ_SIZE_45
+# define BOOST_PP_SEQ_SIZE_45(_) BOOST_PP_SEQ_SIZE_46
+# define BOOST_PP_SEQ_SIZE_46(_) BOOST_PP_SEQ_SIZE_47
+# define BOOST_PP_SEQ_SIZE_47(_) BOOST_PP_SEQ_SIZE_48
+# define BOOST_PP_SEQ_SIZE_48(_) BOOST_PP_SEQ_SIZE_49
+# define BOOST_PP_SEQ_SIZE_49(_) BOOST_PP_SEQ_SIZE_50
+# define BOOST_PP_SEQ_SIZE_50(_) BOOST_PP_SEQ_SIZE_51
+# define BOOST_PP_SEQ_SIZE_51(_) BOOST_PP_SEQ_SIZE_52
+# define BOOST_PP_SEQ_SIZE_52(_) BOOST_PP_SEQ_SIZE_53
+# define BOOST_PP_SEQ_SIZE_53(_) BOOST_PP_SEQ_SIZE_54
+# define BOOST_PP_SEQ_SIZE_54(_) BOOST_PP_SEQ_SIZE_55
+# define BOOST_PP_SEQ_SIZE_55(_) BOOST_PP_SEQ_SIZE_56
+# define BOOST_PP_SEQ_SIZE_56(_) BOOST_PP_SEQ_SIZE_57
+# define BOOST_PP_SEQ_SIZE_57(_) BOOST_PP_SEQ_SIZE_58
+# define BOOST_PP_SEQ_SIZE_58(_) BOOST_PP_SEQ_SIZE_59
+# define BOOST_PP_SEQ_SIZE_59(_) BOOST_PP_SEQ_SIZE_60
+# define BOOST_PP_SEQ_SIZE_60(_) BOOST_PP_SEQ_SIZE_61
+# define BOOST_PP_SEQ_SIZE_61(_) BOOST_PP_SEQ_SIZE_62
+# define BOOST_PP_SEQ_SIZE_62(_) BOOST_PP_SEQ_SIZE_63
+# define BOOST_PP_SEQ_SIZE_63(_) BOOST_PP_SEQ_SIZE_64
+# define BOOST_PP_SEQ_SIZE_64(_) BOOST_PP_SEQ_SIZE_65
+# define BOOST_PP_SEQ_SIZE_65(_) BOOST_PP_SEQ_SIZE_66
+# define BOOST_PP_SEQ_SIZE_66(_) BOOST_PP_SEQ_SIZE_67
+# define BOOST_PP_SEQ_SIZE_67(_) BOOST_PP_SEQ_SIZE_68
+# define BOOST_PP_SEQ_SIZE_68(_) BOOST_PP_SEQ_SIZE_69
+# define BOOST_PP_SEQ_SIZE_69(_) BOOST_PP_SEQ_SIZE_70
+# define BOOST_PP_SEQ_SIZE_70(_) BOOST_PP_SEQ_SIZE_71
+# define BOOST_PP_SEQ_SIZE_71(_) BOOST_PP_SEQ_SIZE_72
+# define BOOST_PP_SEQ_SIZE_72(_) BOOST_PP_SEQ_SIZE_73
+# define BOOST_PP_SEQ_SIZE_73(_) BOOST_PP_SEQ_SIZE_74
+# define BOOST_PP_SEQ_SIZE_74(_) BOOST_PP_SEQ_SIZE_75
+# define BOOST_PP_SEQ_SIZE_75(_) BOOST_PP_SEQ_SIZE_76
+# define BOOST_PP_SEQ_SIZE_76(_) BOOST_PP_SEQ_SIZE_77
+# define BOOST_PP_SEQ_SIZE_77(_) BOOST_PP_SEQ_SIZE_78
+# define BOOST_PP_SEQ_SIZE_78(_) BOOST_PP_SEQ_SIZE_79
+# define BOOST_PP_SEQ_SIZE_79(_) BOOST_PP_SEQ_SIZE_80
+# define BOOST_PP_SEQ_SIZE_80(_) BOOST_PP_SEQ_SIZE_81
+# define BOOST_PP_SEQ_SIZE_81(_) BOOST_PP_SEQ_SIZE_82
+# define BOOST_PP_SEQ_SIZE_82(_) BOOST_PP_SEQ_SIZE_83
+# define BOOST_PP_SEQ_SIZE_83(_) BOOST_PP_SEQ_SIZE_84
+# define BOOST_PP_SEQ_SIZE_84(_) BOOST_PP_SEQ_SIZE_85
+# define BOOST_PP_SEQ_SIZE_85(_) BOOST_PP_SEQ_SIZE_86
+# define BOOST_PP_SEQ_SIZE_86(_) BOOST_PP_SEQ_SIZE_87
+# define BOOST_PP_SEQ_SIZE_87(_) BOOST_PP_SEQ_SIZE_88
+# define BOOST_PP_SEQ_SIZE_88(_) BOOST_PP_SEQ_SIZE_89
+# define BOOST_PP_SEQ_SIZE_89(_) BOOST_PP_SEQ_SIZE_90
+# define BOOST_PP_SEQ_SIZE_90(_) BOOST_PP_SEQ_SIZE_91
+# define BOOST_PP_SEQ_SIZE_91(_) BOOST_PP_SEQ_SIZE_92
+# define BOOST_PP_SEQ_SIZE_92(_) BOOST_PP_SEQ_SIZE_93
+# define BOOST_PP_SEQ_SIZE_93(_) BOOST_PP_SEQ_SIZE_94
+# define BOOST_PP_SEQ_SIZE_94(_) BOOST_PP_SEQ_SIZE_95
+# define BOOST_PP_SEQ_SIZE_95(_) BOOST_PP_SEQ_SIZE_96
+# define BOOST_PP_SEQ_SIZE_96(_) BOOST_PP_SEQ_SIZE_97
+# define BOOST_PP_SEQ_SIZE_97(_) BOOST_PP_SEQ_SIZE_98
+# define BOOST_PP_SEQ_SIZE_98(_) BOOST_PP_SEQ_SIZE_99
+# define BOOST_PP_SEQ_SIZE_99(_) BOOST_PP_SEQ_SIZE_100
+# define BOOST_PP_SEQ_SIZE_100(_) BOOST_PP_SEQ_SIZE_101
+# define BOOST_PP_SEQ_SIZE_101(_) BOOST_PP_SEQ_SIZE_102
+# define BOOST_PP_SEQ_SIZE_102(_) BOOST_PP_SEQ_SIZE_103
+# define BOOST_PP_SEQ_SIZE_103(_) BOOST_PP_SEQ_SIZE_104
+# define BOOST_PP_SEQ_SIZE_104(_) BOOST_PP_SEQ_SIZE_105
+# define BOOST_PP_SEQ_SIZE_105(_) BOOST_PP_SEQ_SIZE_106
+# define BOOST_PP_SEQ_SIZE_106(_) BOOST_PP_SEQ_SIZE_107
+# define BOOST_PP_SEQ_SIZE_107(_) BOOST_PP_SEQ_SIZE_108
+# define BOOST_PP_SEQ_SIZE_108(_) BOOST_PP_SEQ_SIZE_109
+# define BOOST_PP_SEQ_SIZE_109(_) BOOST_PP_SEQ_SIZE_110
+# define BOOST_PP_SEQ_SIZE_110(_) BOOST_PP_SEQ_SIZE_111
+# define BOOST_PP_SEQ_SIZE_111(_) BOOST_PP_SEQ_SIZE_112
+# define BOOST_PP_SEQ_SIZE_112(_) BOOST_PP_SEQ_SIZE_113
+# define BOOST_PP_SEQ_SIZE_113(_) BOOST_PP_SEQ_SIZE_114
+# define BOOST_PP_SEQ_SIZE_114(_) BOOST_PP_SEQ_SIZE_115
+# define BOOST_PP_SEQ_SIZE_115(_) BOOST_PP_SEQ_SIZE_116
+# define BOOST_PP_SEQ_SIZE_116(_) BOOST_PP_SEQ_SIZE_117
+# define BOOST_PP_SEQ_SIZE_117(_) BOOST_PP_SEQ_SIZE_118
+# define BOOST_PP_SEQ_SIZE_118(_) BOOST_PP_SEQ_SIZE_119
+# define BOOST_PP_SEQ_SIZE_119(_) BOOST_PP_SEQ_SIZE_120
+# define BOOST_PP_SEQ_SIZE_120(_) BOOST_PP_SEQ_SIZE_121
+# define BOOST_PP_SEQ_SIZE_121(_) BOOST_PP_SEQ_SIZE_122
+# define BOOST_PP_SEQ_SIZE_122(_) BOOST_PP_SEQ_SIZE_123
+# define BOOST_PP_SEQ_SIZE_123(_) BOOST_PP_SEQ_SIZE_124
+# define BOOST_PP_SEQ_SIZE_124(_) BOOST_PP_SEQ_SIZE_125
+# define BOOST_PP_SEQ_SIZE_125(_) BOOST_PP_SEQ_SIZE_126
+# define BOOST_PP_SEQ_SIZE_126(_) BOOST_PP_SEQ_SIZE_127
+# define BOOST_PP_SEQ_SIZE_127(_) BOOST_PP_SEQ_SIZE_128
+# define BOOST_PP_SEQ_SIZE_128(_) BOOST_PP_SEQ_SIZE_129
+# define BOOST_PP_SEQ_SIZE_129(_) BOOST_PP_SEQ_SIZE_130
+# define BOOST_PP_SEQ_SIZE_130(_) BOOST_PP_SEQ_SIZE_131
+# define BOOST_PP_SEQ_SIZE_131(_) BOOST_PP_SEQ_SIZE_132
+# define BOOST_PP_SEQ_SIZE_132(_) BOOST_PP_SEQ_SIZE_133
+# define BOOST_PP_SEQ_SIZE_133(_) BOOST_PP_SEQ_SIZE_134
+# define BOOST_PP_SEQ_SIZE_134(_) BOOST_PP_SEQ_SIZE_135
+# define BOOST_PP_SEQ_SIZE_135(_) BOOST_PP_SEQ_SIZE_136
+# define BOOST_PP_SEQ_SIZE_136(_) BOOST_PP_SEQ_SIZE_137
+# define BOOST_PP_SEQ_SIZE_137(_) BOOST_PP_SEQ_SIZE_138
+# define BOOST_PP_SEQ_SIZE_138(_) BOOST_PP_SEQ_SIZE_139
+# define BOOST_PP_SEQ_SIZE_139(_) BOOST_PP_SEQ_SIZE_140
+# define BOOST_PP_SEQ_SIZE_140(_) BOOST_PP_SEQ_SIZE_141
+# define BOOST_PP_SEQ_SIZE_141(_) BOOST_PP_SEQ_SIZE_142
+# define BOOST_PP_SEQ_SIZE_142(_) BOOST_PP_SEQ_SIZE_143
+# define BOOST_PP_SEQ_SIZE_143(_) BOOST_PP_SEQ_SIZE_144
+# define BOOST_PP_SEQ_SIZE_144(_) BOOST_PP_SEQ_SIZE_145
+# define BOOST_PP_SEQ_SIZE_145(_) BOOST_PP_SEQ_SIZE_146
+# define BOOST_PP_SEQ_SIZE_146(_) BOOST_PP_SEQ_SIZE_147
+# define BOOST_PP_SEQ_SIZE_147(_) BOOST_PP_SEQ_SIZE_148
+# define BOOST_PP_SEQ_SIZE_148(_) BOOST_PP_SEQ_SIZE_149
+# define BOOST_PP_SEQ_SIZE_149(_) BOOST_PP_SEQ_SIZE_150
+# define BOOST_PP_SEQ_SIZE_150(_) BOOST_PP_SEQ_SIZE_151
+# define BOOST_PP_SEQ_SIZE_151(_) BOOST_PP_SEQ_SIZE_152
+# define BOOST_PP_SEQ_SIZE_152(_) BOOST_PP_SEQ_SIZE_153
+# define BOOST_PP_SEQ_SIZE_153(_) BOOST_PP_SEQ_SIZE_154
+# define BOOST_PP_SEQ_SIZE_154(_) BOOST_PP_SEQ_SIZE_155
+# define BOOST_PP_SEQ_SIZE_155(_) BOOST_PP_SEQ_SIZE_156
+# define BOOST_PP_SEQ_SIZE_156(_) BOOST_PP_SEQ_SIZE_157
+# define BOOST_PP_SEQ_SIZE_157(_) BOOST_PP_SEQ_SIZE_158
+# define BOOST_PP_SEQ_SIZE_158(_) BOOST_PP_SEQ_SIZE_159
+# define BOOST_PP_SEQ_SIZE_159(_) BOOST_PP_SEQ_SIZE_160
+# define BOOST_PP_SEQ_SIZE_160(_) BOOST_PP_SEQ_SIZE_161
+# define BOOST_PP_SEQ_SIZE_161(_) BOOST_PP_SEQ_SIZE_162
+# define BOOST_PP_SEQ_SIZE_162(_) BOOST_PP_SEQ_SIZE_163
+# define BOOST_PP_SEQ_SIZE_163(_) BOOST_PP_SEQ_SIZE_164
+# define BOOST_PP_SEQ_SIZE_164(_) BOOST_PP_SEQ_SIZE_165
+# define BOOST_PP_SEQ_SIZE_165(_) BOOST_PP_SEQ_SIZE_166
+# define BOOST_PP_SEQ_SIZE_166(_) BOOST_PP_SEQ_SIZE_167
+# define BOOST_PP_SEQ_SIZE_167(_) BOOST_PP_SEQ_SIZE_168
+# define BOOST_PP_SEQ_SIZE_168(_) BOOST_PP_SEQ_SIZE_169
+# define BOOST_PP_SEQ_SIZE_169(_) BOOST_PP_SEQ_SIZE_170
+# define BOOST_PP_SEQ_SIZE_170(_) BOOST_PP_SEQ_SIZE_171
+# define BOOST_PP_SEQ_SIZE_171(_) BOOST_PP_SEQ_SIZE_172
+# define BOOST_PP_SEQ_SIZE_172(_) BOOST_PP_SEQ_SIZE_173
+# define BOOST_PP_SEQ_SIZE_173(_) BOOST_PP_SEQ_SIZE_174
+# define BOOST_PP_SEQ_SIZE_174(_) BOOST_PP_SEQ_SIZE_175
+# define BOOST_PP_SEQ_SIZE_175(_) BOOST_PP_SEQ_SIZE_176
+# define BOOST_PP_SEQ_SIZE_176(_) BOOST_PP_SEQ_SIZE_177
+# define BOOST_PP_SEQ_SIZE_177(_) BOOST_PP_SEQ_SIZE_178
+# define BOOST_PP_SEQ_SIZE_178(_) BOOST_PP_SEQ_SIZE_179
+# define BOOST_PP_SEQ_SIZE_179(_) BOOST_PP_SEQ_SIZE_180
+# define BOOST_PP_SEQ_SIZE_180(_) BOOST_PP_SEQ_SIZE_181
+# define BOOST_PP_SEQ_SIZE_181(_) BOOST_PP_SEQ_SIZE_182
+# define BOOST_PP_SEQ_SIZE_182(_) BOOST_PP_SEQ_SIZE_183
+# define BOOST_PP_SEQ_SIZE_183(_) BOOST_PP_SEQ_SIZE_184
+# define BOOST_PP_SEQ_SIZE_184(_) BOOST_PP_SEQ_SIZE_185
+# define BOOST_PP_SEQ_SIZE_185(_) BOOST_PP_SEQ_SIZE_186
+# define BOOST_PP_SEQ_SIZE_186(_) BOOST_PP_SEQ_SIZE_187
+# define BOOST_PP_SEQ_SIZE_187(_) BOOST_PP_SEQ_SIZE_188
+# define BOOST_PP_SEQ_SIZE_188(_) BOOST_PP_SEQ_SIZE_189
+# define BOOST_PP_SEQ_SIZE_189(_) BOOST_PP_SEQ_SIZE_190
+# define BOOST_PP_SEQ_SIZE_190(_) BOOST_PP_SEQ_SIZE_191
+# define BOOST_PP_SEQ_SIZE_191(_) BOOST_PP_SEQ_SIZE_192
+# define BOOST_PP_SEQ_SIZE_192(_) BOOST_PP_SEQ_SIZE_193
+# define BOOST_PP_SEQ_SIZE_193(_) BOOST_PP_SEQ_SIZE_194
+# define BOOST_PP_SEQ_SIZE_194(_) BOOST_PP_SEQ_SIZE_195
+# define BOOST_PP_SEQ_SIZE_195(_) BOOST_PP_SEQ_SIZE_196
+# define BOOST_PP_SEQ_SIZE_196(_) BOOST_PP_SEQ_SIZE_197
+# define BOOST_PP_SEQ_SIZE_197(_) BOOST_PP_SEQ_SIZE_198
+# define BOOST_PP_SEQ_SIZE_198(_) BOOST_PP_SEQ_SIZE_199
+# define BOOST_PP_SEQ_SIZE_199(_) BOOST_PP_SEQ_SIZE_200
+# define BOOST_PP_SEQ_SIZE_200(_) BOOST_PP_SEQ_SIZE_201
+# define BOOST_PP_SEQ_SIZE_201(_) BOOST_PP_SEQ_SIZE_202
+# define BOOST_PP_SEQ_SIZE_202(_) BOOST_PP_SEQ_SIZE_203
+# define BOOST_PP_SEQ_SIZE_203(_) BOOST_PP_SEQ_SIZE_204
+# define BOOST_PP_SEQ_SIZE_204(_) BOOST_PP_SEQ_SIZE_205
+# define BOOST_PP_SEQ_SIZE_205(_) BOOST_PP_SEQ_SIZE_206
+# define BOOST_PP_SEQ_SIZE_206(_) BOOST_PP_SEQ_SIZE_207
+# define BOOST_PP_SEQ_SIZE_207(_) BOOST_PP_SEQ_SIZE_208
+# define BOOST_PP_SEQ_SIZE_208(_) BOOST_PP_SEQ_SIZE_209
+# define BOOST_PP_SEQ_SIZE_209(_) BOOST_PP_SEQ_SIZE_210
+# define BOOST_PP_SEQ_SIZE_210(_) BOOST_PP_SEQ_SIZE_211
+# define BOOST_PP_SEQ_SIZE_211(_) BOOST_PP_SEQ_SIZE_212
+# define BOOST_PP_SEQ_SIZE_212(_) BOOST_PP_SEQ_SIZE_213
+# define BOOST_PP_SEQ_SIZE_213(_) BOOST_PP_SEQ_SIZE_214
+# define BOOST_PP_SEQ_SIZE_214(_) BOOST_PP_SEQ_SIZE_215
+# define BOOST_PP_SEQ_SIZE_215(_) BOOST_PP_SEQ_SIZE_216
+# define BOOST_PP_SEQ_SIZE_216(_) BOOST_PP_SEQ_SIZE_217
+# define BOOST_PP_SEQ_SIZE_217(_) BOOST_PP_SEQ_SIZE_218
+# define BOOST_PP_SEQ_SIZE_218(_) BOOST_PP_SEQ_SIZE_219
+# define BOOST_PP_SEQ_SIZE_219(_) BOOST_PP_SEQ_SIZE_220
+# define BOOST_PP_SEQ_SIZE_220(_) BOOST_PP_SEQ_SIZE_221
+# define BOOST_PP_SEQ_SIZE_221(_) BOOST_PP_SEQ_SIZE_222
+# define BOOST_PP_SEQ_SIZE_222(_) BOOST_PP_SEQ_SIZE_223
+# define BOOST_PP_SEQ_SIZE_223(_) BOOST_PP_SEQ_SIZE_224
+# define BOOST_PP_SEQ_SIZE_224(_) BOOST_PP_SEQ_SIZE_225
+# define BOOST_PP_SEQ_SIZE_225(_) BOOST_PP_SEQ_SIZE_226
+# define BOOST_PP_SEQ_SIZE_226(_) BOOST_PP_SEQ_SIZE_227
+# define BOOST_PP_SEQ_SIZE_227(_) BOOST_PP_SEQ_SIZE_228
+# define BOOST_PP_SEQ_SIZE_228(_) BOOST_PP_SEQ_SIZE_229
+# define BOOST_PP_SEQ_SIZE_229(_) BOOST_PP_SEQ_SIZE_230
+# define BOOST_PP_SEQ_SIZE_230(_) BOOST_PP_SEQ_SIZE_231
+# define BOOST_PP_SEQ_SIZE_231(_) BOOST_PP_SEQ_SIZE_232
+# define BOOST_PP_SEQ_SIZE_232(_) BOOST_PP_SEQ_SIZE_233
+# define BOOST_PP_SEQ_SIZE_233(_) BOOST_PP_SEQ_SIZE_234
+# define BOOST_PP_SEQ_SIZE_234(_) BOOST_PP_SEQ_SIZE_235
+# define BOOST_PP_SEQ_SIZE_235(_) BOOST_PP_SEQ_SIZE_236
+# define BOOST_PP_SEQ_SIZE_236(_) BOOST_PP_SEQ_SIZE_237
+# define BOOST_PP_SEQ_SIZE_237(_) BOOST_PP_SEQ_SIZE_238
+# define BOOST_PP_SEQ_SIZE_238(_) BOOST_PP_SEQ_SIZE_239
+# define BOOST_PP_SEQ_SIZE_239(_) BOOST_PP_SEQ_SIZE_240
+# define BOOST_PP_SEQ_SIZE_240(_) BOOST_PP_SEQ_SIZE_241
+# define BOOST_PP_SEQ_SIZE_241(_) BOOST_PP_SEQ_SIZE_242
+# define BOOST_PP_SEQ_SIZE_242(_) BOOST_PP_SEQ_SIZE_243
+# define BOOST_PP_SEQ_SIZE_243(_) BOOST_PP_SEQ_SIZE_244
+# define BOOST_PP_SEQ_SIZE_244(_) BOOST_PP_SEQ_SIZE_245
+# define BOOST_PP_SEQ_SIZE_245(_) BOOST_PP_SEQ_SIZE_246
+# define BOOST_PP_SEQ_SIZE_246(_) BOOST_PP_SEQ_SIZE_247
+# define BOOST_PP_SEQ_SIZE_247(_) BOOST_PP_SEQ_SIZE_248
+# define BOOST_PP_SEQ_SIZE_248(_) BOOST_PP_SEQ_SIZE_249
+# define BOOST_PP_SEQ_SIZE_249(_) BOOST_PP_SEQ_SIZE_250
+# define BOOST_PP_SEQ_SIZE_250(_) BOOST_PP_SEQ_SIZE_251
+# define BOOST_PP_SEQ_SIZE_251(_) BOOST_PP_SEQ_SIZE_252
+# define BOOST_PP_SEQ_SIZE_252(_) BOOST_PP_SEQ_SIZE_253
+# define BOOST_PP_SEQ_SIZE_253(_) BOOST_PP_SEQ_SIZE_254
+# define BOOST_PP_SEQ_SIZE_254(_) BOOST_PP_SEQ_SIZE_255
+# define BOOST_PP_SEQ_SIZE_255(_) BOOST_PP_SEQ_SIZE_256
+# define BOOST_PP_SEQ_SIZE_256(_) BOOST_PP_SEQ_SIZE_257
+#
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_0 0
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_1 1
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_2 2
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_3 3
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_4 4
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_5 5
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_6 6
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_7 7
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_8 8
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_9 9
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_10 10
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_11 11
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_12 12
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_13 13
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_14 14
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_15 15
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_16 16
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_17 17
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_18 18
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_19 19
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_20 20
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_21 21
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_22 22
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_23 23
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_24 24
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_25 25
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_26 26
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_27 27
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_28 28
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_29 29
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_30 30
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_31 31
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_32 32
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_33 33
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_34 34
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_35 35
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_36 36
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_37 37
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_38 38
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_39 39
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_40 40
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_41 41
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_42 42
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_43 43
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_44 44
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_45 45
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_46 46
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_47 47
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_48 48
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_49 49
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_50 50
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_51 51
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_52 52
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_53 53
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_54 54
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_55 55
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_56 56
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_57 57
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_58 58
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_59 59
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_60 60
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_61 61
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_62 62
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_63 63
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_64 64
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_65 65
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_66 66
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_67 67
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_68 68
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_69 69
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_70 70
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_71 71
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_72 72
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_73 73
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_74 74
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_75 75
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_76 76
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_77 77
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_78 78
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_79 79
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_80 80
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_81 81
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_82 82
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_83 83
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_84 84
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_85 85
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_86 86
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_87 87
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_88 88
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_89 89
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_90 90
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_91 91
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_92 92
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_93 93
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_94 94
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_95 95
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_96 96
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_97 97
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_98 98
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_99 99
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_100 100
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_101 101
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_102 102
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_103 103
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_104 104
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_105 105
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_106 106
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_107 107
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_108 108
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_109 109
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_110 110
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_111 111
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_112 112
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_113 113
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_114 114
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_115 115
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_116 116
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_117 117
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_118 118
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_119 119
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_120 120
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_121 121
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_122 122
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_123 123
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_124 124
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_125 125
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_126 126
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_127 127
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_128 128
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_129 129
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_130 130
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_131 131
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_132 132
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_133 133
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_134 134
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_135 135
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_136 136
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_137 137
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_138 138
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_139 139
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_140 140
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_141 141
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_142 142
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_143 143
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_144 144
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_145 145
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_146 146
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_147 147
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_148 148
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_149 149
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_150 150
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_151 151
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_152 152
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_153 153
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_154 154
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_155 155
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_156 156
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_157 157
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_158 158
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_159 159
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_160 160
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_161 161
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_162 162
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_163 163
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_164 164
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_165 165
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_166 166
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_167 167
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_168 168
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_169 169
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_170 170
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_171 171
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_172 172
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_173 173
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_174 174
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_175 175
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_176 176
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_177 177
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_178 178
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_179 179
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_180 180
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_181 181
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_182 182
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_183 183
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_184 184
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_185 185
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_186 186
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_187 187
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_188 188
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_189 189
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_190 190
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_191 191
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_192 192
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_193 193
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_194 194
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_195 195
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_196 196
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_197 197
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_198 198
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_199 199
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_200 200
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_201 201
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_202 202
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_203 203
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_204 204
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_205 205
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_206 206
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_207 207
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_208 208
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_209 209
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_210 210
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_211 211
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_212 212
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_213 213
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_214 214
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_215 215
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_216 216
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_217 217
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_218 218
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_219 219
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_220 220
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_221 221
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_222 222
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_223 223
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_224 224
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_225 225
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_226 226
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_227 227
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_228 228
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_229 229
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_230 230
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_231 231
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_232 232
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_233 233
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_234 234
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_235 235
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_236 236
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_237 237
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_238 238
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_239 239
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_240 240
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_241 241
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_242 242
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_243 243
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_244 244
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_245 245
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_246 246
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_247 247
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_248 248
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_249 249
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_250 250
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_251 251
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_252 252
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_253 253
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_254 254
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_255 255
+# define BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_256 256
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/for_each_i.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/for_each_i.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/for_each_i.hpp	(working copy)
@@ -0,0 +1,61 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SEQ_FOR_EACH_I_HPP
+# define BOOST_PREPROCESSOR_SEQ_FOR_EACH_I_HPP
+#
+# include <boost/preprocessor/arithmetic/dec.hpp>
+# include <boost/preprocessor/arithmetic/inc.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/repetition/for.hpp>
+# include <boost/preprocessor/seq/seq.hpp>
+# include <boost/preprocessor/seq/size.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+# include <boost/preprocessor/tuple/rem.hpp>
+#
+# /* BOOST_PP_SEQ_FOR_EACH_I */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_SEQ_FOR_EACH_I(macro, data, seq) BOOST_PP_FOR((macro, data, seq (nil), 0), BOOST_PP_SEQ_FOR_EACH_I_P, BOOST_PP_SEQ_FOR_EACH_I_O, BOOST_PP_SEQ_FOR_EACH_I_M)
+# else
+#    define BOOST_PP_SEQ_FOR_EACH_I(macro, data, seq) BOOST_PP_SEQ_FOR_EACH_I_I(macro, data, seq)
+#    define BOOST_PP_SEQ_FOR_EACH_I_I(macro, data, seq) BOOST_PP_FOR((macro, data, seq (nil), 0), BOOST_PP_SEQ_FOR_EACH_I_P, BOOST_PP_SEQ_FOR_EACH_I_O, BOOST_PP_SEQ_FOR_EACH_I_M)
+# endif
+#
+# define BOOST_PP_SEQ_FOR_EACH_I_P(r, x) BOOST_PP_DEC(BOOST_PP_SEQ_SIZE(BOOST_PP_TUPLE_ELEM(4, 2, x)))
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_STRICT()
+#    define BOOST_PP_SEQ_FOR_EACH_I_O(r, x) BOOST_PP_SEQ_FOR_EACH_I_O_I x
+# else
+#    define BOOST_PP_SEQ_FOR_EACH_I_O(r, x) BOOST_PP_SEQ_FOR_EACH_I_O_I(BOOST_PP_TUPLE_ELEM(4, 0, x), BOOST_PP_TUPLE_ELEM(4, 1, x), BOOST_PP_TUPLE_ELEM(4, 2, x), BOOST_PP_TUPLE_ELEM(4, 3, x))
+# endif
+#
+# define BOOST_PP_SEQ_FOR_EACH_I_O_I(macro, data, seq, i) (macro, data, BOOST_PP_SEQ_TAIL(seq), BOOST_PP_INC(i))
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_STRICT()
+#    define BOOST_PP_SEQ_FOR_EACH_I_M(r, x) BOOST_PP_SEQ_FOR_EACH_I_M_IM(r, BOOST_PP_TUPLE_REM_4 x)
+#    define BOOST_PP_SEQ_FOR_EACH_I_M_IM(r, im) BOOST_PP_SEQ_FOR_EACH_I_M_I(r, im)
+# else
+#    define BOOST_PP_SEQ_FOR_EACH_I_M(r, x) BOOST_PP_SEQ_FOR_EACH_I_M_I(r, BOOST_PP_TUPLE_ELEM(4, 0, x), BOOST_PP_TUPLE_ELEM(4, 1, x), BOOST_PP_TUPLE_ELEM(4, 2, x), BOOST_PP_TUPLE_ELEM(4, 3, x))
+# endif
+#
+# define BOOST_PP_SEQ_FOR_EACH_I_M_I(r, macro, data, seq, i) macro(r, data, i, BOOST_PP_SEQ_HEAD(seq))
+#
+# /* BOOST_PP_SEQ_FOR_EACH_I_R */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_SEQ_FOR_EACH_I_R(r, macro, data, seq) BOOST_PP_FOR_ ## r((macro, data, seq (nil), 0), BOOST_PP_SEQ_FOR_EACH_I_P, BOOST_PP_SEQ_FOR_EACH_I_O, BOOST_PP_SEQ_FOR_EACH_I_M)
+# else
+#    define BOOST_PP_SEQ_FOR_EACH_I_R(r, macro, data, seq) BOOST_PP_SEQ_FOR_EACH_I_R_I(r, macro, data, seq)
+#    define BOOST_PP_SEQ_FOR_EACH_I_R_I(r, macro, data, seq) BOOST_PP_FOR_ ## r((macro, data, seq (nil), 0), BOOST_PP_SEQ_FOR_EACH_I_P, BOOST_PP_SEQ_FOR_EACH_I_O, BOOST_PP_SEQ_FOR_EACH_I_M)
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/elem.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/elem.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/elem.hpp	(working copy)
@@ -0,0 +1,304 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SEQ_ELEM_HPP
+# define BOOST_PREPROCESSOR_SEQ_ELEM_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/facilities/empty.hpp>
+#
+# /* BOOST_PP_SEQ_ELEM */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_SEQ_ELEM(i, seq) BOOST_PP_SEQ_ELEM_I(i, seq)
+# else
+#    define BOOST_PP_SEQ_ELEM(i, seq) BOOST_PP_SEQ_ELEM_I((i, seq))
+# endif
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_SEQ_ELEM_I(i, seq) BOOST_PP_SEQ_ELEM_II((BOOST_PP_SEQ_ELEM_ ## i seq))
+#    define BOOST_PP_SEQ_ELEM_II(res) BOOST_PP_SEQ_ELEM_IV(BOOST_PP_SEQ_ELEM_III res)
+#    define BOOST_PP_SEQ_ELEM_III(x, _) x BOOST_PP_EMPTY()
+#    define BOOST_PP_SEQ_ELEM_IV(x) x
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_SEQ_ELEM_I(par) BOOST_PP_SEQ_ELEM_II ## par
+#    define BOOST_PP_SEQ_ELEM_II(i, seq) BOOST_PP_SEQ_ELEM_III(BOOST_PP_SEQ_ELEM_ ## i ## seq)
+#    define BOOST_PP_SEQ_ELEM_III(im) BOOST_PP_SEQ_ELEM_IV(im)
+#    define BOOST_PP_SEQ_ELEM_IV(x, _) x
+# else
+#    if defined(__IBMC__) || defined(__IBMCPP__)
+#        define BOOST_PP_SEQ_ELEM_I(i, seq) BOOST_PP_SEQ_ELEM_II(BOOST_PP_CAT(BOOST_PP_SEQ_ELEM_ ## i, seq))
+#    else
+#        define BOOST_PP_SEQ_ELEM_I(i, seq) BOOST_PP_SEQ_ELEM_II(BOOST_PP_SEQ_ELEM_ ## i seq)
+#    endif
+#    define BOOST_PP_SEQ_ELEM_II(im) BOOST_PP_SEQ_ELEM_III(im)
+#    define BOOST_PP_SEQ_ELEM_III(x, _) x
+# endif
+#
+# define BOOST_PP_SEQ_ELEM_0(x) x, BOOST_PP_NIL
+# define BOOST_PP_SEQ_ELEM_1(_) BOOST_PP_SEQ_ELEM_0
+# define BOOST_PP_SEQ_ELEM_2(_) BOOST_PP_SEQ_ELEM_1
+# define BOOST_PP_SEQ_ELEM_3(_) BOOST_PP_SEQ_ELEM_2
+# define BOOST_PP_SEQ_ELEM_4(_) BOOST_PP_SEQ_ELEM_3
+# define BOOST_PP_SEQ_ELEM_5(_) BOOST_PP_SEQ_ELEM_4
+# define BOOST_PP_SEQ_ELEM_6(_) BOOST_PP_SEQ_ELEM_5
+# define BOOST_PP_SEQ_ELEM_7(_) BOOST_PP_SEQ_ELEM_6
+# define BOOST_PP_SEQ_ELEM_8(_) BOOST_PP_SEQ_ELEM_7
+# define BOOST_PP_SEQ_ELEM_9(_) BOOST_PP_SEQ_ELEM_8
+# define BOOST_PP_SEQ_ELEM_10(_) BOOST_PP_SEQ_ELEM_9
+# define BOOST_PP_SEQ_ELEM_11(_) BOOST_PP_SEQ_ELEM_10
+# define BOOST_PP_SEQ_ELEM_12(_) BOOST_PP_SEQ_ELEM_11
+# define BOOST_PP_SEQ_ELEM_13(_) BOOST_PP_SEQ_ELEM_12
+# define BOOST_PP_SEQ_ELEM_14(_) BOOST_PP_SEQ_ELEM_13
+# define BOOST_PP_SEQ_ELEM_15(_) BOOST_PP_SEQ_ELEM_14
+# define BOOST_PP_SEQ_ELEM_16(_) BOOST_PP_SEQ_ELEM_15
+# define BOOST_PP_SEQ_ELEM_17(_) BOOST_PP_SEQ_ELEM_16
+# define BOOST_PP_SEQ_ELEM_18(_) BOOST_PP_SEQ_ELEM_17
+# define BOOST_PP_SEQ_ELEM_19(_) BOOST_PP_SEQ_ELEM_18
+# define BOOST_PP_SEQ_ELEM_20(_) BOOST_PP_SEQ_ELEM_19
+# define BOOST_PP_SEQ_ELEM_21(_) BOOST_PP_SEQ_ELEM_20
+# define BOOST_PP_SEQ_ELEM_22(_) BOOST_PP_SEQ_ELEM_21
+# define BOOST_PP_SEQ_ELEM_23(_) BOOST_PP_SEQ_ELEM_22
+# define BOOST_PP_SEQ_ELEM_24(_) BOOST_PP_SEQ_ELEM_23
+# define BOOST_PP_SEQ_ELEM_25(_) BOOST_PP_SEQ_ELEM_24
+# define BOOST_PP_SEQ_ELEM_26(_) BOOST_PP_SEQ_ELEM_25
+# define BOOST_PP_SEQ_ELEM_27(_) BOOST_PP_SEQ_ELEM_26
+# define BOOST_PP_SEQ_ELEM_28(_) BOOST_PP_SEQ_ELEM_27
+# define BOOST_PP_SEQ_ELEM_29(_) BOOST_PP_SEQ_ELEM_28
+# define BOOST_PP_SEQ_ELEM_30(_) BOOST_PP_SEQ_ELEM_29
+# define BOOST_PP_SEQ_ELEM_31(_) BOOST_PP_SEQ_ELEM_30
+# define BOOST_PP_SEQ_ELEM_32(_) BOOST_PP_SEQ_ELEM_31
+# define BOOST_PP_SEQ_ELEM_33(_) BOOST_PP_SEQ_ELEM_32
+# define BOOST_PP_SEQ_ELEM_34(_) BOOST_PP_SEQ_ELEM_33
+# define BOOST_PP_SEQ_ELEM_35(_) BOOST_PP_SEQ_ELEM_34
+# define BOOST_PP_SEQ_ELEM_36(_) BOOST_PP_SEQ_ELEM_35
+# define BOOST_PP_SEQ_ELEM_37(_) BOOST_PP_SEQ_ELEM_36
+# define BOOST_PP_SEQ_ELEM_38(_) BOOST_PP_SEQ_ELEM_37
+# define BOOST_PP_SEQ_ELEM_39(_) BOOST_PP_SEQ_ELEM_38
+# define BOOST_PP_SEQ_ELEM_40(_) BOOST_PP_SEQ_ELEM_39
+# define BOOST_PP_SEQ_ELEM_41(_) BOOST_PP_SEQ_ELEM_40
+# define BOOST_PP_SEQ_ELEM_42(_) BOOST_PP_SEQ_ELEM_41
+# define BOOST_PP_SEQ_ELEM_43(_) BOOST_PP_SEQ_ELEM_42
+# define BOOST_PP_SEQ_ELEM_44(_) BOOST_PP_SEQ_ELEM_43
+# define BOOST_PP_SEQ_ELEM_45(_) BOOST_PP_SEQ_ELEM_44
+# define BOOST_PP_SEQ_ELEM_46(_) BOOST_PP_SEQ_ELEM_45
+# define BOOST_PP_SEQ_ELEM_47(_) BOOST_PP_SEQ_ELEM_46
+# define BOOST_PP_SEQ_ELEM_48(_) BOOST_PP_SEQ_ELEM_47
+# define BOOST_PP_SEQ_ELEM_49(_) BOOST_PP_SEQ_ELEM_48
+# define BOOST_PP_SEQ_ELEM_50(_) BOOST_PP_SEQ_ELEM_49
+# define BOOST_PP_SEQ_ELEM_51(_) BOOST_PP_SEQ_ELEM_50
+# define BOOST_PP_SEQ_ELEM_52(_) BOOST_PP_SEQ_ELEM_51
+# define BOOST_PP_SEQ_ELEM_53(_) BOOST_PP_SEQ_ELEM_52
+# define BOOST_PP_SEQ_ELEM_54(_) BOOST_PP_SEQ_ELEM_53
+# define BOOST_PP_SEQ_ELEM_55(_) BOOST_PP_SEQ_ELEM_54
+# define BOOST_PP_SEQ_ELEM_56(_) BOOST_PP_SEQ_ELEM_55
+# define BOOST_PP_SEQ_ELEM_57(_) BOOST_PP_SEQ_ELEM_56
+# define BOOST_PP_SEQ_ELEM_58(_) BOOST_PP_SEQ_ELEM_57
+# define BOOST_PP_SEQ_ELEM_59(_) BOOST_PP_SEQ_ELEM_58
+# define BOOST_PP_SEQ_ELEM_60(_) BOOST_PP_SEQ_ELEM_59
+# define BOOST_PP_SEQ_ELEM_61(_) BOOST_PP_SEQ_ELEM_60
+# define BOOST_PP_SEQ_ELEM_62(_) BOOST_PP_SEQ_ELEM_61
+# define BOOST_PP_SEQ_ELEM_63(_) BOOST_PP_SEQ_ELEM_62
+# define BOOST_PP_SEQ_ELEM_64(_) BOOST_PP_SEQ_ELEM_63
+# define BOOST_PP_SEQ_ELEM_65(_) BOOST_PP_SEQ_ELEM_64
+# define BOOST_PP_SEQ_ELEM_66(_) BOOST_PP_SEQ_ELEM_65
+# define BOOST_PP_SEQ_ELEM_67(_) BOOST_PP_SEQ_ELEM_66
+# define BOOST_PP_SEQ_ELEM_68(_) BOOST_PP_SEQ_ELEM_67
+# define BOOST_PP_SEQ_ELEM_69(_) BOOST_PP_SEQ_ELEM_68
+# define BOOST_PP_SEQ_ELEM_70(_) BOOST_PP_SEQ_ELEM_69
+# define BOOST_PP_SEQ_ELEM_71(_) BOOST_PP_SEQ_ELEM_70
+# define BOOST_PP_SEQ_ELEM_72(_) BOOST_PP_SEQ_ELEM_71
+# define BOOST_PP_SEQ_ELEM_73(_) BOOST_PP_SEQ_ELEM_72
+# define BOOST_PP_SEQ_ELEM_74(_) BOOST_PP_SEQ_ELEM_73
+# define BOOST_PP_SEQ_ELEM_75(_) BOOST_PP_SEQ_ELEM_74
+# define BOOST_PP_SEQ_ELEM_76(_) BOOST_PP_SEQ_ELEM_75
+# define BOOST_PP_SEQ_ELEM_77(_) BOOST_PP_SEQ_ELEM_76
+# define BOOST_PP_SEQ_ELEM_78(_) BOOST_PP_SEQ_ELEM_77
+# define BOOST_PP_SEQ_ELEM_79(_) BOOST_PP_SEQ_ELEM_78
+# define BOOST_PP_SEQ_ELEM_80(_) BOOST_PP_SEQ_ELEM_79
+# define BOOST_PP_SEQ_ELEM_81(_) BOOST_PP_SEQ_ELEM_80
+# define BOOST_PP_SEQ_ELEM_82(_) BOOST_PP_SEQ_ELEM_81
+# define BOOST_PP_SEQ_ELEM_83(_) BOOST_PP_SEQ_ELEM_82
+# define BOOST_PP_SEQ_ELEM_84(_) BOOST_PP_SEQ_ELEM_83
+# define BOOST_PP_SEQ_ELEM_85(_) BOOST_PP_SEQ_ELEM_84
+# define BOOST_PP_SEQ_ELEM_86(_) BOOST_PP_SEQ_ELEM_85
+# define BOOST_PP_SEQ_ELEM_87(_) BOOST_PP_SEQ_ELEM_86
+# define BOOST_PP_SEQ_ELEM_88(_) BOOST_PP_SEQ_ELEM_87
+# define BOOST_PP_SEQ_ELEM_89(_) BOOST_PP_SEQ_ELEM_88
+# define BOOST_PP_SEQ_ELEM_90(_) BOOST_PP_SEQ_ELEM_89
+# define BOOST_PP_SEQ_ELEM_91(_) BOOST_PP_SEQ_ELEM_90
+# define BOOST_PP_SEQ_ELEM_92(_) BOOST_PP_SEQ_ELEM_91
+# define BOOST_PP_SEQ_ELEM_93(_) BOOST_PP_SEQ_ELEM_92
+# define BOOST_PP_SEQ_ELEM_94(_) BOOST_PP_SEQ_ELEM_93
+# define BOOST_PP_SEQ_ELEM_95(_) BOOST_PP_SEQ_ELEM_94
+# define BOOST_PP_SEQ_ELEM_96(_) BOOST_PP_SEQ_ELEM_95
+# define BOOST_PP_SEQ_ELEM_97(_) BOOST_PP_SEQ_ELEM_96
+# define BOOST_PP_SEQ_ELEM_98(_) BOOST_PP_SEQ_ELEM_97
+# define BOOST_PP_SEQ_ELEM_99(_) BOOST_PP_SEQ_ELEM_98
+# define BOOST_PP_SEQ_ELEM_100(_) BOOST_PP_SEQ_ELEM_99
+# define BOOST_PP_SEQ_ELEM_101(_) BOOST_PP_SEQ_ELEM_100
+# define BOOST_PP_SEQ_ELEM_102(_) BOOST_PP_SEQ_ELEM_101
+# define BOOST_PP_SEQ_ELEM_103(_) BOOST_PP_SEQ_ELEM_102
+# define BOOST_PP_SEQ_ELEM_104(_) BOOST_PP_SEQ_ELEM_103
+# define BOOST_PP_SEQ_ELEM_105(_) BOOST_PP_SEQ_ELEM_104
+# define BOOST_PP_SEQ_ELEM_106(_) BOOST_PP_SEQ_ELEM_105
+# define BOOST_PP_SEQ_ELEM_107(_) BOOST_PP_SEQ_ELEM_106
+# define BOOST_PP_SEQ_ELEM_108(_) BOOST_PP_SEQ_ELEM_107
+# define BOOST_PP_SEQ_ELEM_109(_) BOOST_PP_SEQ_ELEM_108
+# define BOOST_PP_SEQ_ELEM_110(_) BOOST_PP_SEQ_ELEM_109
+# define BOOST_PP_SEQ_ELEM_111(_) BOOST_PP_SEQ_ELEM_110
+# define BOOST_PP_SEQ_ELEM_112(_) BOOST_PP_SEQ_ELEM_111
+# define BOOST_PP_SEQ_ELEM_113(_) BOOST_PP_SEQ_ELEM_112
+# define BOOST_PP_SEQ_ELEM_114(_) BOOST_PP_SEQ_ELEM_113
+# define BOOST_PP_SEQ_ELEM_115(_) BOOST_PP_SEQ_ELEM_114
+# define BOOST_PP_SEQ_ELEM_116(_) BOOST_PP_SEQ_ELEM_115
+# define BOOST_PP_SEQ_ELEM_117(_) BOOST_PP_SEQ_ELEM_116
+# define BOOST_PP_SEQ_ELEM_118(_) BOOST_PP_SEQ_ELEM_117
+# define BOOST_PP_SEQ_ELEM_119(_) BOOST_PP_SEQ_ELEM_118
+# define BOOST_PP_SEQ_ELEM_120(_) BOOST_PP_SEQ_ELEM_119
+# define BOOST_PP_SEQ_ELEM_121(_) BOOST_PP_SEQ_ELEM_120
+# define BOOST_PP_SEQ_ELEM_122(_) BOOST_PP_SEQ_ELEM_121
+# define BOOST_PP_SEQ_ELEM_123(_) BOOST_PP_SEQ_ELEM_122
+# define BOOST_PP_SEQ_ELEM_124(_) BOOST_PP_SEQ_ELEM_123
+# define BOOST_PP_SEQ_ELEM_125(_) BOOST_PP_SEQ_ELEM_124
+# define BOOST_PP_SEQ_ELEM_126(_) BOOST_PP_SEQ_ELEM_125
+# define BOOST_PP_SEQ_ELEM_127(_) BOOST_PP_SEQ_ELEM_126
+# define BOOST_PP_SEQ_ELEM_128(_) BOOST_PP_SEQ_ELEM_127
+# define BOOST_PP_SEQ_ELEM_129(_) BOOST_PP_SEQ_ELEM_128
+# define BOOST_PP_SEQ_ELEM_130(_) BOOST_PP_SEQ_ELEM_129
+# define BOOST_PP_SEQ_ELEM_131(_) BOOST_PP_SEQ_ELEM_130
+# define BOOST_PP_SEQ_ELEM_132(_) BOOST_PP_SEQ_ELEM_131
+# define BOOST_PP_SEQ_ELEM_133(_) BOOST_PP_SEQ_ELEM_132
+# define BOOST_PP_SEQ_ELEM_134(_) BOOST_PP_SEQ_ELEM_133
+# define BOOST_PP_SEQ_ELEM_135(_) BOOST_PP_SEQ_ELEM_134
+# define BOOST_PP_SEQ_ELEM_136(_) BOOST_PP_SEQ_ELEM_135
+# define BOOST_PP_SEQ_ELEM_137(_) BOOST_PP_SEQ_ELEM_136
+# define BOOST_PP_SEQ_ELEM_138(_) BOOST_PP_SEQ_ELEM_137
+# define BOOST_PP_SEQ_ELEM_139(_) BOOST_PP_SEQ_ELEM_138
+# define BOOST_PP_SEQ_ELEM_140(_) BOOST_PP_SEQ_ELEM_139
+# define BOOST_PP_SEQ_ELEM_141(_) BOOST_PP_SEQ_ELEM_140
+# define BOOST_PP_SEQ_ELEM_142(_) BOOST_PP_SEQ_ELEM_141
+# define BOOST_PP_SEQ_ELEM_143(_) BOOST_PP_SEQ_ELEM_142
+# define BOOST_PP_SEQ_ELEM_144(_) BOOST_PP_SEQ_ELEM_143
+# define BOOST_PP_SEQ_ELEM_145(_) BOOST_PP_SEQ_ELEM_144
+# define BOOST_PP_SEQ_ELEM_146(_) BOOST_PP_SEQ_ELEM_145
+# define BOOST_PP_SEQ_ELEM_147(_) BOOST_PP_SEQ_ELEM_146
+# define BOOST_PP_SEQ_ELEM_148(_) BOOST_PP_SEQ_ELEM_147
+# define BOOST_PP_SEQ_ELEM_149(_) BOOST_PP_SEQ_ELEM_148
+# define BOOST_PP_SEQ_ELEM_150(_) BOOST_PP_SEQ_ELEM_149
+# define BOOST_PP_SEQ_ELEM_151(_) BOOST_PP_SEQ_ELEM_150
+# define BOOST_PP_SEQ_ELEM_152(_) BOOST_PP_SEQ_ELEM_151
+# define BOOST_PP_SEQ_ELEM_153(_) BOOST_PP_SEQ_ELEM_152
+# define BOOST_PP_SEQ_ELEM_154(_) BOOST_PP_SEQ_ELEM_153
+# define BOOST_PP_SEQ_ELEM_155(_) BOOST_PP_SEQ_ELEM_154
+# define BOOST_PP_SEQ_ELEM_156(_) BOOST_PP_SEQ_ELEM_155
+# define BOOST_PP_SEQ_ELEM_157(_) BOOST_PP_SEQ_ELEM_156
+# define BOOST_PP_SEQ_ELEM_158(_) BOOST_PP_SEQ_ELEM_157
+# define BOOST_PP_SEQ_ELEM_159(_) BOOST_PP_SEQ_ELEM_158
+# define BOOST_PP_SEQ_ELEM_160(_) BOOST_PP_SEQ_ELEM_159
+# define BOOST_PP_SEQ_ELEM_161(_) BOOST_PP_SEQ_ELEM_160
+# define BOOST_PP_SEQ_ELEM_162(_) BOOST_PP_SEQ_ELEM_161
+# define BOOST_PP_SEQ_ELEM_163(_) BOOST_PP_SEQ_ELEM_162
+# define BOOST_PP_SEQ_ELEM_164(_) BOOST_PP_SEQ_ELEM_163
+# define BOOST_PP_SEQ_ELEM_165(_) BOOST_PP_SEQ_ELEM_164
+# define BOOST_PP_SEQ_ELEM_166(_) BOOST_PP_SEQ_ELEM_165
+# define BOOST_PP_SEQ_ELEM_167(_) BOOST_PP_SEQ_ELEM_166
+# define BOOST_PP_SEQ_ELEM_168(_) BOOST_PP_SEQ_ELEM_167
+# define BOOST_PP_SEQ_ELEM_169(_) BOOST_PP_SEQ_ELEM_168
+# define BOOST_PP_SEQ_ELEM_170(_) BOOST_PP_SEQ_ELEM_169
+# define BOOST_PP_SEQ_ELEM_171(_) BOOST_PP_SEQ_ELEM_170
+# define BOOST_PP_SEQ_ELEM_172(_) BOOST_PP_SEQ_ELEM_171
+# define BOOST_PP_SEQ_ELEM_173(_) BOOST_PP_SEQ_ELEM_172
+# define BOOST_PP_SEQ_ELEM_174(_) BOOST_PP_SEQ_ELEM_173
+# define BOOST_PP_SEQ_ELEM_175(_) BOOST_PP_SEQ_ELEM_174
+# define BOOST_PP_SEQ_ELEM_176(_) BOOST_PP_SEQ_ELEM_175
+# define BOOST_PP_SEQ_ELEM_177(_) BOOST_PP_SEQ_ELEM_176
+# define BOOST_PP_SEQ_ELEM_178(_) BOOST_PP_SEQ_ELEM_177
+# define BOOST_PP_SEQ_ELEM_179(_) BOOST_PP_SEQ_ELEM_178
+# define BOOST_PP_SEQ_ELEM_180(_) BOOST_PP_SEQ_ELEM_179
+# define BOOST_PP_SEQ_ELEM_181(_) BOOST_PP_SEQ_ELEM_180
+# define BOOST_PP_SEQ_ELEM_182(_) BOOST_PP_SEQ_ELEM_181
+# define BOOST_PP_SEQ_ELEM_183(_) BOOST_PP_SEQ_ELEM_182
+# define BOOST_PP_SEQ_ELEM_184(_) BOOST_PP_SEQ_ELEM_183
+# define BOOST_PP_SEQ_ELEM_185(_) BOOST_PP_SEQ_ELEM_184
+# define BOOST_PP_SEQ_ELEM_186(_) BOOST_PP_SEQ_ELEM_185
+# define BOOST_PP_SEQ_ELEM_187(_) BOOST_PP_SEQ_ELEM_186
+# define BOOST_PP_SEQ_ELEM_188(_) BOOST_PP_SEQ_ELEM_187
+# define BOOST_PP_SEQ_ELEM_189(_) BOOST_PP_SEQ_ELEM_188
+# define BOOST_PP_SEQ_ELEM_190(_) BOOST_PP_SEQ_ELEM_189
+# define BOOST_PP_SEQ_ELEM_191(_) BOOST_PP_SEQ_ELEM_190
+# define BOOST_PP_SEQ_ELEM_192(_) BOOST_PP_SEQ_ELEM_191
+# define BOOST_PP_SEQ_ELEM_193(_) BOOST_PP_SEQ_ELEM_192
+# define BOOST_PP_SEQ_ELEM_194(_) BOOST_PP_SEQ_ELEM_193
+# define BOOST_PP_SEQ_ELEM_195(_) BOOST_PP_SEQ_ELEM_194
+# define BOOST_PP_SEQ_ELEM_196(_) BOOST_PP_SEQ_ELEM_195
+# define BOOST_PP_SEQ_ELEM_197(_) BOOST_PP_SEQ_ELEM_196
+# define BOOST_PP_SEQ_ELEM_198(_) BOOST_PP_SEQ_ELEM_197
+# define BOOST_PP_SEQ_ELEM_199(_) BOOST_PP_SEQ_ELEM_198
+# define BOOST_PP_SEQ_ELEM_200(_) BOOST_PP_SEQ_ELEM_199
+# define BOOST_PP_SEQ_ELEM_201(_) BOOST_PP_SEQ_ELEM_200
+# define BOOST_PP_SEQ_ELEM_202(_) BOOST_PP_SEQ_ELEM_201
+# define BOOST_PP_SEQ_ELEM_203(_) BOOST_PP_SEQ_ELEM_202
+# define BOOST_PP_SEQ_ELEM_204(_) BOOST_PP_SEQ_ELEM_203
+# define BOOST_PP_SEQ_ELEM_205(_) BOOST_PP_SEQ_ELEM_204
+# define BOOST_PP_SEQ_ELEM_206(_) BOOST_PP_SEQ_ELEM_205
+# define BOOST_PP_SEQ_ELEM_207(_) BOOST_PP_SEQ_ELEM_206
+# define BOOST_PP_SEQ_ELEM_208(_) BOOST_PP_SEQ_ELEM_207
+# define BOOST_PP_SEQ_ELEM_209(_) BOOST_PP_SEQ_ELEM_208
+# define BOOST_PP_SEQ_ELEM_210(_) BOOST_PP_SEQ_ELEM_209
+# define BOOST_PP_SEQ_ELEM_211(_) BOOST_PP_SEQ_ELEM_210
+# define BOOST_PP_SEQ_ELEM_212(_) BOOST_PP_SEQ_ELEM_211
+# define BOOST_PP_SEQ_ELEM_213(_) BOOST_PP_SEQ_ELEM_212
+# define BOOST_PP_SEQ_ELEM_214(_) BOOST_PP_SEQ_ELEM_213
+# define BOOST_PP_SEQ_ELEM_215(_) BOOST_PP_SEQ_ELEM_214
+# define BOOST_PP_SEQ_ELEM_216(_) BOOST_PP_SEQ_ELEM_215
+# define BOOST_PP_SEQ_ELEM_217(_) BOOST_PP_SEQ_ELEM_216
+# define BOOST_PP_SEQ_ELEM_218(_) BOOST_PP_SEQ_ELEM_217
+# define BOOST_PP_SEQ_ELEM_219(_) BOOST_PP_SEQ_ELEM_218
+# define BOOST_PP_SEQ_ELEM_220(_) BOOST_PP_SEQ_ELEM_219
+# define BOOST_PP_SEQ_ELEM_221(_) BOOST_PP_SEQ_ELEM_220
+# define BOOST_PP_SEQ_ELEM_222(_) BOOST_PP_SEQ_ELEM_221
+# define BOOST_PP_SEQ_ELEM_223(_) BOOST_PP_SEQ_ELEM_222
+# define BOOST_PP_SEQ_ELEM_224(_) BOOST_PP_SEQ_ELEM_223
+# define BOOST_PP_SEQ_ELEM_225(_) BOOST_PP_SEQ_ELEM_224
+# define BOOST_PP_SEQ_ELEM_226(_) BOOST_PP_SEQ_ELEM_225
+# define BOOST_PP_SEQ_ELEM_227(_) BOOST_PP_SEQ_ELEM_226
+# define BOOST_PP_SEQ_ELEM_228(_) BOOST_PP_SEQ_ELEM_227
+# define BOOST_PP_SEQ_ELEM_229(_) BOOST_PP_SEQ_ELEM_228
+# define BOOST_PP_SEQ_ELEM_230(_) BOOST_PP_SEQ_ELEM_229
+# define BOOST_PP_SEQ_ELEM_231(_) BOOST_PP_SEQ_ELEM_230
+# define BOOST_PP_SEQ_ELEM_232(_) BOOST_PP_SEQ_ELEM_231
+# define BOOST_PP_SEQ_ELEM_233(_) BOOST_PP_SEQ_ELEM_232
+# define BOOST_PP_SEQ_ELEM_234(_) BOOST_PP_SEQ_ELEM_233
+# define BOOST_PP_SEQ_ELEM_235(_) BOOST_PP_SEQ_ELEM_234
+# define BOOST_PP_SEQ_ELEM_236(_) BOOST_PP_SEQ_ELEM_235
+# define BOOST_PP_SEQ_ELEM_237(_) BOOST_PP_SEQ_ELEM_236
+# define BOOST_PP_SEQ_ELEM_238(_) BOOST_PP_SEQ_ELEM_237
+# define BOOST_PP_SEQ_ELEM_239(_) BOOST_PP_SEQ_ELEM_238
+# define BOOST_PP_SEQ_ELEM_240(_) BOOST_PP_SEQ_ELEM_239
+# define BOOST_PP_SEQ_ELEM_241(_) BOOST_PP_SEQ_ELEM_240
+# define BOOST_PP_SEQ_ELEM_242(_) BOOST_PP_SEQ_ELEM_241
+# define BOOST_PP_SEQ_ELEM_243(_) BOOST_PP_SEQ_ELEM_242
+# define BOOST_PP_SEQ_ELEM_244(_) BOOST_PP_SEQ_ELEM_243
+# define BOOST_PP_SEQ_ELEM_245(_) BOOST_PP_SEQ_ELEM_244
+# define BOOST_PP_SEQ_ELEM_246(_) BOOST_PP_SEQ_ELEM_245
+# define BOOST_PP_SEQ_ELEM_247(_) BOOST_PP_SEQ_ELEM_246
+# define BOOST_PP_SEQ_ELEM_248(_) BOOST_PP_SEQ_ELEM_247
+# define BOOST_PP_SEQ_ELEM_249(_) BOOST_PP_SEQ_ELEM_248
+# define BOOST_PP_SEQ_ELEM_250(_) BOOST_PP_SEQ_ELEM_249
+# define BOOST_PP_SEQ_ELEM_251(_) BOOST_PP_SEQ_ELEM_250
+# define BOOST_PP_SEQ_ELEM_252(_) BOOST_PP_SEQ_ELEM_251
+# define BOOST_PP_SEQ_ELEM_253(_) BOOST_PP_SEQ_ELEM_252
+# define BOOST_PP_SEQ_ELEM_254(_) BOOST_PP_SEQ_ELEM_253
+# define BOOST_PP_SEQ_ELEM_255(_) BOOST_PP_SEQ_ELEM_254
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/enum.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/enum.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/enum.hpp	(working copy)
@@ -0,0 +1,288 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SEQ_ENUM_HPP
+# define BOOST_PREPROCESSOR_SEQ_ENUM_HPP
+#
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/seq/size.hpp>
+#
+# /* BOOST_PP_SEQ_ENUM */
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_SEQ_ENUM(seq) BOOST_PP_SEQ_ENUM_I(seq)
+#    define BOOST_PP_SEQ_ENUM_I(seq) BOOST_PP_CAT(BOOST_PP_SEQ_ENUM_, BOOST_PP_SEQ_SIZE(seq)) seq
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_SEQ_ENUM(seq) BOOST_PP_SEQ_ENUM_I(BOOST_PP_SEQ_SIZE(seq), seq)
+#    define BOOST_PP_SEQ_ENUM_I(size, seq) BOOST_PP_CAT(BOOST_PP_SEQ_ENUM_, size) seq
+# else
+#    define BOOST_PP_SEQ_ENUM(seq) BOOST_PP_CAT(BOOST_PP_SEQ_ENUM_, BOOST_PP_SEQ_SIZE(seq)) seq
+# endif
+#
+# define BOOST_PP_SEQ_ENUM_1(x) x
+# define BOOST_PP_SEQ_ENUM_2(x) x, BOOST_PP_SEQ_ENUM_1
+# define BOOST_PP_SEQ_ENUM_3(x) x, BOOST_PP_SEQ_ENUM_2
+# define BOOST_PP_SEQ_ENUM_4(x) x, BOOST_PP_SEQ_ENUM_3
+# define BOOST_PP_SEQ_ENUM_5(x) x, BOOST_PP_SEQ_ENUM_4
+# define BOOST_PP_SEQ_ENUM_6(x) x, BOOST_PP_SEQ_ENUM_5
+# define BOOST_PP_SEQ_ENUM_7(x) x, BOOST_PP_SEQ_ENUM_6
+# define BOOST_PP_SEQ_ENUM_8(x) x, BOOST_PP_SEQ_ENUM_7
+# define BOOST_PP_SEQ_ENUM_9(x) x, BOOST_PP_SEQ_ENUM_8
+# define BOOST_PP_SEQ_ENUM_10(x) x, BOOST_PP_SEQ_ENUM_9
+# define BOOST_PP_SEQ_ENUM_11(x) x, BOOST_PP_SEQ_ENUM_10
+# define BOOST_PP_SEQ_ENUM_12(x) x, BOOST_PP_SEQ_ENUM_11
+# define BOOST_PP_SEQ_ENUM_13(x) x, BOOST_PP_SEQ_ENUM_12
+# define BOOST_PP_SEQ_ENUM_14(x) x, BOOST_PP_SEQ_ENUM_13
+# define BOOST_PP_SEQ_ENUM_15(x) x, BOOST_PP_SEQ_ENUM_14
+# define BOOST_PP_SEQ_ENUM_16(x) x, BOOST_PP_SEQ_ENUM_15
+# define BOOST_PP_SEQ_ENUM_17(x) x, BOOST_PP_SEQ_ENUM_16
+# define BOOST_PP_SEQ_ENUM_18(x) x, BOOST_PP_SEQ_ENUM_17
+# define BOOST_PP_SEQ_ENUM_19(x) x, BOOST_PP_SEQ_ENUM_18
+# define BOOST_PP_SEQ_ENUM_20(x) x, BOOST_PP_SEQ_ENUM_19
+# define BOOST_PP_SEQ_ENUM_21(x) x, BOOST_PP_SEQ_ENUM_20
+# define BOOST_PP_SEQ_ENUM_22(x) x, BOOST_PP_SEQ_ENUM_21
+# define BOOST_PP_SEQ_ENUM_23(x) x, BOOST_PP_SEQ_ENUM_22
+# define BOOST_PP_SEQ_ENUM_24(x) x, BOOST_PP_SEQ_ENUM_23
+# define BOOST_PP_SEQ_ENUM_25(x) x, BOOST_PP_SEQ_ENUM_24
+# define BOOST_PP_SEQ_ENUM_26(x) x, BOOST_PP_SEQ_ENUM_25
+# define BOOST_PP_SEQ_ENUM_27(x) x, BOOST_PP_SEQ_ENUM_26
+# define BOOST_PP_SEQ_ENUM_28(x) x, BOOST_PP_SEQ_ENUM_27
+# define BOOST_PP_SEQ_ENUM_29(x) x, BOOST_PP_SEQ_ENUM_28
+# define BOOST_PP_SEQ_ENUM_30(x) x, BOOST_PP_SEQ_ENUM_29
+# define BOOST_PP_SEQ_ENUM_31(x) x, BOOST_PP_SEQ_ENUM_30
+# define BOOST_PP_SEQ_ENUM_32(x) x, BOOST_PP_SEQ_ENUM_31
+# define BOOST_PP_SEQ_ENUM_33(x) x, BOOST_PP_SEQ_ENUM_32
+# define BOOST_PP_SEQ_ENUM_34(x) x, BOOST_PP_SEQ_ENUM_33
+# define BOOST_PP_SEQ_ENUM_35(x) x, BOOST_PP_SEQ_ENUM_34
+# define BOOST_PP_SEQ_ENUM_36(x) x, BOOST_PP_SEQ_ENUM_35
+# define BOOST_PP_SEQ_ENUM_37(x) x, BOOST_PP_SEQ_ENUM_36
+# define BOOST_PP_SEQ_ENUM_38(x) x, BOOST_PP_SEQ_ENUM_37
+# define BOOST_PP_SEQ_ENUM_39(x) x, BOOST_PP_SEQ_ENUM_38
+# define BOOST_PP_SEQ_ENUM_40(x) x, BOOST_PP_SEQ_ENUM_39
+# define BOOST_PP_SEQ_ENUM_41(x) x, BOOST_PP_SEQ_ENUM_40
+# define BOOST_PP_SEQ_ENUM_42(x) x, BOOST_PP_SEQ_ENUM_41
+# define BOOST_PP_SEQ_ENUM_43(x) x, BOOST_PP_SEQ_ENUM_42
+# define BOOST_PP_SEQ_ENUM_44(x) x, BOOST_PP_SEQ_ENUM_43
+# define BOOST_PP_SEQ_ENUM_45(x) x, BOOST_PP_SEQ_ENUM_44
+# define BOOST_PP_SEQ_ENUM_46(x) x, BOOST_PP_SEQ_ENUM_45
+# define BOOST_PP_SEQ_ENUM_47(x) x, BOOST_PP_SEQ_ENUM_46
+# define BOOST_PP_SEQ_ENUM_48(x) x, BOOST_PP_SEQ_ENUM_47
+# define BOOST_PP_SEQ_ENUM_49(x) x, BOOST_PP_SEQ_ENUM_48
+# define BOOST_PP_SEQ_ENUM_50(x) x, BOOST_PP_SEQ_ENUM_49
+# define BOOST_PP_SEQ_ENUM_51(x) x, BOOST_PP_SEQ_ENUM_50
+# define BOOST_PP_SEQ_ENUM_52(x) x, BOOST_PP_SEQ_ENUM_51
+# define BOOST_PP_SEQ_ENUM_53(x) x, BOOST_PP_SEQ_ENUM_52
+# define BOOST_PP_SEQ_ENUM_54(x) x, BOOST_PP_SEQ_ENUM_53
+# define BOOST_PP_SEQ_ENUM_55(x) x, BOOST_PP_SEQ_ENUM_54
+# define BOOST_PP_SEQ_ENUM_56(x) x, BOOST_PP_SEQ_ENUM_55
+# define BOOST_PP_SEQ_ENUM_57(x) x, BOOST_PP_SEQ_ENUM_56
+# define BOOST_PP_SEQ_ENUM_58(x) x, BOOST_PP_SEQ_ENUM_57
+# define BOOST_PP_SEQ_ENUM_59(x) x, BOOST_PP_SEQ_ENUM_58
+# define BOOST_PP_SEQ_ENUM_60(x) x, BOOST_PP_SEQ_ENUM_59
+# define BOOST_PP_SEQ_ENUM_61(x) x, BOOST_PP_SEQ_ENUM_60
+# define BOOST_PP_SEQ_ENUM_62(x) x, BOOST_PP_SEQ_ENUM_61
+# define BOOST_PP_SEQ_ENUM_63(x) x, BOOST_PP_SEQ_ENUM_62
+# define BOOST_PP_SEQ_ENUM_64(x) x, BOOST_PP_SEQ_ENUM_63
+# define BOOST_PP_SEQ_ENUM_65(x) x, BOOST_PP_SEQ_ENUM_64
+# define BOOST_PP_SEQ_ENUM_66(x) x, BOOST_PP_SEQ_ENUM_65
+# define BOOST_PP_SEQ_ENUM_67(x) x, BOOST_PP_SEQ_ENUM_66
+# define BOOST_PP_SEQ_ENUM_68(x) x, BOOST_PP_SEQ_ENUM_67
+# define BOOST_PP_SEQ_ENUM_69(x) x, BOOST_PP_SEQ_ENUM_68
+# define BOOST_PP_SEQ_ENUM_70(x) x, BOOST_PP_SEQ_ENUM_69
+# define BOOST_PP_SEQ_ENUM_71(x) x, BOOST_PP_SEQ_ENUM_70
+# define BOOST_PP_SEQ_ENUM_72(x) x, BOOST_PP_SEQ_ENUM_71
+# define BOOST_PP_SEQ_ENUM_73(x) x, BOOST_PP_SEQ_ENUM_72
+# define BOOST_PP_SEQ_ENUM_74(x) x, BOOST_PP_SEQ_ENUM_73
+# define BOOST_PP_SEQ_ENUM_75(x) x, BOOST_PP_SEQ_ENUM_74
+# define BOOST_PP_SEQ_ENUM_76(x) x, BOOST_PP_SEQ_ENUM_75
+# define BOOST_PP_SEQ_ENUM_77(x) x, BOOST_PP_SEQ_ENUM_76
+# define BOOST_PP_SEQ_ENUM_78(x) x, BOOST_PP_SEQ_ENUM_77
+# define BOOST_PP_SEQ_ENUM_79(x) x, BOOST_PP_SEQ_ENUM_78
+# define BOOST_PP_SEQ_ENUM_80(x) x, BOOST_PP_SEQ_ENUM_79
+# define BOOST_PP_SEQ_ENUM_81(x) x, BOOST_PP_SEQ_ENUM_80
+# define BOOST_PP_SEQ_ENUM_82(x) x, BOOST_PP_SEQ_ENUM_81
+# define BOOST_PP_SEQ_ENUM_83(x) x, BOOST_PP_SEQ_ENUM_82
+# define BOOST_PP_SEQ_ENUM_84(x) x, BOOST_PP_SEQ_ENUM_83
+# define BOOST_PP_SEQ_ENUM_85(x) x, BOOST_PP_SEQ_ENUM_84
+# define BOOST_PP_SEQ_ENUM_86(x) x, BOOST_PP_SEQ_ENUM_85
+# define BOOST_PP_SEQ_ENUM_87(x) x, BOOST_PP_SEQ_ENUM_86
+# define BOOST_PP_SEQ_ENUM_88(x) x, BOOST_PP_SEQ_ENUM_87
+# define BOOST_PP_SEQ_ENUM_89(x) x, BOOST_PP_SEQ_ENUM_88
+# define BOOST_PP_SEQ_ENUM_90(x) x, BOOST_PP_SEQ_ENUM_89
+# define BOOST_PP_SEQ_ENUM_91(x) x, BOOST_PP_SEQ_ENUM_90
+# define BOOST_PP_SEQ_ENUM_92(x) x, BOOST_PP_SEQ_ENUM_91
+# define BOOST_PP_SEQ_ENUM_93(x) x, BOOST_PP_SEQ_ENUM_92
+# define BOOST_PP_SEQ_ENUM_94(x) x, BOOST_PP_SEQ_ENUM_93
+# define BOOST_PP_SEQ_ENUM_95(x) x, BOOST_PP_SEQ_ENUM_94
+# define BOOST_PP_SEQ_ENUM_96(x) x, BOOST_PP_SEQ_ENUM_95
+# define BOOST_PP_SEQ_ENUM_97(x) x, BOOST_PP_SEQ_ENUM_96
+# define BOOST_PP_SEQ_ENUM_98(x) x, BOOST_PP_SEQ_ENUM_97
+# define BOOST_PP_SEQ_ENUM_99(x) x, BOOST_PP_SEQ_ENUM_98
+# define BOOST_PP_SEQ_ENUM_100(x) x, BOOST_PP_SEQ_ENUM_99
+# define BOOST_PP_SEQ_ENUM_101(x) x, BOOST_PP_SEQ_ENUM_100
+# define BOOST_PP_SEQ_ENUM_102(x) x, BOOST_PP_SEQ_ENUM_101
+# define BOOST_PP_SEQ_ENUM_103(x) x, BOOST_PP_SEQ_ENUM_102
+# define BOOST_PP_SEQ_ENUM_104(x) x, BOOST_PP_SEQ_ENUM_103
+# define BOOST_PP_SEQ_ENUM_105(x) x, BOOST_PP_SEQ_ENUM_104
+# define BOOST_PP_SEQ_ENUM_106(x) x, BOOST_PP_SEQ_ENUM_105
+# define BOOST_PP_SEQ_ENUM_107(x) x, BOOST_PP_SEQ_ENUM_106
+# define BOOST_PP_SEQ_ENUM_108(x) x, BOOST_PP_SEQ_ENUM_107
+# define BOOST_PP_SEQ_ENUM_109(x) x, BOOST_PP_SEQ_ENUM_108
+# define BOOST_PP_SEQ_ENUM_110(x) x, BOOST_PP_SEQ_ENUM_109
+# define BOOST_PP_SEQ_ENUM_111(x) x, BOOST_PP_SEQ_ENUM_110
+# define BOOST_PP_SEQ_ENUM_112(x) x, BOOST_PP_SEQ_ENUM_111
+# define BOOST_PP_SEQ_ENUM_113(x) x, BOOST_PP_SEQ_ENUM_112
+# define BOOST_PP_SEQ_ENUM_114(x) x, BOOST_PP_SEQ_ENUM_113
+# define BOOST_PP_SEQ_ENUM_115(x) x, BOOST_PP_SEQ_ENUM_114
+# define BOOST_PP_SEQ_ENUM_116(x) x, BOOST_PP_SEQ_ENUM_115
+# define BOOST_PP_SEQ_ENUM_117(x) x, BOOST_PP_SEQ_ENUM_116
+# define BOOST_PP_SEQ_ENUM_118(x) x, BOOST_PP_SEQ_ENUM_117
+# define BOOST_PP_SEQ_ENUM_119(x) x, BOOST_PP_SEQ_ENUM_118
+# define BOOST_PP_SEQ_ENUM_120(x) x, BOOST_PP_SEQ_ENUM_119
+# define BOOST_PP_SEQ_ENUM_121(x) x, BOOST_PP_SEQ_ENUM_120
+# define BOOST_PP_SEQ_ENUM_122(x) x, BOOST_PP_SEQ_ENUM_121
+# define BOOST_PP_SEQ_ENUM_123(x) x, BOOST_PP_SEQ_ENUM_122
+# define BOOST_PP_SEQ_ENUM_124(x) x, BOOST_PP_SEQ_ENUM_123
+# define BOOST_PP_SEQ_ENUM_125(x) x, BOOST_PP_SEQ_ENUM_124
+# define BOOST_PP_SEQ_ENUM_126(x) x, BOOST_PP_SEQ_ENUM_125
+# define BOOST_PP_SEQ_ENUM_127(x) x, BOOST_PP_SEQ_ENUM_126
+# define BOOST_PP_SEQ_ENUM_128(x) x, BOOST_PP_SEQ_ENUM_127
+# define BOOST_PP_SEQ_ENUM_129(x) x, BOOST_PP_SEQ_ENUM_128
+# define BOOST_PP_SEQ_ENUM_130(x) x, BOOST_PP_SEQ_ENUM_129
+# define BOOST_PP_SEQ_ENUM_131(x) x, BOOST_PP_SEQ_ENUM_130
+# define BOOST_PP_SEQ_ENUM_132(x) x, BOOST_PP_SEQ_ENUM_131
+# define BOOST_PP_SEQ_ENUM_133(x) x, BOOST_PP_SEQ_ENUM_132
+# define BOOST_PP_SEQ_ENUM_134(x) x, BOOST_PP_SEQ_ENUM_133
+# define BOOST_PP_SEQ_ENUM_135(x) x, BOOST_PP_SEQ_ENUM_134
+# define BOOST_PP_SEQ_ENUM_136(x) x, BOOST_PP_SEQ_ENUM_135
+# define BOOST_PP_SEQ_ENUM_137(x) x, BOOST_PP_SEQ_ENUM_136
+# define BOOST_PP_SEQ_ENUM_138(x) x, BOOST_PP_SEQ_ENUM_137
+# define BOOST_PP_SEQ_ENUM_139(x) x, BOOST_PP_SEQ_ENUM_138
+# define BOOST_PP_SEQ_ENUM_140(x) x, BOOST_PP_SEQ_ENUM_139
+# define BOOST_PP_SEQ_ENUM_141(x) x, BOOST_PP_SEQ_ENUM_140
+# define BOOST_PP_SEQ_ENUM_142(x) x, BOOST_PP_SEQ_ENUM_141
+# define BOOST_PP_SEQ_ENUM_143(x) x, BOOST_PP_SEQ_ENUM_142
+# define BOOST_PP_SEQ_ENUM_144(x) x, BOOST_PP_SEQ_ENUM_143
+# define BOOST_PP_SEQ_ENUM_145(x) x, BOOST_PP_SEQ_ENUM_144
+# define BOOST_PP_SEQ_ENUM_146(x) x, BOOST_PP_SEQ_ENUM_145
+# define BOOST_PP_SEQ_ENUM_147(x) x, BOOST_PP_SEQ_ENUM_146
+# define BOOST_PP_SEQ_ENUM_148(x) x, BOOST_PP_SEQ_ENUM_147
+# define BOOST_PP_SEQ_ENUM_149(x) x, BOOST_PP_SEQ_ENUM_148
+# define BOOST_PP_SEQ_ENUM_150(x) x, BOOST_PP_SEQ_ENUM_149
+# define BOOST_PP_SEQ_ENUM_151(x) x, BOOST_PP_SEQ_ENUM_150
+# define BOOST_PP_SEQ_ENUM_152(x) x, BOOST_PP_SEQ_ENUM_151
+# define BOOST_PP_SEQ_ENUM_153(x) x, BOOST_PP_SEQ_ENUM_152
+# define BOOST_PP_SEQ_ENUM_154(x) x, BOOST_PP_SEQ_ENUM_153
+# define BOOST_PP_SEQ_ENUM_155(x) x, BOOST_PP_SEQ_ENUM_154
+# define BOOST_PP_SEQ_ENUM_156(x) x, BOOST_PP_SEQ_ENUM_155
+# define BOOST_PP_SEQ_ENUM_157(x) x, BOOST_PP_SEQ_ENUM_156
+# define BOOST_PP_SEQ_ENUM_158(x) x, BOOST_PP_SEQ_ENUM_157
+# define BOOST_PP_SEQ_ENUM_159(x) x, BOOST_PP_SEQ_ENUM_158
+# define BOOST_PP_SEQ_ENUM_160(x) x, BOOST_PP_SEQ_ENUM_159
+# define BOOST_PP_SEQ_ENUM_161(x) x, BOOST_PP_SEQ_ENUM_160
+# define BOOST_PP_SEQ_ENUM_162(x) x, BOOST_PP_SEQ_ENUM_161
+# define BOOST_PP_SEQ_ENUM_163(x) x, BOOST_PP_SEQ_ENUM_162
+# define BOOST_PP_SEQ_ENUM_164(x) x, BOOST_PP_SEQ_ENUM_163
+# define BOOST_PP_SEQ_ENUM_165(x) x, BOOST_PP_SEQ_ENUM_164
+# define BOOST_PP_SEQ_ENUM_166(x) x, BOOST_PP_SEQ_ENUM_165
+# define BOOST_PP_SEQ_ENUM_167(x) x, BOOST_PP_SEQ_ENUM_166
+# define BOOST_PP_SEQ_ENUM_168(x) x, BOOST_PP_SEQ_ENUM_167
+# define BOOST_PP_SEQ_ENUM_169(x) x, BOOST_PP_SEQ_ENUM_168
+# define BOOST_PP_SEQ_ENUM_170(x) x, BOOST_PP_SEQ_ENUM_169
+# define BOOST_PP_SEQ_ENUM_171(x) x, BOOST_PP_SEQ_ENUM_170
+# define BOOST_PP_SEQ_ENUM_172(x) x, BOOST_PP_SEQ_ENUM_171
+# define BOOST_PP_SEQ_ENUM_173(x) x, BOOST_PP_SEQ_ENUM_172
+# define BOOST_PP_SEQ_ENUM_174(x) x, BOOST_PP_SEQ_ENUM_173
+# define BOOST_PP_SEQ_ENUM_175(x) x, BOOST_PP_SEQ_ENUM_174
+# define BOOST_PP_SEQ_ENUM_176(x) x, BOOST_PP_SEQ_ENUM_175
+# define BOOST_PP_SEQ_ENUM_177(x) x, BOOST_PP_SEQ_ENUM_176
+# define BOOST_PP_SEQ_ENUM_178(x) x, BOOST_PP_SEQ_ENUM_177
+# define BOOST_PP_SEQ_ENUM_179(x) x, BOOST_PP_SEQ_ENUM_178
+# define BOOST_PP_SEQ_ENUM_180(x) x, BOOST_PP_SEQ_ENUM_179
+# define BOOST_PP_SEQ_ENUM_181(x) x, BOOST_PP_SEQ_ENUM_180
+# define BOOST_PP_SEQ_ENUM_182(x) x, BOOST_PP_SEQ_ENUM_181
+# define BOOST_PP_SEQ_ENUM_183(x) x, BOOST_PP_SEQ_ENUM_182
+# define BOOST_PP_SEQ_ENUM_184(x) x, BOOST_PP_SEQ_ENUM_183
+# define BOOST_PP_SEQ_ENUM_185(x) x, BOOST_PP_SEQ_ENUM_184
+# define BOOST_PP_SEQ_ENUM_186(x) x, BOOST_PP_SEQ_ENUM_185
+# define BOOST_PP_SEQ_ENUM_187(x) x, BOOST_PP_SEQ_ENUM_186
+# define BOOST_PP_SEQ_ENUM_188(x) x, BOOST_PP_SEQ_ENUM_187
+# define BOOST_PP_SEQ_ENUM_189(x) x, BOOST_PP_SEQ_ENUM_188
+# define BOOST_PP_SEQ_ENUM_190(x) x, BOOST_PP_SEQ_ENUM_189
+# define BOOST_PP_SEQ_ENUM_191(x) x, BOOST_PP_SEQ_ENUM_190
+# define BOOST_PP_SEQ_ENUM_192(x) x, BOOST_PP_SEQ_ENUM_191
+# define BOOST_PP_SEQ_ENUM_193(x) x, BOOST_PP_SEQ_ENUM_192
+# define BOOST_PP_SEQ_ENUM_194(x) x, BOOST_PP_SEQ_ENUM_193
+# define BOOST_PP_SEQ_ENUM_195(x) x, BOOST_PP_SEQ_ENUM_194
+# define BOOST_PP_SEQ_ENUM_196(x) x, BOOST_PP_SEQ_ENUM_195
+# define BOOST_PP_SEQ_ENUM_197(x) x, BOOST_PP_SEQ_ENUM_196
+# define BOOST_PP_SEQ_ENUM_198(x) x, BOOST_PP_SEQ_ENUM_197
+# define BOOST_PP_SEQ_ENUM_199(x) x, BOOST_PP_SEQ_ENUM_198
+# define BOOST_PP_SEQ_ENUM_200(x) x, BOOST_PP_SEQ_ENUM_199
+# define BOOST_PP_SEQ_ENUM_201(x) x, BOOST_PP_SEQ_ENUM_200
+# define BOOST_PP_SEQ_ENUM_202(x) x, BOOST_PP_SEQ_ENUM_201
+# define BOOST_PP_SEQ_ENUM_203(x) x, BOOST_PP_SEQ_ENUM_202
+# define BOOST_PP_SEQ_ENUM_204(x) x, BOOST_PP_SEQ_ENUM_203
+# define BOOST_PP_SEQ_ENUM_205(x) x, BOOST_PP_SEQ_ENUM_204
+# define BOOST_PP_SEQ_ENUM_206(x) x, BOOST_PP_SEQ_ENUM_205
+# define BOOST_PP_SEQ_ENUM_207(x) x, BOOST_PP_SEQ_ENUM_206
+# define BOOST_PP_SEQ_ENUM_208(x) x, BOOST_PP_SEQ_ENUM_207
+# define BOOST_PP_SEQ_ENUM_209(x) x, BOOST_PP_SEQ_ENUM_208
+# define BOOST_PP_SEQ_ENUM_210(x) x, BOOST_PP_SEQ_ENUM_209
+# define BOOST_PP_SEQ_ENUM_211(x) x, BOOST_PP_SEQ_ENUM_210
+# define BOOST_PP_SEQ_ENUM_212(x) x, BOOST_PP_SEQ_ENUM_211
+# define BOOST_PP_SEQ_ENUM_213(x) x, BOOST_PP_SEQ_ENUM_212
+# define BOOST_PP_SEQ_ENUM_214(x) x, BOOST_PP_SEQ_ENUM_213
+# define BOOST_PP_SEQ_ENUM_215(x) x, BOOST_PP_SEQ_ENUM_214
+# define BOOST_PP_SEQ_ENUM_216(x) x, BOOST_PP_SEQ_ENUM_215
+# define BOOST_PP_SEQ_ENUM_217(x) x, BOOST_PP_SEQ_ENUM_216
+# define BOOST_PP_SEQ_ENUM_218(x) x, BOOST_PP_SEQ_ENUM_217
+# define BOOST_PP_SEQ_ENUM_219(x) x, BOOST_PP_SEQ_ENUM_218
+# define BOOST_PP_SEQ_ENUM_220(x) x, BOOST_PP_SEQ_ENUM_219
+# define BOOST_PP_SEQ_ENUM_221(x) x, BOOST_PP_SEQ_ENUM_220
+# define BOOST_PP_SEQ_ENUM_222(x) x, BOOST_PP_SEQ_ENUM_221
+# define BOOST_PP_SEQ_ENUM_223(x) x, BOOST_PP_SEQ_ENUM_222
+# define BOOST_PP_SEQ_ENUM_224(x) x, BOOST_PP_SEQ_ENUM_223
+# define BOOST_PP_SEQ_ENUM_225(x) x, BOOST_PP_SEQ_ENUM_224
+# define BOOST_PP_SEQ_ENUM_226(x) x, BOOST_PP_SEQ_ENUM_225
+# define BOOST_PP_SEQ_ENUM_227(x) x, BOOST_PP_SEQ_ENUM_226
+# define BOOST_PP_SEQ_ENUM_228(x) x, BOOST_PP_SEQ_ENUM_227
+# define BOOST_PP_SEQ_ENUM_229(x) x, BOOST_PP_SEQ_ENUM_228
+# define BOOST_PP_SEQ_ENUM_230(x) x, BOOST_PP_SEQ_ENUM_229
+# define BOOST_PP_SEQ_ENUM_231(x) x, BOOST_PP_SEQ_ENUM_230
+# define BOOST_PP_SEQ_ENUM_232(x) x, BOOST_PP_SEQ_ENUM_231
+# define BOOST_PP_SEQ_ENUM_233(x) x, BOOST_PP_SEQ_ENUM_232
+# define BOOST_PP_SEQ_ENUM_234(x) x, BOOST_PP_SEQ_ENUM_233
+# define BOOST_PP_SEQ_ENUM_235(x) x, BOOST_PP_SEQ_ENUM_234
+# define BOOST_PP_SEQ_ENUM_236(x) x, BOOST_PP_SEQ_ENUM_235
+# define BOOST_PP_SEQ_ENUM_237(x) x, BOOST_PP_SEQ_ENUM_236
+# define BOOST_PP_SEQ_ENUM_238(x) x, BOOST_PP_SEQ_ENUM_237
+# define BOOST_PP_SEQ_ENUM_239(x) x, BOOST_PP_SEQ_ENUM_238
+# define BOOST_PP_SEQ_ENUM_240(x) x, BOOST_PP_SEQ_ENUM_239
+# define BOOST_PP_SEQ_ENUM_241(x) x, BOOST_PP_SEQ_ENUM_240
+# define BOOST_PP_SEQ_ENUM_242(x) x, BOOST_PP_SEQ_ENUM_241
+# define BOOST_PP_SEQ_ENUM_243(x) x, BOOST_PP_SEQ_ENUM_242
+# define BOOST_PP_SEQ_ENUM_244(x) x, BOOST_PP_SEQ_ENUM_243
+# define BOOST_PP_SEQ_ENUM_245(x) x, BOOST_PP_SEQ_ENUM_244
+# define BOOST_PP_SEQ_ENUM_246(x) x, BOOST_PP_SEQ_ENUM_245
+# define BOOST_PP_SEQ_ENUM_247(x) x, BOOST_PP_SEQ_ENUM_246
+# define BOOST_PP_SEQ_ENUM_248(x) x, BOOST_PP_SEQ_ENUM_247
+# define BOOST_PP_SEQ_ENUM_249(x) x, BOOST_PP_SEQ_ENUM_248
+# define BOOST_PP_SEQ_ENUM_250(x) x, BOOST_PP_SEQ_ENUM_249
+# define BOOST_PP_SEQ_ENUM_251(x) x, BOOST_PP_SEQ_ENUM_250
+# define BOOST_PP_SEQ_ENUM_252(x) x, BOOST_PP_SEQ_ENUM_251
+# define BOOST_PP_SEQ_ENUM_253(x) x, BOOST_PP_SEQ_ENUM_252
+# define BOOST_PP_SEQ_ENUM_254(x) x, BOOST_PP_SEQ_ENUM_253
+# define BOOST_PP_SEQ_ENUM_255(x) x, BOOST_PP_SEQ_ENUM_254
+# define BOOST_PP_SEQ_ENUM_256(x) x, BOOST_PP_SEQ_ENUM_255
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/seq.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/seq.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/seq/seq.hpp	(working copy)
@@ -0,0 +1,44 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_SEQ_SEQ_HPP
+# define BOOST_PREPROCESSOR_SEQ_SEQ_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/seq/elem.hpp>
+#
+# /* BOOST_PP_SEQ_HEAD */
+#
+# define BOOST_PP_SEQ_HEAD(seq) BOOST_PP_SEQ_ELEM(0, seq)
+#
+# /* BOOST_PP_SEQ_TAIL */
+#
+# if BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_SEQ_TAIL(seq) BOOST_PP_SEQ_TAIL_1((seq))
+#    define BOOST_PP_SEQ_TAIL_1(par) BOOST_PP_SEQ_TAIL_2 ## par
+#    define BOOST_PP_SEQ_TAIL_2(seq) BOOST_PP_SEQ_TAIL_I ## seq
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_SEQ_TAIL(seq) BOOST_PP_SEQ_TAIL_ID(BOOST_PP_SEQ_TAIL_I seq)
+#    define BOOST_PP_SEQ_TAIL_ID(id) id
+# elif BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_SEQ_TAIL(seq) BOOST_PP_SEQ_TAIL_D(seq)
+#    define BOOST_PP_SEQ_TAIL_D(seq) BOOST_PP_SEQ_TAIL_I seq
+# else
+#    define BOOST_PP_SEQ_TAIL(seq) BOOST_PP_SEQ_TAIL_I seq
+# endif
+#
+# define BOOST_PP_SEQ_TAIL_I(x)
+#
+# /* BOOST_PP_SEQ_NIL */
+#
+# define BOOST_PP_SEQ_NIL(x) (x)
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/sub.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/sub.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/sub.hpp	(working copy)
@@ -0,0 +1,50 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARITHMETIC_SUB_HPP
+# define BOOST_PREPROCESSOR_ARITHMETIC_SUB_HPP
+#
+# include <boost/preprocessor/arithmetic/dec.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/control/while.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+#
+# /* BOOST_PP_SUB */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_SUB(x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (x, y)))
+# else
+#    define BOOST_PP_SUB(x, y) BOOST_PP_SUB_I(x, y)
+#    define BOOST_PP_SUB_I(x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (x, y)))
+# endif
+#
+# define BOOST_PP_SUB_P(d, xy) BOOST_PP_TUPLE_ELEM(2, 1, xy)
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_SUB_O(d, xy) BOOST_PP_SUB_O_I xy
+# else
+#    define BOOST_PP_SUB_O(d, xy) BOOST_PP_SUB_O_I(BOOST_PP_TUPLE_ELEM(2, 0, xy), BOOST_PP_TUPLE_ELEM(2, 1, xy))
+# endif
+#
+# define BOOST_PP_SUB_O_I(x, y) (BOOST_PP_DEC(x), BOOST_PP_DEC(y))
+#
+# /* BOOST_PP_SUB_D */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_SUB_D(d, x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE_ ## d(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (x, y)))
+# else
+#    define BOOST_PP_SUB_D(d, x, y) BOOST_PP_SUB_D_I(d, x, y)
+#    define BOOST_PP_SUB_D_I(d, x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE_ ## d(BOOST_PP_SUB_P, BOOST_PP_SUB_O, (x, y)))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/inc.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/inc.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/inc.hpp	(working copy)
@@ -0,0 +1,288 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARITHMETIC_INC_HPP
+# define BOOST_PREPROCESSOR_ARITHMETIC_INC_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_INC */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_INC(x) BOOST_PP_INC_I(x)
+# else
+#    define BOOST_PP_INC(x) BOOST_PP_INC_OO((x))
+#    define BOOST_PP_INC_OO(par) BOOST_PP_INC_I ## par
+# endif
+#
+# define BOOST_PP_INC_I(x) BOOST_PP_INC_ ## x
+#
+# define BOOST_PP_INC_0 1
+# define BOOST_PP_INC_1 2
+# define BOOST_PP_INC_2 3
+# define BOOST_PP_INC_3 4
+# define BOOST_PP_INC_4 5
+# define BOOST_PP_INC_5 6
+# define BOOST_PP_INC_6 7
+# define BOOST_PP_INC_7 8
+# define BOOST_PP_INC_8 9
+# define BOOST_PP_INC_9 10
+# define BOOST_PP_INC_10 11
+# define BOOST_PP_INC_11 12
+# define BOOST_PP_INC_12 13
+# define BOOST_PP_INC_13 14
+# define BOOST_PP_INC_14 15
+# define BOOST_PP_INC_15 16
+# define BOOST_PP_INC_16 17
+# define BOOST_PP_INC_17 18
+# define BOOST_PP_INC_18 19
+# define BOOST_PP_INC_19 20
+# define BOOST_PP_INC_20 21
+# define BOOST_PP_INC_21 22
+# define BOOST_PP_INC_22 23
+# define BOOST_PP_INC_23 24
+# define BOOST_PP_INC_24 25
+# define BOOST_PP_INC_25 26
+# define BOOST_PP_INC_26 27
+# define BOOST_PP_INC_27 28
+# define BOOST_PP_INC_28 29
+# define BOOST_PP_INC_29 30
+# define BOOST_PP_INC_30 31
+# define BOOST_PP_INC_31 32
+# define BOOST_PP_INC_32 33
+# define BOOST_PP_INC_33 34
+# define BOOST_PP_INC_34 35
+# define BOOST_PP_INC_35 36
+# define BOOST_PP_INC_36 37
+# define BOOST_PP_INC_37 38
+# define BOOST_PP_INC_38 39
+# define BOOST_PP_INC_39 40
+# define BOOST_PP_INC_40 41
+# define BOOST_PP_INC_41 42
+# define BOOST_PP_INC_42 43
+# define BOOST_PP_INC_43 44
+# define BOOST_PP_INC_44 45
+# define BOOST_PP_INC_45 46
+# define BOOST_PP_INC_46 47
+# define BOOST_PP_INC_47 48
+# define BOOST_PP_INC_48 49
+# define BOOST_PP_INC_49 50
+# define BOOST_PP_INC_50 51
+# define BOOST_PP_INC_51 52
+# define BOOST_PP_INC_52 53
+# define BOOST_PP_INC_53 54
+# define BOOST_PP_INC_54 55
+# define BOOST_PP_INC_55 56
+# define BOOST_PP_INC_56 57
+# define BOOST_PP_INC_57 58
+# define BOOST_PP_INC_58 59
+# define BOOST_PP_INC_59 60
+# define BOOST_PP_INC_60 61
+# define BOOST_PP_INC_61 62
+# define BOOST_PP_INC_62 63
+# define BOOST_PP_INC_63 64
+# define BOOST_PP_INC_64 65
+# define BOOST_PP_INC_65 66
+# define BOOST_PP_INC_66 67
+# define BOOST_PP_INC_67 68
+# define BOOST_PP_INC_68 69
+# define BOOST_PP_INC_69 70
+# define BOOST_PP_INC_70 71
+# define BOOST_PP_INC_71 72
+# define BOOST_PP_INC_72 73
+# define BOOST_PP_INC_73 74
+# define BOOST_PP_INC_74 75
+# define BOOST_PP_INC_75 76
+# define BOOST_PP_INC_76 77
+# define BOOST_PP_INC_77 78
+# define BOOST_PP_INC_78 79
+# define BOOST_PP_INC_79 80
+# define BOOST_PP_INC_80 81
+# define BOOST_PP_INC_81 82
+# define BOOST_PP_INC_82 83
+# define BOOST_PP_INC_83 84
+# define BOOST_PP_INC_84 85
+# define BOOST_PP_INC_85 86
+# define BOOST_PP_INC_86 87
+# define BOOST_PP_INC_87 88
+# define BOOST_PP_INC_88 89
+# define BOOST_PP_INC_89 90
+# define BOOST_PP_INC_90 91
+# define BOOST_PP_INC_91 92
+# define BOOST_PP_INC_92 93
+# define BOOST_PP_INC_93 94
+# define BOOST_PP_INC_94 95
+# define BOOST_PP_INC_95 96
+# define BOOST_PP_INC_96 97
+# define BOOST_PP_INC_97 98
+# define BOOST_PP_INC_98 99
+# define BOOST_PP_INC_99 100
+# define BOOST_PP_INC_100 101
+# define BOOST_PP_INC_101 102
+# define BOOST_PP_INC_102 103
+# define BOOST_PP_INC_103 104
+# define BOOST_PP_INC_104 105
+# define BOOST_PP_INC_105 106
+# define BOOST_PP_INC_106 107
+# define BOOST_PP_INC_107 108
+# define BOOST_PP_INC_108 109
+# define BOOST_PP_INC_109 110
+# define BOOST_PP_INC_110 111
+# define BOOST_PP_INC_111 112
+# define BOOST_PP_INC_112 113
+# define BOOST_PP_INC_113 114
+# define BOOST_PP_INC_114 115
+# define BOOST_PP_INC_115 116
+# define BOOST_PP_INC_116 117
+# define BOOST_PP_INC_117 118
+# define BOOST_PP_INC_118 119
+# define BOOST_PP_INC_119 120
+# define BOOST_PP_INC_120 121
+# define BOOST_PP_INC_121 122
+# define BOOST_PP_INC_122 123
+# define BOOST_PP_INC_123 124
+# define BOOST_PP_INC_124 125
+# define BOOST_PP_INC_125 126
+# define BOOST_PP_INC_126 127
+# define BOOST_PP_INC_127 128
+# define BOOST_PP_INC_128 129
+# define BOOST_PP_INC_129 130
+# define BOOST_PP_INC_130 131
+# define BOOST_PP_INC_131 132
+# define BOOST_PP_INC_132 133
+# define BOOST_PP_INC_133 134
+# define BOOST_PP_INC_134 135
+# define BOOST_PP_INC_135 136
+# define BOOST_PP_INC_136 137
+# define BOOST_PP_INC_137 138
+# define BOOST_PP_INC_138 139
+# define BOOST_PP_INC_139 140
+# define BOOST_PP_INC_140 141
+# define BOOST_PP_INC_141 142
+# define BOOST_PP_INC_142 143
+# define BOOST_PP_INC_143 144
+# define BOOST_PP_INC_144 145
+# define BOOST_PP_INC_145 146
+# define BOOST_PP_INC_146 147
+# define BOOST_PP_INC_147 148
+# define BOOST_PP_INC_148 149
+# define BOOST_PP_INC_149 150
+# define BOOST_PP_INC_150 151
+# define BOOST_PP_INC_151 152
+# define BOOST_PP_INC_152 153
+# define BOOST_PP_INC_153 154
+# define BOOST_PP_INC_154 155
+# define BOOST_PP_INC_155 156
+# define BOOST_PP_INC_156 157
+# define BOOST_PP_INC_157 158
+# define BOOST_PP_INC_158 159
+# define BOOST_PP_INC_159 160
+# define BOOST_PP_INC_160 161
+# define BOOST_PP_INC_161 162
+# define BOOST_PP_INC_162 163
+# define BOOST_PP_INC_163 164
+# define BOOST_PP_INC_164 165
+# define BOOST_PP_INC_165 166
+# define BOOST_PP_INC_166 167
+# define BOOST_PP_INC_167 168
+# define BOOST_PP_INC_168 169
+# define BOOST_PP_INC_169 170
+# define BOOST_PP_INC_170 171
+# define BOOST_PP_INC_171 172
+# define BOOST_PP_INC_172 173
+# define BOOST_PP_INC_173 174
+# define BOOST_PP_INC_174 175
+# define BOOST_PP_INC_175 176
+# define BOOST_PP_INC_176 177
+# define BOOST_PP_INC_177 178
+# define BOOST_PP_INC_178 179
+# define BOOST_PP_INC_179 180
+# define BOOST_PP_INC_180 181
+# define BOOST_PP_INC_181 182
+# define BOOST_PP_INC_182 183
+# define BOOST_PP_INC_183 184
+# define BOOST_PP_INC_184 185
+# define BOOST_PP_INC_185 186
+# define BOOST_PP_INC_186 187
+# define BOOST_PP_INC_187 188
+# define BOOST_PP_INC_188 189
+# define BOOST_PP_INC_189 190
+# define BOOST_PP_INC_190 191
+# define BOOST_PP_INC_191 192
+# define BOOST_PP_INC_192 193
+# define BOOST_PP_INC_193 194
+# define BOOST_PP_INC_194 195
+# define BOOST_PP_INC_195 196
+# define BOOST_PP_INC_196 197
+# define BOOST_PP_INC_197 198
+# define BOOST_PP_INC_198 199
+# define BOOST_PP_INC_199 200
+# define BOOST_PP_INC_200 201
+# define BOOST_PP_INC_201 202
+# define BOOST_PP_INC_202 203
+# define BOOST_PP_INC_203 204
+# define BOOST_PP_INC_204 205
+# define BOOST_PP_INC_205 206
+# define BOOST_PP_INC_206 207
+# define BOOST_PP_INC_207 208
+# define BOOST_PP_INC_208 209
+# define BOOST_PP_INC_209 210
+# define BOOST_PP_INC_210 211
+# define BOOST_PP_INC_211 212
+# define BOOST_PP_INC_212 213
+# define BOOST_PP_INC_213 214
+# define BOOST_PP_INC_214 215
+# define BOOST_PP_INC_215 216
+# define BOOST_PP_INC_216 217
+# define BOOST_PP_INC_217 218
+# define BOOST_PP_INC_218 219
+# define BOOST_PP_INC_219 220
+# define BOOST_PP_INC_220 221
+# define BOOST_PP_INC_221 222
+# define BOOST_PP_INC_222 223
+# define BOOST_PP_INC_223 224
+# define BOOST_PP_INC_224 225
+# define BOOST_PP_INC_225 226
+# define BOOST_PP_INC_226 227
+# define BOOST_PP_INC_227 228
+# define BOOST_PP_INC_228 229
+# define BOOST_PP_INC_229 230
+# define BOOST_PP_INC_230 231
+# define BOOST_PP_INC_231 232
+# define BOOST_PP_INC_232 233
+# define BOOST_PP_INC_233 234
+# define BOOST_PP_INC_234 235
+# define BOOST_PP_INC_235 236
+# define BOOST_PP_INC_236 237
+# define BOOST_PP_INC_237 238
+# define BOOST_PP_INC_238 239
+# define BOOST_PP_INC_239 240
+# define BOOST_PP_INC_240 241
+# define BOOST_PP_INC_241 242
+# define BOOST_PP_INC_242 243
+# define BOOST_PP_INC_243 244
+# define BOOST_PP_INC_244 245
+# define BOOST_PP_INC_245 246
+# define BOOST_PP_INC_246 247
+# define BOOST_PP_INC_247 248
+# define BOOST_PP_INC_248 249
+# define BOOST_PP_INC_249 250
+# define BOOST_PP_INC_250 251
+# define BOOST_PP_INC_251 252
+# define BOOST_PP_INC_252 253
+# define BOOST_PP_INC_253 254
+# define BOOST_PP_INC_254 255
+# define BOOST_PP_INC_255 256
+# define BOOST_PP_INC_256 256
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/dec.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/dec.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/dec.hpp	(working copy)
@@ -0,0 +1,288 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARITHMETIC_DEC_HPP
+# define BOOST_PREPROCESSOR_ARITHMETIC_DEC_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_DEC */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_DEC(x) BOOST_PP_DEC_I(x)
+# else
+#    define BOOST_PP_DEC(x) BOOST_PP_DEC_OO((x))
+#    define BOOST_PP_DEC_OO(par) BOOST_PP_DEC_I ## par
+# endif
+#
+# define BOOST_PP_DEC_I(x) BOOST_PP_DEC_ ## x
+#
+# define BOOST_PP_DEC_0 0
+# define BOOST_PP_DEC_1 0
+# define BOOST_PP_DEC_2 1
+# define BOOST_PP_DEC_3 2
+# define BOOST_PP_DEC_4 3
+# define BOOST_PP_DEC_5 4
+# define BOOST_PP_DEC_6 5
+# define BOOST_PP_DEC_7 6
+# define BOOST_PP_DEC_8 7
+# define BOOST_PP_DEC_9 8
+# define BOOST_PP_DEC_10 9
+# define BOOST_PP_DEC_11 10
+# define BOOST_PP_DEC_12 11
+# define BOOST_PP_DEC_13 12
+# define BOOST_PP_DEC_14 13
+# define BOOST_PP_DEC_15 14
+# define BOOST_PP_DEC_16 15
+# define BOOST_PP_DEC_17 16
+# define BOOST_PP_DEC_18 17
+# define BOOST_PP_DEC_19 18
+# define BOOST_PP_DEC_20 19
+# define BOOST_PP_DEC_21 20
+# define BOOST_PP_DEC_22 21
+# define BOOST_PP_DEC_23 22
+# define BOOST_PP_DEC_24 23
+# define BOOST_PP_DEC_25 24
+# define BOOST_PP_DEC_26 25
+# define BOOST_PP_DEC_27 26
+# define BOOST_PP_DEC_28 27
+# define BOOST_PP_DEC_29 28
+# define BOOST_PP_DEC_30 29
+# define BOOST_PP_DEC_31 30
+# define BOOST_PP_DEC_32 31
+# define BOOST_PP_DEC_33 32
+# define BOOST_PP_DEC_34 33
+# define BOOST_PP_DEC_35 34
+# define BOOST_PP_DEC_36 35
+# define BOOST_PP_DEC_37 36
+# define BOOST_PP_DEC_38 37
+# define BOOST_PP_DEC_39 38
+# define BOOST_PP_DEC_40 39
+# define BOOST_PP_DEC_41 40
+# define BOOST_PP_DEC_42 41
+# define BOOST_PP_DEC_43 42
+# define BOOST_PP_DEC_44 43
+# define BOOST_PP_DEC_45 44
+# define BOOST_PP_DEC_46 45
+# define BOOST_PP_DEC_47 46
+# define BOOST_PP_DEC_48 47
+# define BOOST_PP_DEC_49 48
+# define BOOST_PP_DEC_50 49
+# define BOOST_PP_DEC_51 50
+# define BOOST_PP_DEC_52 51
+# define BOOST_PP_DEC_53 52
+# define BOOST_PP_DEC_54 53
+# define BOOST_PP_DEC_55 54
+# define BOOST_PP_DEC_56 55
+# define BOOST_PP_DEC_57 56
+# define BOOST_PP_DEC_58 57
+# define BOOST_PP_DEC_59 58
+# define BOOST_PP_DEC_60 59
+# define BOOST_PP_DEC_61 60
+# define BOOST_PP_DEC_62 61
+# define BOOST_PP_DEC_63 62
+# define BOOST_PP_DEC_64 63
+# define BOOST_PP_DEC_65 64
+# define BOOST_PP_DEC_66 65
+# define BOOST_PP_DEC_67 66
+# define BOOST_PP_DEC_68 67
+# define BOOST_PP_DEC_69 68
+# define BOOST_PP_DEC_70 69
+# define BOOST_PP_DEC_71 70
+# define BOOST_PP_DEC_72 71
+# define BOOST_PP_DEC_73 72
+# define BOOST_PP_DEC_74 73
+# define BOOST_PP_DEC_75 74
+# define BOOST_PP_DEC_76 75
+# define BOOST_PP_DEC_77 76
+# define BOOST_PP_DEC_78 77
+# define BOOST_PP_DEC_79 78
+# define BOOST_PP_DEC_80 79
+# define BOOST_PP_DEC_81 80
+# define BOOST_PP_DEC_82 81
+# define BOOST_PP_DEC_83 82
+# define BOOST_PP_DEC_84 83
+# define BOOST_PP_DEC_85 84
+# define BOOST_PP_DEC_86 85
+# define BOOST_PP_DEC_87 86
+# define BOOST_PP_DEC_88 87
+# define BOOST_PP_DEC_89 88
+# define BOOST_PP_DEC_90 89
+# define BOOST_PP_DEC_91 90
+# define BOOST_PP_DEC_92 91
+# define BOOST_PP_DEC_93 92
+# define BOOST_PP_DEC_94 93
+# define BOOST_PP_DEC_95 94
+# define BOOST_PP_DEC_96 95
+# define BOOST_PP_DEC_97 96
+# define BOOST_PP_DEC_98 97
+# define BOOST_PP_DEC_99 98
+# define BOOST_PP_DEC_100 99
+# define BOOST_PP_DEC_101 100
+# define BOOST_PP_DEC_102 101
+# define BOOST_PP_DEC_103 102
+# define BOOST_PP_DEC_104 103
+# define BOOST_PP_DEC_105 104
+# define BOOST_PP_DEC_106 105
+# define BOOST_PP_DEC_107 106
+# define BOOST_PP_DEC_108 107
+# define BOOST_PP_DEC_109 108
+# define BOOST_PP_DEC_110 109
+# define BOOST_PP_DEC_111 110
+# define BOOST_PP_DEC_112 111
+# define BOOST_PP_DEC_113 112
+# define BOOST_PP_DEC_114 113
+# define BOOST_PP_DEC_115 114
+# define BOOST_PP_DEC_116 115
+# define BOOST_PP_DEC_117 116
+# define BOOST_PP_DEC_118 117
+# define BOOST_PP_DEC_119 118
+# define BOOST_PP_DEC_120 119
+# define BOOST_PP_DEC_121 120
+# define BOOST_PP_DEC_122 121
+# define BOOST_PP_DEC_123 122
+# define BOOST_PP_DEC_124 123
+# define BOOST_PP_DEC_125 124
+# define BOOST_PP_DEC_126 125
+# define BOOST_PP_DEC_127 126
+# define BOOST_PP_DEC_128 127
+# define BOOST_PP_DEC_129 128
+# define BOOST_PP_DEC_130 129
+# define BOOST_PP_DEC_131 130
+# define BOOST_PP_DEC_132 131
+# define BOOST_PP_DEC_133 132
+# define BOOST_PP_DEC_134 133
+# define BOOST_PP_DEC_135 134
+# define BOOST_PP_DEC_136 135
+# define BOOST_PP_DEC_137 136
+# define BOOST_PP_DEC_138 137
+# define BOOST_PP_DEC_139 138
+# define BOOST_PP_DEC_140 139
+# define BOOST_PP_DEC_141 140
+# define BOOST_PP_DEC_142 141
+# define BOOST_PP_DEC_143 142
+# define BOOST_PP_DEC_144 143
+# define BOOST_PP_DEC_145 144
+# define BOOST_PP_DEC_146 145
+# define BOOST_PP_DEC_147 146
+# define BOOST_PP_DEC_148 147
+# define BOOST_PP_DEC_149 148
+# define BOOST_PP_DEC_150 149
+# define BOOST_PP_DEC_151 150
+# define BOOST_PP_DEC_152 151
+# define BOOST_PP_DEC_153 152
+# define BOOST_PP_DEC_154 153
+# define BOOST_PP_DEC_155 154
+# define BOOST_PP_DEC_156 155
+# define BOOST_PP_DEC_157 156
+# define BOOST_PP_DEC_158 157
+# define BOOST_PP_DEC_159 158
+# define BOOST_PP_DEC_160 159
+# define BOOST_PP_DEC_161 160
+# define BOOST_PP_DEC_162 161
+# define BOOST_PP_DEC_163 162
+# define BOOST_PP_DEC_164 163
+# define BOOST_PP_DEC_165 164
+# define BOOST_PP_DEC_166 165
+# define BOOST_PP_DEC_167 166
+# define BOOST_PP_DEC_168 167
+# define BOOST_PP_DEC_169 168
+# define BOOST_PP_DEC_170 169
+# define BOOST_PP_DEC_171 170
+# define BOOST_PP_DEC_172 171
+# define BOOST_PP_DEC_173 172
+# define BOOST_PP_DEC_174 173
+# define BOOST_PP_DEC_175 174
+# define BOOST_PP_DEC_176 175
+# define BOOST_PP_DEC_177 176
+# define BOOST_PP_DEC_178 177
+# define BOOST_PP_DEC_179 178
+# define BOOST_PP_DEC_180 179
+# define BOOST_PP_DEC_181 180
+# define BOOST_PP_DEC_182 181
+# define BOOST_PP_DEC_183 182
+# define BOOST_PP_DEC_184 183
+# define BOOST_PP_DEC_185 184
+# define BOOST_PP_DEC_186 185
+# define BOOST_PP_DEC_187 186
+# define BOOST_PP_DEC_188 187
+# define BOOST_PP_DEC_189 188
+# define BOOST_PP_DEC_190 189
+# define BOOST_PP_DEC_191 190
+# define BOOST_PP_DEC_192 191
+# define BOOST_PP_DEC_193 192
+# define BOOST_PP_DEC_194 193
+# define BOOST_PP_DEC_195 194
+# define BOOST_PP_DEC_196 195
+# define BOOST_PP_DEC_197 196
+# define BOOST_PP_DEC_198 197
+# define BOOST_PP_DEC_199 198
+# define BOOST_PP_DEC_200 199
+# define BOOST_PP_DEC_201 200
+# define BOOST_PP_DEC_202 201
+# define BOOST_PP_DEC_203 202
+# define BOOST_PP_DEC_204 203
+# define BOOST_PP_DEC_205 204
+# define BOOST_PP_DEC_206 205
+# define BOOST_PP_DEC_207 206
+# define BOOST_PP_DEC_208 207
+# define BOOST_PP_DEC_209 208
+# define BOOST_PP_DEC_210 209
+# define BOOST_PP_DEC_211 210
+# define BOOST_PP_DEC_212 211
+# define BOOST_PP_DEC_213 212
+# define BOOST_PP_DEC_214 213
+# define BOOST_PP_DEC_215 214
+# define BOOST_PP_DEC_216 215
+# define BOOST_PP_DEC_217 216
+# define BOOST_PP_DEC_218 217
+# define BOOST_PP_DEC_219 218
+# define BOOST_PP_DEC_220 219
+# define BOOST_PP_DEC_221 220
+# define BOOST_PP_DEC_222 221
+# define BOOST_PP_DEC_223 222
+# define BOOST_PP_DEC_224 223
+# define BOOST_PP_DEC_225 224
+# define BOOST_PP_DEC_226 225
+# define BOOST_PP_DEC_227 226
+# define BOOST_PP_DEC_228 227
+# define BOOST_PP_DEC_229 228
+# define BOOST_PP_DEC_230 229
+# define BOOST_PP_DEC_231 230
+# define BOOST_PP_DEC_232 231
+# define BOOST_PP_DEC_233 232
+# define BOOST_PP_DEC_234 233
+# define BOOST_PP_DEC_235 234
+# define BOOST_PP_DEC_236 235
+# define BOOST_PP_DEC_237 236
+# define BOOST_PP_DEC_238 237
+# define BOOST_PP_DEC_239 238
+# define BOOST_PP_DEC_240 239
+# define BOOST_PP_DEC_241 240
+# define BOOST_PP_DEC_242 241
+# define BOOST_PP_DEC_243 242
+# define BOOST_PP_DEC_244 243
+# define BOOST_PP_DEC_245 244
+# define BOOST_PP_DEC_246 245
+# define BOOST_PP_DEC_247 246
+# define BOOST_PP_DEC_248 247
+# define BOOST_PP_DEC_249 248
+# define BOOST_PP_DEC_250 249
+# define BOOST_PP_DEC_251 250
+# define BOOST_PP_DEC_252 251
+# define BOOST_PP_DEC_253 252
+# define BOOST_PP_DEC_254 253
+# define BOOST_PP_DEC_255 254
+# define BOOST_PP_DEC_256 255
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/add.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/add.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/arithmetic/add.hpp	(working copy)
@@ -0,0 +1,51 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARITHMETIC_ADD_HPP
+# define BOOST_PREPROCESSOR_ARITHMETIC_ADD_HPP
+#
+# include <boost/preprocessor/arithmetic/dec.hpp>
+# include <boost/preprocessor/arithmetic/inc.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/control/while.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+#
+# /* BOOST_PP_ADD */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ADD(x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (x, y)))
+# else
+#    define BOOST_PP_ADD(x, y) BOOST_PP_ADD_I(x, y)
+#    define BOOST_PP_ADD_I(x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (x, y)))
+# endif
+#
+# define BOOST_PP_ADD_P(d, xy) BOOST_PP_TUPLE_ELEM(2, 1, xy)
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_ADD_O(d, xy) BOOST_PP_ADD_O_I xy
+# else
+#    define BOOST_PP_ADD_O(d, xy) BOOST_PP_ADD_O_I(BOOST_PP_TUPLE_ELEM(2, 0, xy), BOOST_PP_TUPLE_ELEM(2, 1, xy))
+# endif
+#
+# define BOOST_PP_ADD_O_I(x, y) (BOOST_PP_INC(x), BOOST_PP_DEC(y))
+#
+# /* BOOST_PP_ADD_D */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ADD_D(d, x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE_ ## d(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (x, y)))
+# else
+#    define BOOST_PP_ADD_D(d, x, y) BOOST_PP_ADD_D_I(d, x, y)
+#    define BOOST_PP_ADD_D_I(d, x, y) BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_WHILE_ ## d(BOOST_PP_ADD_P, BOOST_PP_ADD_O, (x, y)))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/iter/forward1.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/iter/forward1.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/iter/forward1.hpp	(working copy)
@@ -0,0 +1,1342 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# if defined(BOOST_PP_ITERATION_LIMITS)
+#    if !defined(BOOST_PP_FILENAME_1)
+#        error BOOST_PP_ERROR:  depth #1 filename is not defined
+#    endif
+#    define BOOST_PP_VALUE BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_ITERATION_LIMITS)
+#    include <boost/preprocessor/iteration/detail/bounds/lower1.hpp>
+#    define BOOST_PP_VALUE BOOST_PP_TUPLE_ELEM(2, 1, BOOST_PP_ITERATION_LIMITS)
+#    include <boost/preprocessor/iteration/detail/bounds/upper1.hpp>
+#    define BOOST_PP_ITERATION_FLAGS_1 0
+#    undef BOOST_PP_ITERATION_LIMITS
+# elif defined(BOOST_PP_ITERATION_PARAMS_1)
+#    define BOOST_PP_VALUE BOOST_PP_ARRAY_ELEM(0, BOOST_PP_ITERATION_PARAMS_1)
+#    include <boost/preprocessor/iteration/detail/bounds/lower1.hpp>
+#    define BOOST_PP_VALUE BOOST_PP_ARRAY_ELEM(1, BOOST_PP_ITERATION_PARAMS_1)
+#    include <boost/preprocessor/iteration/detail/bounds/upper1.hpp>
+#    define BOOST_PP_FILENAME_1 BOOST_PP_ARRAY_ELEM(2, BOOST_PP_ITERATION_PARAMS_1)
+#    if BOOST_PP_ARRAY_SIZE(BOOST_PP_ITERATION_PARAMS_1) >= 4
+#        define BOOST_PP_ITERATION_FLAGS_1 BOOST_PP_ARRAY_ELEM(3, BOOST_PP_ITERATION_PARAMS_1)
+#    else
+#        define BOOST_PP_ITERATION_FLAGS_1 0
+#    endif
+# else
+#    error BOOST_PP_ERROR:  depth #1 iteration boundaries or filename not defined
+# endif
+#
+# undef BOOST_PP_ITERATION_DEPTH
+# define BOOST_PP_ITERATION_DEPTH() 1
+#
+# define BOOST_PP_IS_ITERATING 1
+#
+# if (BOOST_PP_ITERATION_START_1) > (BOOST_PP_ITERATION_FINISH_1)
+#    include <boost/preprocessor/iteration/detail/iter/reverse1.hpp>
+# else
+#    if BOOST_PP_ITERATION_START_1 <= 0 && BOOST_PP_ITERATION_FINISH_1 >= 0
+#        define BOOST_PP_ITERATION_1 0
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 1 && BOOST_PP_ITERATION_FINISH_1 >= 1
+#        define BOOST_PP_ITERATION_1 1
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 2 && BOOST_PP_ITERATION_FINISH_1 >= 2
+#        define BOOST_PP_ITERATION_1 2
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 3 && BOOST_PP_ITERATION_FINISH_1 >= 3
+#        define BOOST_PP_ITERATION_1 3
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 4 && BOOST_PP_ITERATION_FINISH_1 >= 4
+#        define BOOST_PP_ITERATION_1 4
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 5 && BOOST_PP_ITERATION_FINISH_1 >= 5
+#        define BOOST_PP_ITERATION_1 5
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 6 && BOOST_PP_ITERATION_FINISH_1 >= 6
+#        define BOOST_PP_ITERATION_1 6
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 7 && BOOST_PP_ITERATION_FINISH_1 >= 7
+#        define BOOST_PP_ITERATION_1 7
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 8 && BOOST_PP_ITERATION_FINISH_1 >= 8
+#        define BOOST_PP_ITERATION_1 8
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 9 && BOOST_PP_ITERATION_FINISH_1 >= 9
+#        define BOOST_PP_ITERATION_1 9
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 10 && BOOST_PP_ITERATION_FINISH_1 >= 10
+#        define BOOST_PP_ITERATION_1 10
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 11 && BOOST_PP_ITERATION_FINISH_1 >= 11
+#        define BOOST_PP_ITERATION_1 11
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 12 && BOOST_PP_ITERATION_FINISH_1 >= 12
+#        define BOOST_PP_ITERATION_1 12
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 13 && BOOST_PP_ITERATION_FINISH_1 >= 13
+#        define BOOST_PP_ITERATION_1 13
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 14 && BOOST_PP_ITERATION_FINISH_1 >= 14
+#        define BOOST_PP_ITERATION_1 14
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 15 && BOOST_PP_ITERATION_FINISH_1 >= 15
+#        define BOOST_PP_ITERATION_1 15
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 16 && BOOST_PP_ITERATION_FINISH_1 >= 16
+#        define BOOST_PP_ITERATION_1 16
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 17 && BOOST_PP_ITERATION_FINISH_1 >= 17
+#        define BOOST_PP_ITERATION_1 17
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 18 && BOOST_PP_ITERATION_FINISH_1 >= 18
+#        define BOOST_PP_ITERATION_1 18
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 19 && BOOST_PP_ITERATION_FINISH_1 >= 19
+#        define BOOST_PP_ITERATION_1 19
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 20 && BOOST_PP_ITERATION_FINISH_1 >= 20
+#        define BOOST_PP_ITERATION_1 20
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 21 && BOOST_PP_ITERATION_FINISH_1 >= 21
+#        define BOOST_PP_ITERATION_1 21
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 22 && BOOST_PP_ITERATION_FINISH_1 >= 22
+#        define BOOST_PP_ITERATION_1 22
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 23 && BOOST_PP_ITERATION_FINISH_1 >= 23
+#        define BOOST_PP_ITERATION_1 23
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 24 && BOOST_PP_ITERATION_FINISH_1 >= 24
+#        define BOOST_PP_ITERATION_1 24
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 25 && BOOST_PP_ITERATION_FINISH_1 >= 25
+#        define BOOST_PP_ITERATION_1 25
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 26 && BOOST_PP_ITERATION_FINISH_1 >= 26
+#        define BOOST_PP_ITERATION_1 26
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 27 && BOOST_PP_ITERATION_FINISH_1 >= 27
+#        define BOOST_PP_ITERATION_1 27
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 28 && BOOST_PP_ITERATION_FINISH_1 >= 28
+#        define BOOST_PP_ITERATION_1 28
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 29 && BOOST_PP_ITERATION_FINISH_1 >= 29
+#        define BOOST_PP_ITERATION_1 29
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 30 && BOOST_PP_ITERATION_FINISH_1 >= 30
+#        define BOOST_PP_ITERATION_1 30
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 31 && BOOST_PP_ITERATION_FINISH_1 >= 31
+#        define BOOST_PP_ITERATION_1 31
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 32 && BOOST_PP_ITERATION_FINISH_1 >= 32
+#        define BOOST_PP_ITERATION_1 32
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 33 && BOOST_PP_ITERATION_FINISH_1 >= 33
+#        define BOOST_PP_ITERATION_1 33
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 34 && BOOST_PP_ITERATION_FINISH_1 >= 34
+#        define BOOST_PP_ITERATION_1 34
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 35 && BOOST_PP_ITERATION_FINISH_1 >= 35
+#        define BOOST_PP_ITERATION_1 35
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 36 && BOOST_PP_ITERATION_FINISH_1 >= 36
+#        define BOOST_PP_ITERATION_1 36
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 37 && BOOST_PP_ITERATION_FINISH_1 >= 37
+#        define BOOST_PP_ITERATION_1 37
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 38 && BOOST_PP_ITERATION_FINISH_1 >= 38
+#        define BOOST_PP_ITERATION_1 38
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 39 && BOOST_PP_ITERATION_FINISH_1 >= 39
+#        define BOOST_PP_ITERATION_1 39
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 40 && BOOST_PP_ITERATION_FINISH_1 >= 40
+#        define BOOST_PP_ITERATION_1 40
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 41 && BOOST_PP_ITERATION_FINISH_1 >= 41
+#        define BOOST_PP_ITERATION_1 41
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 42 && BOOST_PP_ITERATION_FINISH_1 >= 42
+#        define BOOST_PP_ITERATION_1 42
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 43 && BOOST_PP_ITERATION_FINISH_1 >= 43
+#        define BOOST_PP_ITERATION_1 43
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 44 && BOOST_PP_ITERATION_FINISH_1 >= 44
+#        define BOOST_PP_ITERATION_1 44
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 45 && BOOST_PP_ITERATION_FINISH_1 >= 45
+#        define BOOST_PP_ITERATION_1 45
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 46 && BOOST_PP_ITERATION_FINISH_1 >= 46
+#        define BOOST_PP_ITERATION_1 46
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 47 && BOOST_PP_ITERATION_FINISH_1 >= 47
+#        define BOOST_PP_ITERATION_1 47
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 48 && BOOST_PP_ITERATION_FINISH_1 >= 48
+#        define BOOST_PP_ITERATION_1 48
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 49 && BOOST_PP_ITERATION_FINISH_1 >= 49
+#        define BOOST_PP_ITERATION_1 49
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 50 && BOOST_PP_ITERATION_FINISH_1 >= 50
+#        define BOOST_PP_ITERATION_1 50
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 51 && BOOST_PP_ITERATION_FINISH_1 >= 51
+#        define BOOST_PP_ITERATION_1 51
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 52 && BOOST_PP_ITERATION_FINISH_1 >= 52
+#        define BOOST_PP_ITERATION_1 52
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 53 && BOOST_PP_ITERATION_FINISH_1 >= 53
+#        define BOOST_PP_ITERATION_1 53
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 54 && BOOST_PP_ITERATION_FINISH_1 >= 54
+#        define BOOST_PP_ITERATION_1 54
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 55 && BOOST_PP_ITERATION_FINISH_1 >= 55
+#        define BOOST_PP_ITERATION_1 55
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 56 && BOOST_PP_ITERATION_FINISH_1 >= 56
+#        define BOOST_PP_ITERATION_1 56
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 57 && BOOST_PP_ITERATION_FINISH_1 >= 57
+#        define BOOST_PP_ITERATION_1 57
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 58 && BOOST_PP_ITERATION_FINISH_1 >= 58
+#        define BOOST_PP_ITERATION_1 58
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 59 && BOOST_PP_ITERATION_FINISH_1 >= 59
+#        define BOOST_PP_ITERATION_1 59
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 60 && BOOST_PP_ITERATION_FINISH_1 >= 60
+#        define BOOST_PP_ITERATION_1 60
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 61 && BOOST_PP_ITERATION_FINISH_1 >= 61
+#        define BOOST_PP_ITERATION_1 61
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 62 && BOOST_PP_ITERATION_FINISH_1 >= 62
+#        define BOOST_PP_ITERATION_1 62
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 63 && BOOST_PP_ITERATION_FINISH_1 >= 63
+#        define BOOST_PP_ITERATION_1 63
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 64 && BOOST_PP_ITERATION_FINISH_1 >= 64
+#        define BOOST_PP_ITERATION_1 64
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 65 && BOOST_PP_ITERATION_FINISH_1 >= 65
+#        define BOOST_PP_ITERATION_1 65
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 66 && BOOST_PP_ITERATION_FINISH_1 >= 66
+#        define BOOST_PP_ITERATION_1 66
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 67 && BOOST_PP_ITERATION_FINISH_1 >= 67
+#        define BOOST_PP_ITERATION_1 67
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 68 && BOOST_PP_ITERATION_FINISH_1 >= 68
+#        define BOOST_PP_ITERATION_1 68
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 69 && BOOST_PP_ITERATION_FINISH_1 >= 69
+#        define BOOST_PP_ITERATION_1 69
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 70 && BOOST_PP_ITERATION_FINISH_1 >= 70
+#        define BOOST_PP_ITERATION_1 70
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 71 && BOOST_PP_ITERATION_FINISH_1 >= 71
+#        define BOOST_PP_ITERATION_1 71
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 72 && BOOST_PP_ITERATION_FINISH_1 >= 72
+#        define BOOST_PP_ITERATION_1 72
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 73 && BOOST_PP_ITERATION_FINISH_1 >= 73
+#        define BOOST_PP_ITERATION_1 73
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 74 && BOOST_PP_ITERATION_FINISH_1 >= 74
+#        define BOOST_PP_ITERATION_1 74
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 75 && BOOST_PP_ITERATION_FINISH_1 >= 75
+#        define BOOST_PP_ITERATION_1 75
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 76 && BOOST_PP_ITERATION_FINISH_1 >= 76
+#        define BOOST_PP_ITERATION_1 76
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 77 && BOOST_PP_ITERATION_FINISH_1 >= 77
+#        define BOOST_PP_ITERATION_1 77
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 78 && BOOST_PP_ITERATION_FINISH_1 >= 78
+#        define BOOST_PP_ITERATION_1 78
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 79 && BOOST_PP_ITERATION_FINISH_1 >= 79
+#        define BOOST_PP_ITERATION_1 79
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 80 && BOOST_PP_ITERATION_FINISH_1 >= 80
+#        define BOOST_PP_ITERATION_1 80
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 81 && BOOST_PP_ITERATION_FINISH_1 >= 81
+#        define BOOST_PP_ITERATION_1 81
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 82 && BOOST_PP_ITERATION_FINISH_1 >= 82
+#        define BOOST_PP_ITERATION_1 82
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 83 && BOOST_PP_ITERATION_FINISH_1 >= 83
+#        define BOOST_PP_ITERATION_1 83
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 84 && BOOST_PP_ITERATION_FINISH_1 >= 84
+#        define BOOST_PP_ITERATION_1 84
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 85 && BOOST_PP_ITERATION_FINISH_1 >= 85
+#        define BOOST_PP_ITERATION_1 85
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 86 && BOOST_PP_ITERATION_FINISH_1 >= 86
+#        define BOOST_PP_ITERATION_1 86
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 87 && BOOST_PP_ITERATION_FINISH_1 >= 87
+#        define BOOST_PP_ITERATION_1 87
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 88 && BOOST_PP_ITERATION_FINISH_1 >= 88
+#        define BOOST_PP_ITERATION_1 88
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 89 && BOOST_PP_ITERATION_FINISH_1 >= 89
+#        define BOOST_PP_ITERATION_1 89
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 90 && BOOST_PP_ITERATION_FINISH_1 >= 90
+#        define BOOST_PP_ITERATION_1 90
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 91 && BOOST_PP_ITERATION_FINISH_1 >= 91
+#        define BOOST_PP_ITERATION_1 91
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 92 && BOOST_PP_ITERATION_FINISH_1 >= 92
+#        define BOOST_PP_ITERATION_1 92
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 93 && BOOST_PP_ITERATION_FINISH_1 >= 93
+#        define BOOST_PP_ITERATION_1 93
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 94 && BOOST_PP_ITERATION_FINISH_1 >= 94
+#        define BOOST_PP_ITERATION_1 94
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 95 && BOOST_PP_ITERATION_FINISH_1 >= 95
+#        define BOOST_PP_ITERATION_1 95
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 96 && BOOST_PP_ITERATION_FINISH_1 >= 96
+#        define BOOST_PP_ITERATION_1 96
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 97 && BOOST_PP_ITERATION_FINISH_1 >= 97
+#        define BOOST_PP_ITERATION_1 97
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 98 && BOOST_PP_ITERATION_FINISH_1 >= 98
+#        define BOOST_PP_ITERATION_1 98
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 99 && BOOST_PP_ITERATION_FINISH_1 >= 99
+#        define BOOST_PP_ITERATION_1 99
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 100 && BOOST_PP_ITERATION_FINISH_1 >= 100
+#        define BOOST_PP_ITERATION_1 100
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 101 && BOOST_PP_ITERATION_FINISH_1 >= 101
+#        define BOOST_PP_ITERATION_1 101
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 102 && BOOST_PP_ITERATION_FINISH_1 >= 102
+#        define BOOST_PP_ITERATION_1 102
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 103 && BOOST_PP_ITERATION_FINISH_1 >= 103
+#        define BOOST_PP_ITERATION_1 103
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 104 && BOOST_PP_ITERATION_FINISH_1 >= 104
+#        define BOOST_PP_ITERATION_1 104
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 105 && BOOST_PP_ITERATION_FINISH_1 >= 105
+#        define BOOST_PP_ITERATION_1 105
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 106 && BOOST_PP_ITERATION_FINISH_1 >= 106
+#        define BOOST_PP_ITERATION_1 106
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 107 && BOOST_PP_ITERATION_FINISH_1 >= 107
+#        define BOOST_PP_ITERATION_1 107
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 108 && BOOST_PP_ITERATION_FINISH_1 >= 108
+#        define BOOST_PP_ITERATION_1 108
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 109 && BOOST_PP_ITERATION_FINISH_1 >= 109
+#        define BOOST_PP_ITERATION_1 109
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 110 && BOOST_PP_ITERATION_FINISH_1 >= 110
+#        define BOOST_PP_ITERATION_1 110
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 111 && BOOST_PP_ITERATION_FINISH_1 >= 111
+#        define BOOST_PP_ITERATION_1 111
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 112 && BOOST_PP_ITERATION_FINISH_1 >= 112
+#        define BOOST_PP_ITERATION_1 112
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 113 && BOOST_PP_ITERATION_FINISH_1 >= 113
+#        define BOOST_PP_ITERATION_1 113
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 114 && BOOST_PP_ITERATION_FINISH_1 >= 114
+#        define BOOST_PP_ITERATION_1 114
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 115 && BOOST_PP_ITERATION_FINISH_1 >= 115
+#        define BOOST_PP_ITERATION_1 115
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 116 && BOOST_PP_ITERATION_FINISH_1 >= 116
+#        define BOOST_PP_ITERATION_1 116
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 117 && BOOST_PP_ITERATION_FINISH_1 >= 117
+#        define BOOST_PP_ITERATION_1 117
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 118 && BOOST_PP_ITERATION_FINISH_1 >= 118
+#        define BOOST_PP_ITERATION_1 118
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 119 && BOOST_PP_ITERATION_FINISH_1 >= 119
+#        define BOOST_PP_ITERATION_1 119
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 120 && BOOST_PP_ITERATION_FINISH_1 >= 120
+#        define BOOST_PP_ITERATION_1 120
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 121 && BOOST_PP_ITERATION_FINISH_1 >= 121
+#        define BOOST_PP_ITERATION_1 121
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 122 && BOOST_PP_ITERATION_FINISH_1 >= 122
+#        define BOOST_PP_ITERATION_1 122
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 123 && BOOST_PP_ITERATION_FINISH_1 >= 123
+#        define BOOST_PP_ITERATION_1 123
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 124 && BOOST_PP_ITERATION_FINISH_1 >= 124
+#        define BOOST_PP_ITERATION_1 124
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 125 && BOOST_PP_ITERATION_FINISH_1 >= 125
+#        define BOOST_PP_ITERATION_1 125
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 126 && BOOST_PP_ITERATION_FINISH_1 >= 126
+#        define BOOST_PP_ITERATION_1 126
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 127 && BOOST_PP_ITERATION_FINISH_1 >= 127
+#        define BOOST_PP_ITERATION_1 127
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 128 && BOOST_PP_ITERATION_FINISH_1 >= 128
+#        define BOOST_PP_ITERATION_1 128
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 129 && BOOST_PP_ITERATION_FINISH_1 >= 129
+#        define BOOST_PP_ITERATION_1 129
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 130 && BOOST_PP_ITERATION_FINISH_1 >= 130
+#        define BOOST_PP_ITERATION_1 130
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 131 && BOOST_PP_ITERATION_FINISH_1 >= 131
+#        define BOOST_PP_ITERATION_1 131
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 132 && BOOST_PP_ITERATION_FINISH_1 >= 132
+#        define BOOST_PP_ITERATION_1 132
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 133 && BOOST_PP_ITERATION_FINISH_1 >= 133
+#        define BOOST_PP_ITERATION_1 133
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 134 && BOOST_PP_ITERATION_FINISH_1 >= 134
+#        define BOOST_PP_ITERATION_1 134
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 135 && BOOST_PP_ITERATION_FINISH_1 >= 135
+#        define BOOST_PP_ITERATION_1 135
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 136 && BOOST_PP_ITERATION_FINISH_1 >= 136
+#        define BOOST_PP_ITERATION_1 136
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 137 && BOOST_PP_ITERATION_FINISH_1 >= 137
+#        define BOOST_PP_ITERATION_1 137
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 138 && BOOST_PP_ITERATION_FINISH_1 >= 138
+#        define BOOST_PP_ITERATION_1 138
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 139 && BOOST_PP_ITERATION_FINISH_1 >= 139
+#        define BOOST_PP_ITERATION_1 139
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 140 && BOOST_PP_ITERATION_FINISH_1 >= 140
+#        define BOOST_PP_ITERATION_1 140
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 141 && BOOST_PP_ITERATION_FINISH_1 >= 141
+#        define BOOST_PP_ITERATION_1 141
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 142 && BOOST_PP_ITERATION_FINISH_1 >= 142
+#        define BOOST_PP_ITERATION_1 142
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 143 && BOOST_PP_ITERATION_FINISH_1 >= 143
+#        define BOOST_PP_ITERATION_1 143
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 144 && BOOST_PP_ITERATION_FINISH_1 >= 144
+#        define BOOST_PP_ITERATION_1 144
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 145 && BOOST_PP_ITERATION_FINISH_1 >= 145
+#        define BOOST_PP_ITERATION_1 145
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 146 && BOOST_PP_ITERATION_FINISH_1 >= 146
+#        define BOOST_PP_ITERATION_1 146
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 147 && BOOST_PP_ITERATION_FINISH_1 >= 147
+#        define BOOST_PP_ITERATION_1 147
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 148 && BOOST_PP_ITERATION_FINISH_1 >= 148
+#        define BOOST_PP_ITERATION_1 148
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 149 && BOOST_PP_ITERATION_FINISH_1 >= 149
+#        define BOOST_PP_ITERATION_1 149
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 150 && BOOST_PP_ITERATION_FINISH_1 >= 150
+#        define BOOST_PP_ITERATION_1 150
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 151 && BOOST_PP_ITERATION_FINISH_1 >= 151
+#        define BOOST_PP_ITERATION_1 151
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 152 && BOOST_PP_ITERATION_FINISH_1 >= 152
+#        define BOOST_PP_ITERATION_1 152
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 153 && BOOST_PP_ITERATION_FINISH_1 >= 153
+#        define BOOST_PP_ITERATION_1 153
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 154 && BOOST_PP_ITERATION_FINISH_1 >= 154
+#        define BOOST_PP_ITERATION_1 154
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 155 && BOOST_PP_ITERATION_FINISH_1 >= 155
+#        define BOOST_PP_ITERATION_1 155
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 156 && BOOST_PP_ITERATION_FINISH_1 >= 156
+#        define BOOST_PP_ITERATION_1 156
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 157 && BOOST_PP_ITERATION_FINISH_1 >= 157
+#        define BOOST_PP_ITERATION_1 157
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 158 && BOOST_PP_ITERATION_FINISH_1 >= 158
+#        define BOOST_PP_ITERATION_1 158
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 159 && BOOST_PP_ITERATION_FINISH_1 >= 159
+#        define BOOST_PP_ITERATION_1 159
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 160 && BOOST_PP_ITERATION_FINISH_1 >= 160
+#        define BOOST_PP_ITERATION_1 160
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 161 && BOOST_PP_ITERATION_FINISH_1 >= 161
+#        define BOOST_PP_ITERATION_1 161
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 162 && BOOST_PP_ITERATION_FINISH_1 >= 162
+#        define BOOST_PP_ITERATION_1 162
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 163 && BOOST_PP_ITERATION_FINISH_1 >= 163
+#        define BOOST_PP_ITERATION_1 163
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 164 && BOOST_PP_ITERATION_FINISH_1 >= 164
+#        define BOOST_PP_ITERATION_1 164
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 165 && BOOST_PP_ITERATION_FINISH_1 >= 165
+#        define BOOST_PP_ITERATION_1 165
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 166 && BOOST_PP_ITERATION_FINISH_1 >= 166
+#        define BOOST_PP_ITERATION_1 166
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 167 && BOOST_PP_ITERATION_FINISH_1 >= 167
+#        define BOOST_PP_ITERATION_1 167
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 168 && BOOST_PP_ITERATION_FINISH_1 >= 168
+#        define BOOST_PP_ITERATION_1 168
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 169 && BOOST_PP_ITERATION_FINISH_1 >= 169
+#        define BOOST_PP_ITERATION_1 169
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 170 && BOOST_PP_ITERATION_FINISH_1 >= 170
+#        define BOOST_PP_ITERATION_1 170
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 171 && BOOST_PP_ITERATION_FINISH_1 >= 171
+#        define BOOST_PP_ITERATION_1 171
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 172 && BOOST_PP_ITERATION_FINISH_1 >= 172
+#        define BOOST_PP_ITERATION_1 172
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 173 && BOOST_PP_ITERATION_FINISH_1 >= 173
+#        define BOOST_PP_ITERATION_1 173
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 174 && BOOST_PP_ITERATION_FINISH_1 >= 174
+#        define BOOST_PP_ITERATION_1 174
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 175 && BOOST_PP_ITERATION_FINISH_1 >= 175
+#        define BOOST_PP_ITERATION_1 175
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 176 && BOOST_PP_ITERATION_FINISH_1 >= 176
+#        define BOOST_PP_ITERATION_1 176
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 177 && BOOST_PP_ITERATION_FINISH_1 >= 177
+#        define BOOST_PP_ITERATION_1 177
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 178 && BOOST_PP_ITERATION_FINISH_1 >= 178
+#        define BOOST_PP_ITERATION_1 178
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 179 && BOOST_PP_ITERATION_FINISH_1 >= 179
+#        define BOOST_PP_ITERATION_1 179
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 180 && BOOST_PP_ITERATION_FINISH_1 >= 180
+#        define BOOST_PP_ITERATION_1 180
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 181 && BOOST_PP_ITERATION_FINISH_1 >= 181
+#        define BOOST_PP_ITERATION_1 181
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 182 && BOOST_PP_ITERATION_FINISH_1 >= 182
+#        define BOOST_PP_ITERATION_1 182
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 183 && BOOST_PP_ITERATION_FINISH_1 >= 183
+#        define BOOST_PP_ITERATION_1 183
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 184 && BOOST_PP_ITERATION_FINISH_1 >= 184
+#        define BOOST_PP_ITERATION_1 184
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 185 && BOOST_PP_ITERATION_FINISH_1 >= 185
+#        define BOOST_PP_ITERATION_1 185
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 186 && BOOST_PP_ITERATION_FINISH_1 >= 186
+#        define BOOST_PP_ITERATION_1 186
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 187 && BOOST_PP_ITERATION_FINISH_1 >= 187
+#        define BOOST_PP_ITERATION_1 187
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 188 && BOOST_PP_ITERATION_FINISH_1 >= 188
+#        define BOOST_PP_ITERATION_1 188
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 189 && BOOST_PP_ITERATION_FINISH_1 >= 189
+#        define BOOST_PP_ITERATION_1 189
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 190 && BOOST_PP_ITERATION_FINISH_1 >= 190
+#        define BOOST_PP_ITERATION_1 190
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 191 && BOOST_PP_ITERATION_FINISH_1 >= 191
+#        define BOOST_PP_ITERATION_1 191
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 192 && BOOST_PP_ITERATION_FINISH_1 >= 192
+#        define BOOST_PP_ITERATION_1 192
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 193 && BOOST_PP_ITERATION_FINISH_1 >= 193
+#        define BOOST_PP_ITERATION_1 193
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 194 && BOOST_PP_ITERATION_FINISH_1 >= 194
+#        define BOOST_PP_ITERATION_1 194
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 195 && BOOST_PP_ITERATION_FINISH_1 >= 195
+#        define BOOST_PP_ITERATION_1 195
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 196 && BOOST_PP_ITERATION_FINISH_1 >= 196
+#        define BOOST_PP_ITERATION_1 196
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 197 && BOOST_PP_ITERATION_FINISH_1 >= 197
+#        define BOOST_PP_ITERATION_1 197
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 198 && BOOST_PP_ITERATION_FINISH_1 >= 198
+#        define BOOST_PP_ITERATION_1 198
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 199 && BOOST_PP_ITERATION_FINISH_1 >= 199
+#        define BOOST_PP_ITERATION_1 199
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 200 && BOOST_PP_ITERATION_FINISH_1 >= 200
+#        define BOOST_PP_ITERATION_1 200
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 201 && BOOST_PP_ITERATION_FINISH_1 >= 201
+#        define BOOST_PP_ITERATION_1 201
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 202 && BOOST_PP_ITERATION_FINISH_1 >= 202
+#        define BOOST_PP_ITERATION_1 202
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 203 && BOOST_PP_ITERATION_FINISH_1 >= 203
+#        define BOOST_PP_ITERATION_1 203
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 204 && BOOST_PP_ITERATION_FINISH_1 >= 204
+#        define BOOST_PP_ITERATION_1 204
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 205 && BOOST_PP_ITERATION_FINISH_1 >= 205
+#        define BOOST_PP_ITERATION_1 205
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 206 && BOOST_PP_ITERATION_FINISH_1 >= 206
+#        define BOOST_PP_ITERATION_1 206
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 207 && BOOST_PP_ITERATION_FINISH_1 >= 207
+#        define BOOST_PP_ITERATION_1 207
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 208 && BOOST_PP_ITERATION_FINISH_1 >= 208
+#        define BOOST_PP_ITERATION_1 208
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 209 && BOOST_PP_ITERATION_FINISH_1 >= 209
+#        define BOOST_PP_ITERATION_1 209
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 210 && BOOST_PP_ITERATION_FINISH_1 >= 210
+#        define BOOST_PP_ITERATION_1 210
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 211 && BOOST_PP_ITERATION_FINISH_1 >= 211
+#        define BOOST_PP_ITERATION_1 211
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 212 && BOOST_PP_ITERATION_FINISH_1 >= 212
+#        define BOOST_PP_ITERATION_1 212
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 213 && BOOST_PP_ITERATION_FINISH_1 >= 213
+#        define BOOST_PP_ITERATION_1 213
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 214 && BOOST_PP_ITERATION_FINISH_1 >= 214
+#        define BOOST_PP_ITERATION_1 214
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 215 && BOOST_PP_ITERATION_FINISH_1 >= 215
+#        define BOOST_PP_ITERATION_1 215
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 216 && BOOST_PP_ITERATION_FINISH_1 >= 216
+#        define BOOST_PP_ITERATION_1 216
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 217 && BOOST_PP_ITERATION_FINISH_1 >= 217
+#        define BOOST_PP_ITERATION_1 217
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 218 && BOOST_PP_ITERATION_FINISH_1 >= 218
+#        define BOOST_PP_ITERATION_1 218
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 219 && BOOST_PP_ITERATION_FINISH_1 >= 219
+#        define BOOST_PP_ITERATION_1 219
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 220 && BOOST_PP_ITERATION_FINISH_1 >= 220
+#        define BOOST_PP_ITERATION_1 220
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 221 && BOOST_PP_ITERATION_FINISH_1 >= 221
+#        define BOOST_PP_ITERATION_1 221
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 222 && BOOST_PP_ITERATION_FINISH_1 >= 222
+#        define BOOST_PP_ITERATION_1 222
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 223 && BOOST_PP_ITERATION_FINISH_1 >= 223
+#        define BOOST_PP_ITERATION_1 223
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 224 && BOOST_PP_ITERATION_FINISH_1 >= 224
+#        define BOOST_PP_ITERATION_1 224
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 225 && BOOST_PP_ITERATION_FINISH_1 >= 225
+#        define BOOST_PP_ITERATION_1 225
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 226 && BOOST_PP_ITERATION_FINISH_1 >= 226
+#        define BOOST_PP_ITERATION_1 226
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 227 && BOOST_PP_ITERATION_FINISH_1 >= 227
+#        define BOOST_PP_ITERATION_1 227
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 228 && BOOST_PP_ITERATION_FINISH_1 >= 228
+#        define BOOST_PP_ITERATION_1 228
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 229 && BOOST_PP_ITERATION_FINISH_1 >= 229
+#        define BOOST_PP_ITERATION_1 229
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 230 && BOOST_PP_ITERATION_FINISH_1 >= 230
+#        define BOOST_PP_ITERATION_1 230
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 231 && BOOST_PP_ITERATION_FINISH_1 >= 231
+#        define BOOST_PP_ITERATION_1 231
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 232 && BOOST_PP_ITERATION_FINISH_1 >= 232
+#        define BOOST_PP_ITERATION_1 232
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 233 && BOOST_PP_ITERATION_FINISH_1 >= 233
+#        define BOOST_PP_ITERATION_1 233
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 234 && BOOST_PP_ITERATION_FINISH_1 >= 234
+#        define BOOST_PP_ITERATION_1 234
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 235 && BOOST_PP_ITERATION_FINISH_1 >= 235
+#        define BOOST_PP_ITERATION_1 235
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 236 && BOOST_PP_ITERATION_FINISH_1 >= 236
+#        define BOOST_PP_ITERATION_1 236
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 237 && BOOST_PP_ITERATION_FINISH_1 >= 237
+#        define BOOST_PP_ITERATION_1 237
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 238 && BOOST_PP_ITERATION_FINISH_1 >= 238
+#        define BOOST_PP_ITERATION_1 238
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 239 && BOOST_PP_ITERATION_FINISH_1 >= 239
+#        define BOOST_PP_ITERATION_1 239
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 240 && BOOST_PP_ITERATION_FINISH_1 >= 240
+#        define BOOST_PP_ITERATION_1 240
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 241 && BOOST_PP_ITERATION_FINISH_1 >= 241
+#        define BOOST_PP_ITERATION_1 241
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 242 && BOOST_PP_ITERATION_FINISH_1 >= 242
+#        define BOOST_PP_ITERATION_1 242
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 243 && BOOST_PP_ITERATION_FINISH_1 >= 243
+#        define BOOST_PP_ITERATION_1 243
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 244 && BOOST_PP_ITERATION_FINISH_1 >= 244
+#        define BOOST_PP_ITERATION_1 244
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 245 && BOOST_PP_ITERATION_FINISH_1 >= 245
+#        define BOOST_PP_ITERATION_1 245
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 246 && BOOST_PP_ITERATION_FINISH_1 >= 246
+#        define BOOST_PP_ITERATION_1 246
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 247 && BOOST_PP_ITERATION_FINISH_1 >= 247
+#        define BOOST_PP_ITERATION_1 247
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 248 && BOOST_PP_ITERATION_FINISH_1 >= 248
+#        define BOOST_PP_ITERATION_1 248
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 249 && BOOST_PP_ITERATION_FINISH_1 >= 249
+#        define BOOST_PP_ITERATION_1 249
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 250 && BOOST_PP_ITERATION_FINISH_1 >= 250
+#        define BOOST_PP_ITERATION_1 250
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 251 && BOOST_PP_ITERATION_FINISH_1 >= 251
+#        define BOOST_PP_ITERATION_1 251
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 252 && BOOST_PP_ITERATION_FINISH_1 >= 252
+#        define BOOST_PP_ITERATION_1 252
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 253 && BOOST_PP_ITERATION_FINISH_1 >= 253
+#        define BOOST_PP_ITERATION_1 253
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 254 && BOOST_PP_ITERATION_FINISH_1 >= 254
+#        define BOOST_PP_ITERATION_1 254
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 255 && BOOST_PP_ITERATION_FINISH_1 >= 255
+#        define BOOST_PP_ITERATION_1 255
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+#    if BOOST_PP_ITERATION_START_1 <= 256 && BOOST_PP_ITERATION_FINISH_1 >= 256
+#        define BOOST_PP_ITERATION_1 256
+#        include BOOST_PP_FILENAME_1
+#        undef BOOST_PP_ITERATION_1
+#    endif
+# endif
+#
+# undef BOOST_PP_IS_ITERATING
+#
+# undef BOOST_PP_ITERATION_DEPTH
+# define BOOST_PP_ITERATION_DEPTH() 0
+#
+# undef BOOST_PP_ITERATION_START_1
+# undef BOOST_PP_ITERATION_FINISH_1
+# undef BOOST_PP_FILENAME_1
+#
+# undef BOOST_PP_ITERATION_FLAGS_1
+# undef BOOST_PP_ITERATION_PARAMS_1
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/bounds/lower1.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/bounds/lower1.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/bounds/lower1.hpp	(working copy)
@@ -0,0 +1,99 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# include <boost/preprocessor/slot/detail/shared.hpp>
+#
+# undef BOOST_PP_ITERATION_START_1
+#
+# undef BOOST_PP_ITERATION_START_1_DIGIT_1
+# undef BOOST_PP_ITERATION_START_1_DIGIT_2
+# undef BOOST_PP_ITERATION_START_1_DIGIT_3
+# undef BOOST_PP_ITERATION_START_1_DIGIT_4
+# undef BOOST_PP_ITERATION_START_1_DIGIT_5
+# undef BOOST_PP_ITERATION_START_1_DIGIT_6
+# undef BOOST_PP_ITERATION_START_1_DIGIT_7
+# undef BOOST_PP_ITERATION_START_1_DIGIT_8
+# undef BOOST_PP_ITERATION_START_1_DIGIT_9
+# undef BOOST_PP_ITERATION_START_1_DIGIT_10
+#
+# if BOOST_PP_SLOT_TEMP_3 == 0
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 0
+# elif BOOST_PP_SLOT_TEMP_3 == 1
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 1
+# elif BOOST_PP_SLOT_TEMP_3 == 2
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 2
+# elif BOOST_PP_SLOT_TEMP_3 == 3
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 3
+# elif BOOST_PP_SLOT_TEMP_3 == 4
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 4
+# elif BOOST_PP_SLOT_TEMP_3 == 5
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 5
+# elif BOOST_PP_SLOT_TEMP_3 == 6
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 6
+# elif BOOST_PP_SLOT_TEMP_3 == 7
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 7
+# elif BOOST_PP_SLOT_TEMP_3 == 8
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 8
+# elif BOOST_PP_SLOT_TEMP_3 == 9
+#    define BOOST_PP_ITERATION_START_1_DIGIT_3 9
+# endif
+#
+# if BOOST_PP_SLOT_TEMP_2 == 0
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 0
+# elif BOOST_PP_SLOT_TEMP_2 == 1
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 1
+# elif BOOST_PP_SLOT_TEMP_2 == 2
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 2
+# elif BOOST_PP_SLOT_TEMP_2 == 3
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 3
+# elif BOOST_PP_SLOT_TEMP_2 == 4
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 4
+# elif BOOST_PP_SLOT_TEMP_2 == 5
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 5
+# elif BOOST_PP_SLOT_TEMP_2 == 6
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 6
+# elif BOOST_PP_SLOT_TEMP_2 == 7
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 7
+# elif BOOST_PP_SLOT_TEMP_2 == 8
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 8
+# elif BOOST_PP_SLOT_TEMP_2 == 9
+#    define BOOST_PP_ITERATION_START_1_DIGIT_2 9
+# endif
+#
+# if BOOST_PP_SLOT_TEMP_1 == 0
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 0
+# elif BOOST_PP_SLOT_TEMP_1 == 1
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 1
+# elif BOOST_PP_SLOT_TEMP_1 == 2
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 2
+# elif BOOST_PP_SLOT_TEMP_1 == 3
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 3
+# elif BOOST_PP_SLOT_TEMP_1 == 4
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 4
+# elif BOOST_PP_SLOT_TEMP_1 == 5
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 5
+# elif BOOST_PP_SLOT_TEMP_1 == 6
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 6
+# elif BOOST_PP_SLOT_TEMP_1 == 7
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 7
+# elif BOOST_PP_SLOT_TEMP_1 == 8
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 8
+# elif BOOST_PP_SLOT_TEMP_1 == 9
+#    define BOOST_PP_ITERATION_START_1_DIGIT_1 9
+# endif
+#
+# if BOOST_PP_ITERATION_START_1_DIGIT_3
+#    define BOOST_PP_ITERATION_START_1 BOOST_PP_SLOT_CC_3(BOOST_PP_ITERATION_START_1_DIGIT_3, BOOST_PP_ITERATION_START_1_DIGIT_2, BOOST_PP_ITERATION_START_1_DIGIT_1)
+# elif BOOST_PP_ITERATION_START_1_DIGIT_2
+#    define BOOST_PP_ITERATION_START_1 BOOST_PP_SLOT_CC_2(BOOST_PP_ITERATION_START_1_DIGIT_2, BOOST_PP_ITERATION_START_1_DIGIT_1)
+# else
+#    define BOOST_PP_ITERATION_START_1 BOOST_PP_ITERATION_START_1_DIGIT_1
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/bounds/upper1.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/bounds/upper1.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/detail/bounds/upper1.hpp	(working copy)
@@ -0,0 +1,99 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# include <boost/preprocessor/slot/detail/shared.hpp>
+#
+# undef BOOST_PP_ITERATION_FINISH_1
+#
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_1
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_2
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_3
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_4
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_5
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_6
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_7
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_8
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_9
+# undef BOOST_PP_ITERATION_FINISH_1_DIGIT_10
+#
+# if BOOST_PP_SLOT_TEMP_3 == 0
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 0
+# elif BOOST_PP_SLOT_TEMP_3 == 1
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 1
+# elif BOOST_PP_SLOT_TEMP_3 == 2
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 2
+# elif BOOST_PP_SLOT_TEMP_3 == 3
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 3
+# elif BOOST_PP_SLOT_TEMP_3 == 4
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 4
+# elif BOOST_PP_SLOT_TEMP_3 == 5
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 5
+# elif BOOST_PP_SLOT_TEMP_3 == 6
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 6
+# elif BOOST_PP_SLOT_TEMP_3 == 7
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 7
+# elif BOOST_PP_SLOT_TEMP_3 == 8
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 8
+# elif BOOST_PP_SLOT_TEMP_3 == 9
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_3 9
+# endif
+#
+# if BOOST_PP_SLOT_TEMP_2 == 0
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 0
+# elif BOOST_PP_SLOT_TEMP_2 == 1
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 1
+# elif BOOST_PP_SLOT_TEMP_2 == 2
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 2
+# elif BOOST_PP_SLOT_TEMP_2 == 3
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 3
+# elif BOOST_PP_SLOT_TEMP_2 == 4
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 4
+# elif BOOST_PP_SLOT_TEMP_2 == 5
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 5
+# elif BOOST_PP_SLOT_TEMP_2 == 6
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 6
+# elif BOOST_PP_SLOT_TEMP_2 == 7
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 7
+# elif BOOST_PP_SLOT_TEMP_2 == 8
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 8
+# elif BOOST_PP_SLOT_TEMP_2 == 9
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_2 9
+# endif
+#
+# if BOOST_PP_SLOT_TEMP_1 == 0
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 0
+# elif BOOST_PP_SLOT_TEMP_1 == 1
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 1
+# elif BOOST_PP_SLOT_TEMP_1 == 2
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 2
+# elif BOOST_PP_SLOT_TEMP_1 == 3
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 3
+# elif BOOST_PP_SLOT_TEMP_1 == 4
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 4
+# elif BOOST_PP_SLOT_TEMP_1 == 5
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 5
+# elif BOOST_PP_SLOT_TEMP_1 == 6
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 6
+# elif BOOST_PP_SLOT_TEMP_1 == 7
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 7
+# elif BOOST_PP_SLOT_TEMP_1 == 8
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 8
+# elif BOOST_PP_SLOT_TEMP_1 == 9
+#    define BOOST_PP_ITERATION_FINISH_1_DIGIT_1 9
+# endif
+#
+# if BOOST_PP_ITERATION_FINISH_1_DIGIT_3
+#    define BOOST_PP_ITERATION_FINISH_1 BOOST_PP_SLOT_CC_3(BOOST_PP_ITERATION_FINISH_1_DIGIT_3, BOOST_PP_ITERATION_FINISH_1_DIGIT_2, BOOST_PP_ITERATION_FINISH_1_DIGIT_1)
+# elif BOOST_PP_ITERATION_FINISH_1_DIGIT_2
+#    define BOOST_PP_ITERATION_FINISH_1 BOOST_PP_SLOT_CC_2(BOOST_PP_ITERATION_FINISH_1_DIGIT_2, BOOST_PP_ITERATION_FINISH_1_DIGIT_1)
+# else
+#    define BOOST_PP_ITERATION_FINISH_1 BOOST_PP_ITERATION_FINISH_1_DIGIT_1
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/iterate.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/iterate.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/iteration/iterate.hpp	(working copy)
@@ -0,0 +1,82 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ITERATION_ITERATE_HPP
+# define BOOST_PREPROCESSOR_ITERATION_ITERATE_HPP
+#
+# include <boost/preprocessor/arithmetic/dec.hpp>
+# include <boost/preprocessor/arithmetic/inc.hpp>
+# include <boost/preprocessor/array/elem.hpp>
+# include <boost/preprocessor/array/size.hpp>
+# include <boost/preprocessor/cat.hpp>
+# include <boost/preprocessor/slot/slot.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+#
+# /* BOOST_PP_ITERATION_DEPTH */
+#
+# define BOOST_PP_ITERATION_DEPTH() 0
+#
+# /* BOOST_PP_ITERATION */
+#
+# define BOOST_PP_ITERATION() BOOST_PP_CAT(BOOST_PP_ITERATION_, BOOST_PP_ITERATION_DEPTH())
+#
+# /* BOOST_PP_ITERATION_START && BOOST_PP_ITERATION_FINISH */
+#
+# define BOOST_PP_ITERATION_START() BOOST_PP_CAT(BOOST_PP_ITERATION_START_, BOOST_PP_ITERATION_DEPTH())
+# define BOOST_PP_ITERATION_FINISH() BOOST_PP_CAT(BOOST_PP_ITERATION_FINISH_, BOOST_PP_ITERATION_DEPTH())
+#
+# /* BOOST_PP_ITERATION_FLAGS */
+#
+# define BOOST_PP_ITERATION_FLAGS() (BOOST_PP_CAT(BOOST_PP_ITERATION_FLAGS_, BOOST_PP_ITERATION_DEPTH()))
+#
+# /* BOOST_PP_FRAME_ITERATION */
+#
+# define BOOST_PP_FRAME_ITERATION(i) BOOST_PP_CAT(BOOST_PP_ITERATION_, i)
+#
+# /* BOOST_PP_FRAME_START && BOOST_PP_FRAME_FINISH */
+#
+# define BOOST_PP_FRAME_START(i) BOOST_PP_CAT(BOOST_PP_ITERATION_START_, i)
+# define BOOST_PP_FRAME_FINISH(i) BOOST_PP_CAT(BOOST_PP_ITERATION_FINISH_, i)
+#
+# /* BOOST_PP_FRAME_FLAGS */
+#
+# define BOOST_PP_FRAME_FLAGS(i) (BOOST_PP_CAT(BOOST_PP_ITERATION_FLAGS_, i))
+#
+# /* BOOST_PP_RELATIVE_ITERATION */
+#
+# define BOOST_PP_RELATIVE_ITERATION(i) BOOST_PP_CAT(BOOST_PP_RELATIVE_, i)(BOOST_PP_ITERATION_)
+#
+# define BOOST_PP_RELATIVE_0(m) BOOST_PP_CAT(m, BOOST_PP_ITERATION_DEPTH())
+# define BOOST_PP_RELATIVE_1(m) BOOST_PP_CAT(m, BOOST_PP_DEC(BOOST_PP_ITERATION_DEPTH()))
+# define BOOST_PP_RELATIVE_2(m) BOOST_PP_CAT(m, BOOST_PP_DEC(BOOST_PP_DEC(BOOST_PP_ITERATION_DEPTH())))
+# define BOOST_PP_RELATIVE_3(m) BOOST_PP_CAT(m, BOOST_PP_DEC(BOOST_PP_DEC(BOOST_PP_DEC(BOOST_PP_ITERATION_DEPTH()))))
+# define BOOST_PP_RELATIVE_4(m) BOOST_PP_CAT(m, BOOST_PP_DEC(BOOST_PP_DEC(BOOST_PP_DEC(BOOST_PP_DEC(BOOST_PP_ITERATION_DEPTH())))))
+#
+# /* BOOST_PP_RELATIVE_START && BOOST_PP_RELATIVE_FINISH */
+#
+# define BOOST_PP_RELATIVE_START(i) BOOST_PP_CAT(BOOST_PP_RELATIVE_, i)(BOOST_PP_ITERATION_START_)
+# define BOOST_PP_RELATIVE_FINISH(i) BOOST_PP_CAT(BOOST_PP_RELATIVE_, i)(BOOST_PP_ITERATION_FINISH_)
+#
+# /* BOOST_PP_RELATIVE_FLAGS */
+#
+# define BOOST_PP_RELATIVE_FLAGS(i) (BOOST_PP_CAT(BOOST_PP_RELATIVE_, i)(BOOST_PP_ITERATION_FLAGS_))
+#
+# /* BOOST_PP_ITERATE */
+#
+# define BOOST_PP_ITERATE() BOOST_PP_CAT(BOOST_PP_ITERATE_, BOOST_PP_INC(BOOST_PP_ITERATION_DEPTH()))
+#
+# define BOOST_PP_ITERATE_1 <boost/preprocessor/iteration/detail/iter/forward1.hpp>
+# define BOOST_PP_ITERATE_2 <boost/preprocessor/iteration/detail/iter/forward2.hpp>
+# define BOOST_PP_ITERATE_3 <boost/preprocessor/iteration/detail/iter/forward3.hpp>
+# define BOOST_PP_ITERATE_4 <boost/preprocessor/iteration/detail/iter/forward4.hpp>
+# define BOOST_PP_ITERATE_5 <boost/preprocessor/iteration/detail/iter/forward5.hpp>
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/inc.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/inc.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/inc.hpp	(working copy)
@@ -0,0 +1,17 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_INC_HPP
+# define BOOST_PREPROCESSOR_INC_HPP
+#
+# include <boost/preprocessor/arithmetic/inc.hpp>
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/comma_if.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/comma_if.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/comma_if.hpp	(working copy)
@@ -0,0 +1,17 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_COMMA_IF_HPP
+# define BOOST_PREPROCESSOR_COMMA_IF_HPP
+#
+# include <boost/preprocessor/punctuation/comma_if.hpp>
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/config/config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/config/config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/config/config.hpp	(working copy)
@@ -0,0 +1,70 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_CONFIG_CONFIG_HPP
+# define BOOST_PREPROCESSOR_CONFIG_CONFIG_HPP
+#
+# /* BOOST_PP_CONFIG_FLAGS */
+#
+# define BOOST_PP_CONFIG_STRICT() 0x0001
+# define BOOST_PP_CONFIG_IDEAL() 0x0002
+#
+# define BOOST_PP_CONFIG_MSVC() 0x0004
+# define BOOST_PP_CONFIG_MWCC() 0x0008
+# define BOOST_PP_CONFIG_BCC() 0x0010
+# define BOOST_PP_CONFIG_EDG() 0x0020
+# define BOOST_PP_CONFIG_DMC() 0x0040
+#
+# ifndef BOOST_PP_CONFIG_FLAGS
+#    if defined(__GCCXML__)
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_STRICT())
+#    elif defined(__WAVE__)
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_STRICT())
+#    elif defined(__MWERKS__) && __MWERKS__ >= 0x3200
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_STRICT())
+#    elif defined(__EDG__) || defined(__EDG_VERSION__)
+#        if defined(_MSC_VER) && __EDG_VERSION__ >= 308
+#            define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_MSVC())
+#        else
+#            define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_EDG() | BOOST_PP_CONFIG_STRICT())
+#        endif
+#    elif defined(__MWERKS__)
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_MWCC())
+#    elif defined(__DMC__)
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_DMC())
+#    elif defined(__BORLANDC__) && __BORLANDC__ >= 0x581
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_STRICT())
+#    elif defined(__BORLANDC__) || defined(__IBMC__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_BCC())
+#    elif defined(_MSC_VER)
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_MSVC())
+#    else
+#        define BOOST_PP_CONFIG_FLAGS() (BOOST_PP_CONFIG_STRICT())
+#    endif
+# endif
+#
+# /* BOOST_PP_CONFIG_EXTENDED_LINE_INFO */
+#
+# ifndef BOOST_PP_CONFIG_EXTENDED_LINE_INFO
+#    define BOOST_PP_CONFIG_EXTENDED_LINE_INFO 0
+# endif
+#
+# /* BOOST_PP_CONFIG_ERRORS */
+#
+# ifndef BOOST_PP_CONFIG_ERRORS
+#    ifdef NDEBUG
+#        define BOOST_PP_CONFIG_ERRORS 0
+#    else
+#        define BOOST_PP_CONFIG_ERRORS 1
+#    endif
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/comma_if.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/comma_if.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/comma_if.hpp	(working copy)
@@ -0,0 +1,31 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_PUNCTUATION_COMMA_IF_HPP
+# define BOOST_PREPROCESSOR_PUNCTUATION_COMMA_IF_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/control/if.hpp>
+# include <boost/preprocessor/facilities/empty.hpp>
+# include <boost/preprocessor/punctuation/comma.hpp>
+#
+# /* BOOST_PP_COMMA_IF */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_COMMA_IF(cond) BOOST_PP_IF(cond, BOOST_PP_COMMA, BOOST_PP_EMPTY)()
+# else
+#    define BOOST_PP_COMMA_IF(cond) BOOST_PP_COMMA_IF_I(cond)
+#    define BOOST_PP_COMMA_IF_I(cond) BOOST_PP_IF(cond, BOOST_PP_COMMA, BOOST_PP_EMPTY)()
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/comma.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/comma.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/comma.hpp	(working copy)
@@ -0,0 +1,21 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_PUNCTUATION_COMMA_HPP
+# define BOOST_PREPROCESSOR_PUNCTUATION_COMMA_HPP
+#
+# /* BOOST_PP_COMMA */
+#
+# define BOOST_PP_COMMA() ,
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/paren.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/paren.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/punctuation/paren.hpp	(working copy)
@@ -0,0 +1,23 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_PUNCTUATION_PAREN_HPP
+# define BOOST_PREPROCESSOR_PUNCTUATION_PAREN_HPP
+#
+# /* BOOST_PP_LPAREN */
+#
+# define BOOST_PP_LPAREN() (
+#
+# /* BOOST_PP_RPAREN */
+#
+# define BOOST_PP_RPAREN() )
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/compl.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/compl.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/compl.hpp	(working copy)
@@ -0,0 +1,36 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LOGICAL_COMPL_HPP
+# define BOOST_PREPROCESSOR_LOGICAL_COMPL_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_COMPL */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_COMPL(x) BOOST_PP_COMPL_I(x)
+# else
+#    define BOOST_PP_COMPL(x) BOOST_PP_COMPL_OO((x))
+#    define BOOST_PP_COMPL_OO(par) BOOST_PP_COMPL_I ## par
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_COMPL_I(x) BOOST_PP_COMPL_ ## x
+# else
+#    define BOOST_PP_COMPL_I(x) BOOST_PP_COMPL_ID(BOOST_PP_COMPL_ ## x)
+#    define BOOST_PP_COMPL_ID(id) id
+# endif
+#
+# define BOOST_PP_COMPL_0 1
+# define BOOST_PP_COMPL_1 0
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/bool.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/bool.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/bool.hpp	(working copy)
@@ -0,0 +1,288 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LOGICAL_BOOL_HPP
+# define BOOST_PREPROCESSOR_LOGICAL_BOOL_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_BOOL */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_BOOL(x) BOOST_PP_BOOL_I(x)
+# else
+#    define BOOST_PP_BOOL(x) BOOST_PP_BOOL_OO((x))
+#    define BOOST_PP_BOOL_OO(par) BOOST_PP_BOOL_I ## par
+# endif
+#
+# define BOOST_PP_BOOL_I(x) BOOST_PP_BOOL_ ## x
+#
+# define BOOST_PP_BOOL_0 0
+# define BOOST_PP_BOOL_1 1
+# define BOOST_PP_BOOL_2 1
+# define BOOST_PP_BOOL_3 1
+# define BOOST_PP_BOOL_4 1
+# define BOOST_PP_BOOL_5 1
+# define BOOST_PP_BOOL_6 1
+# define BOOST_PP_BOOL_7 1
+# define BOOST_PP_BOOL_8 1
+# define BOOST_PP_BOOL_9 1
+# define BOOST_PP_BOOL_10 1
+# define BOOST_PP_BOOL_11 1
+# define BOOST_PP_BOOL_12 1
+# define BOOST_PP_BOOL_13 1
+# define BOOST_PP_BOOL_14 1
+# define BOOST_PP_BOOL_15 1
+# define BOOST_PP_BOOL_16 1
+# define BOOST_PP_BOOL_17 1
+# define BOOST_PP_BOOL_18 1
+# define BOOST_PP_BOOL_19 1
+# define BOOST_PP_BOOL_20 1
+# define BOOST_PP_BOOL_21 1
+# define BOOST_PP_BOOL_22 1
+# define BOOST_PP_BOOL_23 1
+# define BOOST_PP_BOOL_24 1
+# define BOOST_PP_BOOL_25 1
+# define BOOST_PP_BOOL_26 1
+# define BOOST_PP_BOOL_27 1
+# define BOOST_PP_BOOL_28 1
+# define BOOST_PP_BOOL_29 1
+# define BOOST_PP_BOOL_30 1
+# define BOOST_PP_BOOL_31 1
+# define BOOST_PP_BOOL_32 1
+# define BOOST_PP_BOOL_33 1
+# define BOOST_PP_BOOL_34 1
+# define BOOST_PP_BOOL_35 1
+# define BOOST_PP_BOOL_36 1
+# define BOOST_PP_BOOL_37 1
+# define BOOST_PP_BOOL_38 1
+# define BOOST_PP_BOOL_39 1
+# define BOOST_PP_BOOL_40 1
+# define BOOST_PP_BOOL_41 1
+# define BOOST_PP_BOOL_42 1
+# define BOOST_PP_BOOL_43 1
+# define BOOST_PP_BOOL_44 1
+# define BOOST_PP_BOOL_45 1
+# define BOOST_PP_BOOL_46 1
+# define BOOST_PP_BOOL_47 1
+# define BOOST_PP_BOOL_48 1
+# define BOOST_PP_BOOL_49 1
+# define BOOST_PP_BOOL_50 1
+# define BOOST_PP_BOOL_51 1
+# define BOOST_PP_BOOL_52 1
+# define BOOST_PP_BOOL_53 1
+# define BOOST_PP_BOOL_54 1
+# define BOOST_PP_BOOL_55 1
+# define BOOST_PP_BOOL_56 1
+# define BOOST_PP_BOOL_57 1
+# define BOOST_PP_BOOL_58 1
+# define BOOST_PP_BOOL_59 1
+# define BOOST_PP_BOOL_60 1
+# define BOOST_PP_BOOL_61 1
+# define BOOST_PP_BOOL_62 1
+# define BOOST_PP_BOOL_63 1
+# define BOOST_PP_BOOL_64 1
+# define BOOST_PP_BOOL_65 1
+# define BOOST_PP_BOOL_66 1
+# define BOOST_PP_BOOL_67 1
+# define BOOST_PP_BOOL_68 1
+# define BOOST_PP_BOOL_69 1
+# define BOOST_PP_BOOL_70 1
+# define BOOST_PP_BOOL_71 1
+# define BOOST_PP_BOOL_72 1
+# define BOOST_PP_BOOL_73 1
+# define BOOST_PP_BOOL_74 1
+# define BOOST_PP_BOOL_75 1
+# define BOOST_PP_BOOL_76 1
+# define BOOST_PP_BOOL_77 1
+# define BOOST_PP_BOOL_78 1
+# define BOOST_PP_BOOL_79 1
+# define BOOST_PP_BOOL_80 1
+# define BOOST_PP_BOOL_81 1
+# define BOOST_PP_BOOL_82 1
+# define BOOST_PP_BOOL_83 1
+# define BOOST_PP_BOOL_84 1
+# define BOOST_PP_BOOL_85 1
+# define BOOST_PP_BOOL_86 1
+# define BOOST_PP_BOOL_87 1
+# define BOOST_PP_BOOL_88 1
+# define BOOST_PP_BOOL_89 1
+# define BOOST_PP_BOOL_90 1
+# define BOOST_PP_BOOL_91 1
+# define BOOST_PP_BOOL_92 1
+# define BOOST_PP_BOOL_93 1
+# define BOOST_PP_BOOL_94 1
+# define BOOST_PP_BOOL_95 1
+# define BOOST_PP_BOOL_96 1
+# define BOOST_PP_BOOL_97 1
+# define BOOST_PP_BOOL_98 1
+# define BOOST_PP_BOOL_99 1
+# define BOOST_PP_BOOL_100 1
+# define BOOST_PP_BOOL_101 1
+# define BOOST_PP_BOOL_102 1
+# define BOOST_PP_BOOL_103 1
+# define BOOST_PP_BOOL_104 1
+# define BOOST_PP_BOOL_105 1
+# define BOOST_PP_BOOL_106 1
+# define BOOST_PP_BOOL_107 1
+# define BOOST_PP_BOOL_108 1
+# define BOOST_PP_BOOL_109 1
+# define BOOST_PP_BOOL_110 1
+# define BOOST_PP_BOOL_111 1
+# define BOOST_PP_BOOL_112 1
+# define BOOST_PP_BOOL_113 1
+# define BOOST_PP_BOOL_114 1
+# define BOOST_PP_BOOL_115 1
+# define BOOST_PP_BOOL_116 1
+# define BOOST_PP_BOOL_117 1
+# define BOOST_PP_BOOL_118 1
+# define BOOST_PP_BOOL_119 1
+# define BOOST_PP_BOOL_120 1
+# define BOOST_PP_BOOL_121 1
+# define BOOST_PP_BOOL_122 1
+# define BOOST_PP_BOOL_123 1
+# define BOOST_PP_BOOL_124 1
+# define BOOST_PP_BOOL_125 1
+# define BOOST_PP_BOOL_126 1
+# define BOOST_PP_BOOL_127 1
+# define BOOST_PP_BOOL_128 1
+# define BOOST_PP_BOOL_129 1
+# define BOOST_PP_BOOL_130 1
+# define BOOST_PP_BOOL_131 1
+# define BOOST_PP_BOOL_132 1
+# define BOOST_PP_BOOL_133 1
+# define BOOST_PP_BOOL_134 1
+# define BOOST_PP_BOOL_135 1
+# define BOOST_PP_BOOL_136 1
+# define BOOST_PP_BOOL_137 1
+# define BOOST_PP_BOOL_138 1
+# define BOOST_PP_BOOL_139 1
+# define BOOST_PP_BOOL_140 1
+# define BOOST_PP_BOOL_141 1
+# define BOOST_PP_BOOL_142 1
+# define BOOST_PP_BOOL_143 1
+# define BOOST_PP_BOOL_144 1
+# define BOOST_PP_BOOL_145 1
+# define BOOST_PP_BOOL_146 1
+# define BOOST_PP_BOOL_147 1
+# define BOOST_PP_BOOL_148 1
+# define BOOST_PP_BOOL_149 1
+# define BOOST_PP_BOOL_150 1
+# define BOOST_PP_BOOL_151 1
+# define BOOST_PP_BOOL_152 1
+# define BOOST_PP_BOOL_153 1
+# define BOOST_PP_BOOL_154 1
+# define BOOST_PP_BOOL_155 1
+# define BOOST_PP_BOOL_156 1
+# define BOOST_PP_BOOL_157 1
+# define BOOST_PP_BOOL_158 1
+# define BOOST_PP_BOOL_159 1
+# define BOOST_PP_BOOL_160 1
+# define BOOST_PP_BOOL_161 1
+# define BOOST_PP_BOOL_162 1
+# define BOOST_PP_BOOL_163 1
+# define BOOST_PP_BOOL_164 1
+# define BOOST_PP_BOOL_165 1
+# define BOOST_PP_BOOL_166 1
+# define BOOST_PP_BOOL_167 1
+# define BOOST_PP_BOOL_168 1
+# define BOOST_PP_BOOL_169 1
+# define BOOST_PP_BOOL_170 1
+# define BOOST_PP_BOOL_171 1
+# define BOOST_PP_BOOL_172 1
+# define BOOST_PP_BOOL_173 1
+# define BOOST_PP_BOOL_174 1
+# define BOOST_PP_BOOL_175 1
+# define BOOST_PP_BOOL_176 1
+# define BOOST_PP_BOOL_177 1
+# define BOOST_PP_BOOL_178 1
+# define BOOST_PP_BOOL_179 1
+# define BOOST_PP_BOOL_180 1
+# define BOOST_PP_BOOL_181 1
+# define BOOST_PP_BOOL_182 1
+# define BOOST_PP_BOOL_183 1
+# define BOOST_PP_BOOL_184 1
+# define BOOST_PP_BOOL_185 1
+# define BOOST_PP_BOOL_186 1
+# define BOOST_PP_BOOL_187 1
+# define BOOST_PP_BOOL_188 1
+# define BOOST_PP_BOOL_189 1
+# define BOOST_PP_BOOL_190 1
+# define BOOST_PP_BOOL_191 1
+# define BOOST_PP_BOOL_192 1
+# define BOOST_PP_BOOL_193 1
+# define BOOST_PP_BOOL_194 1
+# define BOOST_PP_BOOL_195 1
+# define BOOST_PP_BOOL_196 1
+# define BOOST_PP_BOOL_197 1
+# define BOOST_PP_BOOL_198 1
+# define BOOST_PP_BOOL_199 1
+# define BOOST_PP_BOOL_200 1
+# define BOOST_PP_BOOL_201 1
+# define BOOST_PP_BOOL_202 1
+# define BOOST_PP_BOOL_203 1
+# define BOOST_PP_BOOL_204 1
+# define BOOST_PP_BOOL_205 1
+# define BOOST_PP_BOOL_206 1
+# define BOOST_PP_BOOL_207 1
+# define BOOST_PP_BOOL_208 1
+# define BOOST_PP_BOOL_209 1
+# define BOOST_PP_BOOL_210 1
+# define BOOST_PP_BOOL_211 1
+# define BOOST_PP_BOOL_212 1
+# define BOOST_PP_BOOL_213 1
+# define BOOST_PP_BOOL_214 1
+# define BOOST_PP_BOOL_215 1
+# define BOOST_PP_BOOL_216 1
+# define BOOST_PP_BOOL_217 1
+# define BOOST_PP_BOOL_218 1
+# define BOOST_PP_BOOL_219 1
+# define BOOST_PP_BOOL_220 1
+# define BOOST_PP_BOOL_221 1
+# define BOOST_PP_BOOL_222 1
+# define BOOST_PP_BOOL_223 1
+# define BOOST_PP_BOOL_224 1
+# define BOOST_PP_BOOL_225 1
+# define BOOST_PP_BOOL_226 1
+# define BOOST_PP_BOOL_227 1
+# define BOOST_PP_BOOL_228 1
+# define BOOST_PP_BOOL_229 1
+# define BOOST_PP_BOOL_230 1
+# define BOOST_PP_BOOL_231 1
+# define BOOST_PP_BOOL_232 1
+# define BOOST_PP_BOOL_233 1
+# define BOOST_PP_BOOL_234 1
+# define BOOST_PP_BOOL_235 1
+# define BOOST_PP_BOOL_236 1
+# define BOOST_PP_BOOL_237 1
+# define BOOST_PP_BOOL_238 1
+# define BOOST_PP_BOOL_239 1
+# define BOOST_PP_BOOL_240 1
+# define BOOST_PP_BOOL_241 1
+# define BOOST_PP_BOOL_242 1
+# define BOOST_PP_BOOL_243 1
+# define BOOST_PP_BOOL_244 1
+# define BOOST_PP_BOOL_245 1
+# define BOOST_PP_BOOL_246 1
+# define BOOST_PP_BOOL_247 1
+# define BOOST_PP_BOOL_248 1
+# define BOOST_PP_BOOL_249 1
+# define BOOST_PP_BOOL_250 1
+# define BOOST_PP_BOOL_251 1
+# define BOOST_PP_BOOL_252 1
+# define BOOST_PP_BOOL_253 1
+# define BOOST_PP_BOOL_254 1
+# define BOOST_PP_BOOL_255 1
+# define BOOST_PP_BOOL_256 1
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/bitand.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/bitand.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/bitand.hpp	(working copy)
@@ -0,0 +1,38 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LOGICAL_BITAND_HPP
+# define BOOST_PREPROCESSOR_LOGICAL_BITAND_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+#
+# /* BOOST_PP_BITAND */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MWCC()
+#    define BOOST_PP_BITAND(x, y) BOOST_PP_BITAND_I(x, y)
+# else
+#    define BOOST_PP_BITAND(x, y) BOOST_PP_BITAND_OO((x, y))
+#    define BOOST_PP_BITAND_OO(par) BOOST_PP_BITAND_I ## par
+# endif
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_MSVC()
+#    define BOOST_PP_BITAND_I(x, y) BOOST_PP_BITAND_ ## x ## y
+# else
+#    define BOOST_PP_BITAND_I(x, y) BOOST_PP_BITAND_ID(BOOST_PP_BITAND_ ## x ## y)
+#    define BOOST_PP_BITAND_ID(res) res
+# endif
+#
+# define BOOST_PP_BITAND_00 0
+# define BOOST_PP_BITAND_01 0
+# define BOOST_PP_BITAND_10 0
+# define BOOST_PP_BITAND_11 1
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/and.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/and.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/logical/and.hpp	(working copy)
@@ -0,0 +1,30 @@
+# /* Copyright (C) 2001
+#  * Housemarque Oy
+#  * http://www.housemarque.com
+#  *
+#  * Distributed under the Boost Software License, Version 1.0. (See
+#  * accompanying file LICENSE_1_0.txt or copy at
+#  * http://www.boost.org/LICENSE_1_0.txt)
+#  */
+#
+# /* Revised by Paul Mensonides (2002) */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_LOGICAL_AND_HPP
+# define BOOST_PREPROCESSOR_LOGICAL_AND_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/logical/bool.hpp>
+# include <boost/preprocessor/logical/bitand.hpp>
+#
+# /* BOOST_PP_AND */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_AND(p, q) BOOST_PP_BITAND(BOOST_PP_BOOL(p), BOOST_PP_BOOL(q))
+# else
+#    define BOOST_PP_AND(p, q) BOOST_PP_AND_I(p, q)
+#    define BOOST_PP_AND_I(p, q) BOOST_PP_BITAND(BOOST_PP_BOOL(p), BOOST_PP_BOOL(q))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/data.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/data.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/data.hpp	(working copy)
@@ -0,0 +1,28 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARRAY_DATA_HPP
+# define BOOST_PREPROCESSOR_ARRAY_DATA_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+#
+# /* BOOST_PP_ARRAY_DATA */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ARRAY_DATA(array) BOOST_PP_TUPLE_ELEM(2, 1, array)
+# else
+#    define BOOST_PP_ARRAY_DATA(array) BOOST_PP_ARRAY_DATA_I(array)
+#    define BOOST_PP_ARRAY_DATA_I(array) BOOST_PP_ARRAY_DATA_II array
+#    define BOOST_PP_ARRAY_DATA_II(size, data) data
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/size.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/size.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/size.hpp	(working copy)
@@ -0,0 +1,28 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARRAY_SIZE_HPP
+# define BOOST_PREPROCESSOR_ARRAY_SIZE_HPP
+#
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+#
+# /* BOOST_PP_ARRAY_SIZE */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ARRAY_SIZE(array) BOOST_PP_TUPLE_ELEM(2, 0, array)
+# else
+#    define BOOST_PP_ARRAY_SIZE(array) BOOST_PP_ARRAY_SIZE_I(array)
+#    define BOOST_PP_ARRAY_SIZE_I(array) BOOST_PP_ARRAY_SIZE_II array
+#    define BOOST_PP_ARRAY_SIZE_II(size, data) size
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/elem.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/elem.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/preprocessor/array/elem.hpp	(working copy)
@@ -0,0 +1,29 @@
+# /* **************************************************************************
+#  *                                                                          *
+#  *     (C) Copyright Paul Mensonides 2002.
+#  *     Distributed under the Boost Software License, Version 1.0. (See
+#  *     accompanying file LICENSE_1_0.txt or copy at
+#  *     http://www.boost.org/LICENSE_1_0.txt)
+#  *                                                                          *
+#  ************************************************************************** */
+#
+# /* See http://www.boost.org for most recent version. */
+#
+# ifndef BOOST_PREPROCESSOR_ARRAY_ELEM_HPP
+# define BOOST_PREPROCESSOR_ARRAY_ELEM_HPP
+#
+# include <boost/preprocessor/array/data.hpp>
+# include <boost/preprocessor/array/size.hpp>
+# include <boost/preprocessor/config/config.hpp>
+# include <boost/preprocessor/tuple/elem.hpp>
+#
+# /* BOOST_PP_ARRAY_ELEM */
+#
+# if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()
+#    define BOOST_PP_ARRAY_ELEM(i, array) BOOST_PP_TUPLE_ELEM(BOOST_PP_ARRAY_SIZE(array), i, BOOST_PP_ARRAY_DATA(array))
+# else
+#    define BOOST_PP_ARRAY_ELEM(i, array) BOOST_PP_ARRAY_ELEM_I(i, array)
+#    define BOOST_PP_ARRAY_ELEM_I(i, array) BOOST_PP_TUPLE_ELEM(BOOST_PP_ARRAY_SIZE(array), i, BOOST_PP_ARRAY_DATA(array))
+# endif
+#
+# endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/limits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/limits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/limits.hpp	(working copy)
@@ -0,0 +1,146 @@
+
+//  (C) Copyright John maddock 1999.
+//  (C) David Abrahams 2002.  Distributed under the Boost
+//  Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+// use this header as a workaround for missing <limits>
+
+//  See http://www.boost.org/libs/compatibility/index.html for documentation.
+
+#ifndef BOOST_LIMITS
+#define BOOST_LIMITS
+
+#include <boost/config.hpp>
+
+#ifdef BOOST_NO_LIMITS
+# include <boost/detail/limits.hpp>
+#else
+# include <limits>
+#endif
+
+#if (defined(BOOST_HAS_LONG_LONG) && defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)) \
+      || (defined(BOOST_HAS_MS_INT64) && defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS))
+// Add missing specializations for numeric_limits:
+#ifdef BOOST_HAS_MS_INT64
+#  define BOOST_LLT __int64
+#  define BOOST_ULLT unsigned __int64
+#else
+#  define BOOST_LLT  ::boost::long_long_type
+#  define BOOST_ULLT  ::boost::ulong_long_type
+#endif
+
+#include <climits>  // for CHAR_BIT
+
+namespace std
+{
+  template<>
+  class numeric_limits<BOOST_LLT>
+  {
+   public:
+
+      BOOST_STATIC_CONSTANT(bool, is_specialized = true);
+#ifdef BOOST_HAS_MS_INT64
+      static BOOST_LLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return 0x8000000000000000i64; }
+      static BOOST_LLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return 0x7FFFFFFFFFFFFFFFi64; }
+#elif defined(LLONG_MAX)
+      static BOOST_LLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return LLONG_MIN; }
+      static BOOST_LLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return LLONG_MAX; }
+#elif defined(LONGLONG_MAX)
+      static BOOST_LLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return LONGLONG_MIN; }
+      static BOOST_LLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return LONGLONG_MAX; }
+#else
+      static BOOST_LLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return 1LL << (sizeof(BOOST_LLT) * CHAR_BIT - 1); }
+      static BOOST_LLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return ~(min)(); }
+#endif
+      BOOST_STATIC_CONSTANT(int, digits = sizeof(BOOST_LLT) * CHAR_BIT -1);
+      BOOST_STATIC_CONSTANT(int, digits10 = (CHAR_BIT * sizeof (BOOST_LLT) - 1) * 301L / 1000);
+      BOOST_STATIC_CONSTANT(bool, is_signed = true);
+      BOOST_STATIC_CONSTANT(bool, is_integer = true);
+      BOOST_STATIC_CONSTANT(bool, is_exact = true);
+      BOOST_STATIC_CONSTANT(int, radix = 2);
+      static BOOST_LLT epsilon() throw() { return 0; };
+      static BOOST_LLT round_error() throw() { return 0; };
+
+      BOOST_STATIC_CONSTANT(int, min_exponent = 0);
+      BOOST_STATIC_CONSTANT(int, min_exponent10 = 0);
+      BOOST_STATIC_CONSTANT(int, max_exponent = 0);
+      BOOST_STATIC_CONSTANT(int, max_exponent10 = 0);
+
+      BOOST_STATIC_CONSTANT(bool, has_infinity = false);
+      BOOST_STATIC_CONSTANT(bool, has_quiet_NaN = false);
+      BOOST_STATIC_CONSTANT(bool, has_signaling_NaN = false);
+      BOOST_STATIC_CONSTANT(bool, has_denorm = false);
+      BOOST_STATIC_CONSTANT(bool, has_denorm_loss = false);
+      static BOOST_LLT infinity() throw() { return 0; };
+      static BOOST_LLT quiet_NaN() throw() { return 0; };
+      static BOOST_LLT signaling_NaN() throw() { return 0; };
+      static BOOST_LLT denorm_min() throw() { return 0; };
+
+      BOOST_STATIC_CONSTANT(bool, is_iec559 = false);
+      BOOST_STATIC_CONSTANT(bool, is_bounded = true);
+      BOOST_STATIC_CONSTANT(bool, is_modulo = true);
+
+      BOOST_STATIC_CONSTANT(bool, traps = false);
+      BOOST_STATIC_CONSTANT(bool, tinyness_before = false);
+      BOOST_STATIC_CONSTANT(float_round_style, round_style = round_toward_zero);
+
+  };
+
+  template<>
+  class numeric_limits<BOOST_ULLT>
+  {
+   public:
+
+      BOOST_STATIC_CONSTANT(bool, is_specialized = true);
+#ifdef BOOST_HAS_MS_INT64
+      static BOOST_ULLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return 0ui64; }
+      static BOOST_ULLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return 0xFFFFFFFFFFFFFFFFui64; }
+#elif defined(ULLONG_MAX) && defined(ULLONG_MIN)
+      static BOOST_ULLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return ULLONG_MIN; }
+      static BOOST_ULLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return ULLONG_MAX; }
+#elif defined(ULONGLONG_MAX) && defined(ULONGLONG_MIN)
+      static BOOST_ULLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return ULONGLONG_MIN; }
+      static BOOST_ULLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return ULONGLONG_MAX; }
+#else
+      static BOOST_ULLT min BOOST_PREVENT_MACRO_SUBSTITUTION (){ return 0uLL; }
+      static BOOST_ULLT max BOOST_PREVENT_MACRO_SUBSTITUTION (){ return ~0uLL; }
+#endif
+      BOOST_STATIC_CONSTANT(int, digits = sizeof(BOOST_LLT) * CHAR_BIT);
+      BOOST_STATIC_CONSTANT(int, digits10 = (CHAR_BIT * sizeof (BOOST_LLT)) * 301L / 1000);
+      BOOST_STATIC_CONSTANT(bool, is_signed = false);
+      BOOST_STATIC_CONSTANT(bool, is_integer = true);
+      BOOST_STATIC_CONSTANT(bool, is_exact = true);
+      BOOST_STATIC_CONSTANT(int, radix = 2);
+      static BOOST_ULLT epsilon() throw() { return 0; };
+      static BOOST_ULLT round_error() throw() { return 0; };
+
+      BOOST_STATIC_CONSTANT(int, min_exponent = 0);
+      BOOST_STATIC_CONSTANT(int, min_exponent10 = 0);
+      BOOST_STATIC_CONSTANT(int, max_exponent = 0);
+      BOOST_STATIC_CONSTANT(int, max_exponent10 = 0);
+
+      BOOST_STATIC_CONSTANT(bool, has_infinity = false);
+      BOOST_STATIC_CONSTANT(bool, has_quiet_NaN = false);
+      BOOST_STATIC_CONSTANT(bool, has_signaling_NaN = false);
+      BOOST_STATIC_CONSTANT(bool, has_denorm = false);
+      BOOST_STATIC_CONSTANT(bool, has_denorm_loss = false);
+      static BOOST_ULLT infinity() throw() { return 0; };
+      static BOOST_ULLT quiet_NaN() throw() { return 0; };
+      static BOOST_ULLT signaling_NaN() throw() { return 0; };
+      static BOOST_ULLT denorm_min() throw() { return 0; };
+
+      BOOST_STATIC_CONSTANT(bool, is_iec559 = false);
+      BOOST_STATIC_CONSTANT(bool, is_bounded = true);
+      BOOST_STATIC_CONSTANT(bool, is_modulo = true);
+
+      BOOST_STATIC_CONSTANT(bool, traps = false);
+      BOOST_STATIC_CONSTANT(bool, tinyness_before = false);
+      BOOST_STATIC_CONSTANT(float_round_style, round_style = round_toward_zero);
+
+  };
+}
+#endif
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/config.hpp	(working copy)
@@ -0,0 +1,70 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2002.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/config for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  http://www.boost.org/libs/config
+//
+//  CAUTION: This file is intended to be completely stable -
+//           DO NOT MODIFY THIS FILE!
+//
+
+#ifndef BOOST_CONFIG_HPP
+#define BOOST_CONFIG_HPP
+
+// if we don't have a user config, then use the default location:
+#if !defined(BOOST_USER_CONFIG) && !defined(BOOST_NO_USER_CONFIG)
+#  define BOOST_USER_CONFIG <boost/config/user.hpp>
+#endif
+// include it first:
+#ifdef BOOST_USER_CONFIG
+#  include BOOST_USER_CONFIG
+#endif
+
+// if we don't have a compiler config set, try and find one:
+#if !defined(BOOST_COMPILER_CONFIG) && !defined(BOOST_NO_COMPILER_CONFIG) && !defined(BOOST_NO_CONFIG)
+#  include <boost/config/select_compiler_config.hpp>
+#endif
+// if we have a compiler config, include it now:
+#ifdef BOOST_COMPILER_CONFIG
+#  include BOOST_COMPILER_CONFIG
+#endif
+
+// if we don't have a std library config set, try and find one:
+#if !defined(BOOST_STDLIB_CONFIG) && !defined(BOOST_NO_STDLIB_CONFIG) && !defined(BOOST_NO_CONFIG) && defined(__cplusplus)
+#  include <boost/config/select_stdlib_config.hpp>
+#endif
+// if we have a std library config, include it now:
+#ifdef BOOST_STDLIB_CONFIG
+#  include BOOST_STDLIB_CONFIG
+#endif
+
+// if we don't have a platform config set, try and find one:
+#if !defined(BOOST_PLATFORM_CONFIG) && !defined(BOOST_NO_PLATFORM_CONFIG) && !defined(BOOST_NO_CONFIG)
+#  include <boost/config/select_platform_config.hpp>
+#endif
+// if we have a platform config, include it now:
+#ifdef BOOST_PLATFORM_CONFIG
+#  include BOOST_PLATFORM_CONFIG
+#endif
+
+// get config suffix code:
+#include <boost/config/suffix.hpp>
+
+#endif  // BOOST_CONFIG_HPP
+
+
+
+
+
+
+
+
+
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/concept_def.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/concept_def.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/concept_def.hpp	(working copy)
@@ -0,0 +1,51 @@
+// Copyright David Abrahams 2006. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_CONCEPT_DETAIL_CONCEPT_DEF_DWA200651_HPP
+# define BOOST_CONCEPT_DETAIL_CONCEPT_DEF_DWA200651_HPP
+# include <boost/preprocessor/seq/for_each_i.hpp>
+# include <boost/preprocessor/seq/enum.hpp>
+# include <boost/preprocessor/comma_if.hpp>
+# include <boost/preprocessor/cat.hpp>
+#endif // BOOST_CONCEPT_DETAIL_CONCEPT_DEF_DWA200651_HPP
+
+// BOOST_concept(SomeName, (p1)(p2)...(pN))
+//
+// Expands to "template <class p1, class p2, ...class pN> struct SomeName"
+//
+// Also defines an equivalent SomeNameConcept for backward compatibility.
+// Maybe in the next release we can kill off the "Concept" suffix for good.
+#if BOOST_WORKAROUND(__GNUC__, <= 3)
+# define BOOST_concept(name, params)                                            \
+    template < BOOST_PP_SEQ_FOR_EACH_I(BOOST_CONCEPT_typename,~,params) >       \
+    struct name; /* forward declaration */                                      \
+                                                                                \
+    template < BOOST_PP_SEQ_FOR_EACH_I(BOOST_CONCEPT_typename,~,params) >       \
+    struct BOOST_PP_CAT(name,Concept)                                           \
+      : name< BOOST_PP_SEQ_ENUM(params) >                                       \
+    {                                                                           \
+        /* at least 2.96 and 3.4.3 both need this */                            \
+        BOOST_PP_CAT(name,Concept)();                                           \
+    };                                                                          \
+                                                                                \
+    template < BOOST_PP_SEQ_FOR_EACH_I(BOOST_CONCEPT_typename,~,params) >       \
+    struct name
+#else
+# define BOOST_concept(name, params)                                            \
+    template < BOOST_PP_SEQ_FOR_EACH_I(BOOST_CONCEPT_typename,~,params) >       \
+    struct name; /* forward declaration */                                      \
+                                                                                \
+    template < BOOST_PP_SEQ_FOR_EACH_I(BOOST_CONCEPT_typename,~,params) >       \
+    struct BOOST_PP_CAT(name,Concept)                                           \
+      : name< BOOST_PP_SEQ_ENUM(params) >                                       \
+    {                                                                           \
+    };                                                                          \
+                                                                                \
+    template < BOOST_PP_SEQ_FOR_EACH_I(BOOST_CONCEPT_typename,~,params) >       \
+    struct name
+#endif
+
+// Helper for BOOST_concept, above.
+# define BOOST_CONCEPT_typename(r, ignored, index, t) \
+    BOOST_PP_COMMA_IF(index) typename t
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/concept_undef.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/concept_undef.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/concept_undef.hpp	(working copy)
@@ -0,0 +1,5 @@
+// Copyright David Abrahams 2006. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+# undef BOOST_concept_typename
+# undef BOOST_concept
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/general.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/general.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/general.hpp	(working copy)
@@ -0,0 +1,75 @@
+// Copyright David Abrahams 2006. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_CONCEPT_DETAIL_GENERAL_DWA2006429_HPP
+# define BOOST_CONCEPT_DETAIL_GENERAL_DWA2006429_HPP
+
+# include <boost/preprocessor/cat.hpp>
+# include <boost/concept/detail/backward_compatibility.hpp>
+
+# ifdef BOOST_OLD_CONCEPT_SUPPORT
+#  include <boost/concept/detail/has_constraints.hpp>
+#  include <boost/mpl/if.hpp>
+# endif
+
+// This implementation works on Comeau and GCC, all the way back to
+// 2.95
+namespace boost { namespace concepts {
+
+template <class ModelFn>
+struct requirement_;
+
+namespace detail
+{
+  template <void(*)()> struct instantiate {};
+}
+
+template <class Model>
+struct requirement
+{
+    static void failed() { ((Model*)0)->~Model(); }
+};
+
+struct failed {};
+
+template <class Model>
+struct requirement<failed ************ Model::************>
+{
+    static void failed() { ((Model*)0)->~Model(); }
+};
+
+# ifdef BOOST_OLD_CONCEPT_SUPPORT
+
+template <class Model>
+struct constraint
+{
+    static void failed() { ((Model*)0)->constraints(); }
+};
+
+template <class Model>
+struct requirement_<void(*)(Model)>
+  : mpl::if_<
+        concepts::not_satisfied<Model>
+      , constraint<Model>
+      , requirement<failed ************ Model::************>
+    >::type
+{};
+
+# else
+
+// For GCC-2.x, these can't have exactly the same name
+template <class Model>
+struct requirement_<void(*)(Model)>
+    : requirement<failed ************ Model::************>
+{};
+
+# endif
+
+#  define BOOST_CONCEPT_ASSERT_FN( ModelFnPtr )             \
+    typedef ::boost::concepts::detail::instantiate<          \
+    &::boost::concepts::requirement_<ModelFnPtr>::failed>    \
+      BOOST_PP_CAT(boost_concept_check,__LINE__)
+
+}}
+
+#endif // BOOST_CONCEPT_DETAIL_GENERAL_DWA2006429_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/has_constraints.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/has_constraints.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/has_constraints.hpp	(working copy)
@@ -0,0 +1,50 @@
+// Copyright David Abrahams 2006. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_CONCEPT_DETAIL_HAS_CONSTRAINTS_DWA2006429_HPP
+# define BOOST_CONCEPT_DETAIL_HAS_CONSTRAINTS_DWA2006429_HPP
+
+# include <boost/mpl/bool.hpp>
+# include <boost/detail/workaround.hpp>
+# include <boost/concept/detail/backward_compatibility.hpp>
+
+namespace boost { namespace concepts {
+
+namespace detail
+{
+
+// Here we implement the metafunction that detects whether a
+// constraints metafunction exists
+  typedef char yes;
+  typedef char (&no)[2];
+
+  template <class Model, void (Model::*)()>
+  struct wrap_constraints {};
+
+#if BOOST_WORKAROUND(__SUNPRO_CC, <= 0x580) || defined(__CUDACC__)
+  // Work around the following bogus error in Sun Studio 11, by
+  // turning off the has_constraints function entirely:
+  //    Error: complex expression not allowed in dependent template
+  //    argument expression
+  inline no has_constraints_(...);
+#else
+  template <class Model>
+  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
+  inline no has_constraints_(...);
+#endif
+}
+
+// This would be called "detail::has_constraints," but it has a strong
+// tendency to show up in error messages.
+template <class Model>
+struct not_satisfied
+{
+    BOOST_STATIC_CONSTANT(
+        bool
+      , value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes) );
+    typedef mpl::bool_<value> type;
+};
+
+}} // namespace boost::concepts::detail
+
+#endif // BOOST_CONCEPT_DETAIL_HAS_CONSTRAINTS_DWA2006429_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/backward_compatibility.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/backward_compatibility.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/detail/backward_compatibility.hpp	(working copy)
@@ -0,0 +1,16 @@
+// Copyright David Abrahams 2009. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_CONCEPT_BACKWARD_COMPATIBILITY_DWA200968_HPP
+# define BOOST_CONCEPT_BACKWARD_COMPATIBILITY_DWA200968_HPP
+
+namespace boost
+{
+  namespace concepts {}
+
+# if defined(BOOST_HAS_CONCEPTS) && !defined(BOOST_CONCEPT_NO_BACKWARD_KEYWORD)
+  namespace concept = concepts;
+# endif
+} // namespace boost::concept
+
+#endif // BOOST_CONCEPT_BACKWARD_COMPATIBILITY_DWA200968_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/assert.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/assert.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/assert.hpp	(working copy)
@@ -0,0 +1,46 @@
+// Copyright David Abrahams 2006. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_CONCEPT_ASSERT_DWA2006430_HPP
+# define BOOST_CONCEPT_ASSERT_DWA2006430_HPP
+
+# include <boost/config.hpp>
+# include <boost/detail/workaround.hpp>
+
+// The old protocol used a constraints() member function in concept
+// checking classes.  If the compiler supports SFINAE, we can detect
+// that function and seamlessly support the old concept checking
+// classes.  In this release, backward compatibility with the old
+// concept checking classes is enabled by default, where available.
+// The old protocol is deprecated, though, and backward compatibility
+// will no longer be the default in the next release.
+
+# if !defined(BOOST_NO_OLD_CONCEPT_SUPPORT)                                         \
+    && !defined(BOOST_NO_SFINAE)                                                    \
+                                                                                    \
+    && !(BOOST_WORKAROUND(__GNUC__, == 3) && BOOST_WORKAROUND(__GNUC_MINOR__, < 4)) \
+    && !(BOOST_WORKAROUND(__GNUC__, == 2))
+
+// Note: gcc-2.96 through 3.3.x have some SFINAE, but no ability to
+// check for the presence of particularmember functions.
+
+#  define BOOST_OLD_CONCEPT_SUPPORT
+
+# endif
+
+# ifdef BOOST_MSVC
+#  include <boost/concept/detail/msvc.hpp>
+# elif BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))
+#  include <boost/concept/detail/borland.hpp>
+# else
+#  include <boost/concept/detail/general.hpp>
+# endif
+
+  // Usage, in class or function context:
+  //
+  //     BOOST_CONCEPT_ASSERT((UnaryFunctionConcept<F,bool,int>));
+  //
+# define BOOST_CONCEPT_ASSERT(ModelInParens) \
+    BOOST_CONCEPT_ASSERT_FN(void(*)ModelInParens)
+
+#endif // BOOST_CONCEPT_ASSERT_DWA2006430_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/usage.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/usage.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept/usage.hpp	(working copy)
@@ -0,0 +1,44 @@
+// Copyright David Abrahams 2006. Distributed under the Boost
+// Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+#ifndef BOOST_CONCEPT_USAGE_DWA2006919_HPP
+# define BOOST_CONCEPT_USAGE_DWA2006919_HPP
+
+# include <boost/concept/assert.hpp>
+# include <boost/detail/workaround.hpp>
+# include <boost/concept/detail/backward_compatibility.hpp>
+
+namespace boost { namespace concepts {
+
+# if BOOST_WORKAROUND(__GNUC__, == 2)
+
+#  define BOOST_CONCEPT_USAGE(model) ~model()
+
+# else
+
+template <class Model>
+struct usage_requirements
+{
+    ~usage_requirements() { ((Model*)0)->~Model(); }
+};
+
+#  if BOOST_WORKAROUND(__GNUC__, <= 3)
+
+#   define BOOST_CONCEPT_USAGE(model)                                    \
+      model(); /* at least 2.96 and 3.4.3 both need this :( */           \
+      BOOST_CONCEPT_ASSERT((boost::concepts::usage_requirements<model>)); \
+      ~model()
+
+#  else
+
+#   define BOOST_CONCEPT_USAGE(model)                                    \
+      BOOST_CONCEPT_ASSERT((boost::concepts::usage_requirements<model>)); \
+      ~model()
+
+#  endif
+
+# endif
+
+}} // namespace boost::concepts
+
+#endif // BOOST_CONCEPT_USAGE_DWA2006919_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/compressed_pair.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/compressed_pair.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/compressed_pair.hpp	(working copy)
@@ -0,0 +1,24 @@
+//  (C) Copyright Steve Cleary, Beman Dawes, Howard Hinnant & John Maddock 2000.
+//  Use, modification and distribution are subject to the Boost Software License,
+//  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+//  http://www.boost.org/LICENSE_1_0.txt).
+//
+//  See http://www.boost.org/libs/utility for most recent version including documentation.
+
+//  See boost/detail/compressed_pair.hpp and boost/detail/ob_compressed_pair.hpp
+//  for full copyright notices.
+
+#ifndef BOOST_COMPRESSED_PAIR_HPP
+#define BOOST_COMPRESSED_PAIR_HPP
+
+#ifndef BOOST_CONFIG_HPP
+#include <boost/config.hpp>
+#endif
+
+#ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#include <boost/detail/ob_compressed_pair.hpp>
+#else
+#include <boost/detail/compressed_pair.hpp>
+#endif
+
+#endif // BOOST_COMPRESSED_PAIR_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/escape_char.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/escape_char.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/escape_char.hpp	(working copy)
@@ -0,0 +1,27 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_DEPRECATED_INCLUDE_ESCAPE_CHAR
+#define BOOST_SPIRIT_DEPRECATED_INCLUDE_ESCAPE_CHAR
+
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 103800
+#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__DMC__)
+#  pragma message ("Warning: This header is deprecated. Please use: boost/spirit/include/classic_escape_char.hpp")
+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
+#  warning "This header is deprecated. Please use: boost/spirit/include/classic_escape_char.hpp"
+#endif
+#endif
+
+#if !defined(BOOST_SPIRIT_USE_OLD_NAMESPACE)
+#define BOOST_SPIRIT_USE_OLD_NAMESPACE
+#endif
+#include <boost/spirit/include/classic_escape_char.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/confix.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/confix.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/confix.hpp	(working copy)
@@ -0,0 +1,27 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_DEPRECATED_INCLUDE_CONFIX
+#define BOOST_SPIRIT_DEPRECATED_INCLUDE_CONFIX
+
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 103800
+#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__DMC__)
+#  pragma message ("Warning: This header is deprecated. Please use: boost/spirit/include/classic_confix.hpp")
+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
+#  warning "This header is deprecated. Please use: boost/spirit/include/classic_confix.hpp"
+#endif
+#endif
+
+#if !defined(BOOST_SPIRIT_USE_OLD_NAMESPACE)
+#define BOOST_SPIRIT_USE_OLD_NAMESPACE
+#endif
+#include <boost/spirit/include/classic_confix.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/chset.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/chset.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/utility/chset.hpp	(working copy)
@@ -0,0 +1,27 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_DEPRECATED_INCLUDE_CHSET
+#define BOOST_SPIRIT_DEPRECATED_INCLUDE_CHSET
+
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 103800
+#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__DMC__)
+#  pragma message ("Warning: This header is deprecated. Please use: boost/spirit/include/classic_chset.hpp")
+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
+#  warning "This header is deprecated. Please use: boost/spirit/include/classic_chset.hpp"
+#endif
+#endif
+
+#if !defined(BOOST_SPIRIT_USE_OLD_NAMESPACE)
+#define BOOST_SPIRIT_USE_OLD_NAMESPACE
+#endif
+#include <boost/spirit/include/classic_chset.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_symbols.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_symbols.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_symbols.hpp	(working copy)
@@ -0,0 +1,12 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_INCLUDE_CLASSIC_SYMBOLS
+#define BOOST_SPIRIT_INCLUDE_CLASSIC_SYMBOLS
+#include <boost/spirit/home/classic/symbols.hpp>
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_core.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_core.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_core.hpp	(working copy)
@@ -0,0 +1,12 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_INCLUDE_CLASSIC_CORE
+#define BOOST_SPIRIT_INCLUDE_CLASSIC_CORE
+#include <boost/spirit/home/classic/core.hpp>
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic.hpp	(working copy)
@@ -0,0 +1,12 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_INCLUDE_CLASSIC
+#define BOOST_SPIRIT_INCLUDE_CLASSIC
+#include <boost/spirit/home/classic.hpp>
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_confix.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_confix.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/include/classic_confix.hpp	(working copy)
@@ -0,0 +1,12 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_INCLUDE_CLASSIC_CONFIX
+#define BOOST_SPIRIT_INCLUDE_CLASSIC_CONFIX
+#include <boost/spirit/home/classic/utility/confix.hpp>
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/symbols/symbols.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/symbols/symbols.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/symbols/symbols.hpp	(working copy)
@@ -0,0 +1,27 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_DEPRECATED_INCLUDE_SYMBOLS
+#define BOOST_SPIRIT_DEPRECATED_INCLUDE_SYMBOLS
+
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 103800
+#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__DMC__)
+#  pragma message ("Warning: This header is deprecated. Please use: boost/spirit/include/classic_symbols.hpp")
+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
+#  warning "This header is deprecated. Please use: boost/spirit/include/classic_symbols.hpp"
+#endif
+#endif
+
+#if !defined(BOOST_SPIRIT_USE_OLD_NAMESPACE)
+#define BOOST_SPIRIT_USE_OLD_NAMESPACE
+#endif
+#include <boost/spirit/include/classic_symbols.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/namespace.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/namespace.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/namespace.hpp	(working copy)
@@ -0,0 +1,35 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(SPIRIT_CLASSIC_NAMESPACE_HPP)
+#define SPIRIT_CLASSIC_NAMESPACE_HPP
+
+#if defined(BOOST_SPIRIT_USE_OLD_NAMESPACE)
+
+// Use the old namespace for Spirit.Classic, everything is located in the
+// namespace boost::spirit.
+// This is in place for backwards compatibility with Spirit V1.8.x. Don't use
+// it when combining Spirit.Classic with other parts of the library
+
+#define BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN /*namespace classic {*/
+#define BOOST_SPIRIT_CLASSIC_NS              boost::spirit/*::classic*/
+#define BOOST_SPIRIT_CLASSIC_NAMESPACE_END   /*}*/
+
+#else
+
+// This is the normal (and suggested) mode of operation when using
+// Spirit.Classic. Everything will be located in the namespace
+// boost::spirit::classic, avoiding name clashes with other parts of Spirit.
+
+#define BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN namespace classic {
+#define BOOST_SPIRIT_CLASSIC_NS              boost::spirit::classic
+#define BOOST_SPIRIT_CLASSIC_NAMESPACE_END   }
+
+#endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/debug/minimal.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/debug/minimal.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/debug/minimal.hpp	(working copy)
@@ -0,0 +1,81 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_MINIMAL_DEBUG_HPP)
+#define BOOST_SPIRIT_MINIMAL_DEBUG_HPP
+
+#if !defined(BOOST_SPIRIT_DEBUG_MAIN_HPP)
+#error "You must include boost/spirit/debug.hpp, not boost/spirit/debug/minimal.hpp"
+#endif
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Minimum debugging tools support
+//
+///////////////////////////////////////////////////////////////////////////////
+#if !defined(BOOST_SPIRIT_DEBUG_OUT)
+#define BOOST_SPIRIT_DEBUG_OUT std::cout
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+//
+//  BOOST_SPIRIT_DEBUG_FLAGS controls the level of diagnostics printed
+//
+///////////////////////////////////////////////////////////////////////////
+#if !defined(BOOST_SPIRIT_DEBUG_FLAGS_NONE)
+#define BOOST_SPIRIT_DEBUG_FLAGS_NONE         0x0000  // no diagnostics at all
+#endif
+
+#if !defined(BOOST_SPIRIT_DEBUG_FLAGS_MAX)
+#define BOOST_SPIRIT_DEBUG_FLAGS_MAX          0xFFFF  // print maximal diagnostics
+#endif
+
+#if !defined(BOOST_SPIRIT_DEBUG_FLAGS)
+#define BOOST_SPIRIT_DEBUG_FLAGS BOOST_SPIRIT_DEBUG_FLAGS_MAX
+#endif
+
+#if !defined(BOOST_SPIRIT_DEBUG_PRINT_SOME)
+#define BOOST_SPIRIT_DEBUG_PRINT_SOME 20
+#endif
+
+#if !defined(BOOST_SPIRIT_DEBUG_RULE)
+#define BOOST_SPIRIT_DEBUG_RULE(r)
+#endif // !defined(BOOST_SPIRIT_DEBUG_RULE)
+
+#if !defined(BOOST_SPIRIT_DEBUG_NODE)
+#define BOOST_SPIRIT_DEBUG_NODE(r)
+#endif // !defined(BOOST_SPIRIT_DEBUG_NODE)
+
+#if !defined(BOOST_SPIRIT_DEBUG_GRAMMAR)
+#define BOOST_SPIRIT_DEBUG_GRAMMAR(r)
+#endif // !defined(BOOST_SPIRIT_DEBUG_GRAMMAR)
+
+#if !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE)
+#define BOOST_SPIRIT_DEBUG_TRACE_RULE(r, t)
+#endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE)
+
+#if !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE)
+#define BOOST_SPIRIT_DEBUG_TRACE_NODE(r, t)
+#endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE)
+
+#if !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR)
+#define BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR(r, t)
+#endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR)
+
+#if !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE_NAME)
+#define BOOST_SPIRIT_DEBUG_TRACE_RULE_NAME(r, n, t)
+#endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE_NAME)
+
+#if !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE_NAME)
+#define BOOST_SPIRIT_DEBUG_TRACE_NODE_NAME(r, n, t)
+#endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE_NAME)
+
+#if !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR_NAME)
+#define BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR_NAME(r, n, t)
+#endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR_NAME)
+
+#endif  // !defined(BOOST_SPIRIT_MINIMAL_DEBUG_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/traverse.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/traverse.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/traverse.hpp	(working copy)
@@ -0,0 +1,222 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_TRAVERSE_HPP)
+#define BOOST_SPIRIT_TRAVERSE_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/meta/impl/traverse.ipp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Post-order traversal of auxilliary parsers.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct post_order
+    {
+        //  Return the parser type, which is generated as the result of the
+        //  traverse function below.
+
+        template <typename MetaT, typename ParserT>
+        struct result
+        {
+            typedef typename
+                traverse_post_order_return<
+                    MetaT
+                  , ParserT
+                  , traverse_post_order_env<0, 0, 0, 0>
+                >::type
+            type;
+        };
+
+        //  Traverse a given parser and refactor it with the help of the given
+        //  MetaT metafunction template.
+
+        template <typename MetaT, typename ParserT>
+        static typename result<MetaT, ParserT>::type
+        traverse(MetaT const &meta_, ParserT const &parser_)
+        {
+            typedef typename ParserT::parser_category_t parser_category_t;
+            return impl::traverse_post_order<parser_category_t>::generate(
+                meta_, parser_, traverse_post_order_env<0, 0, 0, 0>());
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Transform policies
+    //
+    //      The following policy classes could be used to assemble some new
+    //      transformation metafunction which uses identity transformations
+    //      for some parser_category type parsers.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  transform plain parsers
+    template <typename TransformT>
+    struct plain_identity_policy
+    {
+        template <typename ParserT, typename EnvT>
+        struct plain_result
+        {
+            // plain parsers should be embedded and returned correctly
+            typedef typename ParserT::embed_t type;
+        };
+
+        template <typename ParserT, typename EnvT>
+        typename parser_traversal_plain_result<TransformT, ParserT, EnvT>::type
+        generate_plain(ParserT const &parser_, EnvT const& /*env*/) const
+        {
+            return parser_;
+        }
+    };
+
+    //////////////////////////////////
+    //  transform unary parsers
+    template <typename UnaryT, typename SubjectT>
+    struct unary_identity_policy_return
+    {
+        typedef typename UnaryT::parser_generator_t parser_generator_t;
+        typedef typename parser_generator_t
+            ::template result<SubjectT>::type type;
+    };
+
+    template <typename TransformT>
+    struct unary_identity_policy
+    {
+        template <typename UnaryT, typename SubjectT, typename EnvT>
+        struct unary_result
+        {
+            typedef
+                typename unary_identity_policy_return<UnaryT, SubjectT>::type
+            type;
+        };
+
+        template <typename UnaryT, typename SubjectT, typename EnvT>
+        typename parser_traversal_unary_result<
+            TransformT, UnaryT, SubjectT, EnvT>::type
+        generate_unary(
+            UnaryT const &, SubjectT const &subject_, EnvT const& /*env*/) const
+        {
+            typedef typename UnaryT::parser_generator_t parser_generator_t;
+            return parser_generator_t::template generate<SubjectT>(subject_);
+        }
+    };
+
+    //////////////////////////////////
+    //  transform action parsers
+    template <typename TransformT>
+    struct action_identity_policy
+    {
+        template <typename ActionT, typename SubjectT, typename EnvT>
+        struct action_result
+        {
+            typedef action<SubjectT, typename ActionT::predicate_t> type;
+        };
+
+        template <typename ActionT, typename SubjectT, typename EnvT>
+        typename parser_traversal_action_result<
+            TransformT, ActionT, SubjectT, EnvT
+        >::type
+        generate_action(ActionT const &action_, SubjectT const &subject_,
+            EnvT const& /*env*/) const
+        {
+            return subject_[action_.predicate()];
+        }
+    };
+
+    //////////////////////////////////
+    //  transform binary parsers
+    template <typename BinaryT, typename LeftT, typename RightT>
+    struct binary_identity_policy_return
+    {
+        typedef typename BinaryT::parser_generator_t parser_generator_t;
+        typedef typename parser_generator_t
+            ::template result<LeftT, RightT>::type type;
+    };
+
+    template <typename TransformT>
+    struct binary_identity_policy
+    {
+        template <typename BinaryT, typename LeftT
+            , typename RightT, typename EnvT>
+        struct binary_result {
+
+            typedef typename
+                binary_identity_policy_return<BinaryT, LeftT, RightT>::type
+            type;
+        };
+
+        template <typename BinaryT, typename LeftT
+            , typename RightT, typename EnvT>
+        typename parser_traversal_binary_result<
+            TransformT, BinaryT, LeftT, RightT, EnvT
+        >::type
+        generate_binary(
+            BinaryT const &, LeftT const& left_
+          , RightT const& right_, EnvT const& /*env*/) const
+        {
+            typedef typename BinaryT::parser_generator_t parser_generator_t;
+            return parser_generator_t::
+                template generate<LeftT, RightT>(left_, right_);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  transform_policies template
+    //
+    //      The transform_policies template metafunction could serve as a
+    //      base class for new metafunctions to be passed to the traverse meta
+    //      template (see above), where only minimal parts have to be
+    //      overwritten.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    template <
+        typename TransformT,
+        typename PlainPolicyT = plain_identity_policy<TransformT>,
+        typename UnaryPolicyT = unary_identity_policy<TransformT>,
+        typename ActionPolicyT = action_identity_policy<TransformT>,
+        typename BinaryPolicyT = binary_identity_policy<TransformT>
+    >
+    struct transform_policies :
+        public PlainPolicyT,
+        public UnaryPolicyT,
+        public ActionPolicyT,
+        public BinaryPolicyT
+    {
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Identity transformation
+    //
+    //      The identity_transform metafunction supplied to the traverse
+    //      template will generate a new parser, which will be exactly
+    //      identical to the parser given as the parameter to the traverse
+    //      metafunction. I.e. the following conceptual 'equation' will be
+    //      always true:
+    //
+    //      some_parser ==
+    //          post_order::traverse(identity_transform(), some_parser)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    struct identity_transform : transform_policies<identity_transform> {};
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // !defined(BOOST_SPIRIT_TRAVERSE_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/traverse.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/traverse.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/traverse.ipp	(working copy)
@@ -0,0 +1,393 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_TRAVERSE_IPP)
+#define BOOST_SPIRIT_TRAVERSE_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/meta/fundamental.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+namespace impl
+{
+
+    template <typename CategoryT>
+    struct traverse_post_order_return_category;
+
+}   // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Environment class for post_order_traversal
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <int Level, int Node, int Index, int LastLeft>
+struct traverse_post_order_env {
+
+    BOOST_STATIC_CONSTANT(int, level = Level);
+    BOOST_STATIC_CONSTANT(int, node = Node);
+    BOOST_STATIC_CONSTANT(int, index = Index);
+    BOOST_STATIC_CONSTANT(int, lastleft = LastLeft);
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  traverse_post_order_return template
+//
+//      This template is a helper for dispatching the calculation of a parser
+//      type result for a traversal level to the corresponding parser_category
+//      based specialization.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename MetaT, typename ParserT, typename EnvT>
+struct traverse_post_order_return {
+
+    typedef typename ParserT::parser_category_t parser_category_t;
+    typedef typename impl::traverse_post_order_return_category<parser_category_t>
+        ::template result<MetaT, ParserT, EnvT>::type type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  parser_traversal_..._result templates
+//
+//      These are metafunctions, which calculate the resulting parser type
+//      for all subparsers and feed these types to the user supplied
+//      metafunctions to get back the resulting parser type of this traversal
+//      level.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename MetaT, typename ParserT, typename EnvT>
+struct parser_traversal_plain_result {
+
+    typedef typename MetaT::template plain_result<ParserT, EnvT>::type type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template <typename MetaT, typename UnaryT, typename SubjectT, typename EnvT>
+struct parser_traversal_unary_result {
+
+    typedef typename MetaT
+        ::template unary_result<UnaryT, SubjectT, EnvT>::type type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template <typename MetaT, typename ActionT, typename SubjectT, typename EnvT>
+struct parser_traversal_action_result {
+
+    typedef typename MetaT
+        ::template action_result<ActionT, SubjectT, EnvT>::type type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename MetaT, typename BinaryT, typename LeftT,
+    typename RightT, typename EnvT
+>
+struct parser_traversal_binary_result {
+
+    BOOST_STATIC_CONSTANT(int,
+        thisnum = (node_count<BinaryT>::value + EnvT::lastleft-1));
+    BOOST_STATIC_CONSTANT(int,
+        leftnum = (node_count<LeftT>::value + EnvT::lastleft-1));
+    BOOST_STATIC_CONSTANT(int,
+        leafnum = (leaf_count<LeftT>::value + EnvT::index));
+
+    typedef parser_traversal_binary_result self_t;
+
+    // left traversal environment and resulting parser type
+    typedef traverse_post_order_env<
+                (EnvT::level+1), (self_t::leftnum), (EnvT::index), (EnvT::lastleft)
+            > left_sub_env_t;
+    typedef typename traverse_post_order_return<
+                MetaT, LeftT, left_sub_env_t
+            >::type
+        left_t;
+
+    // right traversal environment and resulting parser type
+    typedef traverse_post_order_env<
+                (EnvT::level+1), (self_t::thisnum-1), (self_t::leafnum), (self_t::leftnum+1)
+            > right_sub_env_t;
+    typedef typename traverse_post_order_return<
+                MetaT, RightT, right_sub_env_t
+            >::type
+        right_t;
+
+    typedef typename MetaT::template binary_result<
+                BinaryT, left_t, right_t, EnvT
+            >::type
+        type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+namespace impl
+{
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Meta functions, which dispatch the calculation of the return type of
+    //  of the post_order traverse function to the result template of the
+    //  corresponding parser_category based metafunction template.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    template <typename CategoryT>
+    struct traverse_post_order_return_category;
+
+    template <>
+    struct traverse_post_order_return_category<plain_parser_category> {
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        struct result {
+
+            typedef typename parser_traversal_plain_result<
+                        MetaT, ParserT, EnvT
+                    >::type
+                type;
+        };
+    };
+
+    template <>
+    struct traverse_post_order_return_category<unary_parser_category> {
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        struct result {
+
+            typedef typename parser_traversal_unary_result<
+                        MetaT, ParserT, typename ParserT::subject_t, EnvT
+                    >::type
+                type;
+        };
+    };
+
+    template <>
+    struct traverse_post_order_return_category<action_parser_category> {
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        struct result {
+
+            typedef typename parser_traversal_action_result<
+                        MetaT, ParserT, typename ParserT::subject_t, EnvT
+                    >::type
+                type;
+        };
+    };
+
+    template <>
+    struct traverse_post_order_return_category<binary_parser_category> {
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        struct result {
+
+            typedef typename parser_traversal_binary_result<
+                        MetaT, ParserT, typename ParserT::left_t,
+                        typename ParserT::right_t, EnvT
+                    >::type
+                type;
+        };
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Post-order parser traversal
+    //
+    //      The following templates contain the parser_category based code for
+    //
+    //        - calculating the type of the resulting parser, which is to be
+    //          returned from a level of traversal
+    //        - traversing down the composite parser structure, this traversal
+    //          returnes a new parser object
+    //
+    //      Both tasks are delegated to the MetaT metafunction supplied by the
+    //      user.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    template <typename CategoryT>
+    struct traverse_post_order;
+
+    template <>
+    struct traverse_post_order<plain_parser_category> {
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        struct result {
+
+            typedef
+                typename parser_traversal_plain_result<MetaT, ParserT, EnvT>::type
+                type;
+        };
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        static
+        typename parser_traversal_plain_result<MetaT, ParserT, EnvT>::type
+        generate(MetaT const &meta_, ParserT const &parser_, EnvT const &env)
+        {
+            return meta_.generate_plain(parser_, env);
+        }
+    };
+
+    template <>
+    struct traverse_post_order<unary_parser_category> {
+
+        template <
+            typename MetaT, typename ParserT, typename SubjectT, typename EnvT
+        >
+        struct result {
+
+            typedef typename parser_traversal_unary_result<
+                        MetaT, ParserT, SubjectT, EnvT
+                    >::type
+                type;
+        };
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        static
+        typename parser_traversal_unary_result<
+            MetaT, ParserT,
+            typename traverse_post_order_return<
+                MetaT, typename ParserT::subject_t, EnvT
+            >::type,
+            EnvT
+        >::type
+        generate(MetaT const &meta_, ParserT const &unary_, EnvT const &env)
+        {
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            return meta_.generate_unary(
+                unary_,
+                traverse_post_order<subject_category_t>::generate(meta_,
+                    unary_.subject(),
+                    traverse_post_order_env<
+                        EnvT::level+1, EnvT::node-1, EnvT::index, EnvT::lastleft
+                    >()
+                ),
+                env
+            );
+        }
+    };
+
+    template <>
+    struct traverse_post_order<action_parser_category> {
+
+        template <
+            typename MetaT, typename ParserT, typename SubjectT, typename EnvT
+        >
+        struct result {
+
+            typedef typename parser_traversal_action_result<
+                        MetaT, ParserT, SubjectT, EnvT
+                    >::type
+                type;
+        };
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        static
+        typename parser_traversal_action_result<
+            MetaT, ParserT,
+            typename traverse_post_order_return<
+                MetaT, typename ParserT::subject_t, EnvT
+            >::type,
+            EnvT
+        >::type
+        generate(MetaT const &meta_, ParserT const &action_, EnvT const &env)
+        {
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            return meta_.generate_action(
+                action_,
+                traverse_post_order<subject_category_t>::generate(meta_,
+                    action_.subject(),
+                    traverse_post_order_env<
+                        EnvT::level+1, EnvT::node-1, EnvT::index, EnvT::lastleft
+                    >()
+                ),
+                env
+            );
+        }
+    };
+
+    template <>
+    struct traverse_post_order<binary_parser_category> {
+
+        template <
+            typename MetaT, typename ParserT, typename LeftT,
+            typename RightT, typename EnvT
+        >
+        struct result {
+
+            typedef typename parser_traversal_binary_result<
+                        MetaT, ParserT, LeftT, RightT, EnvT
+                    >::type
+                type;
+        };
+
+        template <typename MetaT, typename ParserT, typename EnvT>
+        static
+        typename parser_traversal_binary_result<
+            MetaT, ParserT,
+            typename traverse_post_order_return<
+                MetaT, typename ParserT::left_t, EnvT
+            >::type,
+            typename traverse_post_order_return<
+                MetaT, typename ParserT::right_t, EnvT
+            >::type,
+            EnvT
+        >::type
+        generate(MetaT const &meta_, ParserT const &binary_, EnvT const& /*env*/)
+        {
+            typedef typename ParserT::left_t                left_t;
+            typedef typename ParserT::right_t               right_t;
+            typedef typename left_t::parser_category_t      left_category_t;
+            typedef typename right_t::parser_category_t     right_category_t;
+
+            enum {
+                leftnum = (node_count<left_t>::value + EnvT::lastleft-1),
+                thisnum = (node_count<ParserT>::value + EnvT::lastleft-1),
+                rightnum = (thisnum-1),
+                leafnum = (leaf_count<left_t>::value + EnvT::index)
+            };
+
+            return meta_.generate_binary(
+                binary_,
+                traverse_post_order<left_category_t>::generate(
+                    meta_, binary_.left(),
+                    traverse_post_order_env<
+                        EnvT::level+1, leftnum, EnvT::index, EnvT::lastleft
+                    >()
+                ),
+                traverse_post_order<right_category_t>::generate(
+                    meta_, binary_.right(),
+                    traverse_post_order_env<
+                        EnvT::level+1, rightnum, leafnum, leftnum+1
+                    >()
+                ),
+                traverse_post_order_env<
+                    EnvT::level, thisnum, EnvT::index, EnvT::lastleft
+                >()
+            );
+        }
+    };
+
+}   //  namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif // !defined(BOOST_SPIRIT_TRAVERSE_IPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/fundamental.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/fundamental.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/fundamental.ipp	(working copy)
@@ -0,0 +1,309 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_FUNDAMENTAL_IPP)
+#define BOOST_SPIRIT_FUNDAMENTAL_IPP
+
+#include <boost/mpl/int.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+    BOOST_SPIRIT_DEPENDENT_TEMPLATE_WRAPPER2(count_wrapper, count);
+#endif // defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+
+namespace impl
+{
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Helper template for counting the number of nodes contained in a
+    //  given parser type.
+    //  All parser_category type parsers are counted as nodes.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct nodes;
+
+    template <>
+    struct nodes<plain_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum { value = (LeafCountT::value + 1) };
+        };
+    };
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+
+    template <>
+    struct nodes<unary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            typedef nodes<subject_category_t> nodes_t;
+            typedef typename count_wrapper<nodes_t>
+                ::template result_<subject_t, LeafCountT>    count_t;
+
+            BOOST_STATIC_CONSTANT(int, value = count_t::value + 1);
+        };
+    };
+
+    template <>
+    struct nodes<action_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            typedef nodes<subject_category_t> nodes_t;
+            typedef typename count_wrapper<nodes_t>
+                ::template result_<subject_t, LeafCountT>    count_t;
+
+            BOOST_STATIC_CONSTANT(int, value = count_t::value + 1);
+        };
+    };
+
+    template <>
+    struct nodes<binary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::left_t                left_t;
+            typedef typename ParserT::right_t               right_t;
+            typedef typename left_t::parser_category_t      left_category_t;
+            typedef typename right_t::parser_category_t     right_category_t;
+
+            typedef nodes<left_category_t> left_nodes_t;
+            typedef typename count_wrapper<left_nodes_t>
+                ::template result_<left_t, LeafCountT>       left_count_t;
+
+            typedef nodes<right_category_t> right_nodes_t;
+            typedef typename count_wrapper<right_nodes_t>
+                ::template result_<right_t, LeafCountT>      right_count_t;
+
+            BOOST_STATIC_CONSTANT(int,
+                value = (left_count_t::value + right_count_t::value + 1));
+        };
+    };
+
+#else
+
+    template <>
+    struct nodes<unary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum { value = (nodes<subject_category_t>
+                ::template count<subject_t, LeafCountT>::value + 1) };
+        };
+    };
+
+    template <>
+    struct nodes<action_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum { value = (nodes<subject_category_t>
+                ::template count<subject_t, LeafCountT>::value + 1) };
+        };
+    };
+
+    template <>
+    struct nodes<binary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::left_t                left_t;
+            typedef typename ParserT::right_t               right_t;
+            typedef typename left_t::parser_category_t      left_category_t;
+            typedef typename right_t::parser_category_t     right_category_t;
+
+            typedef count self_t;
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum {
+                leftcount = (nodes<left_category_t>
+                    ::template count<left_t, LeafCountT>::value),
+                rightcount = (nodes<right_category_t>
+                    ::template count<right_t, LeafCountT>::value),
+                value = ((self_t::leftcount) + (self_t::rightcount) + 1)
+            };
+        };
+    };
+
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Helper template for counting the number of leaf nodes contained in a
+    //  given parser type.
+    //  Only plain_parser_category type parsers are counted as leaf nodes.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct leafs;
+
+    template <>
+    struct leafs<plain_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum { value = (LeafCountT::value + 1) };
+        };
+    };
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+
+    template <>
+    struct leafs<unary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            typedef leafs<subject_category_t> nodes_t;
+            typedef typename count_wrapper<nodes_t>
+                ::template result_<subject_t, LeafCountT>    count_t;
+
+            BOOST_STATIC_CONSTANT(int, value = count_t::value);
+        };
+    };
+
+    template <>
+    struct leafs<action_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            typedef leafs<subject_category_t> nodes_t;
+            typedef typename count_wrapper<nodes_t>
+                ::template result_<subject_t, LeafCountT>    count_t;
+
+            BOOST_STATIC_CONSTANT(int, value = count_t::value);
+        };
+    };
+
+    template <>
+    struct leafs<binary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::left_t                left_t;
+            typedef typename ParserT::right_t               right_t;
+            typedef typename left_t::parser_category_t      left_category_t;
+            typedef typename right_t::parser_category_t     right_category_t;
+
+            typedef leafs<left_category_t> left_nodes_t;
+            typedef typename count_wrapper<left_nodes_t>
+                ::template result_<left_t, LeafCountT>       left_count_t;
+
+            typedef leafs<right_category_t> right_nodes_t;
+            typedef typename count_wrapper<right_nodes_t>
+                ::template result_<right_t, LeafCountT>      right_count_t;
+
+            BOOST_STATIC_CONSTANT(int,
+                value = (left_count_t::value + right_count_t::value));
+        };
+    };
+
+#else
+
+    template <>
+    struct leafs<unary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum { value = (leafs<subject_category_t>
+                ::template count<subject_t, LeafCountT>::value) };
+        };
+    };
+
+    template <>
+    struct leafs<action_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::subject_t             subject_t;
+            typedef typename subject_t::parser_category_t   subject_category_t;
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum { value = (leafs<subject_category_t>
+                ::template count<subject_t, LeafCountT>::value) };
+        };
+    };
+
+    template <>
+    struct leafs<binary_parser_category> {
+
+        template <typename ParserT, typename LeafCountT>
+        struct count {
+
+            typedef typename ParserT::left_t                left_t;
+            typedef typename ParserT::right_t               right_t;
+            typedef typename left_t::parser_category_t      left_category_t;
+            typedef typename right_t::parser_category_t     right_category_t;
+
+            typedef count self_t;
+
+            // __BORLANDC__ == 0x0561 isn't happy with BOOST_STATIC_CONSTANT
+            enum {
+                leftcount = (leafs<left_category_t>
+                    ::template count<left_t, LeafCountT>::value),
+                rightcount = (leafs<right_category_t>
+                    ::template count<right_t, LeafCountT>::value),
+                value = (self_t::leftcount + self_t::rightcount)
+            };
+        };
+    };
+
+#endif
+
+}   // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif // !defined(BOOST_SPIRIT_FUNDAMENTAL_IPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/parser_traits.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/parser_traits.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/parser_traits.ipp	(working copy)
@@ -0,0 +1,191 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    Copyright (c) 2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PARSER_TRAITS_IPP)
+#define BOOST_SPIRIT_PARSER_TRAITS_IPP
+
+#include <boost/spirit/home/classic/core/composite/operators.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+namespace impl
+{
+
+#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  from spirit 1.1 (copyright (c) 2001 Bruce Florman)
+    //  various workarounds to support compile time decisions without partial
+    //  template specialization whether a given type is an instance of a
+    //  concrete parser type.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T>
+    struct parser_type_traits
+    {
+    //  Determine at compile time (without partial specialization)
+    //  whether a given type is an instance of the alternative<A,B>
+
+        static T t();
+
+        typedef struct { char dummy[1]; }   size1_t;
+        typedef struct { char dummy[2]; }   size2_t;
+        typedef struct { char dummy[3]; }   size3_t;
+        typedef struct { char dummy[4]; }   size4_t;
+        typedef struct { char dummy[5]; }   size5_t;
+        typedef struct { char dummy[6]; }   size6_t;
+        typedef struct { char dummy[7]; }   size7_t;
+        typedef struct { char dummy[8]; }   size8_t;
+        typedef struct { char dummy[9]; }   size9_t;
+        typedef struct { char dummy[10]; }  size10_t;
+
+    // the following functions need no implementation
+        template <typename A, typename B>
+        static size1_t test_(alternative<A, B> const&);
+        template <typename A, typename B>
+        static size2_t test_(sequence<A, B> const&);
+        template <typename A, typename B>
+        static size3_t test_(sequential_or<A, B> const&);
+        template <typename A, typename B>
+        static size4_t test_(intersection<A, B> const&);
+        template <typename A, typename B>
+        static size5_t test_(difference<A, B> const&);
+        template <typename A, typename B>
+        static size6_t test_(exclusive_or<A, B> const&);
+        template <typename S>
+        static size7_t test_(optional<S> const&);
+        template <typename S>
+        static size8_t test_(kleene_star<S> const&);
+        template <typename S>
+        static size9_t test_(positive<S> const&);
+
+        static size10_t test_(...);
+
+        BOOST_STATIC_CONSTANT(bool,
+            is_alternative = (sizeof(size1_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_sequence = (sizeof(size2_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_sequential_or = (sizeof(size3_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_intersection = (sizeof(size4_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_difference = (sizeof(size5_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_exclusive_or = (sizeof(size6_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_optional = (sizeof(size7_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_kleene_star = (sizeof(size8_t) == sizeof(test_(t()))) );
+        BOOST_STATIC_CONSTANT(bool,
+            is_positive = (sizeof(size9_t) == sizeof(test_(t()))) );
+    };
+
+#else
+
+    ///////////////////////////////////////////////////////////////////////////
+    struct parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_alternative = false);
+        BOOST_STATIC_CONSTANT(bool, is_sequence = false);
+        BOOST_STATIC_CONSTANT(bool, is_sequential_or = false);
+        BOOST_STATIC_CONSTANT(bool, is_intersection = false);
+        BOOST_STATIC_CONSTANT(bool, is_difference = false);
+        BOOST_STATIC_CONSTANT(bool, is_exclusive_or = false);
+        BOOST_STATIC_CONSTANT(bool, is_optional = false);
+        BOOST_STATIC_CONSTANT(bool, is_kleene_star = false);
+        BOOST_STATIC_CONSTANT(bool, is_positive = false);
+    };
+
+    template <typename ParserT>
+    struct parser_type_traits : public parser_type_traits_base {
+
+    //  no definition here, fallback for all not explicitly mentioned parser
+    //  types
+    };
+
+    template <typename A, typename B>
+    struct parser_type_traits<alternative<A, B> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_alternative = true);
+    };
+
+    template <typename A, typename B>
+    struct parser_type_traits<sequence<A, B> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_sequence = true);
+    };
+
+    template <typename A, typename B>
+    struct parser_type_traits<sequential_or<A, B> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_sequential_or = true);
+    };
+
+    template <typename A, typename B>
+    struct parser_type_traits<intersection<A, B> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_intersection = true);
+    };
+
+    template <typename A, typename B>
+    struct parser_type_traits<difference<A, B> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_difference = true);
+    };
+
+    template <typename A, typename B>
+    struct parser_type_traits<exclusive_or<A, B> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_exclusive_or = true);
+    };
+
+    template <typename S>
+    struct parser_type_traits<optional<S> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_optional = true);
+    };
+
+    template <typename S>
+    struct parser_type_traits<kleene_star<S> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_kleene_star = true);
+    };
+
+    template <typename S>
+    struct parser_type_traits<positive<S> >
+    :   public parser_type_traits_base {
+
+        BOOST_STATIC_CONSTANT(bool, is_positive = true);
+    };
+
+#endif // defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+}   // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif // !defined(BOOST_SPIRIT_PARSER_TRAITS_IPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/refactoring.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/refactoring.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/impl/refactoring.ipp	(working copy)
@@ -0,0 +1,451 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_REFACTORING_IPP
+#define BOOST_SPIRIT_REFACTORING_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The struct 'self_nested_refactoring' is used to indicate, that the
+//  refactoring algorithm should be 'self-nested'.
+//
+//  The struct 'non_nested_refactoring' is used to indicate, that no nesting
+//  of refactoring algorithms is reqired.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+struct non_nested_refactoring { typedef non_nested_refactoring embed_t; };
+struct self_nested_refactoring { typedef self_nested_refactoring embed_t; };
+
+///////////////////////////////////////////////////////////////////////////////
+namespace impl {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Helper templates for refactoring parsers
+//
+///////////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  refactor the left unary operand of a binary parser
+    //
+    //      The refactoring should be done only if the left operand is an
+    //      unary_parser_category parser.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct refactor_unary_nested {
+
+        template <
+            typename ParserT, typename NestedT,
+            typename ScannerT, typename BinaryT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary,
+            NestedT const& /*nested_d*/)
+        {
+            return binary.parse(scan);
+        }
+    };
+
+    template <>
+    struct refactor_unary_nested<unary_parser_category> {
+
+        template <
+            typename ParserT, typename ScannerT, typename BinaryT,
+            typename NestedT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary,
+            NestedT const& nested_d)
+        {
+            typedef typename BinaryT::parser_generator_t op_t;
+            typedef
+                typename BinaryT::left_t::parser_generator_t
+                unary_t;
+
+            return
+                unary_t::generate(
+                    nested_d[
+                        op_t::generate(binary.left().subject(), binary.right())
+                    ]
+                ).parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct refactor_unary_non_nested {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary)
+        {
+            return binary.parse(scan);
+        }
+    };
+
+    template <>
+    struct refactor_unary_non_nested<unary_parser_category> {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary)
+        {
+            typedef typename BinaryT::parser_generator_t op_t;
+            typedef
+                typename BinaryT::left_t::parser_generator_t
+                unary_t;
+
+            return unary_t::generate(
+                op_t::generate(binary.left().subject(), binary.right())
+            ).parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename NestedT>
+    struct refactor_unary_type {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, BinaryT const& binary,
+            NestedT const& nested_d)
+        {
+            typedef
+                typename BinaryT::left_t::parser_category_t
+                parser_category_t;
+
+            return refactor_unary_nested<parser_category_t>::
+                    parse(p, scan, binary, nested_d);
+        }
+    };
+
+    template <>
+    struct refactor_unary_type<non_nested_refactoring> {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, BinaryT const& binary,
+            non_nested_refactoring const&)
+        {
+            typedef
+                typename BinaryT::left_t::parser_category_t
+                parser_category_t;
+
+            return refactor_unary_non_nested<parser_category_t>::
+                    parse(p, scan, binary);
+        }
+
+    };
+
+    template <>
+    struct refactor_unary_type<self_nested_refactoring> {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, BinaryT const& binary,
+            self_nested_refactoring const &nested_tag)
+        {
+            typedef
+                typename BinaryT::left_t::parser_category_t
+                parser_category_t;
+            typedef typename ParserT::parser_generator_t parser_generator_t;
+
+            parser_generator_t nested_d(nested_tag);
+            return refactor_unary_nested<parser_category_t>::
+                    parse(p, scan, binary, nested_d);
+        }
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  refactor the action on the left operand of a binary parser
+    //
+    //      The refactoring should be done only if the left operand is an
+    //      action_parser_category parser.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct refactor_action_nested {
+
+        template <
+            typename ParserT, typename ScannerT, typename BinaryT,
+            typename NestedT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary,
+            NestedT const& nested_d)
+        {
+            return nested_d[binary].parse(scan);
+        }
+    };
+
+    template <>
+    struct refactor_action_nested<action_parser_category> {
+
+        template <
+            typename ParserT, typename ScannerT, typename BinaryT,
+            typename NestedT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary,
+            NestedT const& nested_d)
+        {
+            typedef typename BinaryT::parser_generator_t binary_gen_t;
+
+            return (
+                nested_d[
+                    binary_gen_t::generate(
+                        binary.left().subject(),
+                        binary.right()
+                    )
+                ][binary.left().predicate()]
+            ).parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct refactor_action_non_nested {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary)
+        {
+            return binary.parse(scan);
+        }
+    };
+
+    template <>
+    struct refactor_action_non_nested<action_parser_category> {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, BinaryT const& binary)
+        {
+            typedef typename BinaryT::parser_generator_t binary_gen_t;
+
+            return (
+                binary_gen_t::generate(
+                    binary.left().subject(),
+                    binary.right()
+                )[binary.left().predicate()]
+            ).parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename NestedT>
+    struct refactor_action_type {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, BinaryT const& binary,
+            NestedT const& nested_d)
+        {
+            typedef
+                typename BinaryT::left_t::parser_category_t
+                parser_category_t;
+
+            return refactor_action_nested<parser_category_t>::
+                    parse(p, scan, binary, nested_d);
+        }
+    };
+
+    template <>
+    struct refactor_action_type<non_nested_refactoring> {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, BinaryT const& binary,
+            non_nested_refactoring const&)
+        {
+            typedef
+                typename BinaryT::left_t::parser_category_t
+                parser_category_t;
+
+            return refactor_action_non_nested<parser_category_t>::
+                parse(p, scan, binary);
+        }
+    };
+
+    template <>
+    struct refactor_action_type<self_nested_refactoring> {
+
+        template <typename ParserT, typename ScannerT, typename BinaryT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, BinaryT const& binary,
+            self_nested_refactoring const &nested_tag)
+        {
+            typedef typename ParserT::parser_generator_t parser_generator_t;
+            typedef
+                typename BinaryT::left_t::parser_category_t
+                parser_category_t;
+
+            parser_generator_t nested_d(nested_tag);
+            return refactor_action_nested<parser_category_t>::
+                    parse(p, scan, binary, nested_d);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  refactor the action attached to a binary parser
+    //
+    //      The refactoring should be done only if the given parser is an
+    //      binary_parser_category parser.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct attach_action_nested {
+
+        template <
+            typename ParserT, typename ScannerT, typename ActionT,
+            typename NestedT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, ActionT const &action,
+            NestedT const& nested_d)
+        {
+            return action.parse(scan);
+        }
+    };
+
+    template <>
+    struct attach_action_nested<binary_parser_category> {
+
+        template <
+            typename ParserT, typename ScannerT, typename ActionT,
+            typename NestedT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, ActionT const &action,
+            NestedT const& nested_d)
+        {
+            typedef
+                typename ActionT::subject_t::parser_generator_t
+                binary_gen_t;
+
+            return (
+                binary_gen_t::generate(
+                    nested_d[action.subject().left()[action.predicate()]],
+                    nested_d[action.subject().right()[action.predicate()]]
+                )
+            ).parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CategoryT>
+    struct attach_action_non_nested {
+
+        template <typename ParserT, typename ScannerT, typename ActionT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, ActionT const &action)
+        {
+            return action.parse(scan);
+        }
+    };
+
+    template <>
+    struct attach_action_non_nested<binary_parser_category> {
+
+        template <typename ParserT, typename ScannerT, typename ActionT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &, ScannerT const& scan, ActionT const &action)
+        {
+            typedef
+                typename ActionT::subject_t::parser_generator_t
+                binary_gen_t;
+
+            return (
+                binary_gen_t::generate(
+                    action.subject().left()[action.predicate()],
+                    action.subject().right()[action.predicate()]
+                )
+            ).parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename NestedT>
+    struct attach_action_type {
+
+        template <typename ParserT, typename ScannerT, typename ActionT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, ActionT const& action,
+            NestedT const& nested_d)
+        {
+            typedef
+                typename ActionT::subject_t::parser_category_t
+                parser_category_t;
+
+            return attach_action_nested<parser_category_t>::
+                    parse(p, scan, action, nested_d);
+        }
+    };
+
+    template <>
+    struct attach_action_type<non_nested_refactoring> {
+
+        template <typename ParserT, typename ScannerT, typename ActionT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, ActionT const &action,
+            non_nested_refactoring const&)
+        {
+            typedef
+                typename ActionT::subject_t::parser_category_t
+                parser_category_t;
+
+            return attach_action_non_nested<parser_category_t>::
+                parse(p, scan, action);
+        }
+    };
+
+    template <>
+    struct attach_action_type<self_nested_refactoring> {
+
+        template <typename ParserT, typename ScannerT, typename ActionT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const &p, ScannerT const& scan, ActionT const &action,
+            self_nested_refactoring const& nested_tag)
+        {
+            typedef typename ParserT::parser_generator_t parser_generator_t;
+            typedef
+                typename ActionT::subject_t::parser_category_t
+                parser_category_t;
+
+            parser_generator_t nested_d(nested_tag);
+            return attach_action_nested<parser_category_t>::
+                    parse(p, scan, action, nested_d);
+        }
+    };
+
+}   // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/fundamental.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/fundamental.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/fundamental.hpp	(working copy)
@@ -0,0 +1,56 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_FUNDAMENTAL_HPP)
+#define BOOST_SPIRIT_FUNDAMENTAL_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/meta/impl/fundamental.ipp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Helper template for counting the number of nodes contained in a
+    //  given parser type.
+    //  All parser_category type parsers are counted as nodes.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ParserT>
+    struct node_count {
+
+        typedef typename ParserT::parser_category_t parser_category_t;
+        typedef typename impl::nodes<parser_category_t>
+            ::template count<ParserT, mpl::int_<0> > count_t;
+
+        BOOST_STATIC_CONSTANT(int, value = count_t::value);
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Helper template for counting the number of leaf nodes contained in a
+    //  given parser type.
+    //  Only plain_parser_category type parsers are counted as leaf nodes.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ParserT>
+    struct leaf_count {
+
+        typedef typename ParserT::parser_category_t parser_category_t;
+        typedef typename impl::leafs<parser_category_t>
+            ::template count<ParserT, mpl::int_<0> > count_t;
+
+        BOOST_STATIC_CONSTANT(int, value = count_t::value);
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // !defined(BOOST_SPIRIT_FUNDAMENTAL_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/as_parser.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/as_parser.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/as_parser.hpp	(working copy)
@@ -0,0 +1,113 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_AS_PARSER_HPP)
+#define BOOST_SPIRIT_AS_PARSER_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Helper templates to derive the parser type from an auxilliary type
+    //  and to generate an object of the required parser type given an
+    //  auxilliary object. Supported types to convert are parsers,
+    //  single characters and character strings.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    namespace impl
+    {
+        template<typename T>
+        struct default_as_parser
+        {
+            typedef T type;
+            static type const& convert(type const& p)
+            {
+                return p;
+            }
+        };
+
+        struct char_as_parser
+        {
+            typedef chlit<char> type;
+            static type convert(char ch)
+            {
+                return type(ch);
+            }
+        };
+
+        struct wchar_as_parser
+        {
+            typedef chlit<wchar_t> type;
+            static type convert(wchar_t ch)
+            {
+                return type(ch);
+            }
+        };
+
+        struct string_as_parser
+        {
+            typedef strlit<char const*> type;
+            static type convert(char const* str)
+            {
+                return type(str);
+            }
+        };
+
+        struct wstring_as_parser
+        {
+            typedef strlit<wchar_t const*> type;
+            static type convert(wchar_t const* str)
+            {
+                return type(str);
+            }
+        };
+    }
+
+    template<typename T>
+    struct as_parser : impl::default_as_parser<T> {};
+
+    template<>
+    struct as_parser<char> : impl::char_as_parser {};
+
+    template<>
+    struct as_parser<wchar_t> : impl::wchar_as_parser {};
+
+    template<>
+    struct as_parser<char*> : impl::string_as_parser {};
+
+    template<>
+    struct as_parser<char const*> : impl::string_as_parser {};
+
+    template<>
+    struct as_parser<wchar_t*> : impl::wstring_as_parser {};
+
+    template<>
+    struct as_parser<wchar_t const*> : impl::wstring_as_parser {};
+
+    template<int N>
+    struct as_parser<char[N]> : impl::string_as_parser {};
+
+    template<int N>
+    struct as_parser<wchar_t[N]> : impl::wstring_as_parser {};
+
+    template<int N>
+    struct as_parser<char const[N]> : impl::string_as_parser {};
+
+    template<int N>
+    struct as_parser<wchar_t const[N]> : impl::wstring_as_parser {};
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/parser_traits.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/parser_traits.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/parser_traits.hpp	(working copy)
@@ -0,0 +1,320 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    Copyright (c) 2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PARSER_TRAITS_HPP)
+#define BOOST_SPIRIT_PARSER_TRAITS_HPP
+
+#include <boost/type_traits/is_base_and_derived.hpp>
+#include <boost/static_assert.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/meta/impl/parser_traits.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Parser traits templates
+//
+//      Used to determine the type and several other characteristics of a given
+//      parser type.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// The is_parser traits template can be used to tell wether a given
+// class is a parser.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T>
+struct is_parser
+{
+    BOOST_STATIC_CONSTANT(bool, value =
+        (::boost::is_base_and_derived<parser<T>, T>::value));
+
+//  [JDG 2/3/03] simplified implementation by
+//  using boost::is_base_and_derived
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The is_unary_composite traits template can be used to tell if a given
+//  parser is a unary parser as for instance kleene_star or optional.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename UnaryT>
+struct is_unary_composite {
+
+    BOOST_STATIC_CONSTANT(bool, value = (::boost::is_convertible<
+        typename UnaryT::parser_category_t, unary_parser_category>::value));
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The is_acction_parser traits template can be used to tell if a given
+//  parser is a action parser, i.e. it is a composite consisting of a
+//  auxilliary parser and an attached semantic action.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActionT>
+struct is_action_parser {
+
+    BOOST_STATIC_CONSTANT(bool, value = (::boost::is_convertible<
+        typename ActionT::parser_category_t, action_parser_category>::value));
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The is_binary_composite traits template can be used to tell if a given
+//  parser is a binary parser as for instance sequence or difference.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename BinaryT>
+struct is_binary_composite {
+
+    BOOST_STATIC_CONSTANT(bool, value = (::boost::is_convertible<
+        typename BinaryT::parser_category_t, binary_parser_category>::value));
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The is_composite_parser traits template can be used to tell if a given
+//  parser is a unary or a binary parser composite type.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CompositeT>
+struct is_composite_parser {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::is_unary_composite<CompositeT>::value ||
+        ::BOOST_SPIRIT_CLASSIC_NS::is_binary_composite<CompositeT>::value));
+};
+
+///////////////////////////////////////////////////////////////////////////////
+template <typename ParserT>
+struct is_alternative {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_alternative));
+};
+
+template <typename ParserT>
+struct is_sequence {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_sequence));
+};
+
+template <typename ParserT>
+struct is_sequential_or {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_sequential_or));
+};
+
+template <typename ParserT>
+struct is_intersection {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_intersection));
+};
+
+template <typename ParserT>
+struct is_difference {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_difference));
+};
+
+template <typename ParserT>
+struct is_exclusive_or {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_exclusive_or));
+};
+
+template <typename ParserT>
+struct is_optional {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_optional));
+};
+
+template <typename ParserT>
+struct is_kleene_star {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_kleene_star));
+};
+
+template <typename ParserT>
+struct is_positive {
+
+    BOOST_STATIC_CONSTANT(bool, value = (
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::parser_type_traits<ParserT>::is_positive));
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Parser extraction templates
+//
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The unary_subject template can be used to return the type of the
+//  parser used as the subject of an unary parser.
+//  If the parser under inspection is not an unary type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename UnaryT>
+struct unary_subject {
+
+    BOOST_STATIC_ASSERT(BOOST_SPIRIT_CLASSIC_NS::is_unary_composite<UnaryT>::value);
+    typedef typename UnaryT::subject_t type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The get_unary_subject template function returns the parser object, which
+//  is used as the subject of an unary parser.
+//  If the parser under inspection is not an unary type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename UnaryT>
+inline typename unary_subject<UnaryT>::type const &
+get_unary_subject(UnaryT const &unary_)
+{
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_unary_composite<UnaryT>::value);
+    return unary_.subject();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The binary_left_subject and binary_right_subject templates can be used to
+//  return the types of the parsers used as the left and right subject of an
+//  binary parser.
+//  If the parser under inspection is not a binary type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename BinaryT>
+struct binary_left_subject {
+
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_binary_composite<BinaryT>::value);
+    typedef typename BinaryT::left_t type;
+};
+
+template <typename BinaryT>
+struct binary_right_subject {
+
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_binary_composite<BinaryT>::value);
+    typedef typename BinaryT::right_t type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The get_binary_left_subject and get_binary_right_subject template functions
+//  return the parser object, which is used as the left or right subject of a
+//  binary parser.
+//  If the parser under inspection is not a binary type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename BinaryT>
+inline typename binary_left_subject<BinaryT>::type const &
+get_binary_left_subject(BinaryT const &binary_)
+{
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_binary_composite<BinaryT>::value);
+    return binary_.left();
+}
+
+template <typename BinaryT>
+inline typename binary_right_subject<BinaryT>::type const &
+get_binary_right_subject(BinaryT const &binary_)
+{
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_binary_composite<BinaryT>::value);
+    return binary_.right();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The action_subject template can be used to return the type of the
+//  parser used as the subject of an action parser.
+//  If the parser under inspection is not an action type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActionT>
+struct action_subject {
+
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_action_parser<ActionT>::value);
+    typedef typename ActionT::subject_t type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The get_action_subject template function returns the parser object, which
+//  is used as the subject of an action parser.
+//  If the parser under inspection is not an action type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActionT>
+inline typename action_subject<ActionT>::type const &
+get_action_subject(ActionT const &action_)
+{
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_action_parser<ActionT>::value);
+    return action_.subject();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The semantic_action template can be used to return the type of the
+//  attached semantic action of an action parser.
+//  If the parser under inspection is not an action type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActionT>
+struct semantic_action {
+
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_action_parser<ActionT>::value);
+    typedef typename ActionT::predicate_t type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The get_semantic_action template function returns the attached semantic
+//  action of an action parser.
+//  If the parser under inspection is not an action type parser the compilation
+//  will fail.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActionT>
+inline typename semantic_action<ActionT>::type const &
+get_semantic_action(ActionT const &action_)
+{
+    BOOST_STATIC_ASSERT(::BOOST_SPIRIT_CLASSIC_NS::is_action_parser<ActionT>::value);
+    return action_.predicate();
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // !defined(BOOST_SPIRIT_PARSER_TRAITS_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/refactoring.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/refactoring.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta/refactoring.hpp	(working copy)
@@ -0,0 +1,287 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_REFACTORING_HPP
+#define BOOST_SPIRIT_REFACTORING_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/static_assert.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/impl/refactoring.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  refactor_unary_parser class
+//
+//      This helper template allows to attach an unary operation to a newly
+//      constructed parser, which combines the subject of the left operand of
+//      the original given parser (BinaryT) with the right operand of the
+//      original binary parser through the original binary operation and
+//      rewraps the resulting parser with the original unary operator.
+//
+//      For instance given the parser:
+//          *some_parser - another_parser
+//
+//      will be refactored to:
+//          *(some_parser - another_parser)
+//
+//      If the parser to refactor is not a unary parser, no refactoring is done
+//      at all.
+//
+//      The original parser should be a binary_parser_category parser,
+//      else the compilation will fail
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename NestedT = non_nested_refactoring>
+class refactor_unary_gen;
+
+template <typename BinaryT, typename NestedT = non_nested_refactoring>
+class refactor_unary_parser :
+    public parser<refactor_unary_parser<BinaryT, NestedT> > {
+
+public:
+    //  the parser to refactor has to be at least a binary_parser_category
+    //  parser
+    BOOST_STATIC_ASSERT((
+        boost::is_convertible<typename BinaryT::parser_category_t,
+            binary_parser_category>::value
+    ));
+
+    refactor_unary_parser(BinaryT const& binary_, NestedT const& nested_)
+    : binary(binary_), nested(nested_) {}
+
+    typedef refactor_unary_parser<BinaryT, NestedT> self_t;
+    typedef refactor_unary_gen<NestedT> parser_generator_t;
+    typedef typename BinaryT::left_t::parser_category_t parser_category_t;
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        return impl::refactor_unary_type<NestedT>::
+            parse(*this, scan, binary, nested);
+    }
+
+private:
+    typename as_parser<BinaryT>::type::embed_t binary;
+    typename NestedT::embed_t nested;
+};
+
+//////////////////////////////////
+template <typename NestedT>
+class refactor_unary_gen {
+
+public:
+    typedef refactor_unary_gen<NestedT> embed_t;
+
+    refactor_unary_gen(NestedT const& nested_ = non_nested_refactoring())
+    : nested(nested_) {}
+
+    template <typename ParserT>
+    refactor_unary_parser<ParserT, NestedT>
+    operator[](parser<ParserT> const& subject) const
+    {
+        return refactor_unary_parser<ParserT, NestedT>
+            (subject.derived(), nested);
+    }
+
+private:
+    typename NestedT::embed_t nested;
+};
+
+const refactor_unary_gen<> refactor_unary_d = refactor_unary_gen<>();
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  refactor_action_parser class
+//
+//      This helper template allows to attach an action taken from the left
+//      operand of the given binary parser to a newly constructed parser,
+//      which combines the subject of the left operand of the original binary
+//      parser with the right operand of the original binary parser by means of
+//      the original binary operator parser.
+//
+//      For instance the parser:
+//          some_parser[some_attached_functor] - another_parser
+//
+//      will be refactored to:
+//          (some_parser - another_parser)[some_attached_functor]
+//
+//      If the left operand to refactor is not an action parser, no refactoring
+//      is done at all.
+//
+//      The original parser should be a binary_parser_category parser,
+//      else the compilation will fail
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename NestedT = non_nested_refactoring>
+class refactor_action_gen;
+
+template <typename BinaryT, typename NestedT = non_nested_refactoring>
+class refactor_action_parser :
+    public parser<refactor_action_parser<BinaryT, NestedT> > {
+
+public:
+    //  the parser to refactor has to be at least a binary_parser_category
+    //  parser
+    BOOST_STATIC_ASSERT((
+        boost::is_convertible<typename BinaryT::parser_category_t,
+            binary_parser_category>::value
+    ));
+
+    refactor_action_parser(BinaryT const& binary_, NestedT const& nested_)
+    : binary(binary_), nested(nested_) {}
+
+    typedef refactor_action_parser<BinaryT, NestedT> self_t;
+    typedef refactor_action_gen<NestedT> parser_generator_t;
+    typedef typename BinaryT::left_t::parser_category_t parser_category_t;
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        return impl::refactor_action_type<NestedT>::
+            parse(*this, scan, binary, nested);
+    }
+
+private:
+    typename as_parser<BinaryT>::type::embed_t binary;
+    typename NestedT::embed_t nested;
+};
+
+//////////////////////////////////
+template <typename NestedT>
+class refactor_action_gen {
+
+public:
+    typedef refactor_action_gen<NestedT> embed_t;
+
+    refactor_action_gen(NestedT const& nested_ = non_nested_refactoring())
+    : nested(nested_) {}
+
+    template <typename ParserT>
+    refactor_action_parser<ParserT, NestedT>
+    operator[](parser<ParserT> const& subject) const
+    {
+        return refactor_action_parser<ParserT, NestedT>
+            (subject.derived(), nested);
+    }
+
+private:
+    typename NestedT::embed_t nested;
+};
+
+const refactor_action_gen<> refactor_action_d = refactor_action_gen<>();
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  attach_action_parser class
+//
+//      This helper template allows to attach an action given separately
+//      to to all parsers, out of which the given parser is constructed and
+//      reconstructs a new parser having the same structure.
+//
+//      For instance the parser:
+//          (some_parser >> another_parser)[some_attached_functor]
+//
+//      will be refactored to:
+//          some_parser[some_attached_functor]
+//              >> another_parser[some_attached_functor]
+//
+//      The original parser should be a action_parser_category parser,
+//      else the compilation will fail
+//
+//      If the parser, to which the action is attached is not an binary parser,
+//      no refactoring is done at all.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename NestedT = non_nested_refactoring>
+class attach_action_gen;
+
+template <typename ActionT, typename NestedT = non_nested_refactoring>
+class attach_action_parser :
+    public parser<attach_action_parser<ActionT, NestedT> > {
+
+public:
+    //  the parser to refactor has to be at least a action_parser_category
+    //  parser
+    BOOST_STATIC_ASSERT((
+        boost::is_convertible<typename ActionT::parser_category_t,
+            action_parser_category>::value
+    ));
+
+    attach_action_parser(ActionT const& actor_, NestedT const& nested_)
+    : actor(actor_), nested(nested_) {}
+
+    typedef attach_action_parser<ActionT, NestedT> self_t;
+    typedef attach_action_gen<NestedT> parser_generator_t;
+    typedef typename ActionT::parser_category_t parser_category_t;
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        return impl::attach_action_type<NestedT>::
+            parse(*this, scan, actor, nested);
+    }
+
+private:
+    typename as_parser<ActionT>::type::embed_t actor;
+    typename NestedT::embed_t nested;
+};
+
+//////////////////////////////////
+template <typename NestedT>
+class attach_action_gen {
+
+public:
+    typedef attach_action_gen<NestedT> embed_t;
+
+    attach_action_gen(NestedT const& nested_ = non_nested_refactoring())
+    : nested(nested_) {}
+
+    template <typename ParserT, typename ActionT>
+    attach_action_parser<action<ParserT, ActionT>, NestedT>
+    operator[](action<ParserT, ActionT> const& actor) const
+    {
+        return attach_action_parser<action<ParserT, ActionT>, NestedT>
+            (actor, nested);
+    }
+
+private:
+    typename NestedT::embed_t nested;
+};
+
+const attach_action_gen<> attach_action_d = attach_action_gen<>();
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // BOOST_SPIRIT_REFACTORING_HPP
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/safe_bool.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/safe_bool.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/safe_bool.hpp	(working copy)
@@ -0,0 +1,64 @@
+/*=============================================================================
+    Copyright (c) 2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SAFE_BOOL_HPP)
+#define BOOST_SPIRIT_SAFE_BOOL_HPP
+
+#include <boost/config.hpp>
+#include <boost/detail/workaround.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace impl
+    {
+        template <typename T>
+        struct no_base {};
+
+        template <typename T>
+        struct safe_bool_impl
+        {
+#if BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+            void stub(T*) {};
+            typedef void (safe_bool_impl::*type)(T*);
+#else
+            typedef T* TP; // workaround to make parsing easier
+            TP stub;
+            typedef TP safe_bool_impl::*type;
+#endif
+        };
+    }
+
+    template <typename DerivedT, typename BaseT = impl::no_base<DerivedT> >
+    struct safe_bool : BaseT
+    {
+    private:
+        typedef impl::safe_bool_impl<DerivedT> impl_t;
+        typedef typename impl_t::type bool_type;
+
+    public:
+        operator bool_type() const
+        {
+            return static_cast<const DerivedT*>(this)->operator_bool() ?
+                &impl_t::stub : 0;
+        }
+
+        operator bool_type()
+        {
+            return static_cast<DerivedT*>(this)->operator_bool() ?
+                &impl_t::stub : 0;
+        }
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}}
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/parser.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/parser.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/parser.hpp	(working copy)
@@ -0,0 +1,223 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PARSER_HPP)
+#define BOOST_SPIRIT_PARSER_HPP
+
+#include <boost/config.hpp>
+#include <boost/type_traits/remove_reference.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/scanner/scanner.hpp>
+#include <boost/spirit/home/classic/core/nil.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename ParserT, typename ActionT>
+    class action; //  forward declaration
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Parser categories
+    //
+    //      Helper template classes to distinguish different types of
+    //      parsers. The following categories are the most generic. More
+    //      specific types may inherit from these. Each parser has a typedef
+    //      parser_category_t that defines its category. By default, if one
+    //      is not specified, it will inherit from the base parser class
+    //      which typedefs its parser_category_t as plain_parser_category.
+    //
+    //          - plain parser has nothing special
+    //          - binary parser has subject a and b (e.g. alternative)
+    //          - unary parser has single subject  (e.g. kleene star)
+    //          - action parser has an attached action parser
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct plain_parser_category {};
+    struct binary_parser_category       : plain_parser_category {};
+    struct unary_parser_category        : plain_parser_category {};
+    struct action_parser_category       : unary_parser_category {};
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_result metafunction
+    //
+    //      Given a scanner type ScannerT and a parser type ParserT, the
+    //      parser_result metafunction provides the actual result of the
+    //      parser.
+    //
+    //  Usage:
+    //
+    //      typename parser_result<ParserT, ScannerT>::type
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ParserT, typename ScannerT>
+    struct parser_result
+    {
+        typedef typename boost::remove_reference<ParserT>::type parser_type;
+        typedef typename parser_type::template result<ScannerT>::type type;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser class
+    //
+    //      This class is a protocol base class for all parsers. This is
+    //      essentially an interface contract. The parser class does not
+    //      really know how to parse anything but instead relies on the
+    //      template parameter DerivedT (which obviously is assumed to be a
+    //      subclass) to do the actual parsing.
+    //
+    //      Concrete sub-classes inheriting from parser must have a
+    //      corresponding member function parse(...) compatible with the
+    //      conceptual Interface:
+    //
+    //          template <typename ScannerT>
+    //          RT parse(ScannerT const& scan) const;
+    //
+    //      where RT is the desired return type of the parser and ScannerT
+    //      scan is the scanner (see scanner.hpp).
+    //
+    //      Concrete sub-classes inheriting from parser in most cases need to
+    //      have a nested meta-function result that returns the result type
+    //      of the parser's parse member function, given a scanner type. The
+    //      meta-function has the form:
+    //
+    //          template <typename ScannerT>
+    //          struct result
+    //          {
+    //              typedef RT type;
+    //          };
+    //
+    //      where RT is the desired return type of the parser. This is
+    //      usually, but not always, dependent on the template parameter
+    //      ScannerT. If a parser does not supply a result metafunction, a
+    //      default is provided by the base parser class.
+    //
+    //      The parser's derived() member function returns a reference to the
+    //      parser as its derived object.
+    //
+    //      An operator[] is provided. The operator returns a semantic action
+    //      handler (see actions.hpp).
+    //
+    //      Each parser has a typedef embed_t. This typedef specifies how a
+    //      parser is embedded in a composite (see composite.hpp). By
+    //      default, if one is not specified, the parser will be embedded by
+    //      value. That is, a copy of the parser is placed as a member
+    //      variable of the composite. Most parsers are embedded by value. In
+    //      certain situations however, this is not desirable or possible.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename DerivedT>
+    struct parser
+    {
+        typedef DerivedT                embed_t;
+        typedef DerivedT                derived_t;
+        typedef plain_parser_category   parser_category_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, nil_t>::type type;
+        };
+
+        DerivedT& derived()
+        {
+            return *static_cast<DerivedT*>(this);
+        }
+
+        DerivedT const& derived() const
+        {
+            return *static_cast<DerivedT const*>(this);
+        }
+
+        template <typename ActionT>
+        action<DerivedT, ActionT>
+        operator[](ActionT const& actor) const
+        {
+            return action<DerivedT, ActionT>(derived(), actor);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parse_info
+    //
+    //      Results returned by the free parse functions:
+    //
+    //      stop:   points to the final parse position (i.e parsing
+    //              processed the input up to this point).
+    //
+    //      hit:    true if parsing is successful. This may be full:
+    //              the parser consumed all the input, or partial:
+    //              the parser consumed only a portion of the input.
+    //
+    //      full:   true when we have a full hit (i.e the parser
+    //              consumed all the input.
+    //
+    //      length: The number of characters consumed by the parser.
+    //              This is valid only if we have a successful hit
+    //              (either partial or full).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT = char const*>
+    struct parse_info
+    {
+        IteratorT   stop;
+        bool        hit;
+        bool        full;
+        std::size_t length;
+
+        parse_info(
+            IteratorT const& stop_ = IteratorT(),
+            bool hit_ = false,
+            bool full_ = false,
+            std::size_t length_ = 0)
+        : stop(stop_)
+        , hit(hit_)
+        , full(full_)
+        , length(length_) {}
+
+        template <typename ParseInfoT>
+        parse_info(ParseInfoT const& pi)
+        : stop(pi.stop)
+        , hit(pi.hit)
+        , full(pi.full)
+        , length(pi.length) {}
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Generic parse function
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT, typename DerivedT>
+    parse_info<IteratorT>
+    parse(
+        IteratorT const&        first,
+        IteratorT const&        last,
+        parser<DerivedT> const& p);
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Parse function for null terminated strings
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT, typename DerivedT>
+    parse_info<CharT const*>
+    parse(
+        CharT const*            str,
+        parser<DerivedT> const& p);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/impl/parser.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/match.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/match.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/match.hpp	(working copy)
@@ -0,0 +1,185 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_MATCH_HPP)
+#define BOOST_SPIRIT_MATCH_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/config.hpp>
+#include <boost/spirit/home/classic/core/nil.hpp>
+#include <boost/call_traits.hpp>
+#include <boost/optional.hpp>
+#include <boost/spirit/home/classic/core/assert.hpp>
+#include <boost/spirit/home/classic/core/safe_bool.hpp>
+#include <boost/spirit/home/classic/core/impl/match_attr_traits.ipp>
+#include <boost/type_traits/add_const.hpp>
+#include <boost/type_traits/is_reference.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  match class
+    //
+    //      The match holds the result of a parser. A match object evaluates
+    //      to true when a successful match is found, otherwise false. The
+    //      length of the match is the number of characters (or tokens) that
+    //      is successfully matched. This can be queried through its length()
+    //      member function. A negative value means that the match is
+    //      unsucessful.
+    //
+    //      Each parser may have an associated attribute. This attribute is
+    //      also returned back to the client on a successful parse through
+    //      the match object. The match's value() member function returns the
+    //      match's attribute.
+    //
+    //      A match attribute is valid:
+    //
+    //          * on a successful match
+    //          * when its value is set through the value(val) member function
+    //          * if it is assigned or copied from a compatible match object
+    //            (e.g. match<double> from match<int>) with a valid attribute.
+    //
+    //      The match attribute is undefined:
+    //
+    //          * on an unsuccessful match
+    //          * when an attempt to copy or assign from another match object
+    //            with an incompatible attribute type (e.g. match<std::string>
+    //            from match<int>).
+    //
+    //      The member function has_valid_attribute() can be queried to know if
+    //      it is safe to get the match's attribute. The attribute may be set
+    //      through the member function value(v) where v is the new attribute
+    //      value.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T = nil_t>
+    class match : public safe_bool<match<T> >
+    {
+
+    public:
+
+        typedef typename boost::optional<T> optional_type;
+        typedef typename optional_type::argument_type ctor_param_t;
+        typedef typename optional_type::reference_const_type return_t;
+        typedef T attr_t;
+
+                                match();
+        explicit                match(std::size_t length);
+                                match(std::size_t length, ctor_param_t val);
+
+        bool                    operator!() const;
+        std::ptrdiff_t          length() const;
+        bool                    has_valid_attribute() const;
+        return_t                value() const;
+        void                    swap(match& other);
+
+        template <typename T2>
+        match(match<T2> const& other)
+        : len(other.length()), val()
+        {
+            impl::match_attr_traits<T>::copy(val, other);
+        }
+
+        template <typename T2>
+        match&
+        operator=(match<T2> const& other)
+        {
+            impl::match_attr_traits<T>::assign(val, other);
+            len = other.length();
+            return *this;
+        }
+
+        template <typename MatchT>
+        void
+        concat(MatchT const& other)
+        {
+            BOOST_SPIRIT_ASSERT(*this && other);
+            len += other.length();
+        }
+
+        template <typename ValueT>
+        void
+        value(ValueT const& val_)
+        {
+            impl::match_attr_traits<T>::set_value(val, val_, is_reference<T>());
+        }
+
+        bool operator_bool() const
+        {
+            return len >= 0;
+        }
+
+    private:
+
+        std::ptrdiff_t len;
+        optional_type val;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  match class specialization for nil_t values
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <>
+    class match<nil_t> : public safe_bool<match<nil_t> >
+    {
+    public:
+
+        typedef nil_t attr_t;
+        typedef nil_t return_t;
+
+                                match();
+        explicit                match(std::size_t length);
+                                match(std::size_t length, nil_t);
+
+        bool                    operator!() const;
+        bool                    has_valid_attribute() const;
+        std::ptrdiff_t          length() const;
+        nil_t                   value() const;
+        void                    value(nil_t);
+        void                    swap(match& other);
+
+        template <typename T>
+        match(match<T> const& other)
+        : len(other.length()) {}
+
+        template <typename T>
+        match<>&
+        operator=(match<T> const& other)
+        {
+            len = other.length();
+            return *this;
+        }
+
+        template <typename T>
+        void
+        concat(match<T> const& other)
+        {
+            BOOST_SPIRIT_ASSERT(*this && other);
+            len += other.length();
+        }
+
+        bool operator_bool() const
+        {
+            return len >= 0;
+        }
+
+    private:
+
+        std::ptrdiff_t len;
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+#include <boost/spirit/home/classic/core/impl/match.ipp>
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/object_with_id.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/object_with_id.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/object_with_id.ipp	(working copy)
@@ -0,0 +1,191 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined BOOST_SPIRIT_OBJECT_WITH_ID_IPP
+#define BOOST_SPIRIT_OBJECT_WITH_ID_IPP
+
+#include <vector>
+#include <boost/shared_ptr.hpp>
+
+#ifdef BOOST_SPIRIT_THREADSAFE
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/once.hpp>
+#endif
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace impl {
+
+        //////////////////////////////////
+        template <typename IdT = std::size_t>
+        struct object_with_id_base_supply
+        {
+            typedef IdT                     object_id;
+            typedef std::vector<object_id>  id_vector;
+
+            object_with_id_base_supply() : max_id(object_id()) {}
+
+#ifdef BOOST_SPIRIT_THREADSAFE
+            boost::mutex        mutex;
+#endif
+            object_id           max_id;
+            id_vector           free_ids;
+
+            object_id           acquire();
+            void                release(object_id);
+        };
+
+        //////////////////////////////////
+        template <typename TagT, typename IdT = std::size_t>
+        struct object_with_id_base
+        {
+            typedef TagT        tag_t;
+            typedef IdT         object_id;
+
+        protected:
+
+            object_id           acquire_object_id();
+            void                release_object_id(object_id);
+
+        private:
+#ifdef BOOST_SPIRIT_THREADSAFE
+            static boost::mutex &mutex_instance();
+            static void mutex_init();
+#endif
+
+            boost::shared_ptr<object_with_id_base_supply<IdT> > id_supply;
+        };
+
+        //////////////////////////////////
+        template<class TagT, typename IdT = std::size_t>
+        struct object_with_id : private object_with_id_base<TagT, IdT>
+        {
+            typedef object_with_id<TagT, IdT>       self_t;
+            typedef object_with_id_base<TagT, IdT>  base_t;
+            typedef IdT                             object_id;
+
+            object_with_id() : id(base_t::acquire_object_id()) {}
+            object_with_id(self_t const &other)
+                : base_t(other)
+                , id(base_t::acquire_object_id())
+            {} // don't copy id
+            self_t &operator = (self_t const &other)
+            {   // don't assign id
+                base_t::operator=(other);
+                return *this;
+            }
+            ~object_with_id() { base_t::release_object_id(id); }
+            object_id get_object_id() const { return id; }
+
+        private:
+
+            object_id const id;
+        };
+
+        //////////////////////////////////
+        template <typename IdT>
+        inline IdT
+        object_with_id_base_supply<IdT>::acquire()
+        {
+#ifdef BOOST_SPIRIT_THREADSAFE
+            boost::mutex::scoped_lock lock(mutex);
+#endif
+            if (free_ids.size())
+            {
+                object_id id = *free_ids.rbegin();
+                free_ids.pop_back();
+                return id;
+            }
+            else
+            {
+                if (free_ids.capacity()<=max_id)
+                    free_ids.reserve(max_id*3/2+1);
+                return ++max_id;
+            }
+        }
+
+        //////////////////////////////////
+        template <typename IdT>
+        inline void
+        object_with_id_base_supply<IdT>::release(IdT id)
+        {
+#ifdef BOOST_SPIRIT_THREADSAFE
+            boost::mutex::scoped_lock lock(mutex);
+#endif
+            if (max_id == id)
+                max_id--;
+            else
+                free_ids.push_back(id); // doesn't throw
+        }
+
+        //////////////////////////////////
+        template <typename TagT, typename IdT>
+        inline IdT
+        object_with_id_base<TagT, IdT>::acquire_object_id()
+        {
+            {
+#ifdef BOOST_SPIRIT_THREADSAFE
+                static boost::once_flag been_here = BOOST_ONCE_INIT;
+                boost::call_once(been_here, mutex_init);
+                boost::mutex &mutex = mutex_instance();
+                boost::mutex::scoped_lock lock(mutex);
+#endif
+                static boost::shared_ptr<object_with_id_base_supply<IdT> >
+                    static_supply;
+
+                if (!static_supply.get())
+                    static_supply.reset(new object_with_id_base_supply<IdT>());
+                id_supply = static_supply;
+            }
+
+            return id_supply->acquire();
+        }
+
+        //////////////////////////////////
+        template <typename TagT, typename IdT>
+        inline void
+        object_with_id_base<TagT, IdT>::release_object_id(IdT id)
+        {
+            id_supply->release(id);
+        }
+
+        //////////////////////////////////
+#ifdef BOOST_SPIRIT_THREADSAFE
+        template <typename TagT, typename IdT>
+        inline boost::mutex &
+        object_with_id_base<TagT, IdT>::mutex_instance()
+        {
+            static boost::mutex mutex;
+            return mutex;
+        }
+#endif
+
+        //////////////////////////////////
+#ifdef BOOST_SPIRIT_THREADSAFE
+        template <typename TagT, typename IdT>
+        inline void
+        object_with_id_base<TagT, IdT>::mutex_init()
+        {
+            mutex_instance();
+        }
+#endif
+
+    } // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/subrule.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/subrule.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/subrule.ipp	(working copy)
@@ -0,0 +1,211 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SUBRULE_IPP)
+#define BOOST_SPIRIT_SUBRULE_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename FirstT, typename RestT>
+    struct subrule_list;
+
+    template <int ID, typename DefT, typename ContextT>
+    struct subrule_parser;
+
+    namespace impl {
+
+    #if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+        template <int N, typename ListT>
+        struct get_subrule;
+
+        template <int N, typename ListT>
+        struct get_subrule_chooser
+        {
+                static ListT t();
+                static char test(nil_t);
+                static int  test(...);
+
+                //  Set value to
+                //      0: ListT is empty
+                //      1: ListT's first item has same ID
+                //      2: ListT's first item has a different ID
+
+                enum
+                {
+                id = ListT::first_t::id,
+                is_same_id = N == id,
+                    is_nil_t = sizeof(char) == sizeof(test(t())),
+                    value = is_nil_t ? 0 : (is_same_id ? 1 : 2)
+                };
+          };
+
+        template <int N>
+        struct subrule_chooser;
+
+        template <>
+        struct subrule_chooser<0>
+        {
+            //  First case. ListT is empty
+
+            template <int N, typename ListT>
+            struct result
+            { typedef nil_t type; };
+        };
+
+        template <>
+        struct subrule_chooser<1>
+        {
+            //  Second case. ListT is non-empty and the list's
+            //  first item has the ID we are looking for.
+
+            template <int N, typename ListT>
+            struct result
+            { typedef typename ListT::first_t::def_t type; };
+        };
+
+        template <>
+        struct subrule_chooser<2>
+        {
+            //  Third case. ListT is non-empty but the list's
+            //  first item does not have the ID we are looking for.
+
+            template <int N, typename ListT>
+            struct result
+            { typedef typename get_subrule<N, ListT::rest_t>::type type; };
+        };
+
+        template <int N, typename ListT>
+        struct get_subrule
+        {
+            enum { n = get_subrule_chooser<N, ListT>::value };
+            typedef typename subrule_chooser<n>::template
+                result<N, ListT>::type type;
+        };
+
+    #else
+
+        template <int N, typename ListT>
+        struct get_subrule
+        {
+            //  First case. ListT is non-empty but the list's
+            //  first item does not have the ID we are looking for.
+
+            typedef typename get_subrule<N, typename ListT::rest_t>::type type;
+        };
+
+        template <int ID, typename DefT, typename ContextT, typename RestT>
+        struct get_subrule<
+            ID,
+            subrule_list<
+                subrule_parser<ID, DefT, ContextT>,
+                RestT> >
+        {
+            //  Second case. ListT is non-empty and the list's
+            //  first item has the ID we are looking for.
+
+            typedef DefT type;
+        };
+
+        template <int ID>
+        struct get_subrule<ID, nil_t>
+        {
+            //  Third case. ListT is empty
+            typedef nil_t type;
+        };
+
+    #endif
+
+        template <typename T1, typename T2>
+        struct get_result_t {
+
+        //  If the result type dictated by the context is nil_t (no closures
+        //  present), then the whole subrule_parser return type is equal to
+        //  the return type of the right hand side of this subrule_parser,
+        //  otherwise it is equal to the dictated return value.
+
+            typedef typename mpl::if_<
+                boost::is_same<T1, nil_t>, T2, T1
+            >::type type;
+        };
+
+        template <int ID, typename ScannerT, typename ContextResultT>
+        struct get_subrule_result
+        {
+            typedef typename
+                impl::get_subrule<ID, typename ScannerT::list_t>::type
+            parser_t;
+
+            typedef typename parser_result<parser_t, ScannerT>::type
+            def_result_t;
+
+            typedef typename match_result<ScannerT, ContextResultT>::type
+            context_result_t;
+
+            typedef typename get_result_t<context_result_t, def_result_t>::type
+            type;
+        };
+
+        template <typename DefT, typename ScannerT, typename ContextResultT>
+        struct get_subrule_parser_result
+        {
+            typedef typename parser_result<DefT, ScannerT>::type
+            def_result_t;
+
+            typedef typename match_result<ScannerT, ContextResultT>::type
+            context_result_t;
+
+            typedef typename get_result_t<context_result_t, def_result_t>::type
+            type;
+        };
+
+        template <typename SubruleT, int ID>
+        struct same_subrule_id
+        {
+            BOOST_STATIC_CONSTANT(bool, value = (SubruleT::id == ID));
+        };
+
+        template <typename RT, typename ScannerT, int ID>
+        struct parse_subrule
+        {
+            template <typename ListT>
+            static void
+            do_parse(RT& r, ScannerT const& scan, ListT const& list, mpl::true_)
+            {
+                r = list.first.rhs.parse(scan);
+            }
+
+            template <typename ListT>
+            static void
+            do_parse(RT& r, ScannerT const& scan, ListT const& list, mpl::false_)
+            {
+                typedef typename ListT::rest_t::first_t subrule_t;
+                mpl::bool_<same_subrule_id<subrule_t, ID>::value> same_id;
+                do_parse(r, scan, list.rest, same_id);
+            }
+
+            static void
+            do_(RT& r, ScannerT const& scan)
+            {
+                typedef typename ScannerT::list_t::first_t subrule_t;
+                mpl::bool_<same_subrule_id<subrule_t, ID>::value> same_id;
+                do_parse(r, scan, scan.list, same_id);
+            }
+        };
+
+}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit::impl
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/grammar.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/grammar.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/grammar.ipp	(working copy)
@@ -0,0 +1,407 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Martin Wille
+    Copyright (c) 2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined BOOST_SPIRIT_GRAMMAR_IPP
+#define BOOST_SPIRIT_GRAMMAR_IPP
+
+#if !defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+#include <boost/spirit/home/classic/core/non_terminal/impl/object_with_id.ipp>
+#include <algorithm>
+#include <functional>
+#include <memory> // for std::auto_ptr
+#include <boost/weak_ptr.hpp>
+#endif
+
+#ifdef BOOST_SPIRIT_THREADSAFE
+#include <boost/spirit/home/classic/core/non_terminal/impl/static.hpp>
+#include <boost/thread/tss.hpp>
+#include <boost/thread/mutex.hpp>
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+template <typename DerivedT, typename ContextT>
+struct grammar;
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC < 1300)
+
+BOOST_SPIRIT_DEPENDENT_TEMPLATE_WRAPPER(grammar_definition_wrapper, definition);
+
+//////////////////////////////////
+template <typename GrammarT, typename ScannerT>
+struct grammar_definition
+{
+    typedef typename impl::grammar_definition_wrapper<GrammarT>
+        ::template result_<ScannerT>::param_t type;
+};
+
+#else
+
+//////////////////////////////////
+template <typename GrammarT, typename ScannerT>
+struct grammar_definition
+{
+    typedef typename GrammarT::template definition<ScannerT> type;
+};
+
+#endif
+
+    namespace impl
+    {
+
+#if !defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+    struct grammar_tag {};
+
+    //////////////////////////////////
+    template <typename GrammarT>
+    struct grammar_helper_base
+    {
+        virtual int undefine(GrammarT *) = 0;
+        virtual ~grammar_helper_base() {}
+    };
+
+    //////////////////////////////////
+    template <typename GrammarT>
+    struct grammar_helper_list
+    {
+        typedef GrammarT                      grammar_t;
+        typedef grammar_helper_base<GrammarT> helper_t;
+        typedef std::vector<helper_t*>        vector_t;
+
+        grammar_helper_list() {}
+        grammar_helper_list(grammar_helper_list const& /*x*/)
+        {   // Does _not_ copy the helpers member !
+        }
+
+        grammar_helper_list& operator=(grammar_helper_list const& x)
+        {   // Does _not_ copy the helpers member !
+            return *this;
+        }
+
+        void push_back(helper_t *helper)
+        { helpers.push_back(helper); }
+
+        void pop_back()
+        { helpers.pop_back(); }
+
+        typename vector_t::size_type
+        size() const
+        { return helpers.size(); }
+
+        typename vector_t::reverse_iterator
+        rbegin()
+        { return helpers.rbegin(); }
+
+        typename vector_t::reverse_iterator
+        rend()
+        { return helpers.rend(); }
+
+#ifdef BOOST_SPIRIT_THREADSAFE
+        boost::mutex & mutex()
+        { return m; }
+#endif
+
+    private:
+
+        vector_t        helpers;
+#ifdef BOOST_SPIRIT_THREADSAFE
+        boost::mutex    m;
+#endif
+    };
+
+    //////////////////////////////////
+    struct grammartract_helper_list;
+
+#if !defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)    \
+    && (!defined(__GNUC__) || (__GNUC__ > 2))
+
+    struct grammartract_helper_list
+    {
+        template<typename GrammarT>
+        static grammar_helper_list<GrammarT>&
+        do_(GrammarT const* g)
+        {
+            return g->helpers;
+        }
+    };
+
+#endif
+
+    //////////////////////////////////
+    template <typename GrammarT, typename DerivedT, typename ScannerT>
+    struct grammar_helper : private grammar_helper_base<GrammarT>
+    {
+        typedef GrammarT grammar_t;
+        typedef ScannerT scanner_t;
+        typedef DerivedT derived_t;
+        typedef typename grammar_definition<DerivedT, ScannerT>::type definition_t;
+
+        typedef grammar_helper<grammar_t, derived_t, scanner_t> helper_t;
+        typedef boost::shared_ptr<helper_t> helper_ptr_t;
+        typedef boost::weak_ptr<helper_t>   helper_weak_ptr_t;
+
+        grammar_helper*
+        this_() { return this; }
+
+        grammar_helper(helper_weak_ptr_t& p)
+        : definitions_cnt(0)
+        , self(this_())
+        { p = self; }
+
+        definition_t&
+        define(grammar_t const* target_grammar)
+        {
+            grammar_helper_list<GrammarT> &helpers =
+#if !defined(__GNUC__) || (__GNUC__ > 2)
+                grammartract_helper_list::do_(target_grammar);
+#else
+                target_grammar->helpers;
+#endif
+            typename grammar_t::object_id id = target_grammar->get_object_id();
+
+            if (definitions.size()<=id)
+                definitions.resize(id*3/2+1);
+            if (definitions[id]!=0)
+                return *definitions[id];
+
+            std::auto_ptr<definition_t>
+                result(new definition_t(target_grammar->derived()));
+
+#ifdef BOOST_SPIRIT_THREADSAFE
+            boost::mutex::scoped_lock lock(helpers.mutex());
+#endif
+            helpers.push_back(this);
+
+            ++definitions_cnt;
+            definitions[id] = result.get();
+            return *(result.release());
+        }
+
+        int
+        undefine(grammar_t* target_grammar)
+        {
+            typename grammar_t::object_id id = target_grammar->get_object_id();
+
+            if (definitions.size()<=id)
+                return 0;
+            delete definitions[id];
+            definitions[id] = 0;
+            if (--definitions_cnt==0)
+                self.reset();
+            return 0;
+        }
+
+    private:
+
+        std::vector<definition_t*>  definitions;
+        unsigned long               definitions_cnt;
+        helper_ptr_t                self;
+    };
+
+#endif /* defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE) */
+
+#ifdef BOOST_SPIRIT_THREADSAFE
+    class get_definition_static_data_tag
+    {
+        template<typename DerivedT, typename ContextT, typename ScannerT>
+        friend typename DerivedT::template definition<ScannerT> &
+            get_definition(grammar<DerivedT, ContextT> const*  self);
+
+        get_definition_static_data_tag() {}
+    };
+#endif
+
+    template<typename DerivedT, typename ContextT, typename ScannerT>
+    inline typename DerivedT::template definition<ScannerT> &
+    get_definition(grammar<DerivedT, ContextT> const*  self)
+    {
+#if defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+
+        typedef typename DerivedT::template definition<ScannerT> definition_t;
+        static definition_t def(self->derived());
+        return def;
+#else
+        typedef grammar<DerivedT, ContextT>                      self_t;
+        typedef impl::grammar_helper<self_t, DerivedT, ScannerT> helper_t;
+        typedef typename helper_t::helper_weak_ptr_t             ptr_t;
+
+# ifdef BOOST_SPIRIT_THREADSAFE
+        boost::thread_specific_ptr<ptr_t> & tld_helper
+            = static_<boost::thread_specific_ptr<ptr_t>,
+                get_definition_static_data_tag>(get_definition_static_data_tag());
+
+        if (!tld_helper.get())
+            tld_helper.reset(new ptr_t);
+        ptr_t &helper = *tld_helper;
+# else
+        static ptr_t helper;
+# endif
+        if (helper.expired())
+            new helper_t(helper);
+        return helper.lock()->define(self);
+#endif
+    }
+
+#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+    template <int N>
+    struct call_helper {
+
+        template <typename RT, typename DefinitionT, typename ScannerT>
+        static void
+        do_ (RT &result, DefinitionT &def, ScannerT const &scan)
+        {
+            result = def.template get_start_parser<N>()->parse(scan);
+        }
+    };
+#else
+    //  The grammar_def stuff isn't supported for compilers, which do not
+    //  support partial template specialization
+    template <int N> struct call_helper;
+#endif
+
+    template <>
+    struct call_helper<0> {
+
+        template <typename RT, typename DefinitionT, typename ScannerT>
+        static void
+        do_ (RT &result, DefinitionT &def, ScannerT const &scan)
+        {
+            result = def.start().parse(scan);
+        }
+    };
+
+    //////////////////////////////////
+    template<int N, typename DerivedT, typename ContextT, typename ScannerT>
+    inline typename parser_result<grammar<DerivedT, ContextT>, ScannerT>::type
+    grammar_parser_parse(
+        grammar<DerivedT, ContextT> const*  self,
+        ScannerT const &scan)
+    {
+        typedef
+            typename parser_result<grammar<DerivedT, ContextT>, ScannerT>::type
+            result_t;
+        typedef typename DerivedT::template definition<ScannerT> definition_t;
+
+        result_t result;
+        definition_t &def = get_definition<DerivedT, ContextT, ScannerT>(self);
+
+        call_helper<N>::do_(result, def, scan);
+        return result;
+    }
+
+    //////////////////////////////////
+    template<typename GrammarT>
+    inline void
+    grammar_destruct(GrammarT* self)
+    {
+#if !defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+        typedef impl::grammar_helper_base<GrammarT> helper_base_t;
+        typedef grammar_helper_list<GrammarT> helper_list_t;
+        typedef typename helper_list_t::vector_t::reverse_iterator iterator_t;
+
+        helper_list_t&  helpers =
+# if !defined(__GNUC__) || (__GNUC__ > 2)
+            grammartract_helper_list::do_(self);
+# else
+            self->helpers;
+# endif
+
+# if (defined(BOOST_MSVC) && (BOOST_MSVC < 1300)) \
+    || defined(BOOST_INTEL_CXX_VERSION)
+        for (iterator_t i = helpers.rbegin(); i != helpers.rend(); ++i)
+            (*i)->undefine(self);
+# else
+        std::for_each(helpers.rbegin(), helpers.rend(),
+            std::bind2nd(std::mem_fun(&helper_base_t::undefine), self));
+# endif
+
+#else
+        (void)self;
+#endif
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  entry_grammar class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename DerivedT, int N, typename ContextT>
+    class entry_grammar
+        : public parser<entry_grammar<DerivedT, N, ContextT> >
+    {
+
+    public:
+        typedef entry_grammar<DerivedT, N, ContextT>    self_t;
+        typedef self_t                                  embed_t;
+        typedef typename ContextT::context_linker_t     context_t;
+        typedef typename context_t::attr_t              attr_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, attr_t>::type type;
+        };
+
+        entry_grammar(DerivedT const &p) : target_grammar(p) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse_main(ScannerT const& scan) const
+        { return impl::grammar_parser_parse<N>(&target_grammar, scan); }
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef parser_scanner_linker<ScannerT> scanner_t;
+            BOOST_SPIRIT_CONTEXT_PARSE(scan, target_grammar, scanner_t,
+                context_t, result_t)
+        }
+
+    private:
+        DerivedT const &target_grammar;
+    };
+
+    } // namespace impl
+
+///////////////////////////////////////
+#if !defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+#define BOOST_SPIRIT_GRAMMAR_ID , public impl::object_with_id<impl::grammar_tag>
+#else
+#define BOOST_SPIRIT_GRAMMAR_ID
+#endif
+
+///////////////////////////////////////
+#if !defined(__GNUC__) || (__GNUC__ > 2)
+#define BOOST_SPIRIT_GRAMMAR_ACCESS private:
+#else
+#define BOOST_SPIRIT_GRAMMAR_ACCESS
+#endif
+
+///////////////////////////////////////
+#if !defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+#define BOOST_SPIRIT_GRAMMAR_STATE                            \
+    BOOST_SPIRIT_GRAMMAR_ACCESS                               \
+    friend struct impl::grammartract_helper_list;    \
+    mutable impl::grammar_helper_list<self_t> helpers;
+#else
+#define BOOST_SPIRIT_GRAMMAR_STATE
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/rule.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/rule.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/impl/rule.ipp	(working copy)
@@ -0,0 +1,420 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_RULE_IPP)
+#define BOOST_SPIRIT_RULE_IPP
+
+#if BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+#include <boost/preprocessor/repeat.hpp>
+#include <boost/preprocessor/repeat_from_to.hpp>
+#include <boost/preprocessor/enum_params.hpp>
+#include <boost/preprocessor/enum_params_with_defaults.hpp>
+#include <boost/preprocessor/facilities/intercept.hpp>
+#include <boost/preprocessor/inc.hpp>
+#include <boost/preprocessor/cat.hpp>
+#endif
+
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/scanner/scanner.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_context.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_id.hpp>
+#include <boost/type_traits/is_base_and_derived.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+        template <
+            BOOST_PP_ENUM_BINARY_PARAMS(
+                BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT,
+                typename ScannerT, = mpl::void_ BOOST_PP_INTERCEPT
+            )
+        >
+        struct scanner_list;
+
+#endif // BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+    ///////////////////////////////////////////////////////////////////////////
+    namespace impl
+    {
+        template <typename BaseT, typename DefaultT
+            , typename T0, typename T1, typename T2>
+        struct get_param
+        {
+            typedef typename mpl::if_<
+                is_base_and_derived<BaseT, T0>
+              , T0
+              , typename mpl::if_<
+                    is_base_and_derived<BaseT, T1>
+                  , T1
+                  , typename mpl::if_<
+                        is_base_and_derived<BaseT, T2>
+                      , T2
+                      , DefaultT
+                    >::type
+                >::type
+            >::type type;
+        };
+
+        template <typename T0, typename T1, typename T2>
+        struct get_context
+        {
+            typedef typename get_param<
+                parser_context_base, parser_context<>, T0, T1, T2>::type
+            type;
+        };
+
+        template <typename T0, typename T1, typename T2>
+        struct get_tag
+        {
+            typedef typename get_param<
+                parser_tag_base, parser_address_tag, T0, T1, T2>::type
+            type;
+        };
+
+        template <typename T0, typename T1, typename T2>
+        struct get_scanner
+        {
+            typedef typename get_param<
+                scanner_base, scanner<>, T0, T1, T2>::type
+            type;
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  rule_base class
+        //
+        //      The rule_base class implements the basic plumbing for rules
+        //      minus the storage mechanism. It is up to the derived class
+        //      to actually store the definition somewhere. The rule_base
+        //      class assumes that the derived class provides a get() function
+        //      that will return a pointer to a parser. The get() function
+        //      may return NULL. See rule below for details.
+        //
+        //      <<< For framework use only. Not for public consumption. >>>
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <
+            typename DerivedT       // derived class
+          , typename EmbedT         // how derived class is embedded
+          , typename T0 = nil_t     // see rule class
+          , typename T1 = nil_t     // see rule class
+          , typename T2 = nil_t     // see rule class
+        >
+        class rule_base; // forward declaration
+
+        class rule_base_access
+        {
+#if defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS) \
+    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x551))
+        public: // YUCK!
+#else
+            template <
+                typename DerivedT
+              , typename EmbedT
+              , typename T0
+              , typename T1
+              , typename T2
+            >
+           friend class rule_base;
+#endif
+            template <typename RuleT>
+            static typename RuleT::abstract_parser_t*
+            get(RuleT const& r)
+            {
+                return r.get();
+            }
+        };
+
+        template <
+            typename DerivedT       // derived class
+          , typename EmbedT         // how derived class is embedded
+          , typename T0             // see rule class
+          , typename T1             // see rule class
+          , typename T2             // see rule class
+        >
+        class rule_base
+            : public parser<DerivedT>
+            , public impl::get_context<T0, T1, T2>::type::base_t
+            , public context_aux<
+                typename impl::get_context<T0, T1, T2>::type, DerivedT>
+            , public impl::get_tag<T0, T1, T2>::type
+        {
+        public:
+
+            typedef typename impl::get_scanner<T0, T1, T2>::type scanner_t;
+            typedef typename impl::get_context<T0, T1, T2>::type context_t;
+            typedef typename impl::get_tag<T0, T1, T2>::type tag_t;
+
+            typedef EmbedT embed_t;
+            typedef typename context_t::context_linker_t linked_context_t;
+            typedef typename linked_context_t::attr_t attr_t;
+
+            template <typename ScannerT>
+            struct result
+            {
+                typedef typename match_result<ScannerT, attr_t>::type type;
+            };
+
+            template <typename ScannerT>
+            typename parser_result<DerivedT, ScannerT>::type
+            parse(ScannerT const& scan) const
+            {
+                typedef parser_scanner_linker<ScannerT> linked_scanner_t;
+                typedef typename parser_result<DerivedT, ScannerT>::type result_t;
+                BOOST_SPIRIT_CONTEXT_PARSE(
+                    scan, *this, linked_scanner_t, linked_context_t, result_t);
+            }
+
+            template <typename ScannerT>
+            typename parser_result<DerivedT, ScannerT>::type
+            parse_main(ScannerT const& scan) const
+            {
+                typename parser_result<DerivedT, ScannerT>::type hit;
+
+                //  MWCW 8.3 needs this cast to be done through a pointer,
+                //  not a reference. Otherwise, it will silently construct
+                //  a temporary, causing an infinite runtime recursion.
+                DerivedT const* derived_this = static_cast<DerivedT const*>(this);
+
+                if (rule_base_access::get(*derived_this))
+                {
+                    typename ScannerT::iterator_t s(scan.first);
+                    hit = rule_base_access::get(*derived_this)
+                            ->do_parse_virtual(scan);
+                    scan.group_match(hit, this->id(), s, scan.first);
+                }
+                else
+                {
+                    hit = scan.no_match();
+                }
+                return hit;
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  abstract_parser class
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <typename ScannerT, typename AttrT>
+        struct abstract_parser
+        {
+            abstract_parser() {}
+            virtual ~abstract_parser() {}
+
+            virtual typename match_result<ScannerT, AttrT>::type
+            do_parse_virtual(ScannerT const& scan) const = 0;
+
+            virtual abstract_parser*
+            clone() const = 0;
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  concrete_parser class
+        //
+        ///////////////////////////////////////////////////////////////////////
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+        template <typename ParserT, typename ScannerT, typename AttrT>
+        struct concrete_parser : abstract_parser<ScannerT, AttrT>
+        {
+            concrete_parser(ParserT const& p_) : p(p_) {}
+            virtual ~concrete_parser() {}
+
+            virtual typename match_result<ScannerT, AttrT>::type
+            do_parse_virtual(ScannerT const& scan) const
+            {
+                return p.parse(scan);
+            }
+
+            virtual abstract_parser<ScannerT, AttrT>*
+            clone() const
+            {
+                return new concrete_parser(p);
+            }
+
+            typename ParserT::embed_t p;
+        };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+#if BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  This generates partial specializations for the class
+        //
+        //          abstract_parser
+        //
+        //  with an increasing number of different ScannerT template parameters
+        //  and corresponding do_parse_virtual function declarations for each
+        //  of the different required scanner types:
+        //
+        //      template <typename ScannerT0, ..., typename AttrT>
+        //      struct abstract_parser<scanner_list<ScannerT0, ...>, AttrT>
+        //      {
+        //          abstract_parser() {}
+        //          virtual ~abstract_parser() {}
+        //
+        //          virtual typename match_result<ScannerT0, AttrT>::type
+        //          do_parse_virtual(ScannerT0 const &scan) const = 0;
+        //
+        //          virtual abstract_parser*
+        //          clone() const = 0;
+        //
+        //          ...
+        //      };
+        //
+        ///////////////////////////////////////////////////////////////////////
+        #define BOOST_SPIRIT_RULE_ENUM_DOPARSE_A(z, N, _)                       \
+                virtual typename match_result<                                  \
+                    BOOST_PP_CAT(ScannerT, N), AttrT                            \
+                >::type                                                         \
+                do_parse_virtual(                                               \
+                    BOOST_PP_CAT(ScannerT, N) const& scan) const = 0;           \
+
+        #define BOOST_SPIRIT_ENUM_ABSTRACT_PARSERS(z, N, _)                     \
+            template <                                                          \
+                BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(N), typename ScannerT),  \
+                typename AttrT                                                  \
+            >                                                                   \
+            struct abstract_parser<                                             \
+                scanner_list<                                                   \
+                    BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(N), ScannerT)        \
+                >,                                                              \
+                AttrT                                                           \
+            >                                                                   \
+            {                                                                   \
+                abstract_parser() {}                                            \
+                virtual ~abstract_parser() {}                                   \
+                                                                                \
+                BOOST_PP_REPEAT_ ## z(                                          \
+                    BOOST_PP_INC(N), BOOST_SPIRIT_RULE_ENUM_DOPARSE_A, _)       \
+                                                                                \
+                virtual abstract_parser*                                        \
+                clone() const = 0;                                              \
+            };                                                                  \
+
+        BOOST_PP_REPEAT_FROM_TO(1, BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT,
+            BOOST_SPIRIT_ENUM_ABSTRACT_PARSERS, _)
+
+        #undef BOOST_SPIRIT_RULE_ENUM_DOPARSE_A
+        #undef BOOST_SPIRIT_ENUM_ABSTRACT_PARSERS
+        ///////////////////////////////////////////////////////////////////////
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  This generates partial specializations for the class
+        //
+        //          concrete_parser
+        //
+        //  with an increasing number of different ScannerT template parameters
+        //  and corresponding do_parse_virtual function declarations for each
+        //  of the different required scanner types:
+        //
+        //      template <
+        //          typename ParserT, typename ScannerT0, ..., typename AttrT
+        //      >
+        //      struct concrete_parser<
+        //          ParserT, scanner_list<ScannerT0, ...>, AttrT
+        //      >
+        //      :   public abstract_parser<scanner_list<ScannerT0, ...>, AttrT>
+        //      {
+        //          concrete_parser(ParserT const& p_) : p(p_) {}
+        //          virtual ~concrete_parser() {}
+        //
+        //          virtual typename match_result<ScannerT0, AttrT>::type
+        //          do_parse_virtual(ScannerT0 const &scan) const
+        //          { return p.parse(scan); }
+        //
+        //          virtual abstract_parser<scanner_list<ScannerT0, ...>, AttrT>*
+        //          clone() const
+        //          {
+        //              return new concrete_parser(p);
+        //          }
+        //
+        //          ...
+        //
+        //          typename ParserT::embed_t p;
+        //      };
+        //
+        ///////////////////////////////////////////////////////////////////////
+        #define BOOST_SPIRIT_RULE_ENUM_DOPARSE_C(z, N, _)                       \
+                virtual typename match_result<                                  \
+                    BOOST_PP_CAT(ScannerT, N), AttrT                            \
+                >::type                                                         \
+                do_parse_virtual(                                               \
+                    BOOST_PP_CAT(ScannerT, N) const& scan) const                \
+                { return p.parse(scan); }                                       \
+
+        #define BOOST_SPIRIT_ENUM_CONCRETE_PARSERS(z, N, _)                     \
+            template <                                                          \
+                typename ParserT,                                               \
+                BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(N), typename ScannerT),  \
+                typename AttrT                                                  \
+            >                                                                   \
+            struct concrete_parser<                                             \
+                ParserT,                                                        \
+                scanner_list<                                                   \
+                    BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(N), ScannerT)        \
+                >,                                                              \
+                AttrT                                                           \
+            >                                                                   \
+            :   abstract_parser<                                                \
+                    scanner_list<                                               \
+                        BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(N), ScannerT)    \
+                    >,                                                          \
+                    AttrT                                                       \
+                >                                                               \
+            {                                                                   \
+                concrete_parser(ParserT const& p_) : p(p_) {}                   \
+                virtual ~concrete_parser() {}                                   \
+                                                                                \
+                BOOST_PP_REPEAT_ ## z(                                          \
+                    BOOST_PP_INC(N), BOOST_SPIRIT_RULE_ENUM_DOPARSE_C, _)       \
+                                                                                \
+                virtual abstract_parser<                                        \
+                    scanner_list<                                               \
+                        BOOST_PP_ENUM_PARAMS_Z(z, BOOST_PP_INC(N), ScannerT)    \
+                    >,                                                          \
+                    AttrT                                                       \
+                >*                                                              \
+                clone() const                                                   \
+                {                                                               \
+                    return new concrete_parser(p);                              \
+                }                                                               \
+                                                                                \
+                typename ParserT::embed_t p;                                    \
+            };                                                                  \
+
+        BOOST_PP_REPEAT_FROM_TO(1, BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT,
+            BOOST_SPIRIT_ENUM_CONCRETE_PARSERS, _)
+
+        #undef BOOST_SPIRIT_ENUM_CONCRETE_PARSERS
+        #undef BOOST_SPIRIT_RULE_ENUM_DOPARSE_C
+        ///////////////////////////////////////////////////////////////////////
+
+#endif // BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+    } // namespace impl
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/parser_context.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/parser_context.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/parser_context.hpp	(working copy)
@@ -0,0 +1,150 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PARSER_CONTEXT_HPP)
+#define BOOST_SPIRIT_PARSER_CONTEXT_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost
+{
+    namespace spirit
+    {
+    BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  default_parser_context_base class { default context base }
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct default_parser_context_base
+    {
+        template <typename DerivedT>
+        struct aux {};
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_context_base class { base class of all context classes }
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct parser_context_base {};
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_context class { default context }
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct nil_t;
+    template<typename ContextT> struct parser_context_linker;
+
+    template<typename AttrT = nil_t>
+    struct parser_context : parser_context_base
+    {
+        typedef AttrT attr_t;
+        typedef default_parser_context_base base_t;
+        typedef parser_context_linker<parser_context<AttrT> > context_linker_t;
+
+        template <typename ParserT>
+        parser_context(ParserT const&) {}
+
+        template <typename ParserT, typename ScannerT>
+        void
+        pre_parse(ParserT const&, ScannerT const&) {}
+
+        template <typename ResultT, typename ParserT, typename ScannerT>
+        ResultT&
+        post_parse(ResultT& hit, ParserT const&, ScannerT const&)
+        { return hit; }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  context_aux class
+    //
+    //      context_aux<ContextT, DerivedT> is a class derived from the
+    //      ContextT's nested base_t::base<DerivedT> template class. (see
+    //      default_parser_context_base::aux for an example).
+    //
+    //      Basically, this class provides ContextT dependent optional
+    //      functionality to the derived class DerivedT through the CRTP
+    //      idiom (Curiously recurring template pattern).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ContextT, typename DerivedT>
+    struct context_aux : public ContextT::base_t::template aux<DerivedT> {};
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_scanner_linker and parser_scanner_linker classes
+    //  { helper templates for the rule extensibility }
+    //
+    //      This classes can be 'overloaded' (defined elsewhere), to plug
+    //      in additional functionality into the non-terminal parsing process.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #if !defined(BOOST_SPIRIT_PARSER_SCANNER_LINKER_DEFINED)
+    #define BOOST_SPIRIT_PARSER_SCANNER_LINKER_DEFINED
+
+    template<typename ScannerT>
+    struct parser_scanner_linker : public ScannerT
+    {
+        parser_scanner_linker(ScannerT const scan_) : ScannerT(scan_) {}
+    };
+
+    #endif // !defined(BOOST_SPIRIT_PARSER_SCANNER_LINKER_DEFINED)
+
+    //////////////////////////////////
+    #if !defined(BOOST_SPIRIT_PARSER_CONTEXT_LINKER_DEFINED)
+    #define BOOST_SPIRIT_PARSER_CONTEXT_LINKER_DEFINED
+
+    template<typename ContextT>
+    struct parser_context_linker : public ContextT
+    {
+        template <typename ParserT>
+        parser_context_linker(ParserT const& p)
+        : ContextT(p) {}
+
+        template <typename ParserT, typename ScannerT>
+        void pre_parse(ParserT const& p, ScannerT const& scan)
+        { ContextT::pre_parse(p, scan); }
+
+        template <typename ResultT, typename ParserT, typename ScannerT>
+        ResultT&
+        post_parse(ResultT& hit, ParserT const& p, ScannerT const& scan)
+        { return ContextT::post_parse(hit, p, scan); }
+    };
+
+    #endif // !defined(BOOST_SPIRIT_PARSER_CONTEXT_LINKER_DEFINED)
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  BOOST_SPIRIT_CONTEXT_PARSE helper macro
+    //
+    //      The original implementation uses a template class. However, we
+    //      need to lessen the template instantiation depth to help inferior
+    //      compilers that sometimes choke on deep template instantiations.
+    //      The objective is to avoid code redundancy. A macro, in this case
+    //      is an obvious solution. Sigh!
+    //
+    //      WARNING: INTERNAL USE ONLY. NOT FOR PUBLIC CONSUMPTION.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #define BOOST_SPIRIT_CONTEXT_PARSE(scan, this_, scanner_t, context_t, result_t) \
+            scanner_t scan_wrap(scan);                                              \
+            context_t context_wrap(this_);                                          \
+            context_wrap.pre_parse(this_, scan_wrap);                               \
+            result_t hit = parse_main(scan);                                        \
+            return context_wrap.post_parse(hit, this_, scan_wrap);
+
+    BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+    } // namespace spirit
+} // namespace boost
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/subrule_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/subrule_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/subrule_fwd.hpp	(working copy)
@@ -0,0 +1,35 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SUBRULE_FWD_HPP)
+#define BOOST_SPIRIT_SUBRULE_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_context.hpp>
+
+namespace boost { namespace spirit  {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <int ID, typename ContextT = parser_context<> >
+    struct subrule;
+
+    template <int ID, typename DefT, typename ContextT = parser_context<> >
+    struct subrule_parser;
+
+    template <typename ScannerT, typename ListT>
+    struct subrules_scanner;
+
+    template <typename FirstT, typename RestT>
+    struct subrule_list;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/subrule.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/subrule.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/subrule.hpp	(working copy)
@@ -0,0 +1,300 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SUBRULE_HPP)
+#define BOOST_SPIRIT_SUBRULE_HPP
+
+#include <boost/config.hpp>
+#include <boost/static_assert.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_context.hpp>
+
+#include <boost/spirit/home/classic/core/non_terminal/subrule_fwd.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/impl/subrule.ipp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  subrules_scanner class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ScannerT, typename ListT>
+    struct subrules_scanner : public ScannerT
+    {
+        typedef ScannerT                            scanner_t;
+        typedef ListT                               list_t;
+        typedef subrules_scanner<ScannerT, ListT>   self_t;
+
+        subrules_scanner(ScannerT const& scan, ListT const& list_)
+        : ScannerT(scan), list(list_) {}
+
+        template <typename PoliciesT>
+        struct rebind_policies
+        {
+            typedef typename rebind_scanner_policies<ScannerT, PoliciesT>::type
+                rebind_scanner;
+            typedef subrules_scanner<rebind_scanner, ListT> type;
+        };
+
+        template <typename PoliciesT>
+        subrules_scanner<
+            typename rebind_scanner_policies<ScannerT, PoliciesT>::type,
+            ListT>
+        change_policies(PoliciesT const& policies) const
+        {
+            typedef subrules_scanner<
+                BOOST_DEDUCED_TYPENAME
+                    rebind_scanner_policies<ScannerT, PoliciesT>::type,
+                ListT>
+            subrules_scanner_t;
+
+            return subrules_scanner_t(
+                    ScannerT::change_policies(policies),
+                    list);
+        }
+
+        template <typename IteratorT>
+        struct rebind_iterator
+        {
+            typedef typename rebind_scanner_iterator<ScannerT, IteratorT>::type
+                rebind_scanner;
+            typedef subrules_scanner<rebind_scanner, ListT> type;
+        };
+
+        template <typename IteratorT>
+        subrules_scanner<
+            typename rebind_scanner_iterator<ScannerT, IteratorT>::type,
+            ListT>
+        change_iterator(IteratorT const& first, IteratorT const &last) const
+        {
+            typedef subrules_scanner<
+                BOOST_DEDUCED_TYPENAME
+                    rebind_scanner_iterator<ScannerT, IteratorT>::type,
+                ListT>
+            subrules_scanner_t;
+
+            return subrules_scanner_t(
+                    ScannerT::change_iterator(first, last),
+                    list);
+        }
+
+        ListT const& list;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  subrule_scanner type computer class
+    //
+    //      This computer ensures that the scanner will not be recursively
+    //      instantiated if it's not needed.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ScannerT, typename ListT>
+    struct subrules_scanner_finder
+    {
+          typedef subrules_scanner<ScannerT, ListT> type;
+    };
+
+    template <typename ScannerT, typename ListT>
+    struct subrules_scanner_finder<subrules_scanner<ScannerT, ListT>, ListT>
+    {
+          typedef subrules_scanner<ScannerT, ListT> type;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  subrule_list class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename FirstT, typename RestT>
+    struct subrule_list : public parser<subrule_list<FirstT, RestT> >
+    {
+        typedef subrule_list<FirstT, RestT> self_t;
+        typedef FirstT                      first_t;
+        typedef RestT                       rest_t;
+
+        subrule_list(FirstT const& first_, RestT const& rest_)
+        : first(first_), rest(rest_) {}
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<FirstT, ScannerT>::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename subrules_scanner_finder<ScannerT, self_t>::type
+            subrules_scanner_t;
+            subrules_scanner_t g_arg(scan, *this);
+            return first.start.parse(g_arg);
+        }
+
+        template <int ID, typename DefT, typename ContextT>
+        subrule_list<
+            FirstT,
+            subrule_list<
+                subrule_parser<ID, DefT, ContextT>,
+                RestT> >
+        operator,(subrule_parser<ID, DefT, ContextT> const& rhs_)
+        {
+            return subrule_list<
+                FirstT,
+                subrule_list<
+                    subrule_parser<ID, DefT, ContextT>,
+                    RestT> >(
+                        first,
+                        subrule_list<
+                            subrule_parser<ID, DefT, ContextT>,
+                            RestT>(rhs_, rest));
+        }
+
+        FirstT first;
+        RestT rest;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  subrule_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <int ID, typename DefT, typename ContextT>
+    struct subrule_parser
+    : public parser<subrule_parser<ID, DefT, ContextT> >
+    {
+        typedef subrule_parser<ID, DefT, ContextT> self_t;
+        typedef subrule<ID, ContextT> subrule_t;
+        typedef DefT def_t;
+
+        BOOST_STATIC_CONSTANT(int, id = ID);
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename
+                impl::get_subrule_parser_result<
+                    DefT, ScannerT, typename subrule_t::attr_t>::type type;
+        };
+
+        subrule_parser(subrule_t const& start_, DefT const& rhs_)
+        : rhs(rhs_), start(start_) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            // This will only be called when parsing single subrules.
+            typedef subrule_list<self_t, nil_t> list_t;
+            typedef subrules_scanner<ScannerT, list_t> scanner_t;
+
+            list_t    list(*this, nil_t());
+            scanner_t g_arg(scan, list);
+            return start.parse(g_arg);
+        }
+
+        template <int ID2, typename DefT2, typename ContextT2>
+        inline subrule_list<
+            self_t,
+            subrule_list<
+                subrule_parser<ID2, DefT2, ContextT2>,
+                nil_t> >
+        operator,(subrule_parser<ID2, DefT2, ContextT2> const& rhs) const
+        {
+            return subrule_list<
+                self_t,
+                subrule_list<
+                    subrule_parser<ID2, DefT2, ContextT2>,
+                    nil_t> >(
+                        *this,
+                        subrule_list<
+                            subrule_parser<ID2, DefT2, ContextT2>, nil_t>(
+                                rhs, nil_t()));
+        }
+
+        typename DefT::embed_t rhs;
+        subrule_t const& start;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  subrule class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <int ID, typename ContextT>
+    struct subrule
+        : public parser<subrule<ID, ContextT> >
+        , public ContextT::base_t
+        , public context_aux<ContextT, subrule<ID, ContextT> >
+    {
+        typedef subrule<ID, ContextT> self_t;
+        typedef subrule<ID, ContextT> const&  embed_t;
+
+        typedef typename ContextT::context_linker_t context_t;
+        typedef typename context_t::attr_t attr_t;
+
+        BOOST_STATIC_CONSTANT(int, id = ID);
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename
+                impl::get_subrule_result<ID, ScannerT, attr_t>::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse_main(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t result_;
+            impl::parse_subrule<result_t, ScannerT, ID>::
+                do_(result_, scan);
+            return result_;
+        }
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef parser_scanner_linker<ScannerT> scanner_t;
+            BOOST_SPIRIT_CONTEXT_PARSE(
+                scan, *this, scanner_t, context_t, result_t);
+        }
+
+        template <typename DefT>
+        subrule_parser<ID, DefT, ContextT>
+        operator=(parser<DefT> const& rhs) const
+        {
+            return subrule_parser<ID, DefT, ContextT>(*this, rhs.derived());
+        }
+
+    private:
+
+        //  assignment of subrules is not allowed. Use subrules
+        //  with identical IDs if you want to have aliases.
+
+        subrule& operator=(subrule const&);
+
+        template <int ID2, typename ContextT2>
+        subrule& operator=(subrule<ID2, ContextT2> const&);
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/grammar.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/grammar.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/grammar.hpp	(working copy)
@@ -0,0 +1,85 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Martin Wille
+    Copyright (c) 2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_GRAMMAR_HPP)
+#define BOOST_SPIRIT_GRAMMAR_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#if defined(BOOST_SPIRIT_THREADSAFE) && defined(BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE)
+#undef BOOST_SPIRIT_SINGLE_GRAMMAR_INSTANCE
+#endif
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_context.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/impl/grammar.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  grammar class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename DerivedT, typename ContextT = parser_context<> >
+struct grammar
+    : public parser<DerivedT>
+    , public ContextT::base_t
+    , public context_aux<ContextT, DerivedT>
+    BOOST_SPIRIT_GRAMMAR_ID
+{
+    typedef grammar<DerivedT, ContextT>         self_t;
+    typedef DerivedT const&                     embed_t;
+    typedef typename ContextT::context_linker_t context_t;
+    typedef typename context_t::attr_t          attr_t;
+
+    template <typename ScannerT>
+    struct result
+    {
+        typedef typename match_result<ScannerT, attr_t>::type type;
+    };
+
+    grammar() {}
+    ~grammar() { impl::grammar_destruct(this); }
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse_main(ScannerT const& scan) const
+    { return impl::grammar_parser_parse<0>(this, scan); }
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        typedef typename parser_result<self_t, ScannerT>::type result_t;
+        typedef parser_scanner_linker<ScannerT> scanner_t;
+        BOOST_SPIRIT_CONTEXT_PARSE(scan, *this, scanner_t, context_t, result_t)
+    }
+
+    template <int N>
+    impl::entry_grammar<DerivedT, N, ContextT>
+    use_parser() const
+    { return impl::entry_grammar<DerivedT, N, ContextT>( this->derived()); }
+
+    BOOST_SPIRIT_GRAMMAR_STATE
+};
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#undef BOOST_SPIRIT_GRAMMAR_ID
+#undef BOOST_SPIRIT_GRAMMAR_ACCESS
+#undef BOOST_SPIRIT_GRAMMAR_STATE
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/rule.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/rule.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/rule.hpp	(working copy)
@@ -0,0 +1,175 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_RULE_HPP)
+#define BOOST_SPIRIT_RULE_HPP
+
+#include <boost/static_assert.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Spirit predefined maximum number of simultaneously usable different
+//  scanner types.
+//
+//  This limit defines the maximum number of of possible different scanner
+//  types for which a specific rule<> may be used. If this isn't defined, a
+//  rule<> may be used with one scanner type only (multiple scanner support
+//  is disabled).
+//
+///////////////////////////////////////////////////////////////////////////////
+#if !defined(BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT)
+#  define BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT 1
+#endif
+
+//  Ensure a meaningful maximum number of simultaneously usable scanner types
+BOOST_STATIC_ASSERT(BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 0);
+
+#include <boost/scoped_ptr.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/impl/rule.ipp>
+
+#if BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+#  include <boost/preprocessor/enum_params.hpp>
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  scanner_list (a fake scanner)
+    //
+    //      Typically, rules are tied to a specific scanner type and
+    //      a particular rule cannot be used with anything else. Sometimes
+    //      there's a need for rules that can accept more than one scanner
+    //      type. The scanner_list<S0, ...SN> can be used as a template
+    //      parameter to the rule class to specify up to the number of
+    //      scanner types defined by the BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT
+    //      constant. Example:
+    //
+    //          rule<scanner_list<ScannerT0, ScannerT1> > r;
+    //
+    //      *** This feature is available only to compilers that support
+    //      partial template specialization. ***
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        BOOST_PP_ENUM_PARAMS(
+            BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT,
+            typename ScannerT
+        )
+    >
+    struct scanner_list : scanner_base {};
+
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  rule class
+    //
+    //      The rule is a polymorphic parser that acts as a named place-
+    //      holder capturing the behavior of an EBNF expression assigned to
+    //      it.
+    //
+    //      The rule is a template class parameterized by:
+    //
+    //          1) scanner (scanner_t, see scanner.hpp),
+    //          2) the rule's context (context_t, see parser_context.hpp)
+    //          3) an arbitrary tag (tag_t, see parser_id.hpp) that allows
+    //             a rule to be tagged for identification.
+    //
+    //      These template parameters may be specified in any order. The
+    //      scanner will default to scanner<> when it is not specified.
+    //      The context will default to parser_context when not specified.
+    //      The tag will default to parser_address_tag when not specified.
+    //
+    //      The definition of the rule (its right hand side, RHS) held by
+    //      the rule through a scoped_ptr. When a rule is seen in the RHS
+    //      of an assignment or copy construction EBNF expression, the rule
+    //      is held by the LHS rule by reference.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T0 = nil_t
+      , typename T1 = nil_t
+      , typename T2 = nil_t
+    >
+    class rule
+        : public impl::rule_base<
+            rule<T0, T1, T2>
+          , rule<T0, T1, T2> const&
+          , T0, T1, T2>
+    {
+    public:
+
+        typedef rule<T0, T1, T2> self_t;
+        typedef impl::rule_base<
+            self_t
+          , self_t const&
+          , T0, T1, T2>
+        base_t;
+
+        typedef typename base_t::scanner_t scanner_t;
+        typedef typename base_t::attr_t attr_t;
+        typedef impl::abstract_parser<scanner_t, attr_t> abstract_parser_t;
+
+        rule() : ptr() {}
+        ~rule() {}
+
+        rule(rule const& r)
+        : ptr(new impl::concrete_parser<rule, scanner_t, attr_t>(r)) {}
+
+        template <typename ParserT>
+        rule(ParserT const& p)
+        : ptr(new impl::concrete_parser<ParserT, scanner_t, attr_t>(p)) {}
+
+        template <typename ParserT>
+        rule& operator=(ParserT const& p)
+        {
+            ptr.reset(new impl::concrete_parser<ParserT, scanner_t, attr_t>(p));
+            return *this;
+        }
+
+        rule& operator=(rule const& r)
+        {
+            ptr.reset(new impl::concrete_parser<rule, scanner_t, attr_t>(r));
+            return *this;
+        }
+
+        rule<T0, T1, T2>
+        copy() const
+        {
+            return rule<T0, T1, T2>(ptr.get() ? ptr->clone() : 0);
+        }
+
+    private:
+        friend class impl::rule_base_access;
+
+        abstract_parser_t*
+        get() const
+        {
+            return ptr.get();
+        }
+
+        rule(abstract_parser_t* ptr_)
+        : ptr(ptr_) {}
+
+        rule(abstract_parser_t const* ptr_)
+        : ptr(ptr_) {}
+
+        scoped_ptr<abstract_parser_t> ptr;
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/parser_id.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/parser_id.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/non_terminal/parser_id.hpp	(working copy)
@@ -0,0 +1,122 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PARSER_ID_HPP)
+#define BOOST_SPIRIT_PARSER_ID_HPP
+
+#if defined(BOOST_SPIRIT_DEBUG)
+#   include <ostream>
+#endif
+#include <boost/spirit/home/classic/namespace.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_id class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    class parser_id
+    {
+    public:
+                    parser_id()                     : p(0) {}
+        explicit    parser_id(void const* prule)    : p(prule) {}
+                    parser_id(std::size_t l_)       : l(l_) {}
+
+        bool operator==(parser_id const& x) const   { return p == x.p; }
+        bool operator!=(parser_id const& x) const   { return !(*this == x); }
+        bool operator<(parser_id const& x) const    { return p < x.p; }
+        std::size_t to_long() const                 { return l; }
+
+    private:
+
+        union
+        {
+            void const* p;
+            std::size_t l;
+        };
+    };
+
+    #if defined(BOOST_SPIRIT_DEBUG)
+    inline std::ostream&
+    operator<<(std::ostream& out, parser_id const& rid)
+    {
+        out << (unsigned int)rid.to_long();
+        return out;
+    }
+    #endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_tag_base class: base class of all parser tags
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct parser_tag_base {};
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_address_tag class: tags a parser with its address
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct parser_address_tag : parser_tag_base
+    {
+        parser_id id() const
+        { return parser_id(reinterpret_cast<std::size_t>(this)); }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_tag class: tags a parser with an integer ID
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <int N>
+    struct parser_tag : parser_tag_base
+    {
+        static parser_id id()
+        { return parser_id(std::size_t(N)); }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  dynamic_parser_tag class: tags a parser with a dynamically changeable
+    //  integer ID
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    class dynamic_parser_tag : public parser_tag_base
+    {
+    public:
+
+        dynamic_parser_tag()
+        : tag(std::size_t(0)) {}
+
+        parser_id
+        id() const
+        {
+            return
+                tag.to_long()
+                ? tag
+                : parser_id(reinterpret_cast<std::size_t>(this));
+        }
+
+        void set_id(parser_id id_) { tag = id_; }
+
+    private:
+
+        parser_id tag;
+    };
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/assert.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/assert.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/assert.hpp	(working copy)
@@ -0,0 +1,38 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ASSERT_HPP)
+#define BOOST_SPIRIT_ASSERT_HPP
+
+#include <boost/config.hpp>
+#include <boost/throw_exception.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  BOOST_SPIRIT_ASSERT is used throughout the framework.  It can be
+//  overridden by the user. If BOOST_SPIRIT_ASSERT_EXCEPTION is defined,
+//  then that will be thrown, otherwise, BOOST_SPIRIT_ASSERT simply turns
+//  into a plain BOOST_ASSERT()
+//
+///////////////////////////////////////////////////////////////////////////////
+#if !defined(BOOST_SPIRIT_ASSERT)
+#if defined(NDEBUG)
+    #define BOOST_SPIRIT_ASSERT(x)
+#elif defined (BOOST_SPIRIT_ASSERT_EXCEPTION)
+    #define BOOST_SPIRIT_ASSERT_AUX(f, l, x) BOOST_SPIRIT_ASSERT_AUX2(f, l, x)
+    #define BOOST_SPIRIT_ASSERT_AUX2(f, l, x)                                   \
+    do{ if (!(x)) boost::throw_exception(                                       \
+        BOOST_SPIRIT_ASSERT_EXCEPTION(f "(" #l "): " #x)); } while(0)
+    #define BOOST_SPIRIT_ASSERT(x) BOOST_SPIRIT_ASSERT_AUX(__FILE__, __LINE__, x)
+#else
+    #include <boost/assert.hpp>
+    #define BOOST_SPIRIT_ASSERT(x) BOOST_ASSERT(x)
+#endif
+#endif // !defined(BOOST_SPIRIT_ASSERT)
+
+#endif // BOOST_SPIRIT_ASSERT_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/scanner_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/scanner_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/scanner_fwd.hpp	(working copy)
@@ -0,0 +1,52 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SCANNER_FWD_HPP)
+#define BOOST_SPIRIT_SCANNER_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  policy classes
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct iteration_policy;
+    struct action_policy;
+    struct match_policy;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  scanner_policies class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename IterationPolicyT   = iteration_policy,
+        typename MatchPolicyT       = match_policy,
+        typename ActionPolicyT      = action_policy>
+    struct scanner_policies;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  scanner class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename IteratorT  = char const*,
+        typename PoliciesT  = scanner_policies<> >
+    class scanner;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/scanner.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/scanner.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/scanner.hpp	(working copy)
@@ -0,0 +1,329 @@
+/*=============================================================================
+    Copyright (c) 1998-2002 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SCANNER_HPP)
+#define BOOST_SPIRIT_SCANNER_HPP
+
+#include <iterator>
+#include <boost/config.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/match.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_id.hpp>
+#include <boost/detail/iterator.hpp> // for boost::detail::iterator_traits
+
+#include <boost/spirit/home/classic/core/scanner/scanner_fwd.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  iteration_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct iteration_policy
+    {
+        template <typename ScannerT>
+        void
+        advance(ScannerT const& scan) const
+        {
+            ++scan.first;
+        }
+
+        template <typename ScannerT>
+        bool at_end(ScannerT const& scan) const
+        {
+            return scan.first == scan.last;
+        }
+
+        template <typename T>
+        T filter(T ch) const
+        {
+            return ch;
+        }
+
+        template <typename ScannerT>
+        typename ScannerT::ref_t
+        get(ScannerT const& scan) const
+        {
+            return *scan.first;
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  match_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct match_policy
+    {
+        template <typename T>
+        struct result { typedef match<T> type; };
+
+        const match<nil_t>
+        no_match() const
+        {
+            return match<nil_t>();
+        }
+
+        const match<nil_t>
+        empty_match() const
+        {
+            return match<nil_t>(0, nil_t());
+        }
+
+        template <typename AttrT, typename IteratorT>
+        match<AttrT>
+        create_match(
+            std::size_t         length,
+            AttrT const&        val,
+            IteratorT const&    /*first*/,
+            IteratorT const&    /*last*/) const
+        {
+            return match<AttrT>(length, val);
+        }
+
+        template <typename MatchT, typename IteratorT>
+        void group_match(
+            MatchT&             /*m*/,
+            parser_id const&    /*id*/,
+            IteratorT const&    /*first*/,
+            IteratorT const&    /*last*/) const {}
+
+        template <typename Match1T, typename Match2T>
+        void concat_match(Match1T& l, Match2T const& r) const
+        {
+            l.concat(r);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  match_result class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename MatchPolicyT, typename T>
+    struct match_result
+    {
+        typedef typename MatchPolicyT::template result<T>::type type;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  action_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename AttrT>
+    struct attributed_action_policy
+    {
+        template <typename ActorT, typename IteratorT>
+        static void
+        call(
+            ActorT const& actor,
+            AttrT& val,
+            IteratorT const&,
+            IteratorT const&)
+        {
+            actor(val);
+        }
+    };
+
+    //////////////////////////////////
+    template <>
+    struct attributed_action_policy<nil_t>
+    {
+        template <typename ActorT, typename IteratorT>
+        static void
+        call(
+            ActorT const& actor,
+            nil_t,
+            IteratorT const& first,
+            IteratorT const& last)
+        {
+            actor(first, last);
+        }
+    };
+
+    //////////////////////////////////
+    struct action_policy
+    {
+        template <typename ActorT, typename AttrT, typename IteratorT>
+        void
+        do_action(
+            ActorT const&       actor,
+            AttrT&              val,
+            IteratorT const&    first,
+            IteratorT const&    last) const
+        {
+            attributed_action_policy<AttrT>::call(actor, val, first, last);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  scanner_policies class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename IterationPolicyT,
+        typename MatchPolicyT,
+        typename ActionPolicyT>
+    struct scanner_policies :
+        public IterationPolicyT,
+        public MatchPolicyT,
+        public ActionPolicyT
+    {
+        typedef IterationPolicyT    iteration_policy_t;
+        typedef MatchPolicyT        match_policy_t;
+        typedef ActionPolicyT       action_policy_t;
+
+        scanner_policies(
+            IterationPolicyT const& i_policy = IterationPolicyT(),
+            MatchPolicyT const&     m_policy = MatchPolicyT(),
+            ActionPolicyT const&    a_policy = ActionPolicyT())
+        : IterationPolicyT(i_policy)
+        , MatchPolicyT(m_policy)
+        , ActionPolicyT(a_policy) {}
+
+        template <typename ScannerPoliciesT>
+        scanner_policies(ScannerPoliciesT const& policies)
+        : IterationPolicyT(policies)
+        , MatchPolicyT(policies)
+        , ActionPolicyT(policies) {}
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  scanner_policies_base class: the base class of all scanners
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct scanner_base {};
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  scanner class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename IteratorT,
+        typename PoliciesT>
+    class scanner : public PoliciesT, public scanner_base
+    {
+    public:
+
+        typedef IteratorT iterator_t;
+        typedef PoliciesT policies_t;
+
+        typedef typename boost::detail::
+            iterator_traits<IteratorT>::value_type value_t;
+        typedef typename boost::detail::
+            iterator_traits<IteratorT>::reference ref_t;
+        typedef typename boost::
+            call_traits<IteratorT>::param_type iter_param_t;
+
+        scanner(
+            IteratorT&          first_,
+            iter_param_t        last_,
+            PoliciesT const&    policies = PoliciesT())
+        : PoliciesT(policies), first(first_), last(last_)
+        {
+            at_end();
+        }
+
+        scanner(scanner const& other)
+        : PoliciesT(other), first(other.first), last(other.last) {}
+
+        scanner(scanner const& other, IteratorT& first_)
+        : PoliciesT(other), first(first_), last(other.last) {}
+
+        template <typename PoliciesT1>
+        scanner(scanner<IteratorT, PoliciesT1> const& other)
+        : PoliciesT(other), first(other.first), last(other.last) {}
+
+        bool
+        at_end() const
+        {
+            typedef typename PoliciesT::iteration_policy_t iteration_policy_type;
+            return iteration_policy_type::at_end(*this);
+        }
+
+        value_t
+        operator*() const
+        {
+            typedef typename PoliciesT::iteration_policy_t iteration_policy_type;
+            return iteration_policy_type::filter(iteration_policy_type::get(*this));
+        }
+
+        scanner const&
+        operator++() const
+        {
+            typedef typename PoliciesT::iteration_policy_t iteration_policy_type;
+            iteration_policy_type::advance(*this);
+            return *this;
+        }
+
+        template <typename PoliciesT2>
+        struct rebind_policies
+        {
+            typedef scanner<IteratorT, PoliciesT2> type;
+        };
+
+        template <typename PoliciesT2>
+        scanner<IteratorT, PoliciesT2>
+        change_policies(PoliciesT2 const& policies) const
+        {
+            return scanner<IteratorT, PoliciesT2>(first, last, policies);
+        }
+
+        template <typename IteratorT2>
+        struct rebind_iterator
+        {
+            typedef scanner<IteratorT2, PoliciesT> type;
+        };
+
+        template <typename IteratorT2>
+        scanner<IteratorT2, PoliciesT>
+        change_iterator(IteratorT2 const& first_, IteratorT2 const &last_) const
+        {
+            return scanner<IteratorT2, PoliciesT>(first_, last_, *this);
+        }
+
+        IteratorT& first;
+        IteratorT const last;
+
+    private:
+
+        scanner&
+        operator=(scanner const& other);
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  rebind_scanner_policies class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ScannerT, typename PoliciesT>
+    struct rebind_scanner_policies
+    {
+        typedef typename ScannerT::template
+            rebind_policies<PoliciesT>::type type;
+    };
+
+    //////////////////////////////////
+    template <typename ScannerT, typename IteratorT>
+    struct rebind_scanner_iterator
+    {
+        typedef typename ScannerT::template
+            rebind_iterator<IteratorT>::type type;
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/impl/skipper.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/impl/skipper.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/impl/skipper.ipp	(working copy)
@@ -0,0 +1,181 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+============================================================================*/
+#if !defined(BOOST_SPIRIT_SKIPPER_IPP)
+#define BOOST_SPIRIT_SKIPPER_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    struct space_parser;
+    template <typename BaseT>
+    struct no_skipper_iteration_policy;
+
+    namespace impl
+    {
+        template <typename ST, typename ScannerT, typename BaseT>
+        inline void
+        skipper_skip(
+            ST const& s,
+            ScannerT const& scan,
+            skipper_iteration_policy<BaseT> const&)
+        {
+            typedef scanner_policies<
+                no_skipper_iteration_policy<
+                    BOOST_DEDUCED_TYPENAME ScannerT::iteration_policy_t>,
+                BOOST_DEDUCED_TYPENAME ScannerT::match_policy_t,
+                BOOST_DEDUCED_TYPENAME ScannerT::action_policy_t
+            > policies_t;
+
+            scanner<BOOST_DEDUCED_TYPENAME ScannerT::iterator_t, policies_t>
+                scan2(scan.first, scan.last, policies_t(scan));
+            typedef typename ScannerT::iterator_t iterator_t;
+
+            for (;;)
+            {
+                iterator_t save = scan.first;
+                if (!s.parse(scan2))
+                {
+                    scan.first = save;
+                    break;
+                }
+            }
+        }
+
+        template <typename ST, typename ScannerT, typename BaseT>
+        inline void
+        skipper_skip(
+            ST const& s,
+            ScannerT const& scan,
+            no_skipper_iteration_policy<BaseT> const&)
+        {
+            for (;;)
+            {
+                typedef typename ScannerT::iterator_t iterator_t;
+                iterator_t save = scan.first;
+                if (!s.parse(scan))
+                {
+                    scan.first = save;
+                    break;
+                }
+            }
+        }
+
+        template <typename ST, typename ScannerT>
+        inline void
+        skipper_skip(
+            ST const& s,
+            ScannerT const& scan,
+            iteration_policy const&)
+        {
+            for (;;)
+            {
+                typedef typename ScannerT::iterator_t iterator_t;
+                iterator_t save = scan.first;
+                if (!s.parse(scan))
+                {
+                    scan.first = save;
+                    break;
+                }
+            }
+        }
+
+        template <typename SkipT>
+        struct phrase_parser
+        {
+            template <typename IteratorT, typename ParserT>
+            static parse_info<IteratorT>
+            parse(
+                IteratorT const&    first_,
+                IteratorT const&    last,
+                ParserT const&      p,
+                SkipT const&        skip)
+            {
+                typedef skip_parser_iteration_policy<SkipT> iter_policy_t;
+                typedef scanner_policies<iter_policy_t> scanner_policies_t;
+                typedef scanner<IteratorT, scanner_policies_t> scanner_t;
+
+                iter_policy_t iter_policy(skip);
+                scanner_policies_t policies(iter_policy);
+                IteratorT first = first_;
+                scanner_t scan(first, last, policies);
+                match<nil_t> hit = p.parse(scan);
+                return parse_info<IteratorT>(
+                    first, hit, hit && (first == last),
+                    hit.length());
+            }
+        };
+
+        template <>
+        struct phrase_parser<space_parser>
+        {
+            template <typename IteratorT, typename ParserT>
+            static parse_info<IteratorT>
+            parse(
+                IteratorT const&    first_,
+                IteratorT const&    last,
+                ParserT const&      p,
+                space_parser const&)
+            {
+                typedef skipper_iteration_policy<> iter_policy_t;
+                typedef scanner_policies<iter_policy_t> scanner_policies_t;
+                typedef scanner<IteratorT, scanner_policies_t> scanner_t;
+
+                IteratorT first = first_;
+                scanner_t scan(first, last);
+                match<nil_t> hit = p.parse(scan);
+                return parse_info<IteratorT>(
+                    first, hit, hit && (first == last),
+                    hit.length());
+            }
+        };
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Free parse functions using the skippers
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT, typename ParserT, typename SkipT>
+    inline parse_info<IteratorT>
+    parse(
+        IteratorT const&        first,
+        IteratorT const&        last,
+        parser<ParserT> const&  p,
+        parser<SkipT> const&    skip)
+    {
+        return impl::phrase_parser<SkipT>::
+            parse(first, last, p.derived(), skip.derived());
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Parse function for null terminated strings using the skippers
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT, typename ParserT, typename SkipT>
+    inline parse_info<CharT const*>
+    parse(
+        CharT const*            str,
+        parser<ParserT> const&  p,
+        parser<SkipT> const&    skip)
+    {
+        CharT const* last = str;
+        while (*last)
+            last++;
+        return parse(str, last, p, skip);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/skipper_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/skipper_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/skipper_fwd.hpp	(working copy)
@@ -0,0 +1,32 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SKIPPER_FWD_HPP)
+#define BOOST_SPIRIT_SKIPPER_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/scanner/scanner_fwd.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename BaseT = iteration_policy>
+    struct skipper_iteration_policy;
+
+    template <typename BaseT = iteration_policy>
+    struct no_skipper_iteration_policy;
+
+    template <typename ParserT, typename BaseT = iteration_policy>
+    class skip_parser_iteration_policy;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/skipper.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/skipper.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/scanner/skipper.hpp	(working copy)
@@ -0,0 +1,197 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SKIPPER_HPP)
+#define BOOST_SPIRIT_SKIPPER_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <cctype>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/scanner/scanner.hpp>
+#include <boost/spirit/home/classic/core/primitives/impl/primitives.ipp>
+
+#include <boost/spirit/home/classic/core/scanner/skipper_fwd.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  skipper_iteration_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename BaseT>
+    struct skipper_iteration_policy : public BaseT
+    {
+        typedef BaseT base_t;
+
+        skipper_iteration_policy()
+        : BaseT() {}
+
+        template <typename PolicyT>
+        skipper_iteration_policy(PolicyT const& other)
+        : BaseT(other) {}
+
+        template <typename ScannerT>
+        void
+        advance(ScannerT const& scan) const
+        {
+            BaseT::advance(scan);
+            scan.skip(scan);
+        }
+
+        template <typename ScannerT>
+        bool
+        at_end(ScannerT const& scan) const
+        {
+            scan.skip(scan);
+            return BaseT::at_end(scan);
+        }
+
+        template <typename ScannerT>
+        void
+        skip(ScannerT const& scan) const
+        {
+            while (!BaseT::at_end(scan) && impl::isspace_(BaseT::get(scan)))
+                BaseT::advance(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  no_skipper_iteration_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename BaseT>
+    struct no_skipper_iteration_policy : public BaseT
+    {
+        typedef BaseT base_t;
+
+        no_skipper_iteration_policy()
+        : BaseT() {}
+
+        template <typename PolicyT>
+        no_skipper_iteration_policy(PolicyT const& other)
+        : BaseT(other) {}
+
+        template <typename ScannerT>
+        void
+        skip(ScannerT const& /*scan*/) const {}
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  skip_parser_iteration_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    namespace impl
+    {
+        template <typename ST, typename ScannerT, typename BaseT>
+        void
+        skipper_skip(
+            ST const& s,
+            ScannerT const& scan,
+            skipper_iteration_policy<BaseT> const&);
+
+        template <typename ST, typename ScannerT, typename BaseT>
+        void
+        skipper_skip(
+            ST const& s,
+            ScannerT const& scan,
+            no_skipper_iteration_policy<BaseT> const&);
+
+        template <typename ST, typename ScannerT>
+        void
+        skipper_skip(
+            ST const& s,
+            ScannerT const& scan,
+            iteration_policy const&);
+    }
+
+    template <typename ParserT, typename BaseT>
+    class skip_parser_iteration_policy : public skipper_iteration_policy<BaseT>
+    {
+    public:
+
+        typedef skipper_iteration_policy<BaseT> base_t;
+
+        skip_parser_iteration_policy(
+            ParserT const& skip_parser,
+            base_t const& base = base_t())
+        : base_t(base), subject(skip_parser) {}
+
+        template <typename PolicyT>
+        skip_parser_iteration_policy(PolicyT const& other)
+        : base_t(other), subject(other.skipper()) {}
+
+        template <typename ScannerT>
+        void
+        skip(ScannerT const& scan) const
+        {
+            impl::skipper_skip(subject, scan, scan);
+        }
+
+        ParserT const&
+        skipper() const
+        {
+            return subject;
+        }
+
+    private:
+
+        ParserT const& subject;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////////
+    //
+    //  Free parse functions using the skippers
+    //
+    ///////////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT, typename ParserT, typename SkipT>
+    parse_info<IteratorT>
+    parse(
+        IteratorT const&        first,
+        IteratorT const&        last,
+        parser<ParserT> const&  p,
+        parser<SkipT> const&    skip);
+
+    ///////////////////////////////////////////////////////////////////////////////
+    //
+    //  Parse function for null terminated strings using the skippers
+    //
+    ///////////////////////////////////////////////////////////////////////////////
+    template <typename CharT, typename ParserT, typename SkipT>
+    parse_info<CharT const*>
+    parse(
+        CharT const*            str,
+        parser<ParserT> const&  p,
+        parser<SkipT> const&    skip);
+
+    ///////////////////////////////////////////////////////////////////////////////
+    //
+    //  phrase_scanner_t and wide_phrase_scanner_t
+    //
+    //      The most common scanners. Use these typedefs when you need
+    //      a scanner that skips white spaces.
+    //
+    ///////////////////////////////////////////////////////////////////////////////
+    typedef skipper_iteration_policy<>                  iter_policy_t;
+    typedef scanner_policies<iter_policy_t>             scanner_policies_t;
+    typedef scanner<char const*, scanner_policies_t>    phrase_scanner_t;
+    typedef scanner<wchar_t const*, scanner_policies_t> wide_phrase_scanner_t;
+
+    ///////////////////////////////////////////////////////////////////////////////
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#include <boost/spirit/home/classic/core/scanner/impl/skipper.ipp>
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/primitives.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/primitives.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/primitives.hpp	(working copy)
@@ -0,0 +1,654 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PRIMITIVES_HPP)
+#define BOOST_SPIRIT_PRIMITIVES_HPP
+
+#include <boost/ref.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/assert.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/impl/directives.ipp>
+#include <boost/spirit/home/classic/core/primitives/impl/primitives.ipp>
+
+#ifdef BOOST_MSVC
+#pragma warning (push)
+#pragma warning(disable : 4512)
+#endif
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  char_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename DerivedT>
+    struct char_parser : public parser<DerivedT>
+    {
+        typedef DerivedT self_t;
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<
+                ScannerT,
+                typename ScannerT::value_t
+            >::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::value_t value_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+
+            if (!scan.at_end())
+            {
+                value_t ch = *scan;
+                if (this->derived().test(ch))
+                {
+                    iterator_t save(scan.first);
+                    ++scan.first;
+                    return scan.create_match(1, ch, save, scan.first);
+                }
+            }
+            return scan.no_match();
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  negation of char_parsers
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename PositiveT>
+    struct negated_char_parser
+    : public char_parser<negated_char_parser<PositiveT> >
+    {
+        typedef negated_char_parser<PositiveT> self_t;
+        typedef PositiveT positive_t;
+
+        negated_char_parser(positive_t const& p)
+        : positive(p.derived()) {}
+
+        template <typename T>
+        bool test(T ch) const
+        {
+            return !positive.test(ch);
+        }
+
+        positive_t const positive;
+    };
+
+    template <typename ParserT>
+    inline negated_char_parser<ParserT>
+    operator~(char_parser<ParserT> const& p)
+    {
+        return negated_char_parser<ParserT>(p.derived());
+    }
+
+    template <typename ParserT>
+    inline ParserT
+    operator~(negated_char_parser<ParserT> const& n)
+    {
+        return n.positive;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  chlit class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT = char>
+    struct chlit : public char_parser<chlit<CharT> >
+    {
+        chlit(CharT ch_)
+        : ch(ch_) {}
+
+        template <typename T>
+        bool test(T ch_) const
+        {
+            return ch_ == ch;
+        }
+
+        CharT   ch;
+    };
+
+    template <typename CharT>
+    inline chlit<CharT>
+    ch_p(CharT ch)
+    {
+        return chlit<CharT>(ch);
+    }
+
+    // This should take care of ch_p("a") "bugs"
+    template <typename CharT, std::size_t N>
+    inline chlit<CharT>
+    ch_p(CharT const (& str)[N])
+    {
+        //  ch_p's argument should be a single character or a null-terminated
+        //  string with a single character
+        BOOST_STATIC_ASSERT(N < 3);
+        return chlit<CharT>(str[0]);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  range class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT = char>
+    struct range : public char_parser<range<CharT> >
+    {
+        range(CharT first_, CharT last_)
+        : first(first_), last(last_)
+        {
+            BOOST_SPIRIT_ASSERT(!(last < first));
+        }
+
+        template <typename T>
+        bool test(T ch) const
+        {
+            return !(CharT(ch) < first) && !(last < CharT(ch));
+        }
+
+        CharT   first;
+        CharT   last;
+    };
+
+    template <typename CharT>
+    inline range<CharT>
+    range_p(CharT first, CharT last)
+    {
+        return range<CharT>(first, last);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  chseq class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT = char const*>
+    class chseq : public parser<chseq<IteratorT> >
+    {
+    public:
+
+        typedef chseq<IteratorT> self_t;
+
+        chseq(IteratorT first_, IteratorT last_)
+        : first(first_), last(last_) {}
+
+        chseq(IteratorT first_)
+        : first(first_), last(impl::get_last(first_)) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename boost::unwrap_reference<IteratorT>::type striter_t;
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::string_parser_parse<result_t>(
+                striter_t(first),
+                striter_t(last),
+                scan);
+        }
+
+    private:
+
+        IteratorT first;
+        IteratorT last;
+    };
+
+    template <typename CharT>
+    inline chseq<CharT const*>
+    chseq_p(CharT const* str)
+    {
+        return chseq<CharT const*>(str);
+    }
+
+    template <typename IteratorT>
+    inline chseq<IteratorT>
+    chseq_p(IteratorT first, IteratorT last)
+    {
+        return chseq<IteratorT>(first, last);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  strlit class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT = char const*>
+    class strlit : public parser<strlit<IteratorT> >
+    {
+    public:
+
+        typedef strlit<IteratorT> self_t;
+
+        strlit(IteratorT first, IteratorT last)
+        : seq(first, last) {}
+
+        strlit(IteratorT first)
+        : seq(first) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::contiguous_parser_parse<result_t>
+                (seq, scan, scan);
+        }
+
+    private:
+
+        chseq<IteratorT> seq;
+    };
+
+    template <typename CharT>
+    inline strlit<CharT const*>
+    str_p(CharT const* str)
+    {
+        return strlit<CharT const*>(str);
+    }
+
+    template <typename CharT>
+    inline strlit<CharT *>
+    str_p(CharT * str)
+    {
+        return strlit<CharT *>(str);
+    }
+
+    template <typename IteratorT>
+    inline strlit<IteratorT>
+    str_p(IteratorT first, IteratorT last)
+    {
+        return strlit<IteratorT>(first, last);
+    }
+
+    // This should take care of str_p('a') "bugs"
+    template <typename CharT>
+    inline chlit<CharT>
+    str_p(CharT ch)
+    {
+        return chlit<CharT>(ch);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  nothing_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct nothing_parser : public parser<nothing_parser>
+    {
+        typedef nothing_parser self_t;
+
+        nothing_parser() {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            return scan.no_match();
+        }
+    };
+
+    nothing_parser const nothing_p = nothing_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  anychar_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct anychar_parser : public char_parser<anychar_parser>
+    {
+        typedef anychar_parser self_t;
+
+        anychar_parser() {}
+
+        template <typename CharT>
+        bool test(CharT) const
+        {
+            return true;
+        }
+    };
+
+    anychar_parser const anychar_p = anychar_parser();
+
+    inline nothing_parser
+    operator~(anychar_parser)
+    {
+        return nothing_p;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  alnum_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct alnum_parser : public char_parser<alnum_parser>
+    {
+        typedef alnum_parser self_t;
+
+        alnum_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isalnum_(ch);
+        }
+    };
+
+    alnum_parser const alnum_p = alnum_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  alpha_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct alpha_parser : public char_parser<alpha_parser>
+    {
+        typedef alpha_parser self_t;
+
+        alpha_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isalpha_(ch);
+        }
+    };
+
+    alpha_parser const alpha_p = alpha_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  cntrl_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct cntrl_parser : public char_parser<cntrl_parser>
+    {
+        typedef cntrl_parser self_t;
+
+        cntrl_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::iscntrl_(ch);
+        }
+    };
+
+    cntrl_parser const cntrl_p = cntrl_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  digit_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct digit_parser : public char_parser<digit_parser>
+    {
+        typedef digit_parser self_t;
+
+        digit_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isdigit_(ch);
+        }
+    };
+
+    digit_parser const digit_p = digit_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  graph_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct graph_parser : public char_parser<graph_parser>
+    {
+        typedef graph_parser self_t;
+
+        graph_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isgraph_(ch);
+        }
+    };
+
+    graph_parser const graph_p = graph_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  lower_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct lower_parser : public char_parser<lower_parser>
+    {
+        typedef lower_parser self_t;
+
+        lower_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::islower_(ch);
+        }
+    };
+
+    lower_parser const lower_p = lower_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  print_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct print_parser : public char_parser<print_parser>
+    {
+        typedef print_parser self_t;
+
+        print_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isprint_(ch);
+        }
+    };
+
+    print_parser const print_p = print_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  punct_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct punct_parser : public char_parser<punct_parser>
+    {
+        typedef punct_parser self_t;
+
+        punct_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::ispunct_(ch);
+        }
+    };
+
+    punct_parser const punct_p = punct_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  blank_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct blank_parser : public char_parser<blank_parser>
+    {
+        typedef blank_parser self_t;
+
+        blank_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isblank_(ch);
+        }
+    };
+
+    blank_parser const blank_p = blank_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  space_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct space_parser : public char_parser<space_parser>
+    {
+        typedef space_parser self_t;
+
+        space_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isspace_(ch);
+        }
+    };
+
+    space_parser const space_p = space_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  upper_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct upper_parser : public char_parser<upper_parser>
+    {
+        typedef upper_parser self_t;
+
+        upper_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isupper_(ch);
+        }
+    };
+
+    upper_parser const upper_p = upper_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  xdigit_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct xdigit_parser : public char_parser<xdigit_parser>
+    {
+        typedef xdigit_parser self_t;
+
+        xdigit_parser() {}
+
+        template <typename CharT>
+        bool test(CharT ch) const
+        {
+            return impl::isxdigit_(ch);
+        }
+    };
+
+    xdigit_parser const xdigit_p = xdigit_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  eol_parser class (contributed by Martin Wille)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct eol_parser : public parser<eol_parser>
+    {
+        typedef eol_parser self_t;
+
+        eol_parser() {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typename ScannerT::iterator_t save = scan.first;
+            std::size_t len = 0;
+
+            if (!scan.at_end() && *scan == '\r')    // CR
+            {
+                ++scan.first;
+                ++len;
+            }
+
+            // Don't call skipper here
+            if (scan.first != scan.last && *scan == '\n')    // LF
+            {
+                ++scan.first;
+                ++len;
+            }
+
+            if (len)
+                return scan.create_match(len, nil_t(), save, scan.first);
+            return scan.no_match();
+        }
+    };
+
+    eol_parser const eol_p = eol_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  end_parser class (suggested by Markus Schoepflin)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct end_parser : public parser<end_parser>
+    {
+        typedef end_parser self_t;
+
+        end_parser() {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            if (scan.at_end())
+                return scan.empty_match();
+            return scan.no_match();
+        }
+    };
+
+    end_parser const end_p = end_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  the pizza_p parser :-)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    inline strlit<char const*> const
+    pizza_p(char const* your_favorite_pizza)
+    {
+        return your_favorite_pizza;
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#ifdef BOOST_MSVC
+#pragma warning (pop)
+#endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/impl/primitives.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/impl/primitives.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/impl/primitives.ipp	(working copy)
@@ -0,0 +1,476 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PRIMITIVES_IPP)
+#define BOOST_SPIRIT_PRIMITIVES_IPP
+
+// This should eventually go to a config file.
+#if defined(__GNUC__) && (__GNUC__ < 3) && !defined(_STLPORT_VERSION)
+#  ifndef BOOST_SPIRIT_NO_CHAR_TRAITS
+#    define BOOST_SPIRIT_NO_CHAR_TRAITS
+#  endif
+#endif
+
+#include <cctype>
+#if !defined(BOOST_NO_CWCTYPE)
+#include <cwctype>
+#endif
+
+#ifndef BOOST_SPIRIT_NO_CHAR_TRAITS
+#  include <string> // char_traits
+#endif
+
+#if defined(BOOST_MSVC)
+#  pragma warning (push)
+#  pragma warning(disable:4800)
+#endif
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename DrivedT> struct char_parser;
+
+    namespace impl
+    {
+        template <typename IteratorT>
+        inline IteratorT
+        get_last(IteratorT first)
+        {
+            while (*first)
+                first++;
+            return first;
+        }
+
+        template<
+            typename RT,
+            typename IteratorT,
+            typename ScannerT>
+        inline RT
+        string_parser_parse(
+            IteratorT str_first,
+            IteratorT str_last,
+            ScannerT& scan)
+        {
+            typedef typename ScannerT::iterator_t iterator_t;
+            iterator_t saved = scan.first;
+            std::size_t slen = str_last - str_first;
+
+            while (str_first != str_last)
+            {
+                if (scan.at_end() || (*str_first != *scan))
+                    return scan.no_match();
+                ++str_first;
+                ++scan;
+            }
+
+            return scan.create_match(slen, nil_t(), saved, scan.first);
+        }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    // Conversion from char_type to int_type
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+#ifndef BOOST_SPIRIT_NO_CHAR_TRAITS
+#  define BOOST_SPIRIT_CHAR_TRAITS_NAMESPACE std
+#else
+
+        template <typename CharT>
+        struct char_traits
+        {
+            typedef CharT int_type;
+            typedef CharT char_type;
+        };
+
+        template<>
+        struct char_traits<char>
+        {
+            typedef int int_type;
+            typedef char char_type;
+
+            static char_type
+            to_char_type(int_type c)
+            {
+                return static_cast<char_type>(c);
+            }
+
+            static int
+            to_int_type(char c)
+            {
+                return static_cast<unsigned char>(c);
+            }
+        };
+
+        template<>
+        struct char_traits<unsigned char>
+        {
+            typedef int int_type;
+            typedef unsigned char char_type;
+
+            static char_type
+            to_char_type(int_type c)
+            {
+                return static_cast<char_type>(c);
+            }
+
+            static int
+            to_int_type(unsigned char c)
+            {
+                return c;
+            }
+        };
+
+#  define BOOST_SPIRIT_CHAR_TRAITS_NAMESPACE impl
+#  ifndef BOOST_NO_CWCTYPE
+
+        template<>
+        struct char_traits<wchar_t>
+        {
+            typedef wint_t int_type;
+            typedef wchar_t char_type;
+
+            static char_type
+            to_char_type(int_type c)
+            {
+                return static_cast<char_type>(c);
+            }
+
+            static wint_t
+            to_int_type(wchar_t c)
+            {
+                return c;
+            }
+        };
+
+#  endif
+#endif // BOOST_SPIRIT_NO_CHAR_TRAITS
+
+        //  Use char_traits for char and wchar_t only, as these are the only
+        //  specializations provided in the standard. Other types are on their
+        //  own.
+        //
+        //  For UDT, one may override:
+        //
+        //      isalnum
+        //      isalpha
+        //      iscntrl
+        //      isdigit
+        //      isgraph
+        //      islower
+        //      isprint
+        //      ispunct
+        //      isspace
+        //      isupper
+        //      isxdigit
+        //      isblank
+        //      isupper
+        //      tolower
+        //      toupper
+        //
+        //  in a namespace suitable for Argument Dependent lookup or in
+        //  namespace std (disallowed by the standard).
+
+        template <typename CharT>
+        struct char_type_char_traits_helper
+        {
+            typedef CharT char_type;
+            typedef typename BOOST_SPIRIT_CHAR_TRAITS_NAMESPACE
+                ::char_traits<CharT>::int_type int_type;
+
+            static int_type to_int_type(CharT c)
+            {
+                return BOOST_SPIRIT_CHAR_TRAITS_NAMESPACE
+                    ::char_traits<CharT>::to_int_type(c);
+            }
+
+            static char_type to_char_type(int_type i)
+            {
+                return BOOST_SPIRIT_CHAR_TRAITS_NAMESPACE
+                    ::char_traits<CharT>::to_char_type(i);
+            }
+        };
+
+        template <typename CharT>
+        struct char_traits_helper
+        {
+            typedef CharT char_type;
+            typedef CharT int_type;
+
+            static CharT & to_int_type(CharT & c)
+            {
+                return c;
+            }
+
+            static CharT & to_char_type(CharT & c)
+            {
+                return c;
+            }
+        };
+
+        template <>
+        struct char_traits_helper<char>
+            : char_type_char_traits_helper<char>
+        {
+        };
+
+#if !defined(BOOST_NO_CWCTYPE)
+
+        template <>
+        struct char_traits_helper<wchar_t>
+            : char_type_char_traits_helper<wchar_t>
+        {
+        };
+
+#endif
+
+        template <typename CharT>
+        inline typename char_traits_helper<CharT>::int_type
+        to_int_type(CharT c)
+        {
+            return char_traits_helper<CharT>::to_int_type(c);
+        }
+
+        template <typename CharT>
+        inline CharT
+        to_char_type(typename char_traits_helper<CharT>::int_type c)
+        {
+            return char_traits_helper<CharT>::to_char_type(c);
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  Convenience functions
+        //
+        ///////////////////////////////////////////////////////////////////////
+
+        template <typename CharT>
+        inline bool
+        isalnum_(CharT c)
+        {
+            using namespace std;
+            return isalnum(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isalpha_(CharT c)
+        {
+            using namespace std;
+            return isalpha(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        iscntrl_(CharT c)
+        {
+            using namespace std;
+            return iscntrl(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isdigit_(CharT c)
+        {
+            using namespace std;
+            return isdigit(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isgraph_(CharT c)
+        {
+            using namespace std;
+            return isgraph(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        islower_(CharT c)
+        {
+            using namespace std;
+            return islower(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isprint_(CharT c)
+        {
+            using namespace std;
+            return isprint(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        ispunct_(CharT c)
+        {
+            using namespace std;
+            return ispunct(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isspace_(CharT c)
+        {
+            using namespace std;
+            return isspace(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isupper_(CharT c)
+        {
+            using namespace std;
+            return isupper(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isxdigit_(CharT c)
+        {
+            using namespace std;
+            return isxdigit(to_int_type(c)) ? true : false;
+        }
+
+        template <typename CharT>
+        inline bool
+        isblank_(CharT c)
+        {
+            return (c == ' ' || c == '\t');
+        }
+
+        template <typename CharT>
+        inline CharT
+        tolower_(CharT c)
+        {
+            using namespace std;
+            return to_char_type<CharT>(tolower(to_int_type(c)));
+        }
+
+        template <typename CharT>
+        inline CharT
+        toupper_(CharT c)
+        {
+            using namespace std;
+            return to_char_type<CharT>(toupper(to_int_type(c)));
+        }
+
+#if !defined(BOOST_NO_CWCTYPE)
+
+        inline bool
+        isalnum_(wchar_t c)
+        {
+            using namespace std;
+            return iswalnum(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isalpha_(wchar_t c)
+        {
+            using namespace std;
+            return iswalpha(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        iscntrl_(wchar_t c)
+        {
+            using namespace std;
+            return iswcntrl(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isdigit_(wchar_t c)
+        {
+            using namespace std;
+            return iswdigit(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isgraph_(wchar_t c)
+        {
+            using namespace std;
+            return iswgraph(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        islower_(wchar_t c)
+        {
+            using namespace std;
+            return iswlower(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isprint_(wchar_t c)
+        {
+            using namespace std;
+            return iswprint(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        ispunct_(wchar_t c)
+        {
+            using namespace std;
+            return iswpunct(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isspace_(wchar_t c)
+        {
+            using namespace std;
+            return iswspace(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isupper_(wchar_t c)
+        {
+            using namespace std;
+            return iswupper(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isxdigit_(wchar_t c)
+        {
+            using namespace std;
+            return iswxdigit(to_int_type(c)) ? true : false;
+        }
+
+        inline bool
+        isblank_(wchar_t c)
+        {
+            return (c == L' ' || c == L'\t');
+        }
+
+        inline wchar_t
+        tolower_(wchar_t c)
+        {
+            using namespace std;
+            return to_char_type<wchar_t>(towlower(to_int_type(c)));
+        }
+
+        inline wchar_t
+        toupper_(wchar_t c)
+        {
+            using namespace std;
+            return to_char_type<wchar_t>(towupper(to_int_type(c)));
+        }
+
+#endif // !defined(BOOST_NO_CWCTYPE)
+
+}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit::impl
+
+#ifdef BOOST_MSVC
+#pragma warning (pop)
+#endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/impl/numerics.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/impl/numerics.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/impl/numerics.ipp	(working copy)
@@ -0,0 +1,478 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_NUMERICS_IPP
+#define BOOST_SPIRIT_NUMERICS_IPP
+
+#include <boost/config/no_tr1/cmath.hpp>
+#include <limits>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    struct sign_parser; // forward declaration only
+
+    namespace impl
+    {
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  Extract the prefix sign (- or +)
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <typename ScannerT>
+        bool
+        extract_sign(ScannerT const& scan, std::size_t& count)
+        {
+            //  Extract the sign
+            count = 0;
+            bool neg = *scan == '-';
+            if (neg || (*scan == '+'))
+            {
+                ++scan;
+                ++count;
+                return neg;
+            }
+
+            return false;
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  Traits class for radix specific number conversion
+        //
+        //      Convert a digit from character representation, ch, to binary
+        //      representation, returned in val.
+        //      Returns whether the conversion was successful.
+        //
+        //        template<typename CharT> static bool digit(CharT ch, T& val);
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template<const int Radix>
+        struct radix_traits;
+
+        ////////////////////////////////// Binary
+        template<>
+        struct radix_traits<2>
+        {
+            template<typename CharT, typename T>
+            static bool digit(CharT ch, T& val)
+            {
+                val = ch - '0';
+                return ('0' == ch || '1' == ch);
+            }
+        };
+
+        ////////////////////////////////// Octal
+        template<>
+        struct radix_traits<8>
+        {
+            template<typename CharT, typename T>
+            static bool digit(CharT ch, T& val)
+            {
+                val = ch - '0';
+                return ('0' <= ch && ch <= '7');
+            }
+        };
+
+        ////////////////////////////////// Decimal
+        template<>
+        struct radix_traits<10>
+        {
+            template<typename CharT, typename T>
+            static bool digit(CharT ch, T& val)
+            {
+                val = ch - '0';
+                return impl::isdigit_(ch);
+            }
+        };
+
+        ////////////////////////////////// Hexadecimal
+        template<>
+        struct radix_traits<16>
+        {
+            template<typename CharT, typename T>
+            static bool digit(CharT ch, T& val)
+            {
+                if (radix_traits<10>::digit(ch, val))
+                    return true;
+
+                CharT lc = impl::tolower_(ch);
+                if ('a' <= lc && lc <= 'f')
+                {
+                    val = lc - 'a' + 10;
+                    return true;
+                }
+                return false;
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //      Helper templates for encapsulation of radix specific
+        //      conversion of an input string to an integral value.
+        //
+        //      main entry point:
+        //
+        //          extract_int<Radix, MinDigits, MaxDigits, Accumulate>
+        //              ::f(first, last, n, count);
+        //
+        //          The template parameter Radix represents the radix of the
+        //          number contained in the parsed string. The template
+        //          parameter MinDigits specifies the minimum digits to
+        //          accept. The template parameter MaxDigits specifies the
+        //          maximum digits to parse. A -1 value for MaxDigits will
+        //          make it parse an arbitrarilly large number as long as the
+        //          numeric type can hold it. Accumulate is either
+        //          positive_accumulate<Radix> (default) for parsing positive
+        //          numbers or negative_accumulate<Radix> otherwise.
+        //          Checking is only performed when std::numeric_limits<T>::
+        //          is_specialized is true. Otherwise, there's no way to
+        //          do the check.
+        //
+        //          scan.first and scan.last are iterators as usual (i.e.
+        //          first is mutable and is moved forward when a match is
+        //          found), n is a variable that holds the number (passed by
+        //          reference). The number of parsed characters is added to
+        //          count (also passed by reference)
+        //
+        //      NOTE:
+        //              Returns a non-match, if the number to parse
+        //              overflows (or underflows) the used type.
+        //
+        //      BEWARE:
+        //              the parameters 'n' and 'count' should be properly
+        //              initialized before calling this function.
+        //
+        ///////////////////////////////////////////////////////////////////////
+#if defined(BOOST_MSVC)
+#pragma warning(push)
+#pragma warning(disable:4127) //conditional expression is constant
+#endif
+
+        template <typename T, int Radix>
+        struct positive_accumulate
+        {
+            //  Use this accumulator if number is positive
+            static bool add(T& n, T digit)
+            {
+                if (std::numeric_limits<T>::is_specialized)
+                {
+                    static T const max = (std::numeric_limits<T>::max)();
+                    static T const max_div_radix = max/Radix;
+
+                    if (n > max_div_radix)
+                        return false;
+                    n *= Radix;
+
+                    if (n > max - digit)
+                        return false;
+                    n += digit;
+
+                    return true;
+                }
+                else
+                {
+                    n *= Radix;
+                    n += digit;
+                    return true;
+                }
+            }
+        };
+
+        template <typename T, int Radix>
+        struct negative_accumulate
+        {
+            //  Use this accumulator if number is negative
+            static bool add(T& n, T digit)
+            {
+                if (std::numeric_limits<T>::is_specialized)
+                {
+                    typedef std::numeric_limits<T> num_limits;
+                    static T const min =
+                        (!num_limits::is_integer && num_limits::is_signed && num_limits::has_denorm) ?
+                        -(num_limits::max)() : (num_limits::min)();
+                    static T const min_div_radix = min/Radix;
+
+                    if (n < min_div_radix)
+                        return false;
+                    n *= Radix;
+
+                    if (n < min + digit)
+                        return false;
+                    n -= digit;
+
+                    return true;
+                }
+                else
+                {
+                    n *= Radix;
+                    n -= digit;
+                    return true;
+                }
+            }
+        };
+
+        template <int MaxDigits>
+        inline bool allow_more_digits(std::size_t i)
+        {
+            return i < MaxDigits;
+        }
+
+        template <>
+        inline bool allow_more_digits<-1>(std::size_t)
+        {
+            return true;
+        }
+
+        //////////////////////////////////
+        template <
+            int Radix, unsigned MinDigits, int MaxDigits,
+            typename Accumulate
+        >
+        struct extract_int
+        {
+            template <typename ScannerT, typename T>
+            static bool
+            f(ScannerT& scan, T& n, std::size_t& count)
+            {
+                std::size_t i = 0;
+                T digit;
+                while( allow_more_digits<MaxDigits>(i) && !scan.at_end() &&
+                    radix_traits<Radix>::digit(*scan, digit) )
+                {
+                    if (!Accumulate::add(n, digit))
+                        return false; // Overflow
+                    ++i, ++scan, ++count;
+                }
+                return i >= MinDigits;
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  uint_parser_impl class
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <
+            typename T = unsigned,
+            int Radix = 10,
+            unsigned MinDigits = 1,
+            int MaxDigits = -1
+        >
+        struct uint_parser_impl
+            : parser<uint_parser_impl<T, Radix, MinDigits, MaxDigits> >
+        {
+            typedef uint_parser_impl<T, Radix, MinDigits, MaxDigits> self_t;
+
+            template <typename ScannerT>
+            struct result
+            {
+                typedef typename match_result<ScannerT, T>::type type;
+            };
+
+            template <typename ScannerT>
+            typename parser_result<self_t, ScannerT>::type
+            parse(ScannerT const& scan) const
+            {
+                if (!scan.at_end())
+                {
+                    T n = 0;
+                    std::size_t count = 0;
+                    typename ScannerT::iterator_t save = scan.first;
+                    if (extract_int<Radix, MinDigits, MaxDigits,
+                        positive_accumulate<T, Radix> >::f(scan, n, count))
+                    {
+                        return scan.create_match(count, n, save, scan.first);
+                    }
+                    // return no-match if number overflows
+                }
+                return scan.no_match();
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  int_parser_impl class
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <
+            typename T = unsigned,
+            int Radix = 10,
+            unsigned MinDigits = 1,
+            int MaxDigits = -1
+        >
+        struct int_parser_impl
+            : parser<int_parser_impl<T, Radix, MinDigits, MaxDigits> >
+        {
+            typedef int_parser_impl<T, Radix, MinDigits, MaxDigits> self_t;
+
+            template <typename ScannerT>
+            struct result
+            {
+                typedef typename match_result<ScannerT, T>::type type;
+            };
+
+            template <typename ScannerT>
+            typename parser_result<self_t, ScannerT>::type
+            parse(ScannerT const& scan) const
+            {
+                typedef extract_int<Radix, MinDigits, MaxDigits,
+                    negative_accumulate<T, Radix> > extract_int_neg_t;
+                typedef extract_int<Radix, MinDigits, MaxDigits,
+                    positive_accumulate<T, Radix> > extract_int_pos_t;
+
+                if (!scan.at_end())
+                {
+                    T n = 0;
+                    std::size_t count = 0;
+                    typename ScannerT::iterator_t save = scan.first;
+
+                    bool hit = impl::extract_sign(scan, count);
+
+                    if (hit)
+                        hit = extract_int_neg_t::f(scan, n, count);
+                    else
+                        hit = extract_int_pos_t::f(scan, n, count);
+
+                    if (hit)
+                        return scan.create_match(count, n, save, scan.first);
+                    else
+                        scan.first = save;
+                    // return no-match if number overflows or underflows
+                }
+                return scan.no_match();
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  real_parser_impl class
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <typename RT, typename T, typename RealPoliciesT>
+        struct real_parser_impl
+        {
+            typedef real_parser_impl<RT, T, RealPoliciesT> self_t;
+
+            template <typename ScannerT>
+            RT parse_main(ScannerT const& scan) const
+            {
+                if (scan.at_end())
+                    return scan.no_match();
+                typename ScannerT::iterator_t save = scan.first;
+
+                typedef typename parser_result<sign_parser, ScannerT>::type
+                    sign_match_t;
+                typedef typename parser_result<chlit<>, ScannerT>::type
+                    exp_match_t;
+
+                sign_match_t    sign_match = RealPoliciesT::parse_sign(scan);
+                std::size_t     count = sign_match ? sign_match.length() : 0;
+                bool            neg = sign_match.has_valid_attribute() ?
+                                    sign_match.value() : false;
+
+                RT              n_match = RealPoliciesT::parse_n(scan);
+                T               n = n_match.has_valid_attribute() ?
+                                    n_match.value() : T(0);
+                bool            got_a_number = n_match;
+                exp_match_t     e_hit;
+
+                if (!got_a_number && !RealPoliciesT::allow_leading_dot)
+                     return scan.no_match();
+                else
+                    count += n_match.length();
+
+                if (neg)
+                    n = -n;
+
+                if (RealPoliciesT::parse_dot(scan))
+                {
+                    //  We got the decimal point. Now we will try to parse
+                    //  the fraction if it is there. If not, it defaults
+                    //  to zero (0) only if we already got a number.
+
+                    if (RT hit = RealPoliciesT::parse_frac_n(scan))
+                    {
+#if !defined(BOOST_NO_STDC_NAMESPACE)
+                        using namespace std;  // allow for ADL to find pow()
+#endif
+                        hit.value(hit.value()
+                            * pow(T(10), T(-hit.length())));
+                        if (neg)
+                            n -= hit.value();
+                        else
+                            n += hit.value();
+                        count += hit.length() + 1;
+
+                    }
+
+                    else if (!got_a_number ||
+                        !RealPoliciesT::allow_trailing_dot)
+                        return scan.no_match();
+
+                    e_hit = RealPoliciesT::parse_exp(scan);
+                }
+                else
+                {
+                    //  We have reached a point where we
+                    //  still haven't seen a number at all.
+                    //  We return early with a no-match.
+                    if (!got_a_number)
+                        return scan.no_match();
+
+                    //  If we must expect a dot and we didn't see
+                    //  an exponent, return early with a no-match.
+                    e_hit = RealPoliciesT::parse_exp(scan);
+                    if (RealPoliciesT::expect_dot && !e_hit)
+                        return scan.no_match();
+                }
+
+                if (e_hit)
+                {
+                    //  We got the exponent prefix. Now we will try to parse the
+                    //  actual exponent. It is an error if it is not there.
+                    if (RT e_n_hit = RealPoliciesT::parse_exp_n(scan))
+                    {
+#if !defined(BOOST_NO_STDC_NAMESPACE)
+                        using namespace std;    // allow for ADL to find pow()
+#endif
+                        n *= pow(T(10), T(e_n_hit.value()));
+                        count += e_n_hit.length() + e_hit.length();
+                    }
+                    else
+                    {
+                        //  Oops, no exponent, return a no-match
+                        return scan.no_match();
+                    }
+                }
+
+                return scan.create_match(count, n, save, scan.first);
+            }
+
+            template <typename ScannerT>
+            static RT parse(ScannerT const& scan)
+            {
+                static self_t this_;
+                return impl::implicit_lexeme_parse<RT>(this_, scan, scan);
+            }
+        };
+
+#if defined(BOOST_MSVC)
+#pragma warning(pop)
+#endif
+
+    }   //  namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/numerics_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/numerics_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/numerics_fwd.hpp	(working copy)
@@ -0,0 +1,88 @@
+/*=============================================================================
+    Copyright (C) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_NUMERICS_FWD_HPP)
+#   define BOOST_SPIRIT_NUMERICS_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  uint_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T = unsigned,
+        int Radix = 10,
+        unsigned MinDigits = 1,
+        int MaxDigits = -1
+    >
+    struct uint_parser;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  int_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T = unsigned,
+        int Radix = 10,
+        unsigned MinDigits = 1,
+        int MaxDigits = -1
+    >
+    struct int_parser;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sign_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct sign_parser;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  default real number policies
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T>
+    struct ureal_parser_policies;
+
+    template <typename T>
+    struct real_parser_policies;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  real_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T = double,
+        typename RealPoliciesT = ureal_parser_policies<T>
+    >
+    struct real_parser;
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  strict reals (do not allow plain integers (no decimal point))
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T>
+    struct strict_ureal_parser_policies;
+
+    template <typename T>
+    struct strict_real_parser_policies;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/numerics.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/numerics.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/primitives/numerics.hpp	(working copy)
@@ -0,0 +1,289 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_NUMERICS_HPP
+#define BOOST_SPIRIT_NUMERICS_HPP
+
+#include <boost/config.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/directives.hpp>
+
+#include <boost/spirit/home/classic/core/primitives/numerics_fwd.hpp>
+#include <boost/spirit/home/classic/core/primitives/impl/numerics.ipp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  uint_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T,
+        int Radix,
+        unsigned MinDigits,
+        int MaxDigits
+    >
+    struct uint_parser : parser<uint_parser<T, Radix, MinDigits, MaxDigits> >
+    {
+        typedef uint_parser<T, Radix, MinDigits, MaxDigits> self_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, T>::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef impl::uint_parser_impl<T, Radix, MinDigits, MaxDigits> impl_t;
+            typedef typename parser_result<impl_t, ScannerT>::type result_t;
+            return impl::contiguous_parser_parse<result_t>(impl_t(), scan, scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  int_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T,
+        int Radix,
+        unsigned MinDigits,
+        int MaxDigits
+    >
+    struct int_parser : parser<int_parser<T, Radix, MinDigits, MaxDigits> >
+    {
+        typedef int_parser<T, Radix, MinDigits, MaxDigits> self_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, T>::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef impl::int_parser_impl<T, Radix, MinDigits, MaxDigits> impl_t;
+            typedef typename parser_result<impl_t, ScannerT>::type result_t;
+            return impl::contiguous_parser_parse<result_t>(impl_t(), scan, scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  uint_parser/int_parser instantiations
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    int_parser<int> const
+        int_p   = int_parser<int>();
+
+    uint_parser<unsigned> const
+        uint_p  = uint_parser<unsigned>();
+
+    uint_parser<unsigned, 2> const
+        bin_p   = uint_parser<unsigned, 2>();
+
+    uint_parser<unsigned, 8> const
+        oct_p   = uint_parser<unsigned, 8>();
+
+    uint_parser<unsigned, 16> const
+        hex_p   = uint_parser<unsigned, 16>();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sign_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    namespace impl
+    {
+        //  Utility to extract the prefix sign ('-' | '+')
+        template <typename ScannerT>
+        bool extract_sign(ScannerT const& scan, std::size_t& count);
+    }
+
+    struct sign_parser : public parser<sign_parser>
+    {
+        typedef sign_parser self_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, bool>::type type;
+        };
+
+        sign_parser() {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            if (!scan.at_end())
+            {
+                std::size_t length;
+                typename ScannerT::iterator_t save(scan.first);
+                bool neg = impl::extract_sign(scan, length);
+                if (length)
+                    return scan.create_match(1, neg, save, scan.first);
+            }
+            return scan.no_match();
+        }
+    };
+
+    sign_parser const sign_p = sign_parser();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  default real number policies
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T>
+    struct ureal_parser_policies
+    {
+        // trailing dot policy suggested suggested by Gustavo Guerra
+        BOOST_STATIC_CONSTANT(bool, allow_leading_dot = true);
+        BOOST_STATIC_CONSTANT(bool, allow_trailing_dot = true);
+        BOOST_STATIC_CONSTANT(bool, expect_dot = false);
+
+        typedef uint_parser<T, 10, 1, -1>   uint_parser_t;
+        typedef int_parser<T, 10, 1, -1>    int_parser_t;
+
+        template <typename ScannerT>
+        static typename match_result<ScannerT, nil_t>::type
+        parse_sign(ScannerT& scan)
+        {
+            return scan.no_match();
+        }
+
+        template <typename ScannerT>
+        static typename parser_result<uint_parser_t, ScannerT>::type
+        parse_n(ScannerT& scan)
+        {
+            return uint_parser_t().parse(scan);
+        }
+
+        template <typename ScannerT>
+        static typename parser_result<chlit<>, ScannerT>::type
+        parse_dot(ScannerT& scan)
+        {
+            return ch_p('.').parse(scan);
+        }
+
+        template <typename ScannerT>
+        static typename parser_result<uint_parser_t, ScannerT>::type
+        parse_frac_n(ScannerT& scan)
+        {
+            return uint_parser_t().parse(scan);
+        }
+
+        template <typename ScannerT>
+        static typename parser_result<chlit<>, ScannerT>::type
+        parse_exp(ScannerT& scan)
+        {
+            return as_lower_d['e'].parse(scan);
+        }
+
+        template <typename ScannerT>
+        static typename parser_result<int_parser_t, ScannerT>::type
+        parse_exp_n(ScannerT& scan)
+        {
+            return int_parser_t().parse(scan);
+        }
+    };
+
+    template <typename T>
+    struct real_parser_policies : public ureal_parser_policies<T>
+    {
+        template <typename ScannerT>
+        static typename parser_result<sign_parser, ScannerT>::type
+        parse_sign(ScannerT& scan)
+        {
+            return sign_p.parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  real_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename T,
+        typename RealPoliciesT
+    >
+    struct real_parser
+    :   public parser<real_parser<T, RealPoliciesT> >
+    {
+        typedef real_parser<T, RealPoliciesT> self_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, T>::type type;
+        };
+
+        real_parser() {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::real_parser_impl<result_t, T, RealPoliciesT>::parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  real_parser instantiations
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    real_parser<double, ureal_parser_policies<double> > const
+        ureal_p     = real_parser<double, ureal_parser_policies<double> >();
+
+    real_parser<double, real_parser_policies<double> > const
+        real_p      = real_parser<double, real_parser_policies<double> >();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  strict reals (do not allow plain integers (no decimal point))
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T>
+    struct strict_ureal_parser_policies : public ureal_parser_policies<T>
+    {
+        BOOST_STATIC_CONSTANT(bool, expect_dot = true);
+    };
+
+    template <typename T>
+    struct strict_real_parser_policies : public real_parser_policies<T>
+    {
+        BOOST_STATIC_CONSTANT(bool, expect_dot = true);
+    };
+
+    real_parser<double, strict_ureal_parser_policies<double> > const
+        strict_ureal_p
+            = real_parser<double, strict_ureal_parser_policies<double> >();
+
+    real_parser<double, strict_real_parser_policies<double> > const
+        strict_real_p
+            = real_parser<double, strict_real_parser_policies<double> >();
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/config.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/config.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/config.hpp	(working copy)
@@ -0,0 +1,62 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_CONFIG_HPP)
+#define BOOST_SPIRIT_CONFIG_HPP
+
+#include <boost/config.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Compiler check:
+//
+//  Historically, Spirit supported a lot of compilers, including (to some
+//  extent) poorly conforming compilers such as VC6. Spirit v1.6.x will be
+//  the last release that will support older poorly conforming compilers.
+//  Starting from Spirit v1.8.0, ill conforming compilers will not be
+//  supported. If you are still using one of these older compilers, you can
+//  still use Spirit v1.6.x.
+//
+//  The reason why Spirit v1.6.x worked on old non-conforming compilers is
+//  that the authors laboriously took the trouble of searching for
+//  workarounds to make these compilers happy. The process takes a lot of
+//  time and energy, especially when one encounters the dreaded ICE or
+//  "Internal Compiler Error". Sometimes searching for a single workaround
+//  takes days or even weeks. Sometimes, there are no known workarounds. This
+//  stifles progress a lot. And, as the library gets more progressive and
+//  takes on more advanced C++ techniques, the difficulty is escalated to
+//  even new heights.
+//
+//  Spirit v1.6.x will still be supported. Maintenance and bug fixes will
+//  still be applied. There will still be active development for the back-
+//  porting of new features introduced in Spirit v1.8.0 (and Spirit 1.9.0)
+//  to lesser able compilers; hopefully, fueled by contributions from the
+//  community. For instance, there is already a working AST tree back-port
+//  for VC6 and VC7 by Peder Holt.
+//
+//  If you got here somehow, your compiler is known to be poorly conforming
+//  WRT ANSI/ISO C++ standard. Library implementers get a bad reputation when
+//  someone attempts to compile the code on a non-conforming compiler. She'll
+//  be confronted with tons of compiler errors when she tries to compile the
+//  library. Such errors will somehow make less informed users conclude that
+//  the code is poorly written. It's better for the user to see a message
+//  "sorry, this code has not been ported to your compiler yet", than to see
+//  pages and pages of compiler error messages.
+//
+/////////////////////////////////////////////////////////////////////////////////
+#if     (defined(BOOST_MSVC) && (BOOST_MSVC < 1310))                            \
+    ||  (defined(__BORLANDC__) && (__BORLANDC__ <= 0x570))                      \
+    ||  (defined(__GNUC__) && (__GNUC__ < 3))                                   \
+    ||  (defined(__GNUC__) && (__GNUC__ == 3) && (__GNUC_MINOR__ < 1))
+# error "Compiler not supported. See note in <boost/spirit/core/config.hpp>"
+#else
+// Pass... Compiler supported.
+#endif
+
+#endif
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/parser.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/parser.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/parser.ipp	(working copy)
@@ -0,0 +1,55 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_PARSER_IPP)
+#define BOOST_SPIRIT_PARSER_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Generic parse function implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IteratorT, typename DerivedT>
+    inline parse_info<IteratorT>
+    parse(
+        IteratorT const& first_
+      , IteratorT const& last
+      , parser<DerivedT> const& p)
+    {
+        IteratorT first = first_;
+        scanner<IteratorT, scanner_policies<> > scan(first, last);
+        match<nil_t> hit = p.derived().parse(scan);
+        return parse_info<IteratorT>(
+            first, hit, hit && (first == last), hit.length());
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Parse function for null terminated strings implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT, typename DerivedT>
+    inline parse_info<CharT const*>
+    parse(CharT const* str, parser<DerivedT> const& p)
+    {
+        CharT const* last = str;
+        while (*last)
+            last++;
+        return parse(str, last, p);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/match_attr_traits.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/match_attr_traits.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/match_attr_traits.ipp	(working copy)
@@ -0,0 +1,102 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_MATCH_ATTR_TRAITS_IPP)
+#define BOOST_SPIRIT_MATCH_ATTR_TRAITS_IPP
+
+#include <boost/optional.hpp>
+#include <boost/mpl/bool.hpp>
+#include <boost/mpl/or.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+#include <boost/type_traits/is_same.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+namespace impl
+{
+    template <typename T>
+    struct match_attr_traits
+    {
+        typedef typename
+            boost::optional<T>::reference_const_type
+        const_reference;
+
+        //  case where src *IS* convertible to T (dest)
+        template <typename T2>
+        static void
+        convert(boost::optional<T>& dest, T2 const& src, mpl::true_)
+        {
+            dest.reset(src);
+        }
+
+        //  case where src *IS NOT* convertible to T (dest)
+        template <typename T2>
+        static void
+        convert(boost::optional<T>& dest, T2 const& /*src*/, mpl::false_)
+        {
+            dest.reset();
+        }
+
+        static void
+        convert(boost::optional<T>& dest, nil_t/*src*/)
+        {
+            dest.reset();
+        }
+
+        template <typename T2>
+        static void
+        convert(boost::optional<T>& dest, T2 const& src)
+        {
+            convert(dest, src, is_convertible<T2, T>());
+        }
+
+        template <typename OtherMatchT>
+        static void
+        copy(boost::optional<T>& dest, OtherMatchT const& src)
+        {
+            if (src.has_valid_attribute())
+                convert(dest, src.value());
+        }
+
+        template <typename OtherMatchT>
+        static void
+        assign(boost::optional<T>& dest, OtherMatchT const& src)
+        {
+            if (src.has_valid_attribute())
+                convert(dest, src.value());
+            else
+                dest.reset();
+        }
+
+        // T is not reference
+        template <typename ValueT>
+        static void
+        set_value(boost::optional<T>& dest, ValueT const& val, mpl::false_)
+        {
+            dest.reset(val);
+        }
+
+        // T is a reference
+        template <typename ValueT>
+        static void
+        set_value(boost::optional<T>& dest, ValueT const& val, mpl::true_)
+        {
+            dest.get() = val;
+        }
+    };
+
+}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit::impl
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/match.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/match.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/impl/match.ipp	(working copy)
@@ -0,0 +1,113 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_MATCH_IPP)
+#define BOOST_SPIRIT_MATCH_IPP
+#include <algorithm>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename T>
+    inline match<T>::match()
+    : len(-1), val() {}
+
+    template <typename T>
+    inline match<T>::match(std::size_t length_)
+    : len(length_), val() {}
+
+    template <typename T>
+    inline match<T>::match(std::size_t length_, ctor_param_t val_)
+    : len(length_), val(val_) {}
+
+    template <typename T>
+    inline bool
+    match<T>::operator!() const
+    {
+        return len < 0;
+    }
+
+    template <typename T>
+    inline std::ptrdiff_t
+    match<T>::length() const
+    {
+        return len;
+    }
+
+    template <typename T>
+    inline bool
+    match<T>::has_valid_attribute() const
+    {
+        return val.is_initialized();
+    }
+
+    template <typename T>
+    inline typename match<T>::return_t
+    match<T>::value() const
+    {
+        BOOST_SPIRIT_ASSERT(val.is_initialized());
+        return *val;
+    }
+
+    template <typename T>
+    inline void
+    match<T>::swap(match& other)
+    {
+        std::swap(len, other.len);
+        std::swap(val, other.val);
+    }
+
+    inline match<nil_t>::match()
+    : len(-1) {}
+
+    inline match<nil_t>::match(std::size_t length_)
+    : len(length_) {}
+
+    inline match<nil_t>::match(std::size_t length_, nil_t)
+    : len(length_) {}
+
+    inline bool
+    match<nil_t>::operator!() const
+    {
+        return len < 0;
+    }
+
+    inline bool
+    match<nil_t>::has_valid_attribute() const
+    {
+        return false;
+    }
+
+    inline std::ptrdiff_t
+    match<nil_t>::length() const
+    {
+        return len;
+    }
+
+    inline nil_t
+    match<nil_t>::value() const
+    {
+        return nil_t();
+    }
+
+    inline void
+    match<nil_t>::value(nil_t) {}
+
+    inline void
+    match<nil_t>::swap(match<nil_t>& other)
+    {
+        std::swap(len, other.len);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/kleene_star.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/kleene_star.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/kleene_star.hpp	(working copy)
@@ -0,0 +1,109 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_KLEENE_STAR_HPP)
+#define BOOST_SPIRIT_KLEENE_STAR_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  kleene_star class
+    //
+    //      Handles expressions of the form:
+    //
+    //          *a
+    //
+    //      where a is a parser. The expression returns a composite
+    //      parser that matches its subject zero (0) or more times.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct kleene_star_parser_gen;
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    template <typename S>
+    struct kleene_star
+    :   public unary<S, parser<kleene_star<S> > >
+    {
+        typedef kleene_star<S>              self_t;
+        typedef unary_parser_category       parser_category_t;
+        typedef kleene_star_parser_gen      parser_generator_t;
+        typedef unary<S, parser<self_t> >   base_t;
+
+        kleene_star(S const& a)
+        : base_t(a) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            result_t hit = scan.empty_match();
+
+            for (;;)
+            {
+                iterator_t save = scan.first;
+                if (result_t next = this->subject().parse(scan))
+                {
+                    scan.concat_match(hit, next);
+                }
+                else
+                {
+                    scan.first = save;
+                    return hit;
+                }
+            }
+        }
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+    struct kleene_star_parser_gen
+    {
+        template <typename S>
+        struct result
+        {
+            typedef kleene_star<S> type;
+        };
+
+        template <typename S>
+        static kleene_star<S>
+        generate(parser<S> const& a)
+        {
+            return kleene_star<S>(a.derived());
+        }
+    };
+
+    //////////////////////////////////
+    template <typename S>
+    kleene_star<S>
+    operator*(parser<S> const& a);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/kleene_star.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/no_actions.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/no_actions.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/no_actions.hpp	(working copy)
@@ -0,0 +1,165 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2003 Vaclav Vesely
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_NO_ACTIONS_HPP)
+#define BOOST_SPIRIT_NO_ACTIONS_HPP
+
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/rule.hpp>
+
+namespace boost {
+namespace spirit {
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+//-----------------------------------------------------------------------------
+// no_actions_action_policy
+
+template<typename BaseT = action_policy>
+struct no_actions_action_policy:
+    public BaseT
+{
+    typedef BaseT base_t;
+
+    no_actions_action_policy():
+        BaseT()
+    {}
+
+    template<typename PolicyT>
+    no_actions_action_policy(PolicyT const& other):
+        BaseT(other)
+    {}
+
+    template<typename ActorT, typename AttrT, typename IteratorT>
+    void
+    do_action(
+        ActorT const&       actor,
+        AttrT&              val,
+        IteratorT const&    first,
+        IteratorT const&    last) const
+    {}
+};
+
+//-----------------------------------------------------------------------------
+// no_actions_scanner
+
+
+namespace detail
+{
+    template <typename ActionPolicy>
+    struct compute_no_actions_action_policy
+    {
+        typedef no_actions_action_policy<ActionPolicy> type;
+    };
+
+    template <typename ActionPolicy>
+    struct compute_no_actions_action_policy<no_actions_action_policy<ActionPolicy> >
+    {
+        typedef no_actions_action_policy<ActionPolicy> type;
+    };
+}
+
+template<typename ScannerT = scanner<> >
+struct no_actions_scanner
+{
+    typedef scanner_policies<
+        typename ScannerT::iteration_policy_t,
+        typename ScannerT::match_policy_t,
+        typename detail::compute_no_actions_action_policy<typename ScannerT::action_policy_t>::type
+    > policies_t;
+
+    typedef typename
+        rebind_scanner_policies<ScannerT, policies_t>::type type;
+};
+
+#if BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+template<typename ScannerT = scanner<> >
+struct no_actions_scanner_list
+{
+    typedef
+        scanner_list<
+            ScannerT,
+            typename no_actions_scanner<ScannerT>::type
+        >
+            type;
+};
+
+#endif // BOOST_SPIRIT_RULE_SCANNERTYPE_LIMIT > 1
+
+//-----------------------------------------------------------------------------
+// no_actions_parser
+
+struct no_actions_parser_gen;
+
+template<typename ParserT>
+struct no_actions_parser:
+    public unary<ParserT, parser<no_actions_parser<ParserT> > >
+{
+    typedef no_actions_parser<ParserT>      self_t;
+    typedef unary_parser_category           parser_category_t;
+    typedef no_actions_parser_gen           parser_generator_t;
+    typedef unary<ParserT, parser<self_t> > base_t;
+
+    template<typename ScannerT>
+    struct result
+    {
+        typedef typename parser_result<ParserT, ScannerT>::type type;
+    };
+
+    no_actions_parser(ParserT const& p)
+    :   base_t(p)
+    {}
+
+    template<typename ScannerT>
+    typename result<ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        typedef typename no_actions_scanner<ScannerT>::policies_t policies_t;
+
+        return this->subject().parse(scan.change_policies(policies_t(scan)));
+    }
+};
+
+//-----------------------------------------------------------------------------
+// no_actions_parser_gen
+
+struct no_actions_parser_gen
+{
+    template<typename ParserT>
+    struct result
+    {
+        typedef no_actions_parser<ParserT> type;
+    };
+
+    template<typename ParserT>
+    static no_actions_parser<ParserT>
+    generate(parser<ParserT> const& subject)
+    {
+        return no_actions_parser<ParserT>(subject.derived());
+    }
+
+    template<typename ParserT>
+    no_actions_parser<ParserT>
+    operator[](parser<ParserT> const& subject) const
+    {
+        return no_actions_parser<ParserT>(subject.derived());
+    }
+};
+
+//-----------------------------------------------------------------------------
+// no_actions_d
+
+const no_actions_parser_gen no_actions_d = no_actions_parser_gen();
+
+//-----------------------------------------------------------------------------
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+} // namespace spirit
+} // namespace boost
+
+#endif // !defined(BOOST_SPIRIT_NO_ACTIONS_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/directives.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/directives.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/directives.hpp	(working copy)
@@ -0,0 +1,607 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DIRECTIVES_HPP)
+#define BOOST_SPIRIT_DIRECTIVES_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <algorithm>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/scanner/skipper.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/core/composite/impl/directives.ipp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  contiguous class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct lexeme_parser_gen;
+
+    template <typename ParserT>
+    struct contiguous
+    :   public unary<ParserT, parser<contiguous<ParserT> > >
+    {
+        typedef contiguous<ParserT>             self_t;
+        typedef unary_parser_category           parser_category_t;
+        typedef lexeme_parser_gen               parser_generator_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        contiguous(ParserT const& p)
+        : base_t(p) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::contiguous_parser_parse<result_t>
+                (this->subject(), scan, scan);
+        }
+    };
+
+    struct lexeme_parser_gen
+    {
+        template <typename ParserT>
+        struct result {
+
+            typedef contiguous<ParserT> type;
+        };
+
+        template <typename ParserT>
+        static contiguous<ParserT>
+        generate(parser<ParserT> const& subject)
+        {
+            return contiguous<ParserT>(subject.derived());
+        }
+
+        template <typename ParserT>
+        contiguous<ParserT>
+        operator[](parser<ParserT> const& subject) const
+        {
+            return contiguous<ParserT>(subject.derived());
+        }
+    };
+
+    //////////////////////////////////
+    const lexeme_parser_gen lexeme_d = lexeme_parser_gen();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  lexeme_scanner
+    //
+    //      Given a Scanner, return the correct scanner type that
+    //      the lexeme_d uses. Scanner is assumed to be a phrase
+    //      level scanner (see skipper.hpp)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ScannerT>
+    struct lexeme_scanner
+    {
+        typedef scanner_policies<
+            no_skipper_iteration_policy<
+                typename ScannerT::iteration_policy_t>,
+            typename ScannerT::match_policy_t,
+            typename ScannerT::action_policy_t
+        > policies_t;
+
+        typedef typename
+            rebind_scanner_policies<ScannerT, policies_t>::type type;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  inhibit_case_iteration_policy class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename BaseT>
+    struct inhibit_case_iteration_policy : public BaseT
+    {
+        typedef BaseT base_t;
+
+        inhibit_case_iteration_policy()
+        : BaseT() {}
+
+        template <typename PolicyT>
+        inhibit_case_iteration_policy(PolicyT const& other)
+        : BaseT(other) {}
+
+        template <typename CharT>
+        CharT filter(CharT ch) const
+        { return impl::tolower_(ch); }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  inhibit_case class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct inhibit_case_parser_gen;
+
+    template <typename ParserT>
+    struct inhibit_case
+    :   public unary<ParserT, parser<inhibit_case<ParserT> > >
+    {
+        typedef inhibit_case<ParserT>           self_t;
+        typedef unary_parser_category           parser_category_t;
+        typedef inhibit_case_parser_gen         parser_generator_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        inhibit_case(ParserT const& p)
+        : base_t(p) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::inhibit_case_parser_parse<result_t>
+                (this->subject(), scan, scan);
+        }
+    };
+
+    template <int N>
+    struct inhibit_case_parser_gen_base
+    {
+        //  This hack is needed to make borland happy.
+        //  If these member operators were defined in the
+        //  inhibit_case_parser_gen class, or if this class
+        //  is non-templated, borland ICEs.
+
+        static inhibit_case<strlit<char const*> >
+        generate(char const* str)
+        { return inhibit_case<strlit<char const*> >(str); }
+
+        static inhibit_case<strlit<wchar_t const*> >
+        generate(wchar_t const* str)
+        { return inhibit_case<strlit<wchar_t const*> >(str); }
+
+        static inhibit_case<chlit<char> >
+        generate(char ch)
+        { return inhibit_case<chlit<char> >(ch); }
+
+        static inhibit_case<chlit<wchar_t> >
+        generate(wchar_t ch)
+        { return inhibit_case<chlit<wchar_t> >(ch); }
+
+        template <typename ParserT>
+        static inhibit_case<ParserT>
+        generate(parser<ParserT> const& subject)
+        { return inhibit_case<ParserT>(subject.derived()); }
+
+        inhibit_case<strlit<char const*> >
+        operator[](char const* str) const
+        { return inhibit_case<strlit<char const*> >(str); }
+
+        inhibit_case<strlit<wchar_t const*> >
+        operator[](wchar_t const* str) const
+        { return inhibit_case<strlit<wchar_t const*> >(str); }
+
+        inhibit_case<chlit<char> >
+        operator[](char ch) const
+        { return inhibit_case<chlit<char> >(ch); }
+
+        inhibit_case<chlit<wchar_t> >
+        operator[](wchar_t ch) const
+        { return inhibit_case<chlit<wchar_t> >(ch); }
+
+        template <typename ParserT>
+        inhibit_case<ParserT>
+        operator[](parser<ParserT> const& subject) const
+        { return inhibit_case<ParserT>(subject.derived()); }
+    };
+
+    //////////////////////////////////
+    struct inhibit_case_parser_gen : public inhibit_case_parser_gen_base<0>
+    {
+        inhibit_case_parser_gen() {}
+    };
+
+    //////////////////////////////////
+    //  Depracated
+    const inhibit_case_parser_gen nocase_d = inhibit_case_parser_gen();
+
+    //  Preferred syntax
+    const inhibit_case_parser_gen as_lower_d = inhibit_case_parser_gen();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  as_lower_scanner
+    //
+    //      Given a Scanner, return the correct scanner type that
+    //      the as_lower_d uses. Scanner is assumed to be a scanner
+    //      with an inhibit_case_iteration_policy.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ScannerT>
+    struct as_lower_scanner
+    {
+        typedef scanner_policies<
+            inhibit_case_iteration_policy<
+                typename ScannerT::iteration_policy_t>,
+            typename ScannerT::match_policy_t,
+            typename ScannerT::action_policy_t
+        > policies_t;
+
+        typedef typename
+            rebind_scanner_policies<ScannerT, policies_t>::type type;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  longest_alternative class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct longest_parser_gen;
+
+    template <typename A, typename B>
+    struct longest_alternative
+    :   public binary<A, B, parser<longest_alternative<A, B> > >
+    {
+        typedef longest_alternative<A, B>       self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef longest_parser_gen              parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        longest_alternative(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typename ScannerT::iterator_t save = scan.first;
+            result_t l = this->left().parse(scan);
+            std::swap(scan.first, save);
+            result_t r = this->right().parse(scan);
+
+            if (l || r)
+            {
+                if (l.length() > r.length())
+                {
+                    scan.first = save;
+                    return l;
+                }
+                return r;
+            }
+
+            return scan.no_match();
+        }
+    };
+
+    struct longest_parser_gen
+    {
+        template <typename A, typename B>
+        struct result {
+
+            typedef typename
+                impl::to_longest_alternative<alternative<A, B> >::result_t
+            type;
+        };
+
+        template <typename A, typename B>
+        static typename
+        impl::to_longest_alternative<alternative<A, B> >::result_t
+        generate(alternative<A, B> const& alt)
+        {
+            return impl::to_longest_alternative<alternative<A, B> >::
+                convert(alt);
+        }
+
+        //'generate' for binary composite
+        template <typename A, typename B>
+        static
+        longest_alternative<A, B>
+        generate(A const &left, B const &right)
+        {
+            return longest_alternative<A, B>(left, right);
+        }
+
+        template <typename A, typename B>
+        typename impl::to_longest_alternative<alternative<A, B> >::result_t
+        operator[](alternative<A, B> const& alt) const
+        {
+            return impl::to_longest_alternative<alternative<A, B> >::
+                convert(alt);
+        }
+    };
+
+    const longest_parser_gen longest_d = longest_parser_gen();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  shortest_alternative class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct shortest_parser_gen;
+
+    template <typename A, typename B>
+    struct shortest_alternative
+    :   public binary<A, B, parser<shortest_alternative<A, B> > >
+    {
+        typedef shortest_alternative<A, B>      self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef shortest_parser_gen             parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        shortest_alternative(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typename ScannerT::iterator_t save = scan.first;
+            result_t l = this->left().parse(scan);
+            std::swap(scan.first, save);
+            result_t r = this->right().parse(scan);
+
+            if (l || r)
+            {
+                if ((l.length() < r.length() && l) || !r)
+                {
+                    scan.first = save;
+                    return l;
+                }
+                return r;
+            }
+
+            return scan.no_match();
+        }
+    };
+
+    struct shortest_parser_gen
+    {
+        template <typename A, typename B>
+        struct result {
+
+            typedef typename
+                impl::to_shortest_alternative<alternative<A, B> >::result_t
+            type;
+        };
+
+        template <typename A, typename B>
+        static typename
+        impl::to_shortest_alternative<alternative<A, B> >::result_t
+        generate(alternative<A, B> const& alt)
+        {
+            return impl::to_shortest_alternative<alternative<A, B> >::
+                convert(alt);
+        }
+
+        //'generate' for binary composite
+        template <typename A, typename B>
+        static
+        shortest_alternative<A, B>
+        generate(A const &left, B const &right)
+        {
+            return shortest_alternative<A, B>(left, right);
+        }
+
+        template <typename A, typename B>
+        typename impl::to_shortest_alternative<alternative<A, B> >::result_t
+        operator[](alternative<A, B> const& alt) const
+        {
+            return impl::to_shortest_alternative<alternative<A, B> >::
+                convert(alt);
+        }
+    };
+
+    const shortest_parser_gen shortest_d = shortest_parser_gen();
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  min_bounded class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename BoundsT>
+    struct min_bounded_gen;
+
+    template <typename ParserT, typename BoundsT>
+    struct min_bounded
+    :   public unary<ParserT, parser<min_bounded<ParserT, BoundsT> > >
+    {
+        typedef min_bounded<ParserT, BoundsT>   self_t;
+        typedef unary_parser_category           parser_category_t;
+        typedef min_bounded_gen<BoundsT>        parser_generator_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        min_bounded(ParserT const& p, BoundsT const& min__)
+        : base_t(p)
+        , min_(min__) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t hit = this->subject().parse(scan);
+            if (hit.has_valid_attribute() && hit.value() < min_)
+                return scan.no_match();
+            return hit;
+        }
+
+        BoundsT min_;
+    };
+
+    template <typename BoundsT>
+    struct min_bounded_gen
+    {
+        min_bounded_gen(BoundsT const& min__)
+        : min_(min__) {}
+
+        template <typename DerivedT>
+        min_bounded<DerivedT, BoundsT>
+        operator[](parser<DerivedT> const& p) const
+        { return min_bounded<DerivedT, BoundsT>(p.derived(), min_); }
+
+        BoundsT min_;
+    };
+
+    template <typename BoundsT>
+    inline min_bounded_gen<BoundsT>
+    min_limit_d(BoundsT const& min_)
+    { return min_bounded_gen<BoundsT>(min_); }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  max_bounded class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename BoundsT>
+    struct max_bounded_gen;
+
+    template <typename ParserT, typename BoundsT>
+    struct max_bounded
+    :   public unary<ParserT, parser<max_bounded<ParserT, BoundsT> > >
+    {
+        typedef max_bounded<ParserT, BoundsT>   self_t;
+        typedef unary_parser_category           parser_category_t;
+        typedef max_bounded_gen<BoundsT>        parser_generator_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        max_bounded(ParserT const& p, BoundsT const& max__)
+        : base_t(p)
+        , max_(max__) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t hit = this->subject().parse(scan);
+            if (hit.has_valid_attribute() && hit.value() > max_)
+                return scan.no_match();
+            return hit;
+        }
+
+        BoundsT max_;
+    };
+
+    template <typename BoundsT>
+    struct max_bounded_gen
+    {
+        max_bounded_gen(BoundsT const& max__)
+        : max_(max__) {}
+
+        template <typename DerivedT>
+        max_bounded<DerivedT, BoundsT>
+        operator[](parser<DerivedT> const& p) const
+        { return max_bounded<DerivedT, BoundsT>(p.derived(), max_); }
+
+        BoundsT max_;
+    };
+
+    //////////////////////////////////
+    template <typename BoundsT>
+    inline max_bounded_gen<BoundsT>
+    max_limit_d(BoundsT const& max_)
+    { return max_bounded_gen<BoundsT>(max_); }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  bounded class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename BoundsT>
+    struct bounded_gen;
+
+    template <typename ParserT, typename BoundsT>
+    struct bounded
+    :   public unary<ParserT, parser<bounded<ParserT, BoundsT> > >
+    {
+        typedef bounded<ParserT, BoundsT>       self_t;
+        typedef unary_parser_category           parser_category_t;
+        typedef bounded_gen<BoundsT>            parser_generator_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        bounded(ParserT const& p, BoundsT const& min__, BoundsT const& max__)
+        : base_t(p)
+        , min_(min__)
+        , max_(max__) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t hit = this->subject().parse(scan);
+            if (hit.has_valid_attribute() &&
+                (hit.value() < min_ || hit.value() > max_))
+                    return scan.no_match();
+            return hit;
+        }
+
+        BoundsT min_, max_;
+    };
+
+    template <typename BoundsT>
+    struct bounded_gen
+    {
+        bounded_gen(BoundsT const& min__, BoundsT const& max__)
+        : min_(min__)
+        , max_(max__) {}
+
+        template <typename DerivedT>
+        bounded<DerivedT, BoundsT>
+        operator[](parser<DerivedT> const& p) const
+        { return bounded<DerivedT, BoundsT>(p.derived(), min_, max_); }
+
+        BoundsT min_, max_;
+    };
+
+    template <typename BoundsT>
+    inline bounded_gen<BoundsT>
+    limit_d(BoundsT const& min_, BoundsT const& max_)
+    { return bounded_gen<BoundsT>(min_, max_); }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/composite.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/composite.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/composite.hpp	(working copy)
@@ -0,0 +1,151 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_COMPOSITE_HPP)
+#define BOOST_SPIRIT_COMPOSITE_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/compressed_pair.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  unary class.
+    //
+    //      Composite class composed of a single subject. This template class
+    //      is parameterized by the subject type S and a base class to
+    //      inherit from, BaseT. The unary class is meant to be a base class
+    //      to inherit from. The inheritance structure, given the BaseT
+    //      template parameter places the unary class in the middle of a
+    //      linear, single parent hierarchy. For instance, given a class S
+    //      and a base class B, a class D can derive from unary:
+    //
+    //          struct D : public unary<S, B> {...};
+    //
+    //      The inheritance structure is thus:
+    //
+    //            B
+    //            |
+    //          unary (has S)
+    //            |
+    //            D
+    //
+    //      The subject can be accessed from the derived class D as:
+    //      this->subject();
+    //
+    //      Typically, the subject S is specified as typename S::embed_t.
+    //      embed_t specifies how the subject is embedded in the composite
+    //      (See parser.hpp for details).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename S, typename BaseT>
+    class unary : public BaseT
+    {
+    public:
+
+        typedef BaseT                                           base_t;
+        typedef typename boost::call_traits<S>::param_type      param_t;
+        typedef typename boost::call_traits<S>::const_reference return_t;
+        typedef S                                               subject_t;
+        typedef typename S::embed_t                             subject_embed_t;
+
+        unary(param_t subj_)
+        : base_t(), subj(subj_) {}
+
+        unary(BaseT const& base, param_t subj_)
+        : base_t(base), subj(subj_) {}
+
+        return_t
+        subject() const
+        { return subj; }
+
+    private:
+
+        subject_embed_t subj;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  binary class.
+    //
+    //      Composite class composed of a pair (left and right). This
+    //      template class is parameterized by the left and right subject
+    //      types A and B and a base class to inherit from, BaseT. The binary
+    //      class is meant to be a base class to inherit from. The
+    //      inheritance structure, given the BaseT template parameter places
+    //      the binary class in the middle of a linear, single parent
+    //      hierarchy. For instance, given classes X and Y and a base class
+    //      B, a class D can derive from binary:
+    //
+    //          struct D : public binary<X, Y, B> {...};
+    //
+    //      The inheritance structure is thus:
+    //
+    //            B
+    //            |
+    //          binary (has X and Y)
+    //            |
+    //            D
+    //
+    //      The left and right subjects can be accessed from the derived
+    //      class D as: this->left(); and this->right();
+    //
+    //      Typically, the pairs X and Y are specified as typename X::embed_t
+    //      and typename Y::embed_t. embed_t specifies how the subject is
+    //      embedded in the composite (See parser.hpp for details).
+    //
+    ///////////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B, typename BaseT>
+    class binary : public BaseT
+    {
+    public:
+
+        typedef BaseT                                           base_t;
+        typedef typename boost::call_traits<A>::param_type      left_param_t;
+        typedef typename boost::call_traits<A>::const_reference left_return_t;
+        typedef typename boost::call_traits<B>::param_type      right_param_t;
+        typedef typename boost::call_traits<B>::const_reference right_return_t;
+        typedef A                                               left_t;
+        typedef typename A::embed_t                             left_embed_t;
+        typedef B                                               right_t;
+        typedef typename B::embed_t                             right_embed_t;
+
+        binary(left_param_t a, right_param_t b)
+        : base_t(), subj(a, b) {}
+
+        left_return_t
+        left() const
+        { return subj.first(); }
+
+        right_return_t
+        right() const
+        { return subj.second(); }
+
+    private:
+
+        boost::compressed_pair<left_embed_t, right_embed_t> subj;
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/positive.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/positive.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/positive.hpp	(working copy)
@@ -0,0 +1,112 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_POSITIVE_HPP)
+#define BOOST_SPIRIT_POSITIVE_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  positive class
+    //
+    //      Handles expressions of the form:
+    //
+    //          +a
+    //
+    //      where a is a parser. The expression returns a composite
+    //      parser that matches its subject one (1) or more times.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct positive_parser_gen;
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    template <typename S>
+    struct positive
+    :   public unary<S, parser<positive<S> > >
+    {
+        typedef positive<S>                 self_t;
+        typedef unary_parser_category       parser_category_t;
+        typedef positive_parser_gen         parser_generator_t;
+        typedef unary<S, parser<self_t> >   base_t;
+
+        positive(S const& a)
+        : base_t(a) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            result_t hit = this->subject().parse(scan);
+
+            if (hit)
+            {
+                for (;;)
+                {
+                    iterator_t save = scan.first;
+                    if (result_t next = this->subject().parse(scan))
+                    {
+                        scan.concat_match(hit, next);
+                    }
+                    else
+                    {
+                        scan.first = save;
+                        break;
+                    }
+                }
+            }
+            return hit;
+        }
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+    struct positive_parser_gen
+    {
+        template <typename S>
+        struct result
+        {
+            typedef positive<S> type;
+        };
+
+        template <typename S>
+        static positive<S>
+        generate(parser<S> const& a)
+        {
+            return positive<S>(a.derived());
+        }
+    };
+
+    template <typename S>
+    inline positive<S>
+    operator+(parser<S> const& a);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/positive.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/exclusive_or.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/exclusive_or.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/exclusive_or.hpp	(working copy)
@@ -0,0 +1,142 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_EXCLUSIVE_OR_HPP)
+#define BOOST_SPIRIT_EXCLUSIVE_OR_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  exclusive_or class
+    //
+    //      Handles expressions of the form:
+    //
+    //          a ^ b
+    //
+    //      where a and b are parsers. The expression returns a composite
+    //      parser that matches a or b but not both. One (not both) of the
+    //      operands may be a literal char, wchar_t or a primitive string
+    //      char const*, wchar_t const*.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct exclusive_or_parser_gen;
+
+    template <typename A, typename B>
+    struct exclusive_or
+    :   public binary<A, B, parser<exclusive_or<A, B> > >
+    {
+        typedef exclusive_or<A, B>              self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef exclusive_or_parser_gen         parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        exclusive_or(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+
+            iterator_t save = scan.first;
+            result_t l = this->left().parse(scan);
+            std::swap(save, scan.first);
+            result_t r = this->right().parse(scan);
+
+            if (l ? !bool(r) : bool(r))
+            {
+                if (l)
+                    scan.first = save;
+                return l ? l : r;
+            }
+
+            return scan.no_match();
+        }
+    };
+
+    struct exclusive_or_parser_gen
+    {
+        template <typename A, typename B>
+        struct result
+        {
+            typedef
+                exclusive_or<
+                    typename as_parser<A>::type
+                  , typename as_parser<B>::type
+                >
+            type;
+        };
+
+        template <typename A, typename B>
+        static exclusive_or<
+            typename as_parser<A>::type
+          , typename as_parser<B>::type
+        >
+        generate(A const& a, B const& b)
+        {
+            return exclusive_or<BOOST_DEDUCED_TYPENAME as_parser<A>::type,
+                BOOST_DEDUCED_TYPENAME as_parser<B>::type>
+                    (as_parser<A>::convert(a), as_parser<B>::convert(b));
+        }
+    };
+
+    template <typename A, typename B>
+    exclusive_or<A, B>
+    operator^(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    exclusive_or<A, chlit<char> >
+    operator^(parser<A> const& a, char b);
+
+    template <typename B>
+    exclusive_or<chlit<char>, B>
+    operator^(char a, parser<B> const& b);
+
+    template <typename A>
+    exclusive_or<A, strlit<char const*> >
+    operator^(parser<A> const& a, char const* b);
+
+    template <typename B>
+    exclusive_or<strlit<char const*>, B>
+    operator^(char const* a, parser<B> const& b);
+
+    template <typename A>
+    exclusive_or<A, chlit<wchar_t> >
+    operator^(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    exclusive_or<chlit<wchar_t>, B>
+    operator^(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    exclusive_or<A, strlit<wchar_t const*> >
+    operator^(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    exclusive_or<strlit<wchar_t const*>, B>
+    operator^(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/exclusive_or.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequence.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequence.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequence.hpp	(working copy)
@@ -0,0 +1,142 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SEQUENCE_HPP)
+#define BOOST_SPIRIT_SEQUENCE_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sequence class
+    //
+    //      Handles expressions of the form:
+    //
+    //          a >> b
+    //
+    //      where a and b are parsers. The expression returns a composite
+    //      parser that matches a and b in sequence. One (not both) of the
+    //      operands may be a literal char, wchar_t or a primitive string
+    //      char const*, wchar_t const*.
+    //
+    //////////////////////////////////////////////////////////////////////////
+    struct sequence_parser_gen;
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    template <typename A, typename B>
+    struct sequence : public binary<A, B, parser<sequence<A, B> > >
+    {
+        typedef sequence<A, B>                  self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef sequence_parser_gen             parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        sequence(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            if (result_t ma = this->left().parse(scan))
+                if (result_t mb = this->right().parse(scan))
+                {
+                    scan.concat_match(ma, mb);
+                    return ma;
+                }
+            return scan.no_match();
+        }
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+    struct sequence_parser_gen
+    {
+        template <typename A, typename B>
+        struct result
+        {
+            typedef
+                sequence<
+                    typename as_parser<A>::type
+                  , typename as_parser<B>::type
+                >
+            type;
+        };
+
+        template <typename A, typename B>
+        static sequence<
+            typename as_parser<A>::type
+          , typename as_parser<B>::type
+        >
+        generate(A const& a, B const& b)
+        {
+            return sequence<BOOST_DEDUCED_TYPENAME as_parser<A>::type,
+                BOOST_DEDUCED_TYPENAME as_parser<B>::type>
+                    (as_parser<A>::convert(a), as_parser<B>::convert(b));
+        }
+    };
+
+    template <typename A, typename B>
+    sequence<A, B>
+    operator>>(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, chlit<char> >
+    operator>>(parser<A> const& a, char b);
+
+    template <typename B>
+    sequence<chlit<char>, B>
+    operator>>(char a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, strlit<char const*> >
+    operator>>(parser<A> const& a, char const* b);
+
+    template <typename B>
+    sequence<strlit<char const*>, B>
+    operator>>(char const* a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, chlit<wchar_t> >
+    operator>>(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    sequence<chlit<wchar_t>, B>
+    operator>>(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, strlit<wchar_t const*> >
+    operator>>(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    sequence<strlit<wchar_t const*>, B>
+    operator>>(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/sequence.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/difference.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/difference.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/difference.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DIFFERENCE_IPP)
+#define BOOST_SPIRIT_DIFFERENCE_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  difference class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline difference<A, B>
+    operator-(parser<A> const& a, parser<B> const& b)
+    {
+        return difference<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline difference<A, chlit<char> >
+    operator-(parser<A> const& a, char b)
+    {
+        return difference<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline difference<chlit<char>, B>
+    operator-(char a, parser<B> const& b)
+    {
+        return difference<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline difference<A, strlit<char const*> >
+    operator-(parser<A> const& a, char const* b)
+    {
+        return difference<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline difference<strlit<char const*>, B>
+    operator-(char const* a, parser<B> const& b)
+    {
+        return difference<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline difference<A, chlit<wchar_t> >
+    operator-(parser<A> const& a, wchar_t b)
+    {
+        return difference<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline difference<chlit<wchar_t>, B>
+    operator-(wchar_t a, parser<B> const& b)
+    {
+        return difference<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline difference<A, strlit<wchar_t const*> >
+    operator-(parser<A> const& a, wchar_t const* b)
+    {
+        return difference<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline difference<strlit<wchar_t const*>, B>
+    operator-(wchar_t const* a, parser<B> const& b)
+    {
+        return difference<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequential_and.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequential_and.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequential_and.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SEQUENTIAL_AND_IPP)
+#define BOOST_SPIRIT_SEQUENTIAL_AND_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sequential-and operators implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline sequence<A, B>
+    operator&&(parser<A> const& a, parser<B> const& b)
+    {
+        return sequence<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, chlit<char> >
+    operator&&(parser<A> const& a, char b)
+    {
+        return sequence<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<chlit<char>, B>
+    operator&&(char a, parser<B> const& b)
+    {
+        return sequence<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, strlit<char const*> >
+    operator&&(parser<A> const& a, char const* b)
+    {
+        return sequence<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<strlit<char const*>, B>
+    operator&&(char const* a, parser<B> const& b)
+    {
+        return sequence<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, chlit<wchar_t> >
+    operator&&(parser<A> const& a, wchar_t b)
+    {
+        return sequence<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<chlit<wchar_t>, B>
+    operator&&(wchar_t a, parser<B> const& b)
+    {
+        return sequence<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, strlit<wchar_t const*> >
+    operator&&(parser<A> const& a, wchar_t const* b)
+    {
+        return sequence<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<strlit<wchar_t const*>, B>
+    operator&&(wchar_t const* a, parser<B> const& b)
+    {
+        return sequence<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/kleene_star.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/kleene_star.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/kleene_star.ipp	(working copy)
@@ -0,0 +1,34 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_KLEENE_STAR_IPP)
+#define BOOST_SPIRIT_KLEENE_STAR_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  kleene_star class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename S>
+    inline kleene_star<S>
+    operator*(parser<S> const& a)
+    {
+        return kleene_star<S>(a.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/directives.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/directives.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/directives.ipp	(working copy)
@@ -0,0 +1,374 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2001 Bruce Florman
+    Copyright (c) 2002 Raghavendra Satish
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DIRECTIVES_IPP)
+#define BOOST_SPIRIT_DIRECTIVES_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/core/scanner/skipper.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename BaseT>
+    struct no_skipper_iteration_policy;
+
+    template <typename BaseT>
+    struct inhibit_case_iteration_policy;
+
+    template <typename A, typename B>
+    struct alternative;
+
+    template <typename A, typename B>
+    struct longest_alternative;
+
+    template <typename A, typename B>
+    struct shortest_alternative;
+
+    namespace impl
+    {
+        template <typename RT, typename ST, typename ScannerT, typename BaseT>
+        inline RT
+        contiguous_parser_parse(
+            ST const& s,
+            ScannerT const& scan,
+            skipper_iteration_policy<BaseT> const&)
+        {
+            typedef scanner_policies<
+                no_skipper_iteration_policy<
+                    BOOST_DEDUCED_TYPENAME ScannerT::iteration_policy_t>,
+                BOOST_DEDUCED_TYPENAME ScannerT::match_policy_t,
+                BOOST_DEDUCED_TYPENAME ScannerT::action_policy_t
+            > policies_t;
+
+            scan.skip(scan);
+            RT hit = s.parse(scan.change_policies(policies_t(scan)));
+            // We will not do a post skip!!!
+            return hit;
+        }
+
+        template <typename RT, typename ST, typename ScannerT, typename BaseT>
+        inline RT
+        contiguous_parser_parse(
+            ST const& s,
+            ScannerT const& scan,
+            no_skipper_iteration_policy<BaseT> const&)
+        {
+            return s.parse(scan);
+        }
+
+        template <typename RT, typename ST, typename ScannerT>
+        inline RT
+        contiguous_parser_parse(
+            ST const& s,
+            ScannerT const& scan,
+            iteration_policy const&)
+        {
+            return s.parse(scan);
+        }
+
+        template <
+            typename RT,
+            typename ParserT,
+            typename ScannerT,
+            typename BaseT>
+        inline RT
+        implicit_lexeme_parse(
+            ParserT const& p,
+            ScannerT const& scan,
+            skipper_iteration_policy<BaseT> const&)
+        {
+            typedef scanner_policies<
+                no_skipper_iteration_policy<
+                    BOOST_DEDUCED_TYPENAME ScannerT::iteration_policy_t>,
+                BOOST_DEDUCED_TYPENAME ScannerT::match_policy_t,
+                BOOST_DEDUCED_TYPENAME ScannerT::action_policy_t
+            > policies_t;
+
+            scan.skip(scan);
+            RT hit = p.parse_main(scan.change_policies(policies_t(scan)));
+            // We will not do a post skip!!!
+            return hit;
+        }
+
+        template <
+            typename RT,
+            typename ParserT,
+            typename ScannerT,
+            typename BaseT>
+        inline RT
+        implicit_lexeme_parse(
+            ParserT const& p,
+            ScannerT const& scan,
+            no_skipper_iteration_policy<BaseT> const&)
+        {
+            return p.parse_main(scan);
+        }
+
+        template <typename RT, typename ParserT, typename ScannerT>
+        inline RT
+        implicit_lexeme_parse(
+            ParserT const& p,
+            ScannerT const& scan,
+            iteration_policy const&)
+        {
+            return p.parse_main(scan);
+        }
+
+        template <typename RT, typename ST, typename ScannerT>
+        inline RT
+        inhibit_case_parser_parse(
+            ST const& s,
+            ScannerT const& scan,
+            iteration_policy const&)
+        {
+            typedef scanner_policies<
+                inhibit_case_iteration_policy<
+                    BOOST_DEDUCED_TYPENAME ScannerT::iteration_policy_t>,
+                BOOST_DEDUCED_TYPENAME ScannerT::match_policy_t,
+                BOOST_DEDUCED_TYPENAME ScannerT::action_policy_t
+            > policies_t;
+
+            return s.parse(scan.change_policies(policies_t(scan)));
+        }
+
+        template <typename RT, typename ST, typename ScannerT, typename BaseT>
+        inline RT
+        inhibit_case_parser_parse(
+            ST const& s,
+            ScannerT const& scan,
+            inhibit_case_iteration_policy<BaseT> const&)
+        {
+            return s.parse(scan);
+        }
+
+#if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  from spirit 1.1 (copyright (c) 2001 Bruce Florman)
+        //  various workarounds to support longest and shortest directives
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <typename T>
+        struct is_alternative
+        {
+        //  Determine at compile time (without partial specialization)
+        //  whether a given type is an instance of the alternative<A,B>
+
+            static T t();
+            template <typename A, typename B>
+            static char test_(alternative<A, B> const&);    // no implementation
+            static int  test_(...);                         // no implementation
+            enum { r = sizeof(char) == sizeof(test_(t())) };
+            typedef mpl::bool_<r> value;
+        };
+
+        template <typename T> struct select_to_longest;
+
+        template <typename T>
+        struct to_longest_alternative
+        {
+            typedef typename select_to_longest<T>::result_t result_t;
+            typedef typename select_to_longest<T>::plain_t  plain_t;
+            typedef typename select_to_longest<T>::choose_t choose_t;
+            static result_t convert(T const& a);
+        };
+
+        template <typename T>
+        struct to_longest_generic
+        {
+            typedef T const&        result_t;
+            typedef T               plain_t;
+            typedef mpl::false_    choose_t;
+        };
+
+        template <typename T>
+        inline T const&
+        to_longest_convert(T const& a, mpl::false_)
+        { return a; }
+
+        template <typename T>
+        struct to_longest_recursive
+        {
+            typedef typename to_longest_alternative<
+                typename T::left_t>::plain_t    a_t;
+            typedef typename to_longest_alternative<
+                typename T::right_t>::plain_t   b_t;
+
+            typedef longest_alternative<a_t, b_t>   result_t;
+
+            typedef result_t    plain_t;
+            typedef mpl::true_ choose_t;
+        };
+
+        template <typename A, typename B>
+        inline typename to_longest_alternative<alternative<A, B> >::result_t
+        to_longest_convert(alternative<A, B> const& alt, mpl::true_)
+        {
+            typedef typename to_longest_alternative<
+                alternative<A, B> >::result_t result_t;
+            return result_t(
+                to_longest_alternative<A>::convert(alt.left()),
+                to_longest_alternative<B>::convert(alt.right()));
+        }
+
+        template <typename T>
+        inline typename to_longest_alternative<T>::result_t
+        to_longest_alternative<T>::convert(T const& a)
+        {
+            return to_longest_convert(
+                a, to_longest_alternative<T>::choose_t());
+        }
+
+        template <typename T>
+        struct select_to_longest
+        {
+            typedef typename mpl::if_<
+                is_alternative<T>           //  IF
+                , to_longest_recursive<T>   //  THEN
+                , to_longest_generic<T>     //  ELSE
+            >::type type;
+
+            typedef typename select_to_longest::type::result_t result_t;
+            typedef typename select_to_longest::type::plain_t  plain_t;
+            typedef typename select_to_longest::type::choose_t choose_t;
+        };
+
+        template <typename T> struct select_to_shortest;
+
+        template <typename T>
+        struct to_shortest_alternative
+        {
+            typedef typename select_to_shortest<T>::result_t    result_t;
+            typedef typename select_to_shortest<T>::plain_t     plain_t;
+            typedef typename select_to_shortest<T>::choose_t    choose_t;
+            static result_t convert(T const& a);
+        };
+
+        template <typename T>
+        struct to_shortest_generic
+        {
+            typedef T const&        result_t;
+            typedef T               plain_t;
+            typedef mpl::false_    choose_t;
+        };
+
+        template <typename T>
+        inline T const&
+        to_shortest_convert(T const& a, mpl::false_) { return a; }
+
+        template <typename T>
+        struct to_shortest_recursive
+        {
+            typedef typename to_shortest_alternative<
+                typename T::left_t>::plain_t    a_t;
+            typedef typename to_shortest_alternative<
+                typename T::right_t>::plain_t   b_t;
+
+            typedef shortest_alternative<a_t, b_t>  result_t;
+
+            typedef result_t        plain_t;
+            typedef mpl::true_     choose_t;
+        };
+
+        template <typename A, typename B>
+        inline typename to_shortest_alternative<alternative<A, B> >::result_t
+        to_shortest_convert(alternative<A, B> const& alt, mpl::true_)
+        {
+            typedef typename to_shortest_alternative<
+                alternative<A, B> >::result_t result_t;
+            return result_t(
+                to_shortest_alternative<A>::convert(alt.left()),
+                to_shortest_alternative<B>::convert(alt.right()));
+        }
+
+        template <typename T>
+        inline typename to_shortest_alternative<T>::result_t
+        to_shortest_alternative<T>::convert(T const& a)
+        {
+            return to_shortest_convert(
+                a, to_shortest_alternative<T>::choose_t());
+        }
+
+        template <typename T>
+        struct select_to_shortest
+        {
+            typedef typename mpl::if_<
+                is_alternative<T>           //  IF
+                , to_shortest_recursive<T>  //  THEN
+                , to_shortest_generic<T>    //  ELSE
+            >::type type;
+
+            typedef typename select_to_shortest::type::result_t result_t;
+            typedef typename select_to_shortest::type::plain_t  plain_t;
+            typedef typename select_to_shortest::type::choose_t choose_t;
+        };
+#else
+        template <typename T>
+        struct to_longest_alternative
+        {
+            typedef T result_t;
+            static result_t const&
+            convert(T const& a)  //  Special (end) case
+            { return a; }
+        };
+
+        template <typename A, typename B>
+        struct to_longest_alternative<alternative<A, B> >
+        {
+            typedef typename to_longest_alternative<A>::result_t    a_t;
+            typedef typename to_longest_alternative<B>::result_t    b_t;
+            typedef longest_alternative<a_t, b_t>                   result_t;
+
+            static result_t
+            convert(alternative<A, B> const& alt) // Recursive case
+            {
+                return result_t(
+                    to_longest_alternative<A>::convert(alt.left()),
+                    to_longest_alternative<B>::convert(alt.right()));
+            }
+        };
+
+        template <typename T>
+        struct to_shortest_alternative
+        {
+            typedef T result_t;
+            static result_t const&
+            convert(T const& a) //  Special (end) case
+            { return a; }
+        };
+
+        template <typename A, typename B>
+        struct to_shortest_alternative<alternative<A, B> >
+        {
+            typedef typename to_shortest_alternative<A>::result_t   a_t;
+            typedef typename to_shortest_alternative<B>::result_t   b_t;
+            typedef shortest_alternative<a_t, b_t>                  result_t;
+
+            static result_t
+            convert(alternative<A, B> const& alt) //  Recursive case
+            {
+                return result_t(
+                    to_shortest_alternative<A>::convert(alt.left()),
+                    to_shortest_alternative<B>::convert(alt.right()));
+            }
+        };
+#endif
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/positive.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/positive.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/positive.ipp	(working copy)
@@ -0,0 +1,34 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_POSITIVE_IPP)
+#define BOOST_SPIRIT_POSITIVE_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  positive class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename S>
+    inline positive<S>
+    operator+(parser<S> const& a)
+    {
+        return positive<S>(a.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/intersection.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/intersection.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/intersection.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_INTERSECTION_IPP)
+#define BOOST_SPIRIT_INTERSECTION_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  intersection class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline intersection<A, B>
+    operator&(parser<A> const& a, parser<B> const& b)
+    {
+        return intersection<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline intersection<A, chlit<char> >
+    operator&(parser<A> const& a, char b)
+    {
+        return intersection<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline intersection<chlit<char>, B>
+    operator&(char a, parser<B> const& b)
+    {
+        return intersection<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline intersection<A, strlit<char const*> >
+    operator&(parser<A> const& a, char const* b)
+    {
+        return intersection<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline intersection<strlit<char const*>, B>
+    operator&(char const* a, parser<B> const& b)
+    {
+        return intersection<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline intersection<A, chlit<wchar_t> >
+    operator&(parser<A> const& a, wchar_t b)
+    {
+        return intersection<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline intersection<chlit<wchar_t>, B>
+    operator&(wchar_t a, parser<B> const& b)
+    {
+        return intersection<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline intersection<A, strlit<wchar_t const*> >
+    operator&(parser<A> const& a, wchar_t const* b)
+    {
+        return intersection<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline intersection<strlit<wchar_t const*>, B>
+    operator&(wchar_t const* a, parser<B> const& b)
+    {
+        return intersection<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/exclusive_or.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/exclusive_or.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/exclusive_or.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_EXCLUSIVE_OR_IPP)
+#define BOOST_SPIRIT_EXCLUSIVE_OR_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  exclusive_or class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline exclusive_or<A, B>
+    operator^(parser<A> const& a, parser<B> const& b)
+    {
+        return exclusive_or<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline exclusive_or<A, chlit<char> >
+    operator^(parser<A> const& a, char b)
+    {
+        return exclusive_or<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline exclusive_or<chlit<char>, B>
+    operator^(char a, parser<B> const& b)
+    {
+        return exclusive_or<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline exclusive_or<A, strlit<char const*> >
+    operator^(parser<A> const& a, char const* b)
+    {
+        return exclusive_or<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline exclusive_or<strlit<char const*>, B>
+    operator^(char const* a, parser<B> const& b)
+    {
+        return exclusive_or<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline exclusive_or<A, chlit<wchar_t> >
+    operator^(parser<A> const& a, wchar_t b)
+    {
+        return exclusive_or<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline exclusive_or<chlit<wchar_t>, B>
+    operator^(wchar_t a, parser<B> const& b)
+    {
+        return exclusive_or<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline exclusive_or<A, strlit<wchar_t const*> >
+    operator^(parser<A> const& a, wchar_t const* b)
+    {
+        return exclusive_or<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline exclusive_or<strlit<wchar_t const*>, B>
+    operator^(wchar_t const* a, parser<B> const& b)
+    {
+        return exclusive_or<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequence.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequence.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequence.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SEQUENCE_IPP)
+#define BOOST_SPIRIT_SEQUENCE_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sequence class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline sequence<A, B>
+    operator>>(parser<A> const& a, parser<B> const& b)
+    {
+        return sequence<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, chlit<char> >
+    operator>>(parser<A> const& a, char b)
+    {
+        return sequence<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<chlit<char>, B>
+    operator>>(char a, parser<B> const& b)
+    {
+        return sequence<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, strlit<char const*> >
+    operator>>(parser<A> const& a, char const* b)
+    {
+        return sequence<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<strlit<char const*>, B>
+    operator>>(char const* a, parser<B> const& b)
+    {
+        return sequence<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, chlit<wchar_t> >
+    operator>>(parser<A> const& a, wchar_t b)
+    {
+        return sequence<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<chlit<wchar_t>, B>
+    operator>>(wchar_t a, parser<B> const& b)
+    {
+        return sequence<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, strlit<wchar_t const*> >
+    operator>>(parser<A> const& a, wchar_t const* b)
+    {
+        return sequence<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequence<strlit<wchar_t const*>, B>
+    operator>>(wchar_t const* a, parser<B> const& b)
+    {
+        return sequence<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequential_or.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequential_or.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/sequential_or.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SEQUENTIAL_OR_IPP)
+#define BOOST_SPIRIT_SEQUENTIAL_OR_IPP
+
+namespace boost { namespace spirit {
+
+ BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+   ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sequential-or class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline sequential_or<A, B>
+    operator||(parser<A> const& a, parser<B> const& b)
+    {
+        return sequential_or<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline sequential_or<A, chlit<char> >
+    operator||(parser<A> const& a, char b)
+    {
+        return sequential_or<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequential_or<chlit<char>, B>
+    operator||(char a, parser<B> const& b)
+    {
+        return sequential_or<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequential_or<A, strlit<char const*> >
+    operator||(parser<A> const& a, char const* b)
+    {
+        return sequential_or<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequential_or<strlit<char const*>, B>
+    operator||(char const* a, parser<B> const& b)
+    {
+        return sequential_or<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequential_or<A, chlit<wchar_t> >
+    operator||(parser<A> const& a, wchar_t b)
+    {
+        return sequential_or<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequential_or<chlit<wchar_t>, B>
+    operator||(wchar_t a, parser<B> const& b)
+    {
+        return sequential_or<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline sequential_or<A, strlit<wchar_t const*> >
+    operator||(parser<A> const& a, wchar_t const* b)
+    {
+        return sequential_or<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline sequential_or<strlit<wchar_t const*>, B>
+    operator||(wchar_t const* a, parser<B> const& b)
+    {
+        return sequential_or<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/list.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/list.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/list.ipp	(working copy)
@@ -0,0 +1,93 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_LIST_IPP)
+#define BOOST_SPIRIT_LIST_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  operator% is defined as:
+    //  a % b ---> a >> *(b >> a)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline sequence<A, kleene_star<sequence<B, A> > >
+    operator%(parser<A> const& a, parser<B> const& b)
+    {
+        return a.derived() >> *(b.derived() >> a.derived());
+    }
+
+    template <typename A>
+    inline sequence<A, kleene_star<sequence<chlit<char>, A> > >
+    operator%(parser<A> const& a, char b)
+    {
+        return a.derived() >> *(b >> a.derived());
+    }
+
+    template <typename B>
+    inline sequence<chlit<char>, kleene_star<sequence<B, chlit<char> > > >
+    operator%(char a, parser<B> const& b)
+    {
+        return a >> *(b.derived() >> a);
+    }
+
+    template <typename A>
+    inline sequence<A, kleene_star<sequence<strlit<char const*>, A> > >
+    operator%(parser<A> const& a, char const* b)
+    {
+        return a.derived() >> *(b >> a.derived());
+    }
+
+    template <typename B>
+    inline sequence<strlit<char const*>,
+        kleene_star<sequence<B, strlit<char const*> > > >
+    operator%(char const* a, parser<B> const& b)
+    {
+        return a >> *(b.derived() >> a);
+    }
+
+    template <typename A>
+    inline sequence<A, kleene_star<sequence<chlit<wchar_t>, A> > >
+    operator%(parser<A> const& a, wchar_t b)
+    {
+        return a.derived() >> *(b >> a.derived());
+    }
+
+    template <typename B>
+    inline sequence<chlit<wchar_t>, kleene_star<sequence<B, chlit<wchar_t> > > >
+    operator%(wchar_t a, parser<B> const& b)
+    {
+        return a >> *(b.derived() >> a);
+    }
+
+    template <typename A>
+    inline sequence<A, kleene_star<sequence<strlit<wchar_t const*>, A> > >
+    operator%(parser<A> const& a, wchar_t const* b)
+    {
+        return a.derived() >> *(b >> a.derived());
+    }
+
+    template <typename B>
+    inline sequence<strlit<wchar_t const*>,
+        kleene_star<sequence<B, strlit<wchar_t const*> > > >
+    operator%(wchar_t const* a, parser<B> const& b)
+    {
+        return a >> *(b.derived() >> a);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/alternative.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/alternative.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/alternative.ipp	(working copy)
@@ -0,0 +1,90 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ALTERNATIVE_IPP)
+#define BOOST_SPIRIT_ALTERNATIVE_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  alternative class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    inline alternative<A, B>
+    operator|(parser<A> const& a, parser<B> const& b)
+    {
+        return alternative<A, B>(a.derived(), b.derived());
+    }
+
+    template <typename A>
+    inline alternative<A, chlit<char> >
+    operator|(parser<A> const& a, char b)
+    {
+        return alternative<A, chlit<char> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline alternative<chlit<char>, B>
+    operator|(char a, parser<B> const& b)
+    {
+        return alternative<chlit<char>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline alternative<A, strlit<char const*> >
+    operator|(parser<A> const& a, char const* b)
+    {
+        return alternative<A, strlit<char const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline alternative<strlit<char const*>, B>
+    operator|(char const* a, parser<B> const& b)
+    {
+        return alternative<strlit<char const*>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline alternative<A, chlit<wchar_t> >
+    operator|(parser<A> const& a, wchar_t b)
+    {
+        return alternative<A, chlit<wchar_t> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline alternative<chlit<wchar_t>, B>
+    operator|(wchar_t a, parser<B> const& b)
+    {
+        return alternative<chlit<wchar_t>, B>(a, b.derived());
+    }
+
+    template <typename A>
+    inline alternative<A, strlit<wchar_t const*> >
+    operator|(parser<A> const& a, wchar_t const* b)
+    {
+        return alternative<A, strlit<wchar_t const*> >(a.derived(), b);
+    }
+
+    template <typename B>
+    inline alternative<strlit<wchar_t const*>, B>
+    operator|(wchar_t const* a, parser<B> const& b)
+    {
+        return alternative<strlit<wchar_t const*>, B>(a, b.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/optional.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/optional.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/impl/optional.ipp	(working copy)
@@ -0,0 +1,34 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_OPTIONAL_IPP)
+#define BOOST_SPIRIT_OPTIONAL_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  optional class implementation
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename S>
+    optional<S>
+    operator!(parser<S> const& a)
+    {
+        return optional<S>(a.derived());
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/list.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/list.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/list.hpp	(working copy)
@@ -0,0 +1,73 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_LIST_HPP)
+#define BOOST_SPIRIT_LIST_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  operator% is defined as:
+    //  a % b ---> a >> *(b >> a)
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    sequence<A, kleene_star<sequence<B, A> > >
+    operator%(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, kleene_star<sequence<chlit<char>, A> > >
+    operator%(parser<A> const& a, char b);
+
+    template <typename B>
+    sequence<chlit<char>, kleene_star<sequence<B, chlit<char> > > >
+    operator%(char a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, kleene_star<sequence<strlit<char const*>, A> > >
+    operator%(parser<A> const& a, char const* b);
+
+    template <typename B>
+    sequence<strlit<char const*>,
+        kleene_star<sequence<B, strlit<char const*> > > >
+    operator%(char const* a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, kleene_star<sequence<chlit<wchar_t>, A> > >
+    operator%(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    sequence<chlit<wchar_t>, kleene_star<sequence<B, chlit<wchar_t> > > >
+    operator%(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, kleene_star<sequence<strlit<wchar_t const*>, A> > >
+    operator%(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    sequence<strlit<wchar_t const*>,
+        kleene_star<sequence<B, strlit<wchar_t const*> > > >
+    operator%(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/list.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/operators.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/operators.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/operators.hpp	(working copy)
@@ -0,0 +1,25 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_OPERATORS_HPP)
+#define BOOST_SPIRIT_OPERATORS_HPP
+
+#include <boost/spirit/home/classic/core/composite/sequence.hpp>
+#include <boost/spirit/home/classic/core/composite/sequential_and.hpp>
+#include <boost/spirit/home/classic/core/composite/sequential_or.hpp>
+#include <boost/spirit/home/classic/core/composite/alternative.hpp>
+#include <boost/spirit/home/classic/core/composite/difference.hpp>
+#include <boost/spirit/home/classic/core/composite/intersection.hpp>
+#include <boost/spirit/home/classic/core/composite/exclusive_or.hpp>
+#include <boost/spirit/home/classic/core/composite/kleene_star.hpp>
+#include <boost/spirit/home/classic/core/composite/positive.hpp>
+#include <boost/spirit/home/classic/core/composite/optional.hpp>
+#include <boost/spirit/home/classic/core/composite/list.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/difference.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/difference.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/difference.hpp	(working copy)
@@ -0,0 +1,150 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DIFFERENCE_HPP)
+#define BOOST_SPIRIT_DIFFERENCE_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  difference: a - b; Matches a but not b
+    //
+    //      Handles expressions of the form:
+    //
+    //          a - b
+    //
+    //      where a and b are parsers. The expression returns a composite
+    //      parser that matches a but not b. One (not both) of the operands
+    //      may be a literal char, wchar_t or a primitive string char const*,
+    //      wchar_t const*.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct difference_parser_gen;
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    template <typename A, typename B>
+    struct difference
+    :   public binary<A, B, parser<difference<A, B> > >
+    {
+        typedef difference<A, B>                self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef difference_parser_gen           parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        difference(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            iterator_t save = scan.first;
+            if (result_t hl = this->left().parse(scan))
+            {
+                std::swap(save, scan.first);
+                result_t hr = this->right().parse(scan);
+                if (!hr || (hr.length() < hl.length()))
+                {
+                    scan.first = save;
+                    return hl;
+                }
+            }
+
+            return scan.no_match();
+        }
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+    struct difference_parser_gen
+    {
+        template <typename A, typename B>
+        struct result
+        {
+            typedef
+                difference<
+                    typename as_parser<A>::type
+                  , typename as_parser<B>::type
+                >
+            type;
+        };
+
+        template <typename A, typename B>
+        static difference<
+            typename as_parser<A>::type
+          , typename as_parser<B>::type
+        >
+        generate(A const& a, B const& b)
+        {
+            return difference<BOOST_DEDUCED_TYPENAME as_parser<A>::type,
+                BOOST_DEDUCED_TYPENAME as_parser<B>::type>
+                    (as_parser<A>::convert(a), as_parser<B>::convert(b));
+        }
+    };
+
+    template <typename A, typename B>
+    difference<A, B>
+    operator-(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    difference<A, chlit<char> >
+    operator-(parser<A> const& a, char b);
+
+    template <typename B>
+    difference<chlit<char>, B>
+    operator-(char a, parser<B> const& b);
+
+    template <typename A>
+    difference<A, strlit<char const*> >
+    operator-(parser<A> const& a, char const* b);
+
+    template <typename B>
+    difference<strlit<char const*>, B>
+    operator-(char const* a, parser<B> const& b);
+
+    template <typename A>
+    difference<A, chlit<wchar_t> >
+    operator-(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    difference<chlit<wchar_t>, B>
+    operator-(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    difference<A, strlit<wchar_t const*> >
+    operator-(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    difference<strlit<wchar_t const*>, B>
+    operator-(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/difference.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequential_and.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequential_and.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequential_and.hpp	(working copy)
@@ -0,0 +1,76 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SEQUENTIAL_AND_HPP)
+#define BOOST_SPIRIT_SEQUENTIAL_AND_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sequential-and operators
+    //
+    //      Handles expressions of the form:
+    //
+    //          a && b
+    //
+    //      Same as a >> b.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename A, typename B>
+    sequence<A, B>
+    operator&&(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, chlit<char> >
+    operator&&(parser<A> const& a, char b);
+
+    template <typename B>
+    sequence<chlit<char>, B>
+    operator&&(char a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, strlit<char const*> >
+    operator&&(parser<A> const& a, char const* b);
+
+    template <typename B>
+    sequence<strlit<char const*>, B>
+    operator&&(char const* a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, chlit<wchar_t> >
+    operator&&(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    sequence<chlit<wchar_t>, B>
+    operator&&(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    sequence<A, strlit<wchar_t const*> >
+    operator&&(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    sequence<strlit<wchar_t const*>, B>
+    operator&&(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/sequential_and.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/actions.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/actions.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/actions.hpp	(working copy)
@@ -0,0 +1,136 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ACTIONS_HPP
+#define BOOST_SPIRIT_ACTIONS_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  action class
+    //
+    //      The action class binds a parser with a user defined semantic
+    //      action. Instances of action are never created manually. Instead,
+    //      action objects are typically created indirectly through
+    //      expression templates of the form:
+    //
+    //          p[f]
+    //
+    //      where p is a parser and f is a function or functor. The semantic
+    //      action may be a function or a functor. When the parser is
+    //      successful, the actor calls the scanner's action_policy policy
+    //      (see scanner.hpp):
+    //
+    //          scan.do_action(actor, attribute, first, last);
+    //
+    //      passing in these information:
+    //
+    //          actor:        The action's function or functor
+    //          attribute:    The match (returned by the parser) object's
+    //                        attribute (see match.hpp)
+    //          first:        Iterator pointing to the start of the matching
+    //                        portion of the input
+    //          last:         Iterator pointing to one past the end of the
+    //                        matching portion of the input
+    //
+    //      It is the responsibility of the scanner's action_policy policy to
+    //      dispatch the function or functor as it sees fit. The expected
+    //      function or functor signature depends on the parser being
+    //      wrapped. In general, if the attribute type of the parser being
+    //      wrapped is a nil_t, the function or functor expect the signature:
+    //
+    //          void func(Iterator first, Iterator last); // functions
+    //
+    //          struct ftor // functors
+    //          {
+    //              void func(Iterator first, Iterator last) const;
+    //          };
+    //
+    //      where Iterator is the type of the iterator that is being used and
+    //      first and last are the iterators pointing to the matching portion
+    //      of the input.
+    //
+    //      If the attribute type of the parser being wrapped is not a nil_t,
+    //      the function or functor usually expect the signature:
+    //
+    //          void func(T val); // functions
+    //
+    //          struct ftor // functors
+    //          {
+    //              void func(T val) const;
+    //          };
+    //
+    //      where T is the attribute type and val is the attribute value
+    //      returned by the parser being wrapped.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ParserT, typename ActionT>
+    class action : public unary<ParserT, parser<action<ParserT, ActionT> > >
+    {
+    public:
+
+        typedef action<ParserT, ActionT>        self_t;
+        typedef action_parser_category          parser_category_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+        typedef ActionT                         predicate_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        action(ParserT const& p, ActionT const& a)
+        : base_t(p)
+        , actor(a) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename ScannerT::iterator_t iterator_t;
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+
+            scan.at_end(); // allow skipper to take effect
+            iterator_t save = scan.first;
+            result_t hit = this->subject().parse(scan);
+            if (hit)
+            {
+                typename result_t::return_t val = hit.value();
+                scan.do_action(actor, val, save, scan.first);
+            }
+            return hit;
+        }
+
+        ActionT const& predicate() const { return actor; }
+
+    private:
+
+        ActionT actor;
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/intersection.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/intersection.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/intersection.hpp	(working copy)
@@ -0,0 +1,142 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_INTERSECTION_HPP)
+#define BOOST_SPIRIT_INTERSECTION_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  intersection class
+    //
+    //      Handles expressions of the form:
+    //
+    //          a & b
+    //
+    //      where a and b are parsers. The expression returns a composite
+    //      parser that matches a and b. One (not both) of the operands may
+    //      be a literal char, wchar_t or a primitive string char const*,
+    //      wchar_t const*.
+    //
+    //      The expression is short circuit evaluated. b is never touched
+    //      when a is returns a no-match.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct intersection_parser_gen;
+
+    template <typename A, typename B>
+    struct intersection
+    :   public binary<A, B, parser<intersection<A, B> > >
+    {
+        typedef intersection<A, B>              self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef intersection_parser_gen         parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        intersection(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            iterator_t save = scan.first;
+            if (result_t hl = this->left().parse(scan))
+            {
+                ScannerT bscan(scan.first, scan.first, scan);
+                scan.first = save;
+                result_t hr = this->right().parse(bscan);
+                if (hl.length() == hr.length())
+                    return hl;
+            }
+
+            return scan.no_match();
+        }
+    };
+
+    struct intersection_parser_gen
+    {
+        template <typename A, typename B>
+        struct result
+        {
+            typedef
+                intersection<
+                    typename as_parser<A>::type
+                  , typename as_parser<B>::type
+                >
+            type;
+        };
+
+        template <typename A, typename B>
+        static intersection<
+            typename as_parser<A>::type
+          , typename as_parser<B>::type
+        >
+        generate(A const& a, B const& b)
+        {
+            return intersection<BOOST_DEDUCED_TYPENAME as_parser<A>::type,
+                BOOST_DEDUCED_TYPENAME as_parser<B>::type>
+                    (as_parser<A>::convert(a), as_parser<B>::convert(b));
+        }
+    };
+
+    template <typename A, typename B>
+    intersection<A, B>
+    operator&(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    intersection<A, chlit<char> >
+    operator&(parser<A> const& a, char b);
+
+    template <typename B>
+    intersection<chlit<char>, B>
+    operator&(char a, parser<B> const& b);
+
+    template <typename A>
+    intersection<A, strlit<char const*> >
+    operator&(parser<A> const& a, char const* b);
+
+    template <typename B>
+    intersection<strlit<char const*>, B>
+    operator&(char const* a, parser<B> const& b);
+
+    template <typename A>
+    intersection<A, chlit<wchar_t> >
+    operator&(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    intersection<chlit<wchar_t>, B>
+    operator&(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    intersection<A, strlit<wchar_t const*> >
+    operator&(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    intersection<strlit<wchar_t const*>, B>
+    operator&(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/intersection.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/epsilon.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/epsilon.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/epsilon.hpp	(working copy)
@@ -0,0 +1,276 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_EPSILON_HPP
+#define BOOST_SPIRIT_EPSILON_HPP
+
+////////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/meta/parser_traits.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/core/composite/no_actions.hpp>
+
+////////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  condition_parser class
+//
+//      handles expresions of the form
+//
+//          epsilon_p(cond)
+//
+//      where cond is a function or a functor that returns a value suitable
+//      to be used in boolean context. The expression returns a parser that
+//      returns an empty match when the condition evaluates to true.
+//
+///////////////////////////////////////////////////////////////////////////////
+    template <typename CondT, bool positive_ = true>
+    struct condition_parser : parser<condition_parser<CondT, positive_> >
+    {
+        typedef condition_parser<CondT, positive_> self_t;
+
+        // not explicit! (needed for implementation of if_p et al.)
+        condition_parser(CondT const& cond_) : cond(cond_) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            if (positive_ == bool(cond())) // allow cond to return int
+                return scan.empty_match();
+            else
+                return scan.no_match();
+        }
+
+        condition_parser<CondT, !positive_>
+        negate() const
+        { return condition_parser<CondT, !positive_>(cond); }
+
+    private:
+
+        CondT cond;
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, == 1310) || \
+    BOOST_WORKAROUND(BOOST_MSVC, == 1400) || \
+    BOOST_WORKAROUND(__SUNPRO_CC, <= 0x580)
+// VC 7.1, VC8 and Sun CC <= 5.8 do not support general
+// expressions of non-type template parameters in instantiations
+    template <typename CondT>
+    inline condition_parser<CondT, false>
+    operator~(condition_parser<CondT, true> const& p)
+    { return p.negate(); }
+
+    template <typename CondT>
+    inline condition_parser<CondT, true>
+    operator~(condition_parser<CondT, false> const& p)
+    { return p.negate(); }
+#else // BOOST_WORKAROUND(BOOST_MSVC, == 1310) || == 1400
+    template <typename CondT, bool positive>
+    inline condition_parser<CondT, !positive>
+    operator~(condition_parser<CondT, positive> const& p)
+    { return p.negate(); }
+#endif // BOOST_WORKAROUND(BOOST_MSVC, == 1310) || == 1400
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  empty_match_parser class
+//
+//      handles expressions of the form
+//          epsilon_p(subject)
+//      where subject is a parser. The expresion returns a composite
+//      parser that returns an empty match if the subject parser matches.
+//
+///////////////////////////////////////////////////////////////////////////////
+    struct empty_match_parser_gen;
+    struct negated_empty_match_parser_gen;
+
+    template <typename SubjectT>
+    struct negated_empty_match_parser; // Forward declaration
+
+    template<typename SubjectT>
+    struct empty_match_parser
+    : unary<SubjectT, parser<empty_match_parser<SubjectT> > >
+    {
+        typedef empty_match_parser<SubjectT>        self_t;
+        typedef unary<SubjectT, parser<self_t> >    base_t;
+        typedef unary_parser_category               parser_category_t;
+        typedef empty_match_parser_gen              parser_genererator_t;
+        typedef self_t embed_t;
+
+        explicit empty_match_parser(SubjectT const& p) : base_t(p) {}
+
+        template <typename ScannerT>
+        struct result
+        { typedef typename match_result<ScannerT, nil_t>::type type; };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typename ScannerT::iterator_t save(scan.first);
+
+            typedef typename no_actions_scanner<ScannerT>::policies_t
+                policies_t;
+
+            bool matches = this->subject().parse(
+                scan.change_policies(policies_t(scan)));
+            if (matches)
+            {
+                scan.first = save; // reset the position
+                return scan.empty_match();
+            }
+            else
+            {
+                return scan.no_match();
+            }
+        }
+
+        negated_empty_match_parser<SubjectT>
+        negate() const
+        { return negated_empty_match_parser<SubjectT>(this->subject()); }
+    };
+
+    template<typename SubjectT>
+    struct negated_empty_match_parser
+    : public unary<SubjectT, parser<negated_empty_match_parser<SubjectT> > >
+    {
+        typedef negated_empty_match_parser<SubjectT>    self_t;
+        typedef unary<SubjectT, parser<self_t> >        base_t;
+        typedef unary_parser_category                   parser_category_t;
+        typedef negated_empty_match_parser_gen          parser_genererator_t;
+
+        explicit negated_empty_match_parser(SubjectT const& p) : base_t(p) {}
+
+        template <typename ScannerT>
+        struct result
+        { typedef typename match_result<ScannerT, nil_t>::type type; };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typename ScannerT::iterator_t save(scan.first);
+
+            typedef typename no_actions_scanner<ScannerT>::policies_t
+                policies_t;
+
+            bool matches = this->subject().parse(
+                scan.change_policies(policies_t(scan)));
+            if (!matches)
+            {
+                scan.first = save; // reset the position
+                return scan.empty_match();
+            }
+            else
+            {
+                return scan.no_match();
+            }
+        }
+
+        empty_match_parser<SubjectT>
+        negate() const
+        { return empty_match_parser<SubjectT>(this->subject()); }
+    };
+
+    struct empty_match_parser_gen
+    {
+        template <typename SubjectT>
+        struct result
+        { typedef empty_match_parser<SubjectT> type; };
+
+        template <typename SubjectT>
+        static empty_match_parser<SubjectT>
+        generate(parser<SubjectT> const& subject)
+        { return empty_match_parser<SubjectT>(subject.derived()); }
+    };
+
+    struct negated_empty_match_parser_gen
+    {
+        template <typename SubjectT>
+        struct result
+        { typedef negated_empty_match_parser<SubjectT> type; };
+
+        template <typename SubjectT>
+        static negated_empty_match_parser<SubjectT>
+        generate(parser<SubjectT> const& subject)
+        { return negated_empty_match_parser<SubjectT>(subject.derived()); }
+    };
+
+    //////////////////////////////
+    template <typename SubjectT>
+    inline negated_empty_match_parser<SubjectT>
+    operator~(empty_match_parser<SubjectT> const& p)
+    { return p.negate(); }
+
+    template <typename SubjectT>
+    inline empty_match_parser<SubjectT>
+    operator~(negated_empty_match_parser<SubjectT> const& p)
+    { return p.negate(); }
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  epsilon_ parser and parser generator class
+//
+//      Operates as primitive parser that always matches an empty sequence.
+//
+//      Also operates as a parser generator. According to the type of the
+//      argument an instance of empty_match_parser<> (when the argument is
+//      a parser) or condition_parser<> (when the argument is not a parser)
+//      is returned by operator().
+//
+///////////////////////////////////////////////////////////////////////////////
+    namespace impl
+    {
+        template <typename SubjectT>
+        struct epsilon_selector
+        {
+            typedef typename as_parser<SubjectT>::type subject_t;
+            typedef typename
+                mpl::if_<
+                    is_parser<subject_t>
+                    ,empty_match_parser<subject_t>
+                    ,condition_parser<subject_t>
+                >::type type;
+        };
+    }
+
+    struct epsilon_parser : public parser<epsilon_parser>
+    {
+        typedef epsilon_parser self_t;
+
+        epsilon_parser() {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        { return scan.empty_match(); }
+
+        template <typename SubjectT>
+        typename impl::epsilon_selector<SubjectT>::type
+        operator()(SubjectT const& subject) const
+        {
+            typedef typename impl::epsilon_selector<SubjectT>::type result_t;
+            return result_t(subject);
+        }
+    };
+
+    epsilon_parser const epsilon_p = epsilon_parser();
+    epsilon_parser const eps_p = epsilon_parser();
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequential_or.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequential_or.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/sequential_or.hpp	(working copy)
@@ -0,0 +1,154 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SEQUENTIAL_OR_HPP)
+#define BOOST_SPIRIT_SEQUENTIAL_OR_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  sequential-or class
+    //
+    //      Handles expressions of the form:
+    //
+    //          a || b
+    //
+    //      Equivalent to
+    //
+    //          a | b | a >> b;
+    //
+    //      where a and b are parsers. The expression returns a composite
+    //      parser that matches matches a or b in sequence. One (not both) of
+    //      the operands may be a literal char, wchar_t or a primitive string
+    //      char const*, wchar_t const*.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct sequential_or_parser_gen;
+
+    template <typename A, typename B>
+    struct sequential_or : public binary<A, B, parser<sequential_or<A, B> > >
+    {
+        typedef sequential_or<A, B>             self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef sequential_or_parser_gen        parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        sequential_or(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            { // scope for save
+                iterator_t save = scan.first;
+                if (result_t ma = this->left().parse(scan))
+                {
+                    save = scan.first;
+                    if (result_t mb = this->right().parse(scan))
+                    {
+                        // matched a b
+                        scan.concat_match(ma, mb);
+                        return ma;
+                    }
+                    else
+                    {
+                        // matched a
+                        scan.first = save;
+                        return ma;
+                    }
+                }
+                scan.first = save;
+            }
+
+            // matched b
+            return this->right().parse(scan);
+        }
+    };
+
+    struct sequential_or_parser_gen
+    {
+        template <typename A, typename B>
+        struct result
+        {
+            typedef
+                sequential_or<
+                    typename as_parser<A>::type
+                  , typename as_parser<B>::type
+                >
+            type;
+        };
+
+        template <typename A, typename B>
+        static sequential_or<
+            typename as_parser<A>::type
+          , typename as_parser<B>::type
+        >
+        generate(A const& a, B const& b)
+        {
+            return sequential_or<BOOST_DEDUCED_TYPENAME as_parser<A>::type,
+                BOOST_DEDUCED_TYPENAME as_parser<B>::type>
+                    (as_parser<A>::convert(a), as_parser<B>::convert(b));
+        }
+    };
+
+    template <typename A, typename B>
+    sequential_or<A, B>
+    operator||(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    sequential_or<A, chlit<char> >
+    operator||(parser<A> const& a, char b);
+
+    template <typename B>
+    sequential_or<chlit<char>, B>
+    operator||(char a, parser<B> const& b);
+
+    template <typename A>
+    sequential_or<A, strlit<char const*> >
+    operator||(parser<A> const& a, char const* b);
+
+    template <typename B>
+    sequential_or<strlit<char const*>, B>
+    operator||(char const* a, parser<B> const& b);
+
+    template <typename A>
+    sequential_or<A, chlit<wchar_t> >
+    operator||(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    sequential_or<chlit<wchar_t>, B>
+    operator||(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    sequential_or<A, strlit<wchar_t const*> >
+    operator||(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    sequential_or<strlit<wchar_t const*>, B>
+    operator||(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/sequential_or.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/alternative.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/alternative.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/alternative.hpp	(working copy)
@@ -0,0 +1,147 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ALTERNATIVE_HPP)
+#define BOOST_SPIRIT_ALTERNATIVE_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  alternative class
+    //
+    //      Handles expressions of the form:
+    //
+    //          a | b
+    //
+    //      where a and b are parsers. The expression returns a composite
+    //      parser that matches a or b. One (not both) of the operands may
+    //      be a literal char, wchar_t or a primitive string char const*,
+    //      wchar_t const*.
+    //
+    //      The expression is short circuit evaluated. b is never touched
+    //      when a is returns a successful match.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct alternative_parser_gen;
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    template <typename A, typename B>
+    struct alternative
+    :   public binary<A, B, parser<alternative<A, B> > >
+    {
+        typedef alternative<A, B>               self_t;
+        typedef binary_parser_category          parser_category_t;
+        typedef alternative_parser_gen          parser_generator_t;
+        typedef binary<A, B, parser<self_t> >   base_t;
+
+        alternative(A const& a, B const& b)
+        : base_t(a, b) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            { // scope for save
+                iterator_t save = scan.first;
+                if (result_t hit = this->left().parse(scan))
+                    return hit;
+                scan.first = save;
+            }
+            return this->right().parse(scan);
+        }
+    };
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+    struct alternative_parser_gen
+    {
+        template <typename A, typename B>
+        struct result
+        {
+            typedef
+                alternative<
+                    typename as_parser<A>::type
+                  , typename as_parser<B>::type
+                >
+            type;
+        };
+
+        template <typename A, typename B>
+        static alternative<
+            typename as_parser<A>::type
+          , typename as_parser<B>::type
+        >
+        generate(A const& a, B const& b)
+        {
+            return alternative<BOOST_DEDUCED_TYPENAME as_parser<A>::type,
+                BOOST_DEDUCED_TYPENAME as_parser<B>::type>
+                    (as_parser<A>::convert(a), as_parser<B>::convert(b));
+        }
+    };
+
+    template <typename A, typename B>
+    alternative<A, B>
+    operator|(parser<A> const& a, parser<B> const& b);
+
+    template <typename A>
+    alternative<A, chlit<char> >
+    operator|(parser<A> const& a, char b);
+
+    template <typename B>
+    alternative<chlit<char>, B>
+    operator|(char a, parser<B> const& b);
+
+    template <typename A>
+    alternative<A, strlit<char const*> >
+    operator|(parser<A> const& a, char const* b);
+
+    template <typename B>
+    alternative<strlit<char const*>, B>
+    operator|(char const* a, parser<B> const& b);
+
+    template <typename A>
+    alternative<A, chlit<wchar_t> >
+    operator|(parser<A> const& a, wchar_t b);
+
+    template <typename B>
+    alternative<chlit<wchar_t>, B>
+    operator|(wchar_t a, parser<B> const& b);
+
+    template <typename A>
+    alternative<A, strlit<wchar_t const*> >
+    operator|(parser<A> const& a, wchar_t const* b);
+
+    template <typename B>
+    alternative<strlit<wchar_t const*>, B>
+    operator|(wchar_t const* a, parser<B> const& b);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/alternative.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/optional.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/optional.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/composite/optional.hpp	(working copy)
@@ -0,0 +1,94 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001 Daniel Nuffer
+    Copyright (c) 2002 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_OPTIONAL_HPP)
+#define BOOST_SPIRIT_OPTIONAL_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  optional class
+    //
+    //      Handles expressions of the form:
+    //
+    //          !a
+    //
+    //      where a is a parser. The expression returns a composite
+    //      parser that matches its subject zero (0) or one (1) time.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    struct optional_parser_gen;
+
+    template <typename S>
+    struct optional
+    :   public unary<S, parser<optional<S> > >
+    {
+        typedef optional<S>                 self_t;
+        typedef unary_parser_category       parser_category_t;
+        typedef optional_parser_gen         parser_generator_t;
+        typedef unary<S, parser<self_t> >   base_t;
+
+        optional(S const& a)
+        : base_t(a) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            iterator_t save = scan.first;
+            if (result_t r = this->subject().parse(scan))
+            {
+                return r;
+            }
+            else
+            {
+                scan.first = save;
+                return scan.empty_match();
+            }
+        }
+    };
+
+    struct optional_parser_gen
+    {
+        template <typename S>
+        struct result
+        {
+            typedef optional<S> type;
+        };
+
+        template <typename S>
+        static optional<S>
+        generate(parser<S> const& a)
+        {
+            return optional<S>(a.derived());
+        }
+    };
+
+    template <typename S>
+    optional<S>
+    operator!(parser<S> const& a);
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/core/composite/impl/optional.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/nil.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/nil.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core/nil.hpp	(working copy)
@@ -0,0 +1,25 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_NIL_HPP)
+#define BOOST_SPIRIT_NIL_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    struct nil_t {};
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}}
+
+#endif
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility.hpp	(working copy)
@@ -0,0 +1,40 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    Copyright (c) 2001-2003 Hartmut Kaiser
+    Copyright (c) 2002-2003 Martin Wille
+    Copyright (c) 2002 Juan Carlos Arevalo-Baeza
+    Copyright (c) 2002 Raghavendra Satish
+    Copyright (c) 2002 Jeff Westfahl
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_UTILITY_MAIN_HPP)
+#define BOOST_SPIRIT_UTILITY_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Master header for Spirit.Utilities
+//
+///////////////////////////////////////////////////////////////////////////////
+
+// Utility.Parsers
+#include <boost/spirit/home/classic/utility/chset.hpp>
+#include <boost/spirit/home/classic/utility/chset_operators.hpp>
+#include <boost/spirit/home/classic/utility/escape_char.hpp>
+#include <boost/spirit/home/classic/utility/functor_parser.hpp>
+#include <boost/spirit/home/classic/utility/loops.hpp>
+#include <boost/spirit/home/classic/utility/confix.hpp>
+#include <boost/spirit/home/classic/utility/lists.hpp>
+#include <boost/spirit/home/classic/utility/distinct.hpp>
+
+// Utility.Support
+#include <boost/spirit/home/classic/utility/flush_multi_pass.hpp>
+#include <boost/spirit/home/classic/utility/scoped_lock.hpp>
+
+
+#endif // !defined(BOOST_SPIRIT_UTILITY_MAIN_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute.hpp	(working copy)
@@ -0,0 +1,37 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ATTRIBUTE_MAIN_HPP)
+#define BOOST_SPIRIT_ATTRIBUTE_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Master header for Spirit.Attributes
+//
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Phoenix predefined maximum limit. This limit defines the maximum
+//  number of elements a tuple can hold. This number defaults to 3. The
+//  actual maximum is rounded up in multiples of 3. Thus, if this value
+//  is 4, the actual limit is 6. The ultimate maximum limit in this
+//  implementation is 15.
+//
+///////////////////////////////////////////////////////////////////////////////
+#if !defined(PHOENIX_LIMIT)
+#define PHOENIX_LIMIT 6
+#endif // !defined(PHOENIX_LIMIT)
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/attribute/parametric.hpp>
+#include <boost/spirit/home/classic/attribute/closure.hpp>
+
+#endif // !defined(BOOST_SPIRIT_ATTRIBUTE_MAIN_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/loops.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/loops.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/loops.hpp	(working copy)
@@ -0,0 +1,317 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2002 Raghavendra Satish
+    Copyright (c) 2002 Jeff Westfahl
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_LOOPS_HPP)
+#define BOOST_SPIRIT_LOOPS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  fixed_loop class
+    //
+    //      This class takes care of the construct:
+    //
+    //          repeat_p (exact) [p]
+    //
+    //      where 'p' is a parser and 'exact' is the number of times to
+    //      repeat. The parser iterates over the input exactly 'exact' times.
+    //      The parse function fails if the parser does not match the input
+    //      exactly 'exact' times.
+    //
+    //      This class is parametizable and can accept constant arguments
+    //      (e.g. repeat_p (5) [p]) as well as references to variables (e.g.
+    //      repeat_p (ref (n)) [p]).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ParserT, typename ExactT>
+    class fixed_loop
+    : public unary<ParserT, parser <fixed_loop <ParserT, ExactT> > >
+    {
+    public:
+
+        typedef fixed_loop<ParserT, ExactT>     self_t;
+        typedef unary<ParserT, parser<self_t> >  base_t;
+
+        fixed_loop (ParserT const & subject_, ExactT const & exact)
+        : base_t(subject_), m_exact(exact) {}
+
+        template <typename ScannerT>
+        typename parser_result <self_t, ScannerT>::type
+        parse (ScannerT const & scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t hit = scan.empty_match();
+            std::size_t n = m_exact;
+
+            for (std::size_t i = 0; i < n; ++i)
+            {
+                if (result_t next = this->subject().parse(scan))
+                {
+                    scan.concat_match(hit, next);
+                }
+                else
+                {
+                    return scan.no_match();
+                }
+            }
+
+            return hit;
+        }
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, nil_t>::type type;
+        };
+
+    private:
+
+        ExactT m_exact;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////////
+    //
+    //  finite_loop class
+    //
+    //      This class takes care of the construct:
+    //
+    //          repeat_p (min, max) [p]
+    //
+    //      where 'p' is a parser, 'min' and 'max' specifies the minimum and
+    //      maximum iterations over 'p'. The parser iterates over the input
+    //      at least 'min' times and at most 'max' times. The parse function
+    //      fails if the parser does not match the input at least 'min' times
+    //      and at most 'max' times.
+    //
+    //      This class is parametizable and can accept constant arguments
+    //      (e.g. repeat_p (5, 10) [p]) as well as references to variables
+    //      (e.g. repeat_p (ref (n1), ref (n2)) [p]).
+    //
+    ///////////////////////////////////////////////////////////////////////////////
+    template <typename ParserT, typename MinT, typename MaxT>
+    class finite_loop
+    : public unary<ParserT, parser<finite_loop<ParserT, MinT, MaxT> > >
+    {
+    public:
+
+        typedef finite_loop <ParserT, MinT, MaxT> self_t;
+        typedef unary<ParserT, parser<self_t> >   base_t;
+
+        finite_loop (ParserT const & subject_, MinT const & min, MaxT const & max)
+        : base_t(subject_), m_min(min), m_max(max) {}
+
+        template <typename ScannerT>
+        typename parser_result <self_t, ScannerT>::type
+        parse(ScannerT const & scan) const
+        {
+            BOOST_SPIRIT_ASSERT(m_min <= m_max);
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t hit = scan.empty_match();
+
+            std::size_t n1 = m_min;
+            std::size_t n2 = m_max;
+
+            for (std::size_t i = 0; i < n2; ++i)
+            {
+                typename ScannerT::iterator_t save = scan.first;
+                result_t next = this->subject().parse(scan);
+
+                if (!next)
+                {
+                    if (i >= n1)
+                    {
+                        scan.first = save;
+                        break;
+                    }
+                    else
+                    {
+                        return scan.no_match();
+                    }
+                }
+
+                scan.concat_match(hit, next);
+            }
+
+            return hit;
+        }
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, nil_t>::type type;
+        };
+
+    private:
+
+        MinT    m_min;
+        MaxT    m_max;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////////
+    //
+    //  infinite_loop class
+    //
+    //      This class takes care of the construct:
+    //
+    //          repeat_p (min, more) [p]
+    //
+    //      where 'p' is a parser, 'min' is the minimum iteration over 'p'
+    //      and more specifies that the iteration should proceed
+    //      indefinitely. The parser iterates over the input at least 'min'
+    //      times and continues indefinitely until 'p' fails or all of the
+    //      input is parsed. The parse function fails if the parser does not
+    //      match the input at least 'min' times.
+    //
+    //      This class is parametizable and can accept constant arguments
+    //      (e.g. repeat_p (5, more) [p]) as well as references to variables
+    //      (e.g. repeat_p (ref (n), more) [p]).
+    //
+    ///////////////////////////////////////////////////////////////////////////////
+
+    struct more_t {};
+    more_t const more = more_t ();
+
+    template <typename ParserT, typename MinT>
+    class infinite_loop
+     : public unary<ParserT, parser<infinite_loop<ParserT, MinT> > >
+    {
+    public:
+
+        typedef infinite_loop <ParserT, MinT>   self_t;
+        typedef unary<ParserT, parser<self_t> > base_t;
+
+        infinite_loop (
+            ParserT const& subject_,
+            MinT const& min,
+            more_t const&
+        )
+        : base_t(subject_), m_min(min) {}
+
+        template <typename ScannerT>
+        typename parser_result <self_t, ScannerT>::type
+        parse(ScannerT const & scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            result_t hit = scan.empty_match();
+            std::size_t n = m_min;
+
+            for (std::size_t i = 0; ; ++i)
+            {
+                typename ScannerT::iterator_t save = scan.first;
+                result_t next = this->subject().parse(scan);
+
+                if (!next)
+                {
+                    if (i >= n)
+                    {
+                        scan.first = save;
+                        break;
+                    }
+                    else
+                    {
+                        return scan.no_match();
+                    }
+                }
+
+                scan.concat_match(hit, next);
+            }
+
+            return hit;
+        }
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, nil_t>::type type;
+        };
+
+        private:
+
+        MinT m_min;
+    };
+
+    template <typename ExactT>
+    struct fixed_loop_gen
+    {
+        fixed_loop_gen (ExactT const & exact)
+        : m_exact (exact) {}
+
+        template <typename ParserT>
+        fixed_loop <ParserT, ExactT>
+        operator[](parser <ParserT> const & subject_) const
+        {
+            return fixed_loop <ParserT, ExactT> (subject_.derived (), m_exact);
+        }
+
+        ExactT m_exact;
+    };
+
+    namespace impl {
+
+        template <typename ParserT, typename MinT, typename MaxT>
+        struct loop_traits
+        {
+            typedef typename mpl::if_<
+                boost::is_same<MaxT, more_t>,
+                infinite_loop<ParserT, MinT>,
+                finite_loop<ParserT, MinT, MaxT>
+            >::type type;
+        };
+
+    } // namespace impl
+
+    template <typename MinT, typename MaxT>
+    struct nonfixed_loop_gen
+    {
+       nonfixed_loop_gen (MinT min, MaxT max)
+        : m_min (min), m_max (max) {}
+
+       template <typename ParserT>
+       typename impl::loop_traits<ParserT, MinT, MaxT>::type
+       operator[](parser <ParserT> const & subject_) const
+       {
+           typedef typename impl::loop_traits<ParserT, MinT, MaxT>::type ret_t;
+           return ret_t(
+                subject_.derived(),
+                m_min,
+                m_max);
+       }
+
+       MinT m_min;
+       MaxT m_max;
+    };
+
+    template <typename ExactT>
+    fixed_loop_gen <ExactT>
+    repeat_p(ExactT const & exact)
+    {
+        return fixed_loop_gen <ExactT> (exact);
+    }
+
+    template <typename MinT, typename MaxT>
+    nonfixed_loop_gen <MinT, MaxT>
+    repeat_p(MinT const & min, MaxT const & max)
+    {
+        return nonfixed_loop_gen <MinT, MaxT> (min, max);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // #if !defined(BOOST_SPIRIT_LOOPS_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/functor_parser.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/functor_parser.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/functor_parser.hpp	(working copy)
@@ -0,0 +1,71 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Juan Carlos Arevalo-Baeza
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_FUNCTOR_PARSER_HPP
+#define BOOST_SPIRIT_FUNCTOR_PARSER_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  functor_parser class
+    //
+    //      Once a functor parser has been defined, you can build a real
+    //      parser from it by passing it to this class as the template
+    //      parameter.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template < class FunctorT >
+    struct functor_parser : public parser<functor_parser<FunctorT> >
+    {
+        FunctorT functor;
+
+        functor_parser(): functor() {}
+        functor_parser(FunctorT const& functor_): functor(functor_) {}
+
+        typedef typename FunctorT::result_t functor_result_t;
+        typedef functor_parser<FunctorT> self_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, functor_result_t>::type
+            type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            typedef typename ScannerT::value_t      value_t;
+            typedef typename ScannerT::iterator_t   iterator_t;
+
+            iterator_t const s(scan.first);
+            functor_result_t functor_result;
+            std::ptrdiff_t len = functor(scan, functor_result);
+
+            if (len < 0)
+                return scan.no_match();
+            else
+                return scan.create_match(std::size_t(len), functor_result, s, scan.first);
+        }
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/escape_char_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/escape_char_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/escape_char_fwd.hpp	(working copy)
@@ -0,0 +1,30 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ESCAPE_CHAR_FWD_HPP)
+#define BOOST_SPIRIT_ESCAPE_CHAR_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <unsigned long Flags, typename CharT = char>
+    struct escape_char_parser;
+
+    template <
+        class ParserT, typename ActionT,
+        unsigned long Flags, typename CharT = char>
+    struct escape_char_action;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/escape_char.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/escape_char.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/escape_char.hpp	(working copy)
@@ -0,0 +1,184 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ESCAPE_CHAR_HPP
+#define BOOST_SPIRIT_ESCAPE_CHAR_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <string>
+#include <iterator>
+#include <cctype>
+#include <boost/limits.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/debug.hpp>
+
+#include <boost/spirit/home/classic/utility/escape_char_fwd.hpp>
+#include <boost/spirit/home/classic/utility/impl/escape_char.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  escape_char_action class
+//
+//      Links an escape char parser with a user defined semantic action.
+//      The semantic action may be a function or a functor. A function
+//      should be compatible with the interface:
+//
+//          void f(CharT ch);
+//
+//      A functor should have a member operator() with a compatible signature
+//      as above. The matching character is passed into the function/functor.
+//      This is the default class that character parsers use when dealing with
+//      the construct:
+//
+//          p[f]
+//
+//      where p is a parser and f is a function or functor.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename ParserT, typename ActionT,
+    unsigned long Flags, typename CharT
+>
+struct escape_char_action
+:   public unary<ParserT,
+        parser<escape_char_action<ParserT, ActionT, Flags, CharT> > >
+{
+    typedef escape_char_action
+        <ParserT, ActionT, Flags, CharT>        self_t;
+    typedef action_parser_category              parser_category_t;
+    typedef unary<ParserT, parser<self_t> >     base_t;
+
+    template <typename ScannerT>
+    struct result
+    {
+        typedef typename match_result<ScannerT, CharT>::type type;
+    };
+
+    escape_char_action(ParserT const& p, ActionT const& a)
+    : base_t(p), actor(a) {}
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        return impl::escape_char_action_parse<Flags, CharT>::
+            parse(scan, *this);
+    }
+
+    ActionT const& predicate() const { return actor; }
+
+private:
+
+    ActionT actor;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  escape_char_parser class
+//
+//      The escape_char_parser helps in conjunction with the escape_char_action
+//      template class (see above) in parsing escaped characters. There are two
+//      different variants of this parser: one for parsing C style escaped
+//      characters and one for parsing LEX style escaped characters.
+//
+//      The C style escaped character parser is generated, when the template
+//      parameter 'Flags' is equal to 'c_escapes' (a constant defined in the
+//      file impl/escape_char.ipp). This parser recognizes all valid C escape
+//      character sequences: '\t', '\b', '\f', '\n', '\r', '\"', '\'', '\\'
+//      and the numeric style escapes '\120' (octal) and '\x2f' (hexadecimal)
+//      and converts these to their character equivalent, for instance the
+//      sequence of a backslash and a 'b' is parsed as the character '\b'.
+//      All other escaped characters are rejected by this parser.
+//
+//      The LEX style escaped character parser is generated, when the template
+//      parameter 'Flags' is equal to 'lex_escapes' (a constant defined in the
+//      file impl/escape_char.ipp). This parser recognizes all the C style
+//      escaped character sequences (as described above) and additionally
+//      does not reject all other escape sequences. All not mentioned escape
+//      sequences are converted by the parser to the plain character, for
+//      instance '\a' will be parsed as 'a'.
+//
+//      All not escaped characters are parsed without modification.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <unsigned long Flags, typename CharT>
+struct escape_char_action_parser_gen;
+
+template <unsigned long Flags, typename CharT>
+struct escape_char_parser :
+    public parser<escape_char_parser<Flags, CharT> > {
+
+    // only the values c_escapes and lex_escapes are valid for Flags
+    BOOST_STATIC_ASSERT(Flags == c_escapes || Flags == lex_escapes);
+
+    typedef escape_char_parser<Flags, CharT> self_t;
+    typedef
+        escape_char_action_parser_gen<Flags, CharT>
+        action_parser_generator_t;
+
+    template <typename ScannerT>
+    struct result {
+
+        typedef typename match_result<ScannerT, CharT>::type type;
+    };
+
+    template <typename ActionT>
+    escape_char_action<self_t, ActionT, Flags, CharT>
+    operator[](ActionT const& actor) const
+    {
+        return escape_char_action<self_t, ActionT, Flags, CharT>(*this, actor);
+    }
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const &scan) const
+    {
+        return impl::escape_char_parse<CharT>::parse(scan, *this);
+    }
+};
+
+template <unsigned long Flags, typename CharT>
+struct escape_char_action_parser_gen {
+
+    template <typename ParserT, typename ActionT>
+    static escape_char_action<ParserT, ActionT, Flags, CharT>
+    generate (ParserT const &p, ActionT const &actor)
+    {
+        typedef
+            escape_char_action<ParserT, ActionT, Flags, CharT>
+            action_parser_t;
+        return action_parser_t(p, actor);
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  predefined escape_char_parser objects
+//
+//      These objects should be used for generating correct escaped character
+//      parsers.
+//
+///////////////////////////////////////////////////////////////////////////////
+const escape_char_parser<lex_escapes> lex_escape_ch_p =
+    escape_char_parser<lex_escapes>();
+
+const escape_char_parser<c_escapes> c_escape_ch_p =
+    escape_char_parser<c_escapes>();
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/lists_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/lists_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/lists_fwd.hpp	(working copy)
@@ -0,0 +1,31 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_LISTS_FWD_HPP)
+#define BOOST_SPIRIT_LISTS_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    struct no_list_endtoken;
+
+    template <
+        typename ItemT, typename DelimT, typename EndT = no_list_endtoken,
+        typename CategoryT = plain_parser_category
+    >
+    struct list_parser;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/lists.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/lists.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/lists.hpp	(working copy)
@@ -0,0 +1,340 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_LISTS_HPP
+#define BOOST_SPIRIT_LISTS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/config.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+
+#include <boost/spirit/home/classic/utility/lists_fwd.hpp>
+#include <boost/spirit/home/classic/utility/impl/lists.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  list_parser class
+//
+//      List parsers allow to parse constructs like
+//
+//          item >> *(delim >> item)
+//
+//      where 'item' is an auxiliary expression to parse and 'delim' is an
+//      auxiliary delimiter to parse.
+//
+//      The list_parser class also can match an optional closing delimiter
+//      represented by the 'end' parser at the end of the list:
+//
+//          item >> *(delim >> item) >> !end.
+//
+//      If ItemT is an action_parser_category type (parser with an attached
+//      semantic action) we have to do something special. This happens, if the
+//      user wrote something like:
+//
+//          list_p(item[f], delim)
+//
+//      where 'item' is the parser matching one item of the list sequence and
+//      'f' is a functor to be called after matching one item. If we would do
+//      nothing, the resulting code would parse the sequence as follows:
+//
+//          (item[f] - delim) >> *(delim >> (item[f] - delim))
+//
+//      what in most cases is not what the user expects.
+//      (If this _is_ what you've expected, then please use one of the list_p
+//      generator functions 'direct()', which will inhibit re-attaching
+//      the actor to the item parser).
+//
+//      To make the list parser behave as expected:
+//
+//          (item - delim)[f] >> *(delim >> (item - delim)[f])
+//
+//      the actor attached to the 'item' parser has to be re-attached to the
+//      *(item - delim) parser construct, which will make the resulting list
+//      parser 'do the right thing'.
+//
+//      Additionally special care must be taken, if the item parser is a
+//      unary_parser_category type parser as
+//
+//          list_p(*anychar_p, ',')
+//
+//      which without any refactoring would result in
+//
+//          (*anychar_p - ch_p(','))
+//              >> *( ch_p(',') >> (*anychar_p - ch_p(',')) )
+//
+//      and will not give the expected result (the first *anychar_p will eat up
+//      all the input up to the end of the input stream). So we have to
+//      refactor this into:
+//
+//          *(anychar_p - ch_p(','))
+//              >> *( ch_p(',') >> *(anychar_p - ch_p(',')) )
+//
+//      what will give the correct result.
+//
+//      The case, where the item parser is a combination of the two mentioned
+//      problems (i.e. the item parser is a unary parser  with an attached
+//      action), is handled accordingly too:
+//
+//          list_p((*anychar_p)[f], ',')
+//
+//      will be parsed as expected:
+//
+//          (*(anychar_p - ch_p(',')))[f]
+//              >> *( ch_p(',') >> (*(anychar_p - ch_p(',')))[f] ).
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename ItemT, typename DelimT, typename EndT, typename CategoryT
+>
+struct list_parser :
+    public parser<list_parser<ItemT, DelimT, EndT, CategoryT> > {
+
+    typedef list_parser<ItemT, DelimT, EndT, CategoryT> self_t;
+    typedef CategoryT parser_category_t;
+
+    list_parser(ItemT const &item_, DelimT const &delim_,
+        EndT const& end_ = no_list_endtoken())
+    : item(item_), delim(delim_), end(end_)
+    {}
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        return impl::list_parser_type<CategoryT>
+            ::parse(scan, *this, item, delim, end);
+    }
+
+private:
+    typename as_parser<ItemT>::type::embed_t item;
+    typename as_parser<DelimT>::type::embed_t delim;
+    typename as_parser<EndT>::type::embed_t end;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  List parser generator template
+//
+//      This is a helper for generating a correct list_parser<> from
+//      auxiliary parameters. There are the following types supported as
+//      parameters yet: parsers, single characters and strings (see
+//      as_parser<> in meta/as_parser.hpp).
+//
+//      The list_parser_gen by itself can be used for parsing comma separated
+//      lists without item formatting:
+//
+//          list_p.parse(...)
+//              matches any comma separated list.
+//
+//      If list_p is used with one parameter, this parameter is used to match
+//      the delimiter:
+//
+//          list_p(';').parse(...)
+//              matches any semicolon separated list.
+//
+//      If list_p is used with two parameters, the first parameter is used to
+//      match the items and the second parameter matches the delimiters:
+//
+//          list_p(uint_p, ',').parse(...)
+//              matches comma separated unsigned integers.
+//
+//      If list_p is used with three parameters, the first parameter is used
+//      to match the items, the second one is used to match the delimiters and
+//      the third one is used to match an optional ending token sequence:
+//
+//          list_p(real_p, ';', eol_p).parse(...)
+//              matches a semicolon separated list of real numbers optionally
+//              followed by an end of line.
+//
+//      The list_p in the previous examples denotes the predefined parser
+//      generator, which should be used to define list parsers (see below).
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename CharT = char>
+struct list_parser_gen :
+    public list_parser<kleene_star<anychar_parser>, chlit<CharT> >
+{
+    typedef list_parser_gen<CharT> self_t;
+
+// construct the list_parser_gen object as an list parser for comma separated
+// lists without item formatting.
+    list_parser_gen()
+    : list_parser<kleene_star<anychar_parser>, chlit<CharT> >
+        (*anychar_p, chlit<CharT>(','))
+    {}
+
+// The following generator functions should be used under normal circumstances.
+// (the operator()(...) functions)
+
+    // Generic generator functions for creation of concrete list parsers, which
+    // support 'normal' syntax:
+    //
+    //      item >> *(delim >> item)
+    //
+    // If item isn't given, everything between two delimiters is matched.
+
+    template<typename DelimT>
+    list_parser<
+        kleene_star<anychar_parser>,
+        typename as_parser<DelimT>::type,
+        no_list_endtoken,
+        unary_parser_category      // there is no action to re-attach
+    >
+    operator()(DelimT const &delim_) const
+    {
+        typedef kleene_star<anychar_parser> item_t;
+        typedef typename as_parser<DelimT>::type delim_t;
+
+        typedef
+            list_parser<item_t, delim_t, no_list_endtoken, unary_parser_category>
+            return_t;
+
+        return return_t(*anychar_p, as_parser<DelimT>::convert(delim_));
+    }
+
+    template<typename ItemT, typename DelimT>
+    list_parser<
+        typename as_parser<ItemT>::type,
+        typename as_parser<DelimT>::type,
+        no_list_endtoken,
+        typename as_parser<ItemT>::type::parser_category_t
+    >
+    operator()(ItemT const &item_, DelimT const &delim_) const
+    {
+        typedef typename as_parser<ItemT>::type item_t;
+        typedef typename as_parser<DelimT>::type delim_t;
+        typedef list_parser<item_t, delim_t, no_list_endtoken,
+                BOOST_DEDUCED_TYPENAME item_t::parser_category_t>
+            return_t;
+
+        return return_t(
+            as_parser<ItemT>::convert(item_),
+            as_parser<DelimT>::convert(delim_)
+        );
+    }
+
+    // Generic generator function for creation of concrete list parsers, which
+    // support 'extended' syntax:
+    //
+    //      item >> *(delim >> item) >> !end
+
+    template<typename ItemT, typename DelimT, typename EndT>
+    list_parser<
+        typename as_parser<ItemT>::type,
+        typename as_parser<DelimT>::type,
+        typename as_parser<EndT>::type,
+        typename as_parser<ItemT>::type::parser_category_t
+    >
+    operator()(
+        ItemT const &item_, DelimT const &delim_, EndT const &end_) const
+    {
+        typedef typename as_parser<ItemT>::type item_t;
+        typedef typename as_parser<DelimT>::type delim_t;
+        typedef typename as_parser<EndT>::type end_t;
+
+        typedef list_parser<item_t, delim_t, end_t,
+                BOOST_DEDUCED_TYPENAME item_t::parser_category_t>
+            return_t;
+
+        return return_t(
+            as_parser<ItemT>::convert(item_),
+            as_parser<DelimT>::convert(delim_),
+            as_parser<EndT>::convert(end_)
+        );
+    }
+
+// The following functions should be used, if the 'item' parser has an attached
+// semantic action or is a unary_parser_category type parser and the structure
+// of the resulting list parser should _not_ be refactored during parser
+// construction (see comment above).
+
+    // Generic generator function for creation of concrete list parsers, which
+    // support 'normal' syntax:
+    //
+    //      item >> *(delim >> item)
+
+    template<typename ItemT, typename DelimT>
+    list_parser<
+        typename as_parser<ItemT>::type,
+        typename as_parser<DelimT>::type,
+        no_list_endtoken,
+        plain_parser_category        // inhibit action re-attachment
+    >
+    direct(ItemT const &item_, DelimT const &delim_) const
+    {
+        typedef typename as_parser<ItemT>::type item_t;
+        typedef typename as_parser<DelimT>::type delim_t;
+        typedef list_parser<item_t, delim_t, no_list_endtoken,
+                plain_parser_category>
+            return_t;
+
+        return return_t(
+            as_parser<ItemT>::convert(item_),
+            as_parser<DelimT>::convert(delim_)
+        );
+    }
+
+    // Generic generator function for creation of concrete list parsers, which
+    // support 'extended' syntax:
+    //
+    //      item >> *(delim >> item) >> !end
+
+    template<typename ItemT, typename DelimT, typename EndT>
+    list_parser<
+        typename as_parser<ItemT>::type,
+        typename as_parser<DelimT>::type,
+        typename as_parser<EndT>::type,
+        plain_parser_category        // inhibit action re-attachment
+    >
+    direct(
+        ItemT const &item_, DelimT const &delim_, EndT const &end_) const
+    {
+        typedef typename as_parser<ItemT>::type item_t;
+        typedef typename as_parser<DelimT>::type delim_t;
+        typedef typename as_parser<EndT>::type end_t;
+
+        typedef
+            list_parser<item_t, delim_t, end_t, plain_parser_category>
+            return_t;
+
+        return return_t(
+            as_parser<ItemT>::convert(item_),
+            as_parser<DelimT>::convert(delim_),
+            as_parser<EndT>::convert(end_)
+        );
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Predefined list parser generator
+//
+//      The list_p parser generator can be used
+//        - by itself for parsing comma separated lists without item formatting
+//      or
+//        - for generating list parsers with auxiliary parser parameters
+//          for the 'item', 'delim' and 'end' subsequences.
+//      (see comment above)
+//
+///////////////////////////////////////////////////////////////////////////////
+const list_parser_gen<> list_p = list_parser_gen<>();
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/chset_operators.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/chset_operators.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/chset_operators.hpp	(working copy)
@@ -0,0 +1,402 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CHSET_OPERATORS_HPP
+#define BOOST_SPIRIT_CHSET_OPERATORS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/utility/chset.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  chset free operators
+//
+//      Where a and b are both chsets, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+//      Where a is a chset, implements:
+//
+//          ~a
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator~(chset<CharT> const& a);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  range <--> chset free operators
+//
+//      Where a is a chset and b is a range, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, range<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, range<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, range<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, range<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(range<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(range<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(range<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(range<CharT> const& a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  chlit <--> chset free operators
+//
+//      Where a is a chset and b is a chlit, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, chlit<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, chlit<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, chlit<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, chlit<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chlit<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chlit<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chlit<CharT> const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chlit<CharT> const& a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  negated_char_parser<range> <--> chset free operators
+//
+//      Where a is a chset and b is a range, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  negated_char_parser<chlit> <--> chset free operators
+//
+//      Where a is a chset and b is a chlit, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  literal primitives <--> chset free operators
+//
+//      Where a is a chset and b is a literal primitive,
+//      and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, CharT b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, CharT b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, CharT b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, CharT b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(CharT a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(CharT a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(CharT a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(CharT a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  anychar_parser <--> chset free operators
+//
+//      Where a is chset and b is a anychar_parser, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, anychar_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, anychar_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, anychar_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, anychar_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(anychar_parser a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(anychar_parser a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(anychar_parser a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(anychar_parser a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  nothing_parser <--> chset free operators
+//
+//      Where a is chset and b is nothing_parser, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(chset<CharT> const& a, nothing_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(chset<CharT> const& a, nothing_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(chset<CharT> const& a, nothing_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(chset<CharT> const& a, nothing_parser b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator|(nothing_parser a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator&(nothing_parser a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator-(nothing_parser a, chset<CharT> const& b);
+
+//////////////////////////////////
+template <typename CharT>
+chset<CharT>
+operator^(nothing_parser a, chset<CharT> const& b);
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/utility/impl/chset_operators.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/chset.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/chset.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/chset.hpp	(working copy)
@@ -0,0 +1,187 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CHSET_HPP
+#define BOOST_SPIRIT_CHSET_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/shared_ptr.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/utility/impl/chset/basic_chset.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+namespace utility { namespace impl {
+
+    // This is here because some compilers choke on out-of-line member
+    // template functions.  And we don't want to put the whole algorithm
+    // in the chset constructor in the class definition.
+    template <typename CharT, typename CharT2>
+    void construct_chset(boost::shared_ptr<basic_chset<CharT> >& ptr,
+            CharT2 const* definition);
+
+}} // namespace utility::impl
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  chset class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT = char>
+class chset: public char_parser<chset<CharT> > {
+
+public:
+                    chset();
+                    chset(chset const& arg_);
+    explicit        chset(CharT arg_);
+    explicit        chset(anychar_parser arg_);
+    explicit        chset(nothing_parser arg_);
+    explicit        chset(chlit<CharT> const& arg_);
+    explicit        chset(range<CharT> const& arg_);
+    explicit        chset(negated_char_parser<chlit<CharT> > const& arg_);
+    explicit        chset(negated_char_parser<range<CharT> > const& arg_);
+
+                    template <typename CharT2>
+    explicit        chset(CharT2 const* definition)
+                    : ptr(new basic_chset<CharT>())
+                    {
+                        utility::impl::construct_chset(ptr, definition);
+                    }
+                    ~chset();
+
+    chset&          operator=(chset const& rhs);
+    chset&          operator=(CharT rhs);
+    chset&          operator=(anychar_parser rhs);
+    chset&          operator=(nothing_parser rhs);
+    chset&          operator=(chlit<CharT> const& rhs);
+    chset&          operator=(range<CharT> const& rhs);
+    chset&          operator=(negated_char_parser<chlit<CharT> > const& rhs);
+    chset&          operator=(negated_char_parser<range<CharT> > const& rhs);
+
+    void            set(range<CharT> const& arg_);
+    void            set(negated_char_parser<chlit<CharT> > const& arg_);
+    void            set(negated_char_parser<range<CharT> > const& arg_);
+
+    void            clear(range<CharT> const& arg_);
+    void            clear(negated_char_parser<range<CharT> > const& arg_);
+    bool            test(CharT ch) const;
+    chset&          inverse();
+    void            swap(chset& x);
+
+    chset&          operator|=(chset const& x);
+    chset&          operator&=(chset const& x);
+    chset&          operator-=(chset const& x);
+    chset&          operator^=(chset const& x);
+
+private:
+
+    boost::shared_ptr<basic_chset<CharT> > ptr;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Generator functions
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+chset_p(chlit<CharT> const& arg_)
+{ return chset<CharT>(arg_); }
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+chset_p(range<CharT> const& arg_)
+{ return chset<CharT>(arg_); }
+
+template <typename CharT>
+inline chset<CharT>
+chset_p(negated_char_parser<chlit<CharT> > const& arg_)
+{ return chset<CharT>(arg_); }
+
+template <typename CharT>
+inline chset<CharT>
+chset_p(negated_char_parser<range<CharT> > const& arg_)
+{ return chset<CharT>(arg_); }
+
+//////////////////////////////////
+inline chset<char>
+chset_p(char const* init)
+{ return chset<char>(init); }
+
+//////////////////////////////////
+inline chset<wchar_t>
+chset_p(wchar_t const* init)
+{ return chset<wchar_t>(init); }
+
+//////////////////////////////////
+inline chset<char>
+chset_p(char ch)
+{ return chset<char>(ch); }
+
+//////////////////////////////////
+inline chset<wchar_t>
+chset_p(wchar_t ch)
+{ return chset<wchar_t>(ch); }
+
+//////////////////////////////////
+inline chset<int>
+chset_p(int ch)
+{ return chset<int>(ch); }
+
+//////////////////////////////////
+inline chset<unsigned int>
+chset_p(unsigned int ch)
+{ return chset<unsigned int>(ch); }
+
+//////////////////////////////////
+inline chset<short>
+chset_p(short ch)
+{ return chset<short>(ch); }
+
+#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
+//////////////////////////////////
+inline chset<unsigned short>
+chset_p(unsigned short ch)
+{ return chset<unsigned short>(ch); }
+#endif
+//////////////////////////////////
+inline chset<long>
+chset_p(long ch)
+{ return chset<long>(ch); }
+
+//////////////////////////////////
+inline chset<unsigned long>
+chset_p(unsigned long ch)
+{ return chset<unsigned long>(ch); }
+
+#ifdef BOOST_HAS_LONG_LONG
+//////////////////////////////////
+inline chset< ::boost::long_long_type>
+chset_p( ::boost::long_long_type ch)
+{ return chset< ::boost::long_long_type>(ch); }
+
+//////////////////////////////////
+inline chset< ::boost::ulong_long_type>
+chset_p( ::boost::ulong_long_type ch)
+{ return chset< ::boost::ulong_long_type>(ch); }
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/utility/impl/chset.ipp>
+#include <boost/spirit/home/classic/utility/chset_operators.hpp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/escape_char.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/escape_char.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/escape_char.ipp	(working copy)
@@ -0,0 +1,224 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Daniel Nuffer
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ESCAPE_CHAR_IPP
+#define BOOST_SPIRIT_ESCAPE_CHAR_IPP
+
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/numerics.hpp>
+#include <boost/spirit/home/classic/core/composite/difference.hpp>
+#include <boost/spirit/home/classic/core/composite/sequence.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  escape_char_parser class
+//
+///////////////////////////////////////////////////////////////////////////////
+
+const unsigned long c_escapes = 1;
+const unsigned long lex_escapes = c_escapes << 1;
+
+//////////////////////////////////
+namespace impl {
+
+    //////////////////////////////////
+#if (defined(BOOST_MSVC) && (BOOST_MSVC <= 1310))
+#pragma warning(push)
+#pragma warning(disable:4127)
+#endif
+    template <unsigned long Flags, typename CharT>
+    struct escape_char_action_parse {
+
+        template <typename ParserT, typename ScannerT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const &p)
+        {
+            // Actually decode the escape char.
+            typedef CharT char_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+            typedef typename parser_result<ParserT, ScannerT>::type result_t;
+
+            if (scan.first != scan.last) {
+
+                iterator_t save = scan.first;
+                if (result_t hit = p.subject().parse(scan)) {
+
+                    char_t unescaped;
+
+                    scan.first = save;
+                    if (*scan.first == '\\') {
+
+                        ++scan.first;
+                        switch (*scan.first) {
+                        case 'b':   unescaped = '\b';   ++scan.first; break;
+                        case 't':   unescaped = '\t';   ++scan.first; break;
+                        case 'n':   unescaped = '\n';   ++scan.first; break;
+                        case 'f':   unescaped = '\f';   ++scan.first; break;
+                        case 'r':   unescaped = '\r';   ++scan.first; break;
+                        case '"':   unescaped = '"';    ++scan.first; break;
+                        case '\'':  unescaped = '\'';   ++scan.first; break;
+                        case '\\':  unescaped = '\\';   ++scan.first; break;
+
+                        case 'x': case 'X':
+                            {
+                                char_t hex = 0;
+                                char_t const lim =
+                                    (std::numeric_limits<char_t>::max)() >> 4;
+
+                                ++scan.first;
+                                while (scan.first != scan.last)
+                                {
+                                    char_t c = *scan.first;
+                                    if (hex > lim && impl::isxdigit_(c))
+                                    {
+                                        // overflow detected
+                                        scan.first = save;
+                                        return scan.no_match();
+                                    }
+                                    if (impl::isdigit_(c))
+                                    {
+                                        hex <<= 4;
+                                        hex |= c - '0';
+                                        ++scan.first;
+                                    }
+                                    else if (impl::isxdigit_(c))
+                                    {
+                                        hex <<= 4;
+                                        c = impl::toupper_(c);
+                                        hex |= c - 'A' + 0xA;
+                                        ++scan.first;
+                                    }
+                                    else
+                                    {
+                                        break; // reached the end of the number
+                                    }
+                                }
+                                unescaped = hex;
+                            }
+                            break;
+
+                        case '0': case '1': case '2': case '3':
+                        case '4': case '5': case '6': case '7':
+                            {
+                                char_t oct = 0;
+                                char_t const lim =
+                                    (std::numeric_limits<char_t>::max)() >> 3;
+                                while (scan.first != scan.last)
+                                {
+                                    char_t c = *scan.first;
+                                    if (oct > lim && (c >= '0' && c <= '7'))
+                                    {
+                                        // overflow detected
+                                        scan.first = save;
+                                        return scan.no_match();
+                                    }
+
+                                    if (c >= '0' && c <= '7')
+                                    {
+                                        oct <<= 3;
+                                        oct |= c - '0';
+                                        ++scan.first;
+                                    }
+                                    else
+                                    {
+                                        break; // reached end of digits
+                                    }
+                                }
+                                unescaped = oct;
+                            }
+                            break;
+
+                        default:
+                            if (Flags & c_escapes)
+                            {
+                                // illegal C escape sequence
+                                scan.first = save;
+                                return scan.no_match();
+                            }
+                            else
+                            {
+                                unescaped = *scan.first;
+                                ++scan.first;
+                            }
+                            break;
+                        }
+                    }
+                    else {
+                        unescaped = *scan.first;
+                        ++scan.first;
+                    }
+
+                    scan.do_action(p.predicate(), unescaped, save, scan.first);
+                    return hit;
+                }
+            }
+            return scan.no_match(); // overflow detected
+        }
+    };
+#if (defined(BOOST_MSVC) && (BOOST_MSVC <= 1310))
+#pragma warning(pop)
+#endif
+
+    //////////////////////////////////
+    template <typename CharT>
+    struct escape_char_parse {
+
+        template <typename ScannerT, typename ParserT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const &scan, ParserT const &/*p*/)
+        {
+            typedef
+                uint_parser<CharT, 8, 1,
+                    std::numeric_limits<CharT>::digits / 3 + 1
+                >
+                oct_parser_t;
+            typedef
+                uint_parser<CharT, 16, 1,
+                    std::numeric_limits<CharT>::digits / 4 + 1
+                >
+                hex_parser_t;
+
+            typedef alternative<difference<anychar_parser, chlit<CharT> >,
+                sequence<chlit<CharT>, alternative<alternative<oct_parser_t,
+                sequence<inhibit_case<chlit<CharT> >, hex_parser_t > >,
+                difference<difference<anychar_parser,
+                inhibit_case<chlit<CharT> > >, oct_parser_t > > > >
+                parser_t;
+
+            static parser_t p =
+                ( (anychar_p - chlit<CharT>(CharT('\\')))
+                | (chlit<CharT>(CharT('\\')) >>
+                    (  oct_parser_t()
+                     | as_lower_d[chlit<CharT>(CharT('x'))] >> hex_parser_t()
+                     | (anychar_p - as_lower_d[chlit<CharT>(CharT('x'))] - oct_parser_t())
+                    )
+                ));
+
+            BOOST_SPIRIT_DEBUG_TRACE_NODE(p,
+                (BOOST_SPIRIT_DEBUG_FLAGS & BOOST_SPIRIT_DEBUG_FLAGS_ESCAPE_CHAR) != 0);
+
+            return p.parse(scan);
+        }
+    };
+
+///////////////////////////////////////////////////////////////////////////////
+} // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/lists.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/lists.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/lists.ipp	(working copy)
@@ -0,0 +1,168 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_LISTS_IPP
+#define BOOST_SPIRIT_LISTS_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/meta/refactoring.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  list_parser_type class implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+struct no_list_endtoken { typedef no_list_endtoken embed_t; };
+
+namespace impl {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Refactor the original list item parser
+//
+///////////////////////////////////////////////////////////////////////////////
+
+    //  match list with 'extended' syntax
+    template <typename EndT>
+    struct select_list_parse_refactor {
+
+        template <
+            typename ParserT, typename ScannerT,
+            typename ItemT, typename DelimT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const& /*p*/,
+            ItemT const &item, DelimT const &delim, EndT const &end)
+        {
+            typedef refactor_action_gen<refactor_unary_gen<> > refactor_t;
+            const refactor_t refactor_item_d = refactor_t(refactor_unary_d);
+
+            return (
+                    refactor_item_d[item - (end | delim)]
+                >> *(delim >> refactor_item_d[item - (end | delim)])
+                >> !(delim >> end)
+            ).parse(scan);
+        }
+    };
+
+    //  match list with 'normal' syntax (without an 'end' parser)
+    template <>
+    struct select_list_parse_refactor<no_list_endtoken> {
+
+        template <
+            typename ParserT, typename ScannerT,
+            typename ItemT, typename DelimT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const& /*p*/,
+            ItemT const &item, DelimT const &delim, no_list_endtoken const&)
+        {
+            typedef refactor_action_gen<refactor_unary_gen<> > refactor_t;
+            const refactor_t refactor_item_d = refactor_t(refactor_unary_d);
+
+            return (
+                    refactor_item_d[item - delim]
+                >> *(delim >> refactor_item_d[item - delim])
+            ).parse(scan);
+        }
+    };
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Do not refactor the original list item parser.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+    //  match list with 'extended' syntax
+    template <typename EndT>
+    struct select_list_parse_no_refactor {
+
+        template <
+            typename ParserT, typename ScannerT,
+            typename ItemT, typename DelimT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const& /*p*/,
+            ItemT const &item, DelimT const &delim, EndT const &end)
+        {
+            return (
+                    (item - (end | delim))
+                >> *(delim >> (item - (end | delim)))
+                >> !(delim >> end)
+            ).parse(scan);
+        }
+    };
+
+    //  match list with 'normal' syntax (without an 'end' parser)
+    template <>
+    struct select_list_parse_no_refactor<no_list_endtoken> {
+
+        template <
+            typename ParserT, typename ScannerT,
+            typename ItemT, typename DelimT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const& /*p*/,
+            ItemT const &item, DelimT const &delim, no_list_endtoken const&)
+        {
+            return (
+                    (item - delim)
+                >> *(delim >> (item - delim))
+            ).parse(scan);
+        }
+    };
+
+    // the refactoring is handled by the refactoring parsers, so here there
+    // is no need to pay attention to these issues.
+
+    template <typename CategoryT>
+    struct list_parser_type {
+
+        template <
+            typename ParserT, typename ScannerT,
+            typename ItemT, typename DelimT, typename EndT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const& p,
+              ItemT const &item, DelimT const &delim, EndT const &end)
+        {
+            return select_list_parse_refactor<EndT>::
+                parse(scan, p, item, delim, end);
+        }
+    };
+
+    template <>
+    struct list_parser_type<plain_parser_category> {
+
+        template <
+            typename ParserT, typename ScannerT,
+            typename ItemT, typename DelimT, typename EndT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ScannerT const& scan, ParserT const& p,
+              ItemT const &item, DelimT const &delim, EndT const &end)
+        {
+            return select_list_parse_no_refactor<EndT>::
+                parse(scan, p, item, delim, end);
+        }
+    };
+
+}   // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/range_run.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/range_run.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/range_run.hpp	(working copy)
@@ -0,0 +1,127 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_RANGE_RUN_HPP
+#define BOOST_SPIRIT_RANGE_RUN_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <vector>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+namespace utility { namespace impl {
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  range class
+    //
+    //      Implements a closed range of values. This class is used in
+    //      the implementation of the range_run class.
+    //
+    //      { Low level implementation detail }
+    //      { Not to be confused with BOOST_SPIRIT_CLASSIC_NS::range }
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT>
+    struct range {
+
+                        range(CharT first, CharT last);
+
+        bool            is_valid() const;
+        bool            includes(CharT v) const;
+        bool            includes(range const& r) const;
+        bool            overlaps(range const& r) const;
+        void            merge(range const& r);
+
+        CharT first;
+        CharT last;
+    };
+
+    //////////////////////////////////
+    template <typename CharT>
+    struct range_char_compare {
+
+        bool operator()(range<CharT> const& x, const CharT y) const
+        { return x.first < y; }
+
+        bool operator()(const CharT x, range<CharT> const& y) const
+        { return x < y.first; }
+
+        // This additional operator is required for the checked STL shipped
+        // with VC8 testing the ordering of the iterators passed to the
+        // std::lower_bound algo this range_char_compare<> predicate is passed
+        // to.
+        bool operator()(range<CharT> const& x, range<CharT> const& y) const
+        { return x.first < y.first; }
+    };
+
+    //////////////////////////////////
+    template <typename CharT>
+    struct range_compare {
+
+        bool operator()(range<CharT> const& x, range<CharT> const& y) const
+        { return x.first < y.first; }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  range_run
+    //
+    //      An implementation of a sparse bit (boolean) set. The set uses
+    //      a sorted vector of disjoint ranges. This class implements the
+    //      bare minimum essentials from which the full range of set
+    //      operators can be implemented. The set is constructed from
+    //      ranges. Internally, adjacent or overlapping ranges are
+    //      coalesced.
+    //
+    //      range_runs are very space-economical in situations where there
+    //      are lots of ranges and a few individual disjoint values.
+    //      Searching is O(log n) where n is the number of ranges.
+    //
+    //      { Low level implementation detail }
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT>
+    class range_run {
+
+    public:
+
+        typedef range<CharT> range_t;
+        typedef std::vector<range_t> run_t;
+        typedef typename run_t::iterator iterator;
+        typedef typename run_t::const_iterator const_iterator;
+
+        void            swap(range_run& rr);
+        bool            test(CharT v) const;
+        void            set(range_t const& r);
+        void            clear(range_t const& r);
+        void            clear();
+
+        const_iterator  begin() const;
+        const_iterator  end() const;
+
+    private:
+
+        void            merge(iterator iter, range_t const& r);
+
+        run_t run;
+    };
+
+}}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS::utility::impl
+
+#endif
+
+#include <boost/spirit/home/classic/utility/impl/chset/range_run.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/range_run.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/range_run.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/range_run.ipp	(working copy)
@@ -0,0 +1,218 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_RANGE_RUN_IPP
+#define BOOST_SPIRIT_RANGE_RUN_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <algorithm> // for std::lower_bound
+#include <boost/spirit/home/classic/core/assert.hpp> // for BOOST_SPIRIT_ASSERT
+#include <boost/spirit/home/classic/utility/impl/chset/range_run.hpp>
+#include <boost/spirit/home/classic/debug.hpp>
+#include <boost/limits.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace utility { namespace impl {
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  range class implementation
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <typename CharT>
+        inline range<CharT>::range(CharT first_, CharT last_)
+        : first(first_), last(last_) {}
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline bool
+        range<CharT>::is_valid() const
+        { return first <= last; }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline bool
+        range<CharT>::includes(range const& r) const
+        { return (first <= r.first) && (last >= r.last); }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline bool
+        range<CharT>::includes(CharT v) const
+        { return (first <= v) && (last >= v); }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline bool
+        range<CharT>::overlaps(range const& r) const
+        {
+            CharT decr_first =
+                first == (std::numeric_limits<CharT>::min)() ? first : first-1;
+            CharT incr_last =
+                last == (std::numeric_limits<CharT>::max)() ? last : last+1;
+
+            return (decr_first <= r.last) && (incr_last >= r.first);
+        }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline void
+        range<CharT>::merge(range const& r)
+        {
+            first = (std::min)(first, r.first);
+            last = (std::max)(last, r.last);
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        //
+        //  range_run class implementation
+        //
+        ///////////////////////////////////////////////////////////////////////
+        template <typename CharT>
+        inline bool
+        range_run<CharT>::test(CharT v) const
+        {
+            if (!run.empty())
+            {
+                const_iterator iter =
+                    std::lower_bound(
+                        run.begin(), run.end(), v,
+                        range_char_compare<CharT>()
+                    );
+
+                if (iter != run.end() && iter->includes(v))
+                    return true;
+                if (iter != run.begin())
+                    return (--iter)->includes(v);
+            }
+            return false;
+        }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline void
+        range_run<CharT>::swap(range_run& rr)
+        { run.swap(rr.run); }
+
+        //////////////////////////////////
+        template <typename CharT>
+        void
+        range_run<CharT>::merge(iterator iter, range<CharT> const& r)
+        {
+            iter->merge(r);
+            iterator i = iter + 1;
+
+            while (i != run.end() && iter->overlaps(*i))
+                iter->merge(*i++);
+
+            run.erase(iter+1, i);
+        }
+
+        //////////////////////////////////
+        template <typename CharT>
+        void
+        range_run<CharT>::set(range<CharT> const& r)
+        {
+            BOOST_SPIRIT_ASSERT(r.is_valid());
+            if (!run.empty())
+            {
+                iterator iter =
+                    std::lower_bound(
+                        run.begin(), run.end(), r,
+                        range_compare<CharT>()
+                    );
+
+                if ((iter != run.end() && iter->includes(r)) ||
+                    ((iter != run.begin()) && (iter - 1)->includes(r)))
+                    return;
+
+                if (iter != run.begin() && (iter - 1)->overlaps(r))
+                    merge(--iter, r);
+
+                else if (iter != run.end() && iter->overlaps(r))
+                    merge(iter, r);
+
+                else
+                    run.insert(iter, r);
+            }
+            else
+            {
+                run.push_back(r);
+            }
+        }
+
+        //////////////////////////////////
+        template <typename CharT>
+        void
+        range_run<CharT>::clear(range<CharT> const& r)
+        {
+            BOOST_SPIRIT_ASSERT(r.is_valid());
+            if (!run.empty())
+            {
+                iterator iter =
+                    std::lower_bound(
+                        run.begin(), run.end(), r,
+                        range_compare<CharT>()
+                    );
+
+                iterator left_iter;
+
+                if ((iter != run.begin()) &&
+                        (left_iter = (iter - 1))->includes(r.first))
+                {
+                    if (left_iter->last > r.last)
+                    {
+                        CharT save_last = left_iter->last;
+                        left_iter->last = r.first-1;
+                        run.insert(iter, range<CharT>(r.last+1, save_last));
+                        return;
+                    }
+                    else
+                    {
+                        left_iter->last = r.first-1;
+                    }
+                }
+
+                iterator i = iter;
+                while (i != run.end() && r.includes(*i))
+                    i++;
+                if (i != run.end() && i->includes(r.last))
+                    i->first = r.last+1;
+                run.erase(iter, i);
+            }
+        }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline void
+        range_run<CharT>::clear()
+        { run.clear(); }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline typename range_run<CharT>::const_iterator
+        range_run<CharT>::begin() const
+        { return run.begin(); }
+
+        //////////////////////////////////
+        template <typename CharT>
+        inline typename range_run<CharT>::const_iterator
+        range_run<CharT>::end() const
+        { return run.end(); }
+
+    }} // namespace utility::impl
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/basic_chset.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/basic_chset.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/basic_chset.hpp	(working copy)
@@ -0,0 +1,107 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_BASIC_CHSET_HPP
+#define BOOST_SPIRIT_BASIC_CHSET_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <bitset>
+#include <climits>
+#include <boost/spirit/home/classic/utility/impl/chset/range_run.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  basic_chset: basic character set implementation using range_run
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT>
+    class basic_chset
+    {
+    public:
+                            basic_chset();
+                            basic_chset(basic_chset const& arg_);
+
+        bool                test(CharT v) const;
+        void                set(CharT from, CharT to);
+        void                set(CharT c);
+        void                clear(CharT from, CharT to);
+        void                clear(CharT c);
+        void                clear();
+
+        void                inverse();
+        void                swap(basic_chset& x);
+
+        basic_chset&        operator|=(basic_chset const& x);
+        basic_chset&        operator&=(basic_chset const& x);
+        basic_chset&        operator-=(basic_chset const& x);
+        basic_chset&        operator^=(basic_chset const& x);
+
+        private: utility::impl::range_run<CharT> rr;
+    };
+
+    #if (CHAR_BIT == 8)
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  basic_chset: specializations for 8 bit chars using std::bitset
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename CharT>
+    class basic_chset_8bit {
+
+    public:
+                            basic_chset_8bit();
+                            basic_chset_8bit(basic_chset_8bit const& arg_);
+
+        bool                test(CharT v) const;
+        void                set(CharT from, CharT to);
+        void                set(CharT c);
+        void                clear(CharT from, CharT to);
+        void                clear(CharT c);
+        void                clear();
+
+        void                inverse();
+        void                swap(basic_chset_8bit& x);
+
+        basic_chset_8bit&   operator|=(basic_chset_8bit const& x);
+        basic_chset_8bit&   operator&=(basic_chset_8bit const& x);
+        basic_chset_8bit&   operator-=(basic_chset_8bit const& x);
+        basic_chset_8bit&   operator^=(basic_chset_8bit const& x);
+
+        private: std::bitset<256> bset;
+    };
+
+    /////////////////////////////////
+    template <>
+    class basic_chset<char>
+    : public basic_chset_8bit<char> {};
+
+    /////////////////////////////////
+    template <>
+    class basic_chset<signed char>
+    : public basic_chset_8bit<signed char> {};
+
+    /////////////////////////////////
+    template <>
+    class basic_chset<unsigned char>
+    : public basic_chset_8bit<unsigned char> {};
+
+#endif
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+#include <boost/spirit/home/classic/utility/impl/chset/basic_chset.ipp>
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/basic_chset.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/basic_chset.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset/basic_chset.ipp	(working copy)
@@ -0,0 +1,246 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_BASIC_CHSET_IPP
+#define BOOST_SPIRIT_BASIC_CHSET_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <bitset>
+#include <boost/spirit/home/classic/utility/impl/chset/basic_chset.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  basic_chset: character set implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline basic_chset<CharT>::basic_chset() {}
+
+//////////////////////////////////
+template <typename CharT>
+inline basic_chset<CharT>::basic_chset(basic_chset const& arg_)
+: rr(arg_.rr) {}
+
+//////////////////////////////////
+template <typename CharT>
+inline bool
+basic_chset<CharT>::test(CharT v) const
+{ return rr.test(v); }
+
+//////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset<CharT>::set(CharT from, CharT to)
+{ rr.set(utility::impl::range<CharT>(from, to)); }
+
+//////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset<CharT>::set(CharT c)
+{ rr.set(utility::impl::range<CharT>(c, c)); }
+
+//////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset<CharT>::clear(CharT from, CharT to)
+{ rr.clear(utility::impl::range<CharT>(from, to)); }
+
+//////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset<CharT>::clear()
+{ rr.clear(); }
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset<CharT>::inverse()
+{
+    basic_chset inv;
+    inv.set(
+        (std::numeric_limits<CharT>::min)(),
+        (std::numeric_limits<CharT>::max)()
+    );
+    inv -= *this;
+    swap(inv);
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset<CharT>::swap(basic_chset& x)
+{ rr.swap(x.rr); }
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset<CharT>&
+basic_chset<CharT>::operator|=(basic_chset<CharT> const& x)
+{
+    typedef typename utility::impl::range_run<CharT>::const_iterator const_iterator;
+    for (const_iterator iter = x.rr.begin(); iter != x.rr.end(); ++iter)
+        rr.set(*iter);
+    return *this;
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset<CharT>&
+basic_chset<CharT>::operator&=(basic_chset<CharT> const& x)
+{
+    basic_chset inv;
+    inv.set(
+        (std::numeric_limits<CharT>::min)(),
+        (std::numeric_limits<CharT>::max)()
+    );
+    inv -= x;
+    *this -= inv;
+    return *this;
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset<CharT>&
+basic_chset<CharT>::operator-=(basic_chset<CharT> const& x)
+{
+    typedef typename utility::impl::range_run<CharT>::const_iterator const_iterator;
+    for (const_iterator iter = x.rr.begin(); iter != x.rr.end(); ++iter)
+        rr.clear(*iter);
+    return *this;
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset<CharT>&
+basic_chset<CharT>::operator^=(basic_chset<CharT> const& x)
+{
+    basic_chset bma = x;
+    bma -= *this;
+    *this -= x;
+    *this |= bma;
+    return *this;
+}
+
+#if (CHAR_BIT == 8)
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  basic_chset: specializations for 8 bit chars using std::bitset
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline basic_chset_8bit<CharT>::basic_chset_8bit() {}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset_8bit<CharT>::basic_chset_8bit(basic_chset_8bit const& arg_)
+: bset(arg_.bset) {}
+
+/////////////////////////////////
+template <typename CharT>
+inline bool
+basic_chset_8bit<CharT>::test(CharT v) const
+{ return bset.test((unsigned char)v); }
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::set(CharT from, CharT to)
+{
+    for (int i = from; i <= to; ++i)
+        bset.set((unsigned char)i);
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::set(CharT c)
+{ bset.set((unsigned char)c); }
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::clear(CharT from, CharT to)
+{
+    for (int i = from; i <= to; ++i)
+        bset.reset((unsigned char)i);
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::clear(CharT c)
+{ bset.reset((unsigned char)c); }
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::clear()
+{ bset.reset(); }
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::inverse()
+{ bset.flip(); }
+
+/////////////////////////////////
+template <typename CharT>
+inline void
+basic_chset_8bit<CharT>::swap(basic_chset_8bit& x)
+{ std::swap(bset, x.bset); }
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset_8bit<CharT>&
+basic_chset_8bit<CharT>::operator|=(basic_chset_8bit const& x)
+{
+    bset |= x.bset;
+    return *this;
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset_8bit<CharT>&
+basic_chset_8bit<CharT>::operator&=(basic_chset_8bit const& x)
+{
+    bset &= x.bset;
+    return *this;
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset_8bit<CharT>&
+basic_chset_8bit<CharT>::operator-=(basic_chset_8bit const& x)
+{
+    bset &= ~x.bset;
+    return *this;
+}
+
+/////////////////////////////////
+template <typename CharT>
+inline basic_chset_8bit<CharT>&
+basic_chset_8bit<CharT>::operator^=(basic_chset_8bit const& x)
+{
+    bset ^= x.bset;
+    return *this;
+}
+
+#endif
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset_operators.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset_operators.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset_operators.ipp	(working copy)
@@ -0,0 +1,666 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CHSET_OPERATORS_IPP
+#define BOOST_SPIRIT_CHSET_OPERATORS_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/limits.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) |= b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) -= b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator~(chset<CharT> const& a)
+{
+    return chset<CharT>(a).inverse();
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) &= b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) ^= b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  range <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, range<CharT> const& b)
+{
+    chset<CharT> a_(a);
+    a_.set(b);
+    return a_;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, range<CharT> const& b)
+{
+    chset<CharT> a_(a);
+    if(b.first != (std::numeric_limits<CharT>::min)()) {
+        a_.clear(range<CharT>((std::numeric_limits<CharT>::min)(), b.first - 1));
+    }
+    if(b.last != (std::numeric_limits<CharT>::max)()) {
+        a_.clear(range<CharT>(b.last + 1, (std::numeric_limits<CharT>::max)()));
+    }
+    return a_;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, range<CharT> const& b)
+{
+    chset<CharT> a_(a);
+    a_.clear(b);
+    return a_;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, range<CharT> const& b)
+{
+    return a ^ chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(range<CharT> const& a, chset<CharT> const& b)
+{
+    chset<CharT> b_(b);
+    b_.set(a);
+    return b_;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(range<CharT> const& a, chset<CharT> const& b)
+{
+    chset<CharT> b_(b);
+    if(a.first != (std::numeric_limits<CharT>::min)()) {
+        b_.clear(range<CharT>((std::numeric_limits<CharT>::min)(), a.first - 1));
+    }
+    if(a.last != (std::numeric_limits<CharT>::max)()) {
+        b_.clear(range<CharT>(a.last + 1, (std::numeric_limits<CharT>::max)()));
+    }
+    return b_;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(range<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) - b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(range<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) ^ b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  literal primitives <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, CharT b)
+{
+    return a | chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, CharT b)
+{
+    return a & chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, CharT b)
+{
+    return a - chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, CharT b)
+{
+    return a ^ chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(CharT a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) | b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(CharT a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) & b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(CharT a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) - b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(CharT a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) ^ b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  chlit <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, chlit<CharT> const& b)
+{
+    return a | chset<CharT>(b.ch);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, chlit<CharT> const& b)
+{
+    return a & chset<CharT>(b.ch);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, chlit<CharT> const& b)
+{
+    return a - chset<CharT>(b.ch);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, chlit<CharT> const& b)
+{
+    return a ^ chset<CharT>(b.ch);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chlit<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a.ch) | b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chlit<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a.ch) & b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chlit<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a.ch) - b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chlit<CharT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a.ch) ^ b;
+}
+
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  negated_char_parser <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, negated_char_parser<ParserT> const& b)
+{
+    return a | chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, negated_char_parser<ParserT> const& b)
+{
+    return a & chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, negated_char_parser<ParserT> const& b)
+{
+    return a - chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, negated_char_parser<ParserT> const& b)
+{
+    return a ^ chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator|(negated_char_parser<ParserT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) | b;
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator&(negated_char_parser<ParserT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) & b;
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator-(negated_char_parser<ParserT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) - b;
+}
+
+//////////////////////////////////
+template <typename CharT, typename ParserT>
+inline chset<CharT>
+operator^(negated_char_parser<ParserT> const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) ^ b;
+}
+
+#else // BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  negated_char_parser<range> <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b)
+{
+    return a | chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b)
+{
+    return a & chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b)
+{
+    return a - chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, negated_char_parser<range<CharT> > const& b)
+{
+    return a ^ chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) | b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) & b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) - b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(negated_char_parser<range<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) ^ b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  negated_char_parser<chlit> <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b)
+{
+    return a | chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b)
+{
+    return a & chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b)
+{
+    return a - chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, negated_char_parser<chlit<CharT> > const& b)
+{
+    return a ^ chset<CharT>(b);
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) | b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) & b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) - b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(negated_char_parser<chlit<CharT> > const& a, chset<CharT> const& b)
+{
+    return chset<CharT>(a) ^ b;
+}
+
+#endif // BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  anychar_parser <--> chset free operators
+//
+//      Where a is chset and b is a anychar_parser, and vice-versa, implements:
+//
+//          a | b, a & b, a - b, a ^ b
+//
+///////////////////////////////////////////////////////////////////////////////
+namespace impl {
+
+    template <typename CharT>
+    inline BOOST_SPIRIT_CLASSIC_NS::range<CharT> const&
+    full()
+    {
+        static BOOST_SPIRIT_CLASSIC_NS::range<CharT> full_(
+            (std::numeric_limits<CharT>::min)(),
+            (std::numeric_limits<CharT>::max)());
+        return full_;
+    }
+
+    template <typename CharT>
+    inline BOOST_SPIRIT_CLASSIC_NS::range<CharT> const&
+    empty()
+    {
+        static BOOST_SPIRIT_CLASSIC_NS::range<CharT> empty_;
+        return empty_;
+    }
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const&, anychar_parser)
+{
+    return chset<CharT>(impl::full<CharT>());
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& a, anychar_parser)
+{
+    return a;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const&, anychar_parser)
+{
+    return chset<CharT>();
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, anychar_parser)
+{
+    return ~a;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(anychar_parser, chset<CharT> const& /*b*/)
+{
+    return chset<CharT>(impl::full<CharT>());
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(anychar_parser, chset<CharT> const& b)
+{
+    return b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(anychar_parser, chset<CharT> const& b)
+{
+    return ~b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(anychar_parser, chset<CharT> const& b)
+{
+    return ~b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  nothing_parser <--> chset free operators implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(chset<CharT> const& a, nothing_parser)
+{
+    return a;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(chset<CharT> const& /*a*/, nothing_parser)
+{
+    return impl::empty<CharT>();
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(chset<CharT> const& a, nothing_parser)
+{
+    return a;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(chset<CharT> const& a, nothing_parser)
+{
+    return a;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator|(nothing_parser, chset<CharT> const& b)
+{
+    return b;
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator&(nothing_parser, chset<CharT> const& /*b*/)
+{
+    return impl::empty<CharT>();
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator-(nothing_parser, chset<CharT> const& /*b*/)
+{
+    return impl::empty<CharT>();
+}
+
+//////////////////////////////////
+template <typename CharT>
+inline chset<CharT>
+operator^(nothing_parser, chset<CharT> const& b)
+{
+    return b;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/confix.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/confix.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/confix.ipp	(working copy)
@@ -0,0 +1,221 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CONFIX_IPP
+#define BOOST_SPIRIT_CONFIX_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/meta/refactoring.hpp>
+#include <boost/spirit/home/classic/core/composite/impl/directives.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Types to distinguish nested and non-nested confix parsers
+//
+///////////////////////////////////////////////////////////////////////////////
+struct is_nested {};
+struct non_nested {};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Types to distinguish between confix parsers, which are implicitly lexems
+//  and without this behaviour
+//
+///////////////////////////////////////////////////////////////////////////////
+struct is_lexeme {};
+struct non_lexeme {};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  confix_parser_type class implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+namespace impl {
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  implicitly insert a lexeme_d into the parsing process
+
+    template <typename LexemeT>
+    struct select_confix_parse_lexeme;
+
+    template <>
+    struct select_confix_parse_lexeme<is_lexeme> {
+
+        template <typename ParserT, typename ScannerT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const& p, ScannerT const& scan)
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type result_t;
+            return contiguous_parser_parse<result_t>(p, scan, scan);
+        }
+    };
+
+    template <>
+    struct select_confix_parse_lexeme<non_lexeme> {
+
+        template <typename ParserT, typename ScannerT>
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(ParserT const& p, ScannerT const& scan)
+        {
+            return p.parse(scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  parse confix sequences with refactoring
+
+    template <typename NestedT>
+    struct select_confix_parse_refactor;
+
+    template <>
+    struct select_confix_parse_refactor<is_nested> {
+
+        template <
+            typename LexemeT, typename ParserT, typename ScannerT,
+            typename OpenT, typename ExprT, typename CloseT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(
+            LexemeT const &, ParserT const& this_, ScannerT const& scan,
+            OpenT const& open, ExprT const& expr, CloseT const& close)
+        {
+            typedef refactor_action_gen<refactor_unary_gen<> > refactor_t;
+            const refactor_t refactor_body_d = refactor_t(refactor_unary_d);
+
+            return select_confix_parse_lexeme<LexemeT>::parse((
+                            open
+                        >>  (this_ | refactor_body_d[expr - close])
+                        >>  close
+                    ),  scan);
+        }
+    };
+
+    template <>
+    struct select_confix_parse_refactor<non_nested> {
+
+        template <
+            typename LexemeT, typename ParserT, typename ScannerT,
+            typename OpenT, typename ExprT, typename CloseT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(
+            LexemeT const &, ParserT const& /*this_*/, ScannerT const& scan,
+            OpenT const& open, ExprT const& expr, CloseT const& close)
+        {
+            typedef refactor_action_gen<refactor_unary_gen<> > refactor_t;
+            const refactor_t refactor_body_d = refactor_t(refactor_unary_d);
+
+            return select_confix_parse_lexeme<LexemeT>::parse((
+                            open
+                        >>  refactor_body_d[expr - close]
+                        >>  close
+                    ),  scan);
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  parse confix sequences without refactoring
+
+    template <typename NestedT>
+    struct select_confix_parse_no_refactor;
+
+    template <>
+    struct select_confix_parse_no_refactor<is_nested> {
+
+        template <
+            typename LexemeT, typename ParserT, typename ScannerT,
+            typename OpenT, typename ExprT, typename CloseT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(
+            LexemeT const &, ParserT const& this_, ScannerT const& scan,
+            OpenT const& open, ExprT const& expr, CloseT const& close)
+        {
+            return select_confix_parse_lexeme<LexemeT>::parse((
+                            open
+                        >>  (this_ | (expr - close))
+                        >>  close
+                    ),  scan);
+        }
+    };
+
+    template <>
+    struct select_confix_parse_no_refactor<non_nested> {
+
+        template <
+            typename LexemeT, typename ParserT, typename ScannerT,
+            typename OpenT, typename ExprT, typename CloseT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(
+            LexemeT const &, ParserT const & /*this_*/, ScannerT const& scan,
+            OpenT const& open, ExprT const& expr, CloseT const& close)
+        {
+            return select_confix_parse_lexeme<LexemeT>::parse((
+                            open
+                        >>  (expr - close)
+                        >>  close
+                    ),  scan);
+        }
+    };
+
+    // the refactoring is handled by the refactoring parsers, so here there
+    // is no need to pay attention to these issues.
+
+    template <typename CategoryT>
+    struct confix_parser_type {
+
+        template <
+            typename NestedT, typename LexemeT,
+            typename ParserT, typename ScannerT,
+            typename OpenT, typename ExprT, typename CloseT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(
+            NestedT const &, LexemeT const &lexeme,
+            ParserT const& this_, ScannerT const& scan,
+            OpenT const& open, ExprT const& expr, CloseT const& close)
+        {
+            return select_confix_parse_refactor<NestedT>::
+                parse(lexeme, this_, scan, open, expr, close);
+        }
+    };
+
+    template <>
+    struct confix_parser_type<plain_parser_category> {
+
+        template <
+            typename NestedT, typename LexemeT,
+            typename ParserT, typename ScannerT,
+            typename OpenT, typename ExprT, typename CloseT
+        >
+        static typename parser_result<ParserT, ScannerT>::type
+        parse(
+            NestedT const &, LexemeT const &lexeme,
+            ParserT const& this_, ScannerT const& scan,
+            OpenT const& open, ExprT const& expr, CloseT const& close)
+        {
+            return select_confix_parse_no_refactor<NestedT>::
+                parse(lexeme, this_, scan, open, expr, close);
+        }
+    };
+
+}   // namespace impl
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/impl/chset.ipp	(working copy)
@@ -0,0 +1,366 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CHSET_IPP
+#define BOOST_SPIRIT_CHSET_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/limits.hpp>
+#include <boost/spirit/home/classic/utility/chset.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  chset class
+//
+///////////////////////////////////////////////////////////////////////////////
+namespace utility { namespace impl {
+    template <typename CharT>
+    inline void
+    detach(boost::shared_ptr<basic_chset<CharT> >& ptr)
+    {
+        if (!ptr.unique())
+            ptr = boost::shared_ptr<basic_chset<CharT> >
+                (new basic_chset<CharT>(*ptr));
+    }
+
+    template <typename CharT>
+    inline void
+    detach_clear(boost::shared_ptr<basic_chset<CharT> >& ptr)
+    {
+        if (ptr.unique())
+            ptr->clear();
+        else
+            ptr.reset(new basic_chset<CharT>());
+    }
+
+    template <typename CharT, typename CharT2>
+    void construct_chset(boost::shared_ptr<basic_chset<CharT> >& ptr,
+            CharT2 const* definition)
+    {
+        CharT2 ch = *definition++;
+        while (ch)
+        {
+            CharT2 next = *definition++;
+            if (next == '-')
+            {
+                next = *definition++;
+                if (next == 0)
+                {
+                    ptr->set(ch);
+                    ptr->set('-');
+                    break;
+                }
+                ptr->set(ch, next);
+            }
+            else
+            {
+                ptr->set(ch);
+            }
+            ch = next;
+        }
+    }
+
+    //////////////////////////////////
+
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+    template <typename CharT, typename FakeT>
+    void chset_negated_set(boost::shared_ptr<basic_chset<CharT> > &ptr, chlit<CharT> const &ch,
+            FakeT)
+    {
+        if(ch.ch != (std::numeric_limits<CharT>::min)()) {
+            ptr->set((std::numeric_limits<CharT>::min)(), ch.ch - 1);
+        }
+        if(ch.ch != (std::numeric_limits<CharT>::max)()) {
+            ptr->set(ch.ch + 1, (std::numeric_limits<CharT>::max)());
+        }
+    }
+
+    template <typename CharT, typename FakeT>
+    void chset_negated_set(boost::shared_ptr<basic_chset<CharT> > &ptr,
+            spirit::range<CharT> const &rng, FakeT)
+    {
+        if(rng.first != (std::numeric_limits<CharT>::min)()) {
+            ptr->set((std::numeric_limits<CharT>::min)(), rng.first - 1);
+        }
+        if(rng.last != (std::numeric_limits<CharT>::max)()) {
+            ptr->set(rng.last + 1, (std::numeric_limits<CharT>::max)());
+        }
+    }
+
+#endif // BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+//////////////////////////////////
+
+}} // namespace utility::impl
+
+template <typename CharT>
+inline chset<CharT>::chset()
+: ptr(new basic_chset<CharT>()) {}
+
+template <typename CharT>
+inline chset<CharT>::chset(chset const& arg_)
+: ptr(new basic_chset<CharT>(*arg_.ptr)) {}
+
+template <typename CharT>
+inline chset<CharT>::chset(CharT arg_)
+: ptr(new basic_chset<CharT>())
+{ ptr->set(arg_); }
+
+template <typename CharT>
+inline chset<CharT>::chset(anychar_parser /*arg*/)
+: ptr(new basic_chset<CharT>())
+{
+    ptr->set(
+        (std::numeric_limits<CharT>::min)(),
+        (std::numeric_limits<CharT>::max)()
+    );
+}
+
+template <typename CharT>
+inline chset<CharT>::chset(nothing_parser arg_)
+: ptr(new basic_chset<CharT>()) {}
+
+template <typename CharT>
+inline chset<CharT>::chset(chlit<CharT> const& arg_)
+: ptr(new basic_chset<CharT>())
+{ ptr->set(arg_.ch); }
+
+template <typename CharT>
+inline chset<CharT>::chset(range<CharT> const& arg_)
+: ptr(new basic_chset<CharT>())
+{ ptr->set(arg_.first, arg_.last); }
+
+#if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+template <typename CharT>
+inline chset<CharT>::chset(negated_char_parser<chlit<CharT> > const& arg_)
+: ptr(new basic_chset<CharT>())
+{
+    set(arg_);
+}
+
+template <typename CharT>
+inline chset<CharT>::chset(negated_char_parser<range<CharT> > const& arg_)
+: ptr(new basic_chset<CharT>())
+{
+    set(arg_);
+}
+
+#endif // !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+template <typename CharT>
+inline chset<CharT>::~chset() {}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(chset const& rhs)
+{
+    ptr = rhs.ptr;
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(CharT rhs)
+{
+    utility::impl::detach_clear(ptr);
+    ptr->set(rhs);
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(anychar_parser rhs)
+{
+    utility::impl::detach_clear(ptr);
+    ptr->set(
+        (std::numeric_limits<CharT>::min)(),
+        (std::numeric_limits<CharT>::max)()
+    );
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(nothing_parser rhs)
+{
+    utility::impl::detach_clear(ptr);
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(chlit<CharT> const& rhs)
+{
+    utility::impl::detach_clear(ptr);
+    ptr->set(rhs.ch);
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(range<CharT> const& rhs)
+{
+    utility::impl::detach_clear(ptr);
+    ptr->set(rhs.first, rhs.last);
+    return *this;
+}
+
+#if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(negated_char_parser<chlit<CharT> > const& rhs)
+{
+    utility::impl::detach_clear(ptr);
+    set(rhs);
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator=(negated_char_parser<range<CharT> > const& rhs)
+{
+    utility::impl::detach_clear(ptr);
+    set(rhs);
+    return *this;
+}
+
+#endif // !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+template <typename CharT>
+inline void
+chset<CharT>::set(range<CharT> const& arg_)
+{
+    utility::impl::detach(ptr);
+    ptr->set(arg_.first, arg_.last);
+}
+
+#if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+template <typename CharT>
+inline void
+chset<CharT>::set(negated_char_parser<chlit<CharT> > const& arg_)
+{
+    utility::impl::detach(ptr);
+
+    if(arg_.positive.ch != (std::numeric_limits<CharT>::min)()) {
+        ptr->set((std::numeric_limits<CharT>::min)(), arg_.positive.ch - 1);
+    }
+    if(arg_.positive.ch != (std::numeric_limits<CharT>::max)()) {
+        ptr->set(arg_.positive.ch + 1, (std::numeric_limits<CharT>::max)());
+    }
+}
+
+template <typename CharT>
+inline void
+chset<CharT>::set(negated_char_parser<range<CharT> > const& arg_)
+{
+    utility::impl::detach(ptr);
+
+    if(arg_.positive.first != (std::numeric_limits<CharT>::min)()) {
+        ptr->set((std::numeric_limits<CharT>::min)(), arg_.positive.first - 1);
+    }
+    if(arg_.positive.last != (std::numeric_limits<CharT>::max)()) {
+        ptr->set(arg_.positive.last + 1, (std::numeric_limits<CharT>::max)());
+    }
+}
+
+#endif // !BOOST_WORKAROUND(BOOST_MSVC, < 1300)
+
+template <typename CharT>
+inline void
+chset<CharT>::clear(range<CharT> const& arg_)
+{
+    utility::impl::detach(ptr);
+    ptr->clear(arg_.first, arg_.last);
+}
+
+template <typename CharT>
+inline void
+chset<CharT>::clear(negated_char_parser<range<CharT> > const& arg_)
+{
+    utility::impl::detach(ptr);
+
+    if(arg_.positive.first != (std::numeric_limits<CharT>::min)()) {
+        ptr->clear((std::numeric_limits<CharT>::min)(), arg_.positive.first - 1);
+    }
+    if(arg_.positive.last != (std::numeric_limits<CharT>::max)()) {
+        ptr->clear(arg_.positive.last + 1, (std::numeric_limits<CharT>::max)());
+    }
+}
+
+template <typename CharT>
+inline bool
+chset<CharT>::test(CharT ch) const
+{ return ptr->test(ch); }
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::inverse()
+{
+    utility::impl::detach(ptr);
+    ptr->inverse();
+    return *this;
+}
+
+template <typename CharT>
+inline void
+chset<CharT>::swap(chset& x)
+{ ptr.swap(x.ptr); }
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator|=(chset const& x)
+{
+    utility::impl::detach(ptr);
+    *ptr |= *x.ptr;
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator&=(chset const& x)
+{
+    utility::impl::detach(ptr);
+    *ptr &= *x.ptr;
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator-=(chset const& x)
+{
+    utility::impl::detach(ptr);
+    *ptr -= *x.ptr;
+    return *this;
+}
+
+template <typename CharT>
+inline chset<CharT>&
+chset<CharT>::operator^=(chset const& x)
+{
+    utility::impl::detach(ptr);
+    *ptr ^= *x.ptr;
+    return *this;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/flush_multi_pass.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/flush_multi_pass.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/flush_multi_pass.hpp	(working copy)
@@ -0,0 +1,77 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Daniel Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_FLUSH_MULTI_PASS_HPP
+#define BOOST_SPIRIT_FLUSH_MULTI_PASS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core.hpp>
+#include <boost/spirit/home/classic/iterator/multi_pass.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace impl {
+
+        template <typename T>
+        void flush_iterator(T &) {}
+
+        template <typename T1, typename T2, typename T3, typename T4>
+        void flush_iterator(BOOST_SPIRIT_CLASSIC_NS::multi_pass<
+            T1, T2, T3, T4, BOOST_SPIRIT_CLASSIC_NS::multi_pass_policies::std_deque> &i)
+        {
+            i.clear_queue();
+        }
+
+    }   // namespace impl
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  flush_multi_pass_parser
+    //
+    //      The flush_multi_pass_parser flushes an underlying
+    //      multi_pass_iterator during the normal parsing process. This may
+    //      be used at certain points during the parsing process, when it is
+    //      clear, that no backtracking is needed anymore and the input
+    //      gathered so far may be discarded.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    class flush_multi_pass_parser
+    :   public parser<flush_multi_pass_parser>
+    {
+    public:
+        typedef flush_multi_pass_parser this_t;
+
+        template <typename ScannerT>
+        typename parser_result<this_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            impl::flush_iterator(scan.first);
+            return scan.empty_match();
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  predefined flush_multi_pass_p object
+    //
+    //      This object should may used to flush a multi_pass_iterator along
+    //      the way during the normal parsing process.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    flush_multi_pass_parser const
+        flush_multi_pass_p = flush_multi_pass_parser();
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // BOOST_SPIRIT_FLUSH_MULTI_PASS_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/distinct_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/distinct_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/distinct_fwd.hpp	(working copy)
@@ -0,0 +1,37 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DISTINCT_FWD_HPP)
+#define BOOST_SPIRIT_DISTINCT_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template<typename CharT> class chset;
+
+    template <typename CharT = char, typename TailT = chset<CharT> >
+    class distinct_parser;
+
+    template <typename CharT = char, typename TailT = chset<CharT> >
+    class distinct_directive;
+
+    template <typename ScannerT = scanner<> >
+    class dynamic_distinct_parser;
+
+    template <typename ScannerT = scanner<> >
+    class dynamic_distinct_directive;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/distinct.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/distinct.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/distinct.hpp	(working copy)
@@ -0,0 +1,229 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2003 Vaclav Vesely
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DISTINCT_HPP)
+#define BOOST_SPIRIT_DISTINCT_HPP
+
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/composite/operators.hpp>
+#include <boost/spirit/home/classic/core/composite/directives.hpp>
+#include <boost/spirit/home/classic/core/composite/epsilon.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/rule.hpp>
+#include <boost/spirit/home/classic/utility/chset.hpp>
+
+#include <boost/spirit/home/classic/utility/distinct_fwd.hpp>
+
+namespace boost {
+    namespace spirit {
+    BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+//-----------------------------------------------------------------------------
+// distinct_parser class
+
+template <typename CharT, typename TailT>
+class distinct_parser
+{
+public:
+    typedef
+        contiguous<
+            sequence<
+                chseq<CharT const*>,
+                negated_empty_match_parser<
+                    TailT
+                >
+            >
+        >
+            result_t;
+
+    distinct_parser()
+    :   tail(chset<CharT>())
+    {
+    }
+
+    explicit distinct_parser(parser<TailT> const & tail_)
+    :   tail(tail_.derived())
+    {
+    }
+
+    explicit distinct_parser(CharT const* letters)
+    :   tail(chset_p(letters))
+    {
+    }
+
+    result_t operator()(CharT const* str) const
+    {
+        return lexeme_d[chseq_p(str) >> ~epsilon_p(tail)];
+    }
+
+    TailT tail;
+};
+
+//-----------------------------------------------------------------------------
+// distinct_directive class
+
+template <typename CharT, typename TailT>
+class distinct_directive
+{
+public:
+    template<typename ParserT>
+    struct result {
+        typedef
+            contiguous<
+                sequence<
+                    ParserT,
+                    negated_empty_match_parser<
+                        TailT
+                    >
+                >
+            >
+                type;
+    };
+
+    distinct_directive()
+    :   tail(chset<CharT>())
+    {
+    }
+
+    explicit distinct_directive(CharT const* letters)
+    :   tail(chset_p(letters))
+    {
+    }
+
+    explicit distinct_directive(parser<TailT> const & tail_)
+    :   tail(tail_.derived())
+    {
+    }
+
+    template<typename ParserT>
+    typename result<typename as_parser<ParserT>::type>::type
+        operator[](ParserT const &subject) const
+    {
+        return
+            lexeme_d[as_parser<ParserT>::convert(subject) >> ~epsilon_p(tail)];
+    }
+
+    TailT tail;
+};
+
+//-----------------------------------------------------------------------------
+// dynamic_distinct_parser class
+
+template <typename ScannerT>
+class dynamic_distinct_parser
+{
+public:
+    typedef typename ScannerT::value_t char_t;
+
+    typedef
+        rule<
+            typename no_actions_scanner<
+                typename lexeme_scanner<ScannerT>::type
+            >::type
+        >
+            tail_t;
+
+    typedef
+        contiguous<
+            sequence<
+                chseq<char_t const*>,
+                negated_empty_match_parser<
+                    tail_t
+                >
+            >
+        >
+            result_t;
+
+    dynamic_distinct_parser()
+    :   tail(nothing_p)
+    {
+    }
+
+    template<typename ParserT>
+    explicit dynamic_distinct_parser(parser<ParserT> const & tail_)
+    :   tail(tail_.derived())
+    {
+    }
+
+    explicit dynamic_distinct_parser(char_t const* letters)
+    :   tail(chset_p(letters))
+    {
+    }
+
+    result_t operator()(char_t const* str) const
+    {
+        return lexeme_d[chseq_p(str) >> ~epsilon_p(tail)];
+    }
+
+    tail_t tail;
+};
+
+//-----------------------------------------------------------------------------
+// dynamic_distinct_directive class
+
+template <typename ScannerT>
+class dynamic_distinct_directive
+{
+public:
+    typedef typename ScannerT::value_t char_t;
+
+    typedef
+        rule<
+            typename no_actions_scanner<
+                typename lexeme_scanner<ScannerT>::type
+            >::type
+        >
+            tail_t;
+
+    template<typename ParserT>
+    struct result {
+        typedef
+            contiguous<
+                sequence<
+                    ParserT,
+                    negated_empty_match_parser<
+                        tail_t
+                    >
+                >
+            >
+                type;
+    };
+
+    dynamic_distinct_directive()
+    :   tail(nothing_p)
+    {
+    }
+
+    template<typename ParserT>
+    explicit dynamic_distinct_directive(parser<ParserT> const & tail_)
+    :   tail(tail_.derived())
+    {
+    }
+
+    explicit dynamic_distinct_directive(char_t const* letters)
+    :   tail(chset_p(letters))
+    {
+    }
+
+    template<typename ParserT>
+    typename result<typename as_parser<ParserT>::type>::type
+        operator[](ParserT const &subject) const
+    {
+        return
+            lexeme_d[as_parser<ParserT>::convert(subject) >> ~epsilon_p(tail)];
+    }
+
+    tail_t tail;
+};
+
+//-----------------------------------------------------------------------------
+    BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+    } // namespace spirit
+} // namespace boost
+
+#endif // !defined(BOOST_SPIRIT_DISTINCT_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/scoped_lock.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/scoped_lock.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/scoped_lock.hpp	(working copy)
@@ -0,0 +1,112 @@
+/*=============================================================================
+    Copyright (c) 2003 Martin Wille
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+ =============================================================================*/
+#ifndef BOOST_SPIRIT_UTILITY_SCOPED_LOCK_HPP
+#define BOOST_SPIRIT_UTILITY_SCOPED_LOCK_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#if !defined(BOOST_SPIRIT_COMPOSITE_HPP)
+#include <boost/spirit/home/classic/core/composite.hpp>
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    // scoped_lock_parser class
+    //
+    //      implements locking of a mutex during execution of
+    //      the parse method of an embedded parser
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename MutexT, typename ParserT>
+    struct scoped_lock_parser
+        : public unary< ParserT, parser< scoped_lock_parser<MutexT, ParserT> > >
+    {
+        typedef scoped_lock_parser<MutexT, ParserT> self_t;
+        typedef MutexT      mutex_t;
+        typedef ParserT     parser_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<parser_t, ScannerT>::type type;
+        };
+
+        scoped_lock_parser(mutex_t &m, parser_t const &p)
+            : unary< ParserT, parser< scoped_lock_parser<MutexT, ParserT> > >(p)
+            , mutex(m)
+        {}
+
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const &scan) const
+        {
+            typedef typename  mutex_t::scoped_lock scoped_lock_t;
+            scoped_lock_t lock(mutex);
+            return this->subject().parse(scan);
+        }
+
+        mutex_t &mutex;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    // scoped_lock_parser_gen
+    //
+    //      generator for scoped_lock_parser objects
+    //      operator[] returns scoped_lock_parser according to its argument
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename MutexT>
+    struct scoped_lock_parser_gen
+    {
+        typedef MutexT mutex_t;
+        explicit scoped_lock_parser_gen(mutex_t &m) : mutex(m) {}
+
+        template<typename ParserT>
+        scoped_lock_parser
+        <
+            MutexT,
+            typename as_parser<ParserT>::type
+        >
+        operator[](ParserT const &p) const
+        {
+            typedef ::BOOST_SPIRIT_CLASSIC_NS::as_parser<ParserT> as_parser_t;
+            typedef typename as_parser_t::type parser_t;
+
+            return scoped_lock_parser<mutex_t, parser_t>
+                (mutex, as_parser_t::convert(p));
+        }
+
+        mutex_t &mutex;
+    };
+
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    // scoped_lock_d parser directive
+    //
+    //      constructs a scoped_lock_parser generator from its argument
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename MutexT>
+    scoped_lock_parser_gen<MutexT>
+    scoped_lock_d(MutexT &mutex)
+    {
+        return scoped_lock_parser_gen<MutexT>(mutex);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+#endif // BOOST_SPIRIT_UTILITY_SCOPED_LOCK_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/confix_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/confix_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/confix_fwd.hpp	(working copy)
@@ -0,0 +1,39 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_CONFIX_FWD_HPP)
+#define BOOST_SPIRIT_CONFIX_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    struct is_nested;
+    struct non_nested;
+    struct is_lexeme;
+    struct non_lexeme;
+
+    template <
+        typename OpenT, typename ExprT, typename CloseT,
+        typename CategoryT = plain_parser_category,
+        typename NestedT = non_nested, typename LexemeT = non_lexeme
+    >
+    struct confix_parser;
+
+    template<typename OpenT, typename CloseT>
+    struct comment_nest_parser;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/confix.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/confix.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/utility/confix.hpp	(working copy)
@@ -0,0 +1,405 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CONFIX_HPP
+#define BOOST_SPIRIT_CONFIX_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/config.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+#include <boost/spirit/home/classic/core/composite/operators.hpp>
+
+#include <boost/spirit/home/classic/utility/confix_fwd.hpp>
+#include <boost/spirit/home/classic/utility/impl/confix.ipp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  confix_parser class
+//
+//      Parses a sequence of 3 sub-matches. This class may
+//      be used to parse structures, where the opening part is possibly
+//      contained in the expression part and the whole sequence is only
+//      parsed after seeing the closing part matching the first opening
+//      subsequence. Example: C-comments:
+//
+//      /* This is a C-comment */
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+template<typename NestedT = non_nested, typename LexemeT = non_lexeme>
+struct confix_parser_gen;
+
+template <
+    typename OpenT, typename ExprT, typename CloseT, typename CategoryT,
+    typename NestedT, typename LexemeT
+>
+struct confix_parser :
+    public parser<
+        confix_parser<OpenT, ExprT, CloseT, CategoryT, NestedT, LexemeT>
+    >
+{
+    typedef
+        confix_parser<OpenT, ExprT, CloseT, CategoryT, NestedT, LexemeT>
+        self_t;
+
+    confix_parser(OpenT const &open_, ExprT const &expr_, CloseT const &close_)
+    : open(open_), expr(expr_), close(close_)
+    {}
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        return impl::confix_parser_type<CategoryT>::
+            parse(NestedT(), LexemeT(), *this, scan, open, expr, close);
+    }
+
+private:
+
+    typename as_parser<OpenT>::type::embed_t open;
+    typename as_parser<ExprT>::type::embed_t expr;
+    typename as_parser<CloseT>::type::embed_t close;
+};
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Confix parser generator template
+//
+//      This is a helper for generating a correct confix_parser<> from
+//      auxiliary parameters. There are the following types supported as
+//      parameters yet: parsers, single characters and strings (see
+//      as_parser).
+//
+//      If the body parser is an action_parser_category type parser (a parser
+//      with an attached semantic action) we have to do something special. This
+//      happens, if the user wrote something like:
+//
+//          confix_p(open, body[f], close)
+//
+//      where 'body' is the parser matching the body of the confix sequence
+//      and 'f' is a functor to be called after matching the body. If we would
+//      do nothing, the resulting code would parse the sequence as follows:
+//
+//          start >> (body[f] - close) >> close
+//
+//      what in most cases is not what the user expects.
+//      (If this _is_ what you've expected, then please use the confix_p
+//      generator function 'direct()', which will inhibit
+//      re-attaching the actor to the body parser).
+//
+//      To make the confix parser behave as expected:
+//
+//          start >> (body - close)[f] >> close
+//
+//      the actor attached to the 'body' parser has to be re-attached to the
+//      (body - close) parser construct, which will make the resulting confix
+//      parser 'do the right thing'. This refactoring is done by the help of
+//      the refactoring parsers (see the files refactoring.[hi]pp).
+//
+//      Additionally special care must be taken, if the body parser is a
+//      unary_parser_category type parser as
+//
+//          confix_p(open, *anychar_p, close)
+//
+//      which without any refactoring would result in
+//
+//          start >> (*anychar_p - close) >> close
+//
+//      and will not give the expected result (*anychar_p will eat up all the
+//      input up to the end of the input stream). So we have to refactor this
+//      into:
+//
+//          start >> *(anychar_p - close) >> close
+//
+//      what will give the correct result.
+//
+//      The case, where the body parser is a combination of the two mentioned
+//      problems (i.e. the body parser is a unary parser  with an attached
+//      action), is handled accordingly too:
+//
+//          confix_p(start, (*anychar_p)[f], end)
+//
+//      will be parsed as expected:
+//
+//          start >> (*(anychar_p - end))[f] >> end.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template<typename NestedT, typename LexemeT>
+struct confix_parser_gen
+{
+    // Generic generator function for creation of concrete confix parsers
+
+    template<typename StartT, typename ExprT, typename EndT>
+    struct paren_op_result_type
+    {
+        typedef confix_parser<
+            typename as_parser<StartT>::type,
+            typename as_parser<ExprT>::type,
+            typename as_parser<EndT>::type,
+            typename as_parser<ExprT>::type::parser_category_t,
+            NestedT,
+            LexemeT
+        > type;
+    };
+
+    template<typename StartT, typename ExprT, typename EndT>
+    typename paren_op_result_type<StartT, ExprT, EndT>::type
+    operator()(StartT const &start_, ExprT const &expr_, EndT const &end_) const
+    {
+        typedef typename paren_op_result_type<StartT,ExprT,EndT>::type
+            return_t;
+
+        return return_t(
+            as_parser<StartT>::convert(start_),
+            as_parser<ExprT>::convert(expr_),
+            as_parser<EndT>::convert(end_)
+        );
+    }
+
+    // Generic generator function for creation of concrete confix parsers
+    // which have an action directly attached to the ExprT part of the
+    // parser (see comment above, no automatic refactoring)
+
+    template<typename StartT, typename ExprT, typename EndT>
+    struct direct_result_type
+    {
+        typedef confix_parser<
+            typename as_parser<StartT>::type,
+            typename as_parser<ExprT>::type,
+            typename as_parser<EndT>::type,
+            plain_parser_category,   // do not re-attach action
+            NestedT,
+            LexemeT
+        > type;
+    };
+
+    template<typename StartT, typename ExprT, typename EndT>
+    typename direct_result_type<StartT,ExprT,EndT>::type
+    direct(StartT const &start_, ExprT const &expr_, EndT const &end_) const
+    {
+        typedef typename direct_result_type<StartT,ExprT,EndT>::type
+            return_t;
+
+        return return_t(
+            as_parser<StartT>::convert(start_),
+            as_parser<ExprT>::convert(expr_),
+            as_parser<EndT>::convert(end_)
+        );
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Predefined non_nested confix parser generators
+//
+///////////////////////////////////////////////////////////////////////////////
+
+const confix_parser_gen<non_nested, non_lexeme> confix_p =
+    confix_parser_gen<non_nested, non_lexeme>();
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Comments are special types of confix parsers
+//
+//      Comment parser generator template. This is a helper for generating a
+//      correct confix_parser<> from auxiliary parameters, which is able to
+//      parse comment constructs: (StartToken >> Comment text >> EndToken).
+//
+//      There are the following types supported as parameters yet: parsers,
+//      single characters and strings (see as_parser).
+//
+//      There are two diffenerent predefined comment parser generators
+//      (comment_p and comment_nest_p, see below), which may be used for
+//      creating special comment parsers in two different ways.
+//
+//      If these are used with one parameter, a comment starting with the given
+//      first parser parameter up to the end of the line is matched. So for
+//      instance the following parser matches C++ style comments:
+//
+//          comment_p("//").
+//
+//      If these are used with two parameters, a comment starting with the
+//      first parser parameter up to the second parser parameter is matched.
+//      For instance a C style comment parser should be constrcuted as:
+//
+//          comment_p("/*", "*/").
+//
+//      Please note, that a comment is parsed implicitly as if the whole
+//      comment_p(...) statement were embedded into a lexeme_d[] directive.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template<typename NestedT>
+struct comment_parser_gen
+{
+    // Generic generator function for creation of concrete comment parsers
+    // from an open token. The newline parser eol_p is used as the
+    // closing token.
+
+    template<typename StartT>
+    struct paren_op1_result_type
+    {
+        typedef confix_parser<
+            typename as_parser<StartT>::type,
+            kleene_star<anychar_parser>,
+            alternative<eol_parser, end_parser>,
+            unary_parser_category,          // there is no action to re-attach
+            NestedT,
+            is_lexeme                       // insert implicit lexeme_d[]
+        >
+        type;
+    };
+
+    template<typename StartT>
+    typename paren_op1_result_type<StartT>::type
+    operator() (StartT const &start_) const
+    {
+        typedef typename paren_op1_result_type<StartT>::type
+            return_t;
+
+        return return_t(
+            as_parser<StartT>::convert(start_),
+            *anychar_p,
+            eol_p | end_p
+        );
+    }
+
+    // Generic generator function for creation of concrete comment parsers
+    // from an open and a close tokens.
+
+    template<typename StartT, typename EndT>
+    struct paren_op2_result_type
+    {
+        typedef confix_parser<
+            typename as_parser<StartT>::type,
+            kleene_star<anychar_parser>,
+            typename as_parser<EndT>::type,
+            unary_parser_category,          // there is no action to re-attach
+            NestedT,
+            is_lexeme                       // insert implicit lexeme_d[]
+        > type;
+    };
+
+    template<typename StartT, typename EndT>
+    typename paren_op2_result_type<StartT,EndT>::type
+    operator() (StartT const &start_, EndT const &end_) const
+    {
+        typedef typename paren_op2_result_type<StartT,EndT>::type
+            return_t;
+
+        return return_t(
+            as_parser<StartT>::convert(start_),
+            *anychar_p,
+            as_parser<EndT>::convert(end_)
+        );
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Predefined non_nested comment parser generator
+//
+///////////////////////////////////////////////////////////////////////////////
+
+const comment_parser_gen<non_nested> comment_p =
+    comment_parser_gen<non_nested>();
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  comment_nest_parser class
+//
+//      Parses a nested comments.
+//      Example: nested PASCAL-comments:
+//
+//      { This is a { nested } PASCAL-comment }
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template<typename OpenT, typename CloseT>
+struct comment_nest_parser:
+    public parser<comment_nest_parser<OpenT, CloseT> >
+{
+    typedef comment_nest_parser<OpenT, CloseT> self_t;
+
+    comment_nest_parser(OpenT const &open_, CloseT const &close_):
+        open(open_), close(close_)
+    {}
+
+    template<typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const &scan) const
+    {
+        return do_parse(
+            open >> *(*this | (anychar_p - close)) >> close,
+            scan);
+    }
+
+private:
+    template<typename ParserT, typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+        do_parse(ParserT const &p, ScannerT const &scan) const
+    {
+        return
+            impl::contiguous_parser_parse<
+                typename parser_result<ParserT, ScannerT>::type
+            >(p, scan, scan);
+    }
+
+    typename as_parser<OpenT>::type::embed_t open;
+    typename as_parser<CloseT>::type::embed_t close;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Predefined nested comment parser generator
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template<typename OpenT, typename CloseT>
+struct comment_nest_p_result
+{
+    typedef comment_nest_parser<
+        typename as_parser<OpenT>::type,
+        typename as_parser<CloseT>::type
+    > type;
+};
+
+template<typename OpenT, typename CloseT>
+inline typename comment_nest_p_result<OpenT,CloseT>::type
+comment_nest_p(OpenT const &open, CloseT const &close)
+{
+    typedef typename comment_nest_p_result<OpenT,CloseT>::type
+        result_t;
+
+    return result_t(
+        as_parser<OpenT>::convert(open),
+        as_parser<CloseT>::convert(close)
+    );
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure_fwd.hpp	(working copy)
@@ -0,0 +1,69 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_CLOSURE_FWD_HPP)
+#define BOOST_SPIRIT_CLOSURE_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/phoenix/tuples.hpp>
+
+#if !defined(BOOST_SPIRIT_CLOSURE_LIMIT)
+#   define BOOST_SPIRIT_CLOSURE_LIMIT PHOENIX_LIMIT
+#endif
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template<typename ClosureT>
+    class closure_context;
+
+    template <typename ClosureT>
+    class init_closure_context;
+
+    template <typename ParserT, typename ActorTupleT>
+    struct init_closure_parser;
+
+    template <
+            typename DerivedT
+        ,   typename T0 = ::phoenix::nil_t
+        ,   typename T1 = ::phoenix::nil_t
+        ,   typename T2 = ::phoenix::nil_t
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 3
+        ,   typename T3 = ::phoenix::nil_t
+        ,   typename T4 = ::phoenix::nil_t
+        ,   typename T5 = ::phoenix::nil_t
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 6
+        ,   typename T6 = ::phoenix::nil_t
+        ,   typename T7 = ::phoenix::nil_t
+        ,   typename T8 = ::phoenix::nil_t
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 9
+        ,   typename T9 = ::phoenix::nil_t
+        ,   typename T10 = ::phoenix::nil_t
+        ,   typename T11 = ::phoenix::nil_t
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 12
+        ,   typename T12 = ::phoenix::nil_t
+        ,   typename T13 = ::phoenix::nil_t
+        ,   typename T14 = ::phoenix::nil_t
+
+    #endif
+    #endif
+    #endif
+    #endif
+    >
+    struct closure;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure.hpp	(working copy)
@@ -0,0 +1,1083 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_CLOSURE_HPP
+#define BOOST_SPIRIT_CLOSURE_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/parser_context.hpp>
+#include <boost/spirit/home/classic/attribute/parametric.hpp>
+#include <boost/spirit/home/classic/attribute/closure_context.hpp>
+#include <boost/spirit/home/classic/attribute/closure_fwd.hpp>
+
+#include <boost/spirit/home/classic/phoenix/closures.hpp>
+#include <boost/spirit/home/classic/phoenix/primitives.hpp>
+#include <boost/spirit/home/classic/phoenix/casts.hpp>
+#include <boost/spirit/home/classic/phoenix/operators.hpp>
+#include <boost/spirit/home/classic/phoenix/tuple_helpers.hpp>
+
+#include <boost/static_assert.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Spirit predefined maximum closure limit. This limit defines the maximum
+//  number of elements a closure can hold. This number defaults to 3. The
+//  actual maximum is rounded up in multiples of 3. Thus, if this value
+//  is 4, the actual limit is 6. The ultimate maximum limit in this
+//  implementation is 15.
+//
+//  It should NOT be greater than PHOENIX_LIMIT!
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#if !defined(BOOST_SPIRIT_CLOSURE_LIMIT)
+#define BOOST_SPIRIT_CLOSURE_LIMIT PHOENIX_LIMIT
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// ensure BOOST_SPIRIT_CLOSURE_LIMIT <= PHOENIX_LIMIT and SPIRIT_CLOSURE_LIMIT <= 15
+//
+///////////////////////////////////////////////////////////////////////////////
+BOOST_STATIC_ASSERT(BOOST_SPIRIT_CLOSURE_LIMIT <= PHOENIX_LIMIT);
+BOOST_STATIC_ASSERT(BOOST_SPIRIT_CLOSURE_LIMIT <= 15);
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  closure_context class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ClosureT>
+    class closure_context : public parser_context_base
+    {
+    public:
+
+        typedef typename ::phoenix::tuple_element<0,
+            typename ClosureT::tuple_t>::type attr_t;
+        typedef ClosureT base_t;
+        typedef closure_context_linker<closure_context<ClosureT> >
+        context_linker_t;
+
+        closure_context(ClosureT const& clos)
+        : frame(clos) {}
+
+        ~closure_context() {}
+
+        template <typename ParserT, typename ScannerT>
+        void pre_parse(ParserT const&, ScannerT const&) {}
+
+        template <typename ResultT, typename ParserT, typename ScannerT>
+        ResultT& post_parse(ResultT& hit, ParserT const&, ScannerT const&)
+        { hit.value(frame[::phoenix::tuple_index<0>()]); return hit; }
+
+    private:
+
+        ::phoenix::closure_frame<typename ClosureT::phoenix_closure_t> frame;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  init_closure_context class
+    //
+    //      The init_closure_context class is a special parser context type
+    //      which additionally initializes a closure contained in the derived
+    //      parser with values from a given tuple. Please note, that this
+    //      given tuple does not contain the required values directly, it
+    //      contains phoenix::actor objects. These actors have to be
+    //      dereferenced to gain the values to be used for initialization
+    //      (this is done by the help of the phoenix::convert_actors<>
+    //      template).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    template <typename ClosureT>
+    class init_closure_context : public parser_context_base
+    {
+        typedef typename ClosureT::tuple_t      tuple_t;
+        typedef typename ClosureT::closure_t    closure_t;
+
+    public:
+
+        init_closure_context(ClosureT const& clos)
+        : frame(clos.subject(), ::phoenix::convert_actors<tuple_t>(clos.init)) {}
+
+        ~init_closure_context() {}
+
+        template <typename ParserT, typename ScannerT>
+        void pre_parse(ParserT const& /*p*/, ScannerT const&) {}
+
+        template <typename ResultT, typename ParserT, typename ScannerT>
+        ResultT& post_parse(ResultT& hit, ParserT const&, ScannerT const&)
+        { hit.value(frame[::phoenix::tuple_index<0>()]); return hit; }
+
+    private:
+
+        ::phoenix::closure_frame<closure_t> frame;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  init_closure_parser class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ParserT, typename ActorTupleT>
+    struct init_closure_parser
+    : public unary<ParserT, parser<init_closure_parser<ParserT, ActorTupleT> > >
+    {
+        typedef init_closure_parser<ParserT, ActorTupleT>           self_t;
+        typedef unary<ParserT, parser<self_t> >                     base_t;
+        typedef typename ParserT::phoenix_closure_t                 closure_t;
+        typedef typename ParserT::tuple_t                           tuple_t;
+        typedef typename ::phoenix::tuple_element<0, tuple_t>::type   attr_t;
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename match_result<ScannerT, attr_t>::type type;
+        };
+
+        init_closure_parser(ParserT const& p, ActorTupleT const& init_)
+        : base_t(p), init(init_) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse_main(ScannerT const& scan) const
+        {
+            return this->subject().parse_main(scan);
+        }
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef init_closure_context<self_t> init_context_t;
+            typedef parser_scanner_linker<ScannerT> scanner_t;
+            typedef closure_context_linker<init_context_t> context_t;
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            BOOST_SPIRIT_CONTEXT_PARSE(
+                scan, *this, scanner_t, context_t, result_t);
+        }
+
+        ActorTupleT init;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  closure class
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+            typename DerivedT
+        ,   typename T0
+        ,   typename T1
+        ,   typename T2
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 3
+        ,   typename T3
+        ,   typename T4
+        ,   typename T5
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 6
+        ,   typename T6
+        ,   typename T7
+        ,   typename T8
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 9
+        ,   typename T9
+        ,   typename T10
+        ,   typename T11
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 12
+        ,   typename T12
+        ,   typename T13
+        ,   typename T14
+    #endif
+    #endif
+    #endif
+    #endif
+    >
+    struct closure :
+        public ::phoenix::closure<
+            T0, T1, T2
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 3
+        ,   T3, T4, T5
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 6
+        ,   T6, T7, T8
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 9
+        ,   T9, T10, T11
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 12
+        ,   T12, T13, T14
+    #endif
+    #endif
+    #endif
+    #endif
+        >
+    {
+        typedef ::phoenix::closure<
+                T0, T1, T2
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 3
+            ,   T3, T4, T5
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 6
+            ,   T6, T7, T8
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 9
+            ,   T9, T10, T11
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 12
+            ,   T12, T13, T14
+    #endif
+    #endif
+    #endif
+    #endif
+            > phoenix_closure_t;
+
+        typedef closure_context<DerivedT> context_t;
+
+        template <typename DerivedT2>
+        struct aux
+        {
+            DerivedT2& aux_derived()
+            { return *static_cast<DerivedT2*>(this); }
+
+            DerivedT2 const& aux_derived() const
+            { return *static_cast<DerivedT2 const*>(this); }
+
+        // initialization functions
+            template <typename A>
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type
+                >
+            >
+            operator()(A const &a) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef ::phoenix::tuple<a_t> actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a)
+                        )
+                    );
+            }
+
+            template <typename A, typename B>
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type
+                >
+            >
+            operator()(A const &a, B const &b) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef ::phoenix::tuple<a_t, b_t> actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b)
+                        )
+                    );
+            }
+
+            template <typename A, typename B, typename C>
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type
+                >
+            >
+            operator()(A const &a, B const &b, C const &c) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef ::phoenix::tuple<a_t, b_t, c_t> actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c)
+                        )
+                    );
+            }
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 3
+
+            template <
+                typename A, typename B, typename C, typename D
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f)
+                        )
+                    );
+            }
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 6
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i)
+                        )
+                    );
+            }
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 9
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I, typename J
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type,
+                    typename ::phoenix::as_actor<J>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i, J const &j
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef typename ::phoenix::as_actor<J>::type j_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t, j_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i),
+                            ::phoenix::as_actor<J>::convert(j)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I, typename J,
+                typename K
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type,
+                    typename ::phoenix::as_actor<J>::type,
+                    typename ::phoenix::as_actor<K>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i, J const &j,
+                K const &k
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef typename ::phoenix::as_actor<J>::type j_t;
+                typedef typename ::phoenix::as_actor<K>::type k_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t, j_t,
+                            k_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i),
+                            ::phoenix::as_actor<J>::convert(j),
+                            ::phoenix::as_actor<K>::convert(k)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I, typename J,
+                typename K, typename L
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type,
+                    typename ::phoenix::as_actor<J>::type,
+                    typename ::phoenix::as_actor<K>::type,
+                    typename ::phoenix::as_actor<L>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i, J const &j,
+                K const &k, L const &l
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef typename ::phoenix::as_actor<J>::type j_t;
+                typedef typename ::phoenix::as_actor<K>::type k_t;
+                typedef typename ::phoenix::as_actor<L>::type l_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t, j_t,
+                            k_t, l_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i),
+                            ::phoenix::as_actor<J>::convert(j),
+                            ::phoenix::as_actor<K>::convert(k),
+                            ::phoenix::as_actor<L>::convert(l)
+                        )
+                    );
+            }
+
+    #if BOOST_SPIRIT_CLOSURE_LIMIT > 12
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I, typename J,
+                typename K, typename L, typename M
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type,
+                    typename ::phoenix::as_actor<J>::type,
+                    typename ::phoenix::as_actor<K>::type,
+                    typename ::phoenix::as_actor<L>::type,
+                    typename ::phoenix::as_actor<M>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i, J const &j,
+                K const &k, L const &l, M const &m
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef typename ::phoenix::as_actor<J>::type j_t;
+                typedef typename ::phoenix::as_actor<K>::type k_t;
+                typedef typename ::phoenix::as_actor<L>::type l_t;
+                typedef typename ::phoenix::as_actor<M>::type m_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t, j_t,
+                            k_t, l_t, m_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i),
+                            ::phoenix::as_actor<J>::convert(j),
+                            ::phoenix::as_actor<K>::convert(k),
+                            ::phoenix::as_actor<L>::convert(l),
+                            ::phoenix::as_actor<M>::convert(m)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I, typename J,
+                typename K, typename L, typename M, typename N
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type,
+                    typename ::phoenix::as_actor<J>::type,
+                    typename ::phoenix::as_actor<K>::type,
+                    typename ::phoenix::as_actor<L>::type,
+                    typename ::phoenix::as_actor<M>::type,
+                    typename ::phoenix::as_actor<N>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i, J const &j,
+                K const &k, L const &l, M const &m, N const &n
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef typename ::phoenix::as_actor<J>::type j_t;
+                typedef typename ::phoenix::as_actor<K>::type k_t;
+                typedef typename ::phoenix::as_actor<L>::type l_t;
+                typedef typename ::phoenix::as_actor<M>::type m_t;
+                typedef typename ::phoenix::as_actor<N>::type n_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t, j_t,
+                            k_t, l_t, m_t, n_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i),
+                            ::phoenix::as_actor<J>::convert(j),
+                            ::phoenix::as_actor<K>::convert(k),
+                            ::phoenix::as_actor<L>::convert(l),
+                            ::phoenix::as_actor<M>::convert(m),
+                            ::phoenix::as_actor<N>::convert(n)
+                        )
+                    );
+            }
+
+            template <
+                typename A, typename B, typename C, typename D, typename E,
+                typename F, typename G, typename H, typename I, typename J,
+                typename K, typename L, typename M, typename N, typename O
+            >
+            init_closure_parser<
+                DerivedT2,
+                ::phoenix::tuple<
+                    typename ::phoenix::as_actor<A>::type,
+                    typename ::phoenix::as_actor<B>::type,
+                    typename ::phoenix::as_actor<C>::type,
+                    typename ::phoenix::as_actor<D>::type,
+                    typename ::phoenix::as_actor<E>::type,
+                    typename ::phoenix::as_actor<F>::type,
+                    typename ::phoenix::as_actor<G>::type,
+                    typename ::phoenix::as_actor<H>::type,
+                    typename ::phoenix::as_actor<I>::type,
+                    typename ::phoenix::as_actor<J>::type,
+                    typename ::phoenix::as_actor<K>::type,
+                    typename ::phoenix::as_actor<L>::type,
+                    typename ::phoenix::as_actor<M>::type,
+                    typename ::phoenix::as_actor<N>::type,
+                    typename ::phoenix::as_actor<O>::type
+                >
+            >
+            operator()(
+                A const &a, B const &b, C const &c, D const &d, E const &e,
+                F const &f, G const &g, H const &h, I const &i, J const &j,
+                K const &k, L const &l, M const &m, N const &n, O const &o
+            ) const
+            {
+                typedef typename ::phoenix::as_actor<A>::type a_t;
+                typedef typename ::phoenix::as_actor<B>::type b_t;
+                typedef typename ::phoenix::as_actor<C>::type c_t;
+                typedef typename ::phoenix::as_actor<D>::type d_t;
+                typedef typename ::phoenix::as_actor<E>::type e_t;
+                typedef typename ::phoenix::as_actor<F>::type f_t;
+                typedef typename ::phoenix::as_actor<G>::type g_t;
+                typedef typename ::phoenix::as_actor<H>::type h_t;
+                typedef typename ::phoenix::as_actor<I>::type i_t;
+                typedef typename ::phoenix::as_actor<J>::type j_t;
+                typedef typename ::phoenix::as_actor<K>::type k_t;
+                typedef typename ::phoenix::as_actor<L>::type l_t;
+                typedef typename ::phoenix::as_actor<M>::type m_t;
+                typedef typename ::phoenix::as_actor<N>::type n_t;
+                typedef typename ::phoenix::as_actor<O>::type o_t;
+                typedef ::phoenix::tuple<
+                            a_t, b_t, c_t, d_t, e_t, f_t, g_t, h_t, i_t, j_t,
+                            k_t, l_t, m_t, n_t, o_t
+                        > actor_tuple_t;
+
+                return init_closure_parser<DerivedT2, actor_tuple_t>(
+                        aux_derived(),
+                        actor_tuple_t(
+                            ::phoenix::as_actor<A>::convert(a),
+                            ::phoenix::as_actor<B>::convert(b),
+                            ::phoenix::as_actor<C>::convert(c),
+                            ::phoenix::as_actor<D>::convert(d),
+                            ::phoenix::as_actor<E>::convert(e),
+                            ::phoenix::as_actor<F>::convert(f),
+                            ::phoenix::as_actor<G>::convert(g),
+                            ::phoenix::as_actor<H>::convert(h),
+                            ::phoenix::as_actor<I>::convert(i),
+                            ::phoenix::as_actor<J>::convert(j),
+                            ::phoenix::as_actor<K>::convert(k),
+                            ::phoenix::as_actor<L>::convert(l),
+                            ::phoenix::as_actor<M>::convert(m),
+                            ::phoenix::as_actor<N>::convert(n),
+                            ::phoenix::as_actor<O>::convert(o)
+                        )
+                    );
+            }
+
+    #endif
+    #endif
+    #endif
+    #endif
+        };
+
+        ~closure() {}
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  overloads for chseq_p and str_p taking in phoenix actors
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ActorT>
+    struct container_begin
+    {
+        typedef container_begin<ActorT> self_t;
+
+        template <typename TupleT>
+        struct result
+        {
+            typedef typename ::phoenix::actor_result<ActorT, TupleT>
+                ::plain_type::iterator type;
+        };
+
+        container_begin(ActorT actor_)
+        : actor(actor_) {}
+
+        template <typename TupleT>
+        typename ::phoenix::actor_result<self_t, TupleT>::type
+        eval(TupleT const& /*args*/) const
+        { return actor().begin(); }
+
+        ActorT actor;
+    };
+
+    template <typename ActorT>
+    struct container_end
+    {
+        typedef container_begin<ActorT> self_t;
+
+        template <typename TupleT>
+        struct result
+        {
+            typedef typename ::phoenix::actor_result<ActorT, TupleT>
+                ::plain_type::iterator type;
+        };
+
+        container_end(ActorT actor_)
+        : actor(actor_) {}
+
+        template <typename TupleT>
+        typename ::phoenix::actor_result<self_t, TupleT>::type
+        eval(TupleT const& /*args*/) const
+        { return actor().end(); }
+
+        ActorT actor;
+    };
+
+    template <typename BaseT>
+    inline f_chseq<
+        ::phoenix::actor<container_begin< ::phoenix::actor<BaseT> > >,
+        ::phoenix::actor<container_end< ::phoenix::actor<BaseT> > >
+    >
+    f_chseq_p(::phoenix::actor<BaseT> const& a)
+    {
+        typedef ::phoenix::actor<container_begin< ::phoenix::actor<BaseT> > >
+            container_begin_t;
+        typedef ::phoenix::actor<container_end< ::phoenix::actor<BaseT> > >
+            container_end_t;
+        typedef f_chseq<container_begin_t, container_end_t> result_t;
+
+        return result_t(container_begin_t(a), container_end_t(a));
+    }
+
+    template <typename BaseT>
+    inline f_strlit<
+        ::phoenix::actor<container_begin< ::phoenix::actor<BaseT> > >,
+        ::phoenix::actor<container_end< ::phoenix::actor<BaseT> > >
+    >
+    f_str_p(::phoenix::actor<BaseT> const& a)
+    {
+        typedef ::phoenix::actor<container_begin< ::phoenix::actor<BaseT> > >
+            container_begin_t;
+        typedef ::phoenix::actor<container_end< ::phoenix::actor<BaseT> > >
+            container_end_t;
+        typedef f_strlit<container_begin_t, container_end_t> result_t;
+
+        return result_t(container_begin_t(a), container_end_t(a));
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure_context.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure_context.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/closure_context.hpp	(working copy)
@@ -0,0 +1,56 @@
+/*=============================================================================
+    Copyright (c) 2002-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_CLOSURE_CONTEXT_HPP)
+#define BOOST_SPIRIT_CLOSURE_CONTEXT_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if !defined(BOOST_SPIRIT_CLOSURE_CONTEXT_LINKER_DEFINED)
+#define BOOST_SPIRIT_CLOSURE_CONTEXT_LINKER_DEFINED
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  closure_context_linker
+//  { helper template for the closure extendability }
+//
+//      This classes can be 'overloaded' (defined elsewhere), to plug
+//      in additional functionality into the closure parsing process.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template<typename ContextT>
+struct closure_context_linker : public ContextT
+{
+    template <typename ParserT>
+    closure_context_linker(ParserT const& p)
+    : ContextT(p) {}
+
+    template <typename ParserT, typename ScannerT>
+    void pre_parse(ParserT const& p, ScannerT const& scan)
+    { ContextT::pre_parse(p, scan); }
+
+    template <typename ResultT, typename ParserT, typename ScannerT>
+    ResultT&
+    post_parse(ResultT& hit, ParserT const& p, ScannerT const& scan)
+    { return ContextT::post_parse(hit, p, scan); }
+};
+
+#endif // !defined(BOOST_SPIRIT_CLOSURE_CONTEXT_LINKER_DEFINED)
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // BOOST_SPIRIT_CLOSURE_CONTEXT_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/parametric.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/parametric.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/attribute/parametric.hpp	(working copy)
@@ -0,0 +1,144 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_PARAMETRIC_HPP
+#define BOOST_SPIRIT_PARAMETRIC_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  f_chlit class [ functional version of chlit ]
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ChGenT>
+    struct f_chlit : public char_parser<f_chlit<ChGenT> >
+    {
+        f_chlit(ChGenT chgen_)
+        : chgen(chgen_) {}
+
+        template <typename T>
+        bool test(T ch) const
+        { return ch == chgen(); }
+
+        ChGenT   chgen;
+    };
+
+    template <typename ChGenT>
+    inline f_chlit<ChGenT>
+    f_ch_p(ChGenT chgen)
+    { return f_chlit<ChGenT>(chgen); }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  f_range class [ functional version of range ]
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ChGenAT, typename ChGenBT>
+    struct f_range : public char_parser<f_range<ChGenAT, ChGenBT> >
+    {
+        f_range(ChGenAT first_, ChGenBT last_)
+        : first(first_), last(last_)
+        {}
+
+        template <typename T>
+        bool test(T ch) const
+        {
+            BOOST_SPIRIT_ASSERT(first() <= last());
+            return (ch >= first()) && (ch <= last());
+        }
+
+        ChGenAT first;
+        ChGenBT last;
+    };
+
+    template <typename ChGenAT, typename ChGenBT>
+    inline f_range<ChGenAT, ChGenBT>
+    f_range_p(ChGenAT first, ChGenBT last)
+    { return f_range<ChGenAT, ChGenBT>(first, last); }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  f_chseq class [ functional version of chseq ]
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IterGenAT, typename IterGenBT>
+    class f_chseq : public parser<f_chseq<IterGenAT, IterGenBT> >
+    {
+    public:
+
+        typedef f_chseq<IterGenAT, IterGenBT> self_t;
+
+        f_chseq(IterGenAT first_, IterGenBT last_)
+        : first(first_), last(last_) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::string_parser_parse<result_t>(first(), last(), scan);
+        }
+
+    private:
+
+        IterGenAT first;
+        IterGenBT last;
+    };
+
+    template <typename IterGenAT, typename IterGenBT>
+    inline f_chseq<IterGenAT, IterGenBT>
+    f_chseq_p(IterGenAT first, IterGenBT last)
+    { return f_chseq<IterGenAT, IterGenBT>(first, last); }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  f_strlit class [ functional version of strlit ]
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename IterGenAT, typename IterGenBT>
+    class f_strlit : public parser<f_strlit<IterGenAT, IterGenBT> >
+    {
+    public:
+
+        typedef f_strlit<IterGenAT, IterGenBT> self_t;
+
+        f_strlit(IterGenAT first, IterGenBT last)
+        : seq(first, last) {}
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::contiguous_parser_parse<result_t>
+                (seq, scan, scan);
+        }
+
+    private:
+
+        f_chseq<IterGenAT, IterGenBT> seq;
+    };
+
+    template <typename IterGenAT, typename IterGenBT>
+    inline f_strlit<IterGenAT, IterGenBT>
+    f_str_p(IterGenAT first, IterGenBT last)
+    { return f_strlit<IterGenAT, IterGenBT>(first, last); }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/assign_actor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/assign_actor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/assign_actor.hpp	(working copy)
@@ -0,0 +1,100 @@
+/*=============================================================================
+    Copyright (c) 2003 Jonathan de Halleux (dehalleux@pelikhan.com)
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ACTOR_ASSIGN_ACTOR_HPP
+#define BOOST_SPIRIT_ACTOR_ASSIGN_ACTOR_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/actor/ref_value_actor.hpp>
+#include <boost/spirit/home/classic/actor/ref_const_ref_actor.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  Summary:
+    //  A semantic action policy that applies the assignement operator.
+    //  (This doc uses convention available in actors.hpp)
+    //
+    //  Actions (what it does):
+    //      ref = value;
+    //      ref = T(first,last);
+    //      ref = value_ref;
+    //
+    //  Policy name:
+    //      assign_action
+    //
+    //  Policy holder, corresponding helper method:
+    //      ref_value_actor, assign_a( ref );
+    //      ref_const_ref_actor, assign_a( ref, value_ref );
+    //
+    //  () operators: both
+    //
+    //  See also ref_value_actor and ref_const_ref_actor for more details.
+    ///////////////////////////////////////////////////////////////////////////
+    struct assign_action
+    {
+        template<
+            typename T,
+            typename ValueT
+        >
+        void act(T& ref_, ValueT const& value_) const
+        {
+            ref_ = value_;
+        }
+        template<
+            typename T,
+            typename IteratorT
+        >
+        void act(
+            T& ref_,
+            IteratorT const& first_,
+            IteratorT const& last_
+            ) const
+        {
+            typedef T value_type;
+#ifndef BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+            value_type value(first_,last_);
+#else
+            value_type value;
+            std::copy(first_, last_, std::inserter(value, value.end()));
+#endif
+            ref_ = value;
+        }
+    };
+
+    // Deprecated. Please use assign_a
+    template<typename T>
+    inline ref_value_actor<T,assign_action> assign(T& ref_)
+    {
+        return ref_value_actor<T,assign_action>(ref_);
+    }
+
+    template<typename T>
+    inline ref_value_actor<T,assign_action> assign_a(T& ref_)
+    {
+        return ref_value_actor<T,assign_action>(ref_);
+    }
+
+    template<
+        typename T,
+        typename ValueT
+    >
+    inline ref_const_ref_actor<T,ValueT,assign_action> assign_a(
+        T& ref_,
+        ValueT const& value_
+    )
+    {
+        return ref_const_ref_actor<T,ValueT,assign_action>(ref_,value_);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/ref_value_actor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/ref_value_actor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/ref_value_actor.hpp	(working copy)
@@ -0,0 +1,82 @@
+/*=============================================================================
+    Copyright (c) 2003 Jonathan de Halleux (dehalleux@pelikhan.com)
+    Copyright (c) 2011 Bryce Lelbach
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ACTOR_REF_VALUE_ACTOR_HPP
+#define BOOST_SPIRIT_ACTOR_REF_VALUE_ACTOR_HPP
+
+#include <boost/detail/workaround.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  Summary:
+    //  A semantic action policy holder. This holder stores a reference to ref.
+    //  act methods are feed with ref and the parse result.
+    //
+    //  (This doc uses convention available in actors.hpp)
+    //
+    //  Constructor:
+    //      ...(T& ref_);
+    //      where ref_ is stored.
+    //
+    //  Action calls:
+    //      act(ref, value);
+    //      act(ref, first,last);
+    //
+    //  () operators: both
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template<
+        typename T,
+        typename ActionT
+    >
+    class ref_value_actor : public ActionT
+    {
+    private:
+        T& ref;
+    public:
+        explicit
+        ref_value_actor(T& ref_)
+        : ref(ref_){}
+
+
+        template<typename T2>
+        void operator()(T2 const& val_) const
+        {
+            this->act(ref,val_); // defined in ActionT
+        }
+
+
+        template<typename IteratorT>
+        void operator()(
+            IteratorT const& first_,
+            IteratorT const& last_
+            ) const
+        {
+            this->act(ref,first_,last_); // defined in ActionT
+        }
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+}}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/ref_const_ref_actor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/ref_const_ref_actor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/ref_const_ref_actor.hpp	(working copy)
@@ -0,0 +1,78 @@
+/*=============================================================================
+    Copyright (c) 2003 Jonathan de Halleux (dehalleux@pelikhan.com)
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ACTOR_REF_CONST_REF_ACTOR_HPP
+#define BOOST_SPIRIT_ACTOR_REF_CONST_REF_ACTOR_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  Summary:
+    //  A semantic action policy holder. This holder stores a reference to ref
+    //  and a const reference to value_ref.
+    //  act methods are feed with ref and value_ref. The parse result is
+    //  not used by this holder.
+    //
+    //  (This doc uses convention available in actors.hpp)
+    //
+    //  Constructor:
+    //      ...(T& ref_, ValueT const& value_ref_);
+    //      where ref_ and value_ref_ are stored in the holder.
+    //
+    //  Action calls:
+    //      act(ref, value_ref);
+    //
+    //  () operators: both
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template<
+        typename T,
+        typename ValueT,
+        typename ActionT
+    >
+    class ref_const_ref_actor : public ActionT
+    {
+    private:
+        T& ref;
+        ValueT const& value_ref;
+    public:
+        ref_const_ref_actor(
+            T& ref_,
+            ValueT const& value_ref_
+            )
+        :
+            ref(ref_),
+            value_ref(value_ref_)
+        {}
+
+
+        template<typename T2>
+        void operator()(T2 const& /*val*/) const
+        {
+            this->act(ref,value_ref); // defined in ActionT
+        }
+
+
+        template<typename IteratorT>
+            void operator()(
+            IteratorT const& /*first*/,
+            IteratorT const& /*last*/
+            ) const
+        {
+            this->act(ref,value_ref); // defined in ActionT
+        }
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/push_back_actor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/push_back_actor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/actor/push_back_actor.hpp	(working copy)
@@ -0,0 +1,101 @@
+/*=============================================================================
+    Copyright (c) 2003 Jonathan de Halleux (dehalleux@pelikhan.com)
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ACTOR_PUSH_BACK_ACTOR_HPP
+#define BOOST_SPIRIT_ACTOR_PUSH_BACK_ACTOR_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/actor/ref_value_actor.hpp>
+#include <boost/spirit/home/classic/actor/ref_const_ref_actor.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  Summary:
+    //
+    //  A semantic action policy that appends a value to the back of a
+    //  container.
+    //  (This doc uses convention available in actors.hpp)
+    //
+    //  Actions (what it does and what ref, value_ref must support):
+    //      ref.push_back( value );
+    //      ref.push_back( T::value_type(first,last) );
+    //      ref.push_back( value_ref );
+    //
+    //  Policy name:
+    //      push_back_action
+    //
+    //  Policy holder, corresponding helper method:
+    //      ref_value_actor, push_back_a( ref );
+    //      ref_const_ref_actor, push_back_a( ref, value_ref );
+    //
+    //  () operators: both
+    //
+    //  See also ref_value_actor and ref_const_ref_actor for more details.
+    ///////////////////////////////////////////////////////////////////////////
+    struct push_back_action
+    {
+        template<
+            typename T,
+            typename ValueT
+        >
+        void act(T& ref_, ValueT const& value_) const
+        {
+            ref_.push_back( value_ );
+        }
+        template<
+            typename T,
+            typename IteratorT
+        >
+        void act(
+            T& ref_,
+            IteratorT const& first_,
+            IteratorT const& last_
+            ) const
+        {
+            typedef typename T::value_type value_type;
+            value_type value(first_,last_);
+
+            ref_.push_back( value );
+        }
+    };
+
+//  Deprecated interface. Use push_back_a
+    template<typename T>
+    inline ref_value_actor<T,push_back_action>
+    append(T& ref_)
+    {
+        return ref_value_actor<T,push_back_action>(ref_);
+    }
+
+    template<typename T>
+    inline ref_value_actor<T,push_back_action>
+    push_back_a(T& ref_)
+    {
+        return ref_value_actor<T,push_back_action>(ref_);
+    }
+
+    template<
+        typename T,
+        typename ValueT
+    >
+    inline ref_const_ref_actor<T,ValueT,push_back_action>
+    push_back_a(
+        T& ref_,
+        ValueT const& value_
+    )
+    {
+        return ref_const_ref_actor<T,ValueT,push_back_action>(ref_,value_);
+    }
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}}
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/version.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/version.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/version.hpp	(working copy)
@@ -0,0 +1,30 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(SPIRIT_CLASSIC_VERSION_HPP)
+#define SPIRIT_CLASSIC_VERSION_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  This checks, whether the used Boost library is at least V1.32.0
+//
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/version.hpp>
+
+#if BOOST_VERSION < 103200
+#error "Spirit v1.8.x needs at least Boost V1.32.0 to compile successfully."
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  This is the version of the current Spirit distribution
+//
+///////////////////////////////////////////////////////////////////////////////
+#define SPIRIT_VERSION 0x1806
+#define SPIRIT_PIZZA_VERSION SPIRIT_MEGA_VEGGI  // :-)
+
+#endif // defined(SPIRIT_VERSION_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols.hpp	(working copy)
@@ -0,0 +1,21 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SYMBOLS_MAIN_HPP)
+#define BOOST_SPIRIT_SYMBOLS_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Master header for Spirit.Symbols
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include <boost/spirit/home/classic/symbols/symbols.hpp>
+
+#endif // !defined(BOOST_SPIRIT_SYMBOLS_MAIN_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator.hpp	(working copy)
@@ -0,0 +1,25 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Daniel Nuffer
+    Copyright (c) 2003 Giovanni Bajo
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ITERATOR_MAIN_HPP)
+#define BOOST_SPIRIT_ITERATOR_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Master header for Spirit.Iterators
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include <boost/spirit/home/classic/iterator/file_iterator.hpp>
+#include <boost/spirit/home/classic/iterator/fixed_size_queue.hpp>
+#include <boost/spirit/home/classic/iterator/position_iterator.hpp>
+#include <boost/spirit/home/classic/iterator/multi_pass.hpp>
+
+#endif // !defined(BOOST_SPIRIT_ITERATOR_MAIN_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling.hpp	(working copy)
@@ -0,0 +1,21 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ERROR_HANDLING_MAIN_HPP)
+#define BOOST_SPIRIT_ERROR_HANDLING_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Master header for Spirit.ErrorHandling
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include <boost/spirit/home/classic/error_handling/exceptions.hpp>
+
+#endif // !defined(BOOST_SPIRIT_ERROR_HANDLING_MAIN_HPP)
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/impl/symbols.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/impl/symbols.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/impl/symbols.ipp	(working copy)
@@ -0,0 +1,118 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_SYMBOLS_IPP
+#define BOOST_SPIRIT_SYMBOLS_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/symbols/impl/tst.ipp>
+#include <boost/detail/workaround.hpp>
+
+// MSVC: void warning about the use of 'this' pointer in constructors
+#if defined(BOOST_MSVC)
+#pragma warning(push)
+#pragma warning(disable : 4355)
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  symbols class implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+inline symbols<T, CharT, SetT>::symbols()
+: SetT()
+, add(*this)
+{
+}
+
+//////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+symbols<T, CharT, SetT>::symbols(symbols const& other)
+: SetT(other)
+// Tru64 CXX seems to be confused by the explicit call of the default
+// constructor and generates wrong code which invalidates the just contructed
+// first base class in the line above.
+#if !BOOST_WORKAROUND(__DECCXX_VER, BOOST_TESTED_AT(60590041))
+, parser<symbols<T, CharT, SetT> >()
+#endif
+, add(*this)
+{
+}
+
+//////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+inline symbols<T, CharT, SetT>::~symbols()
+{}
+
+//////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+inline symbols<T, CharT, SetT>&
+symbols<T, CharT, SetT>::operator=(symbols const& other)
+{
+    SetT::operator=(other);
+    return *this;
+}
+
+//////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+inline symbol_inserter<T, SetT> const&
+symbols<T, CharT, SetT>::operator=(CharT const* str)
+{
+    return add, str;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Symbol table utilities
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+inline T*
+find(symbols<T, CharT, SetT> const& table, CharT const* sym)
+{
+    CharT const* last = sym;
+    while (*last)
+        last++;
+    scanner<CharT const *> scan(sym, last);
+    T* result = table.find(scan);
+    return scan.at_end()? result: 0;
+}
+
+//////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+inline T*
+add(symbols<T, CharT, SetT>& table, CharT const* sym, T const& data)
+{
+    CharT const* first = sym;
+    CharT const* last = sym;
+    while (*last)
+        last++;
+    scanner<CharT const *> scan(first, last);
+    if (table.find(scan) && scan.at_end())
+        return 0;               // symbol already contained in symbol table
+    table.add(sym, last, data);
+    first = sym;
+    return table.find(scan);    // refind the inserted symbol
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#if defined(BOOST_MSVC)
+#pragma warning(pop)
+#endif
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/impl/tst.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/impl/tst.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/impl/tst.ipp	(working copy)
@@ -0,0 +1,281 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_TST_IPP
+#define BOOST_SPIRIT_TST_IPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <memory> // for std::auto_ptr
+#include <boost/spirit/home/classic/core/assert.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace impl
+    {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tst class
+//
+//      Ternary Search Tree implementation. The data structure is faster than
+//      hashing for many typical search problems especially when the search
+//      interface is iterator based. Searching for a string of length k in a
+//      ternary search tree with n strings will require at most O(log n+k)
+//      character comparisons. TSTs are many times faster than hash tables
+//      for unsuccessful searches since mismatches are discovered earlier
+//      after examining only a few characters. Hash tables always examine an
+//      entire key when searching.
+//
+//      For details see http://www.cs.princeton.edu/~rs/strings/.
+//
+//      *** This is a low level class and is
+//          not meant for public consumption ***
+//
+///////////////////////////////////////////////////////////////////////////////
+    template <typename T, typename CharT>
+    struct tst_node
+    {
+        tst_node(CharT value_)
+        : value(value_)
+        , left(0)
+        , right(0)
+        { middle.link = 0; }
+
+        ~tst_node()
+        {
+            delete left;
+            delete right;
+            if (value)
+                delete middle.link;
+            else
+                delete middle.data;
+        }
+
+        tst_node*
+        clone() const
+        {
+            std::auto_ptr<tst_node> copy(new tst_node(value));
+
+            if (left)
+                copy->left = left->clone();
+            if (right)
+                copy->right = right->clone();
+
+            if (value && middle.link)
+            {
+                copy->middle.link = middle.link->clone();
+            }
+            else
+            {
+                std::auto_ptr<T> mid_data(new T(*middle.data));
+                copy->middle.data = mid_data.release();
+            }
+
+            return copy.release();
+        }
+
+        union center {
+
+            tst_node*   link;
+            T*          data;
+        };
+
+        CharT       value;
+        tst_node*   left;
+        center      middle;
+        tst_node*   right;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T, typename CharT>
+    class tst
+    {
+    public:
+
+        struct search_info
+        {
+            T*          data;
+            std::size_t length;
+        };
+
+        tst()
+        : root(0) {}
+
+        tst(tst const& other)
+        : root(other.root ? other.root->clone() : 0) {}
+
+        ~tst()
+        { delete root; }
+
+        tst&
+        operator=(tst const& other)
+        {
+            if (this != &other)
+            {
+                node_t* new_root = other.root ? other.root->clone() : 0;
+                delete root;
+                root = new_root;
+            }
+            return *this;
+        }
+
+        template <typename IteratorT>
+        T* add(IteratorT first, IteratorT const& last, T const& data)
+        {
+            if (first == last)
+                return 0;
+
+            node_t**  np = &root;
+            CharT   ch = *first;
+
+            BOOST_SPIRIT_ASSERT((first == last || ch != 0)
+                && "Won't add string containing null character");
+
+            for (;;)
+            {
+                if (*np == 0 || ch == 0)
+                {
+                    node_t* right = 0;
+                    if (np != 0)
+                        right = *np;
+                    *np = new node_t(ch);
+                    if (right)
+                        (**np).right = right;
+                }
+
+                if (ch < (**np).value)
+                {
+                    np = &(**np).left;
+                }
+                else
+                {
+                    if (ch == (**np).value)
+                    {
+                        if (ch == 0)
+                        {
+                            if ((**np).middle.data == 0)
+                            {
+                                (**np).middle.data = new T(data);
+                                return (**np).middle.data;
+                            }
+                            else
+                            {
+                                //  re-addition is disallowed
+                                return 0;
+                            }
+                       }
+                        ++first;
+                        ch = (first == last) ? CharT(0) : *first;
+                        BOOST_SPIRIT_ASSERT((first == last || ch != 0)
+                            && "Won't add string containing null character");
+                        np = &(**np).middle.link;
+                    }
+                    else
+                    {
+                        np = &(**np).right;
+                    }
+                }
+            }
+        }
+
+        template <typename ScannerT>
+        search_info find(ScannerT const& scan) const
+        {
+            search_info result = { 0, 0 };
+            if (scan.at_end()) {
+                return result;
+            }
+
+            typedef typename ScannerT::iterator_t iterator_t;
+            node_t*     np = root;
+            CharT       ch = *scan;
+            iterator_t  save = scan.first;
+            iterator_t  latest = scan.first;
+            std::size_t latest_len = 0;
+
+            while (np)
+            {
+
+                if (ch < np->value) // => go left!
+                {
+                    if (np->value == 0)
+                    {
+                        result.data = np->middle.data;
+                        if (result.data)
+                        {
+                            latest = scan.first;
+                            latest_len = result.length;
+                        }
+                    }
+
+                    np = np->left;
+                }
+                else if (ch == np->value) // => go middle!
+                {
+                    // Matching the null character is not allowed.
+                    if (np->value == 0)
+                    {
+                        result.data = np->middle.data;
+                        if (result.data)
+                        {
+                            latest = scan.first;
+                            latest_len = result.length;
+                        }
+                        break;
+                    }
+
+                    ++scan;
+                    ch = scan.at_end() ? CharT(0) : *scan;
+                    np = np->middle.link;
+                    ++result.length;
+                }
+                else // (ch > np->value) => go right!
+                {
+                    if (np->value == 0)
+                    {
+                        result.data = np->middle.data;
+                        if (result.data)
+                        {
+                            latest = scan.first;
+                            latest_len = result.length;
+                        }
+                    }
+
+                    np = np->right;
+                }
+            }
+
+            if (result.data == 0)
+            {
+                scan.first = save;
+            }
+            else
+            {
+                scan.first = latest;
+                result.length = latest_len;
+            }
+            return result;
+        }
+
+    private:
+
+        typedef tst_node<T, CharT> node_t;
+        node_t* root;
+    };
+
+///////////////////////////////////////////////////////////////////////////////
+    } // namespace impl
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/symbols_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/symbols_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/symbols_fwd.hpp	(working copy)
@@ -0,0 +1,39 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_SYMBOLS_FWD_HPP)
+#define BOOST_SPIRIT_SYMBOLS_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace impl
+    {
+        template <typename CharT, typename T>
+        class tst;
+    }
+
+    template
+    <
+        typename T = int,
+        typename CharT = char,
+        typename SetT = impl::tst<T, CharT>
+    >
+    class symbols;
+
+    template <typename T, typename SetT>
+    class symbol_inserter;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/symbols.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/symbols.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/symbols/symbols.hpp	(working copy)
@@ -0,0 +1,229 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_SYMBOLS_HPP
+#define BOOST_SPIRIT_SYMBOLS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <string>
+
+#include <boost/ref.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/directives.hpp>
+
+#include <boost/spirit/home/classic/symbols/symbols_fwd.hpp>
+
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  symbols class
+//
+//      This class implements a symbol table. The symbol table holds a
+//      dictionary of symbols where each symbol is a sequence of CharTs.
+//      The template class can work efficiently with 8, 16 and 32 bit
+//      characters. Mutable data of type T is associated with each
+//      symbol.
+//
+//      The class is a parser. The parse member function returns
+//      additional information in the symbol_match class (see below).
+//      The additional data is a pointer to some data associated with
+//      the matching symbol.
+//
+//      The actual set implementation is supplied by the SetT template
+//      parameter. By default, this uses the tst class (see tst.ipp).
+//
+//      Symbols are added into the symbol table statically using the
+//      construct:
+//
+//          sym = a, b, c, d ...;
+//
+//      where sym is a symbol table and a..d are strings. Example:
+//
+//          sym = "pineapple", "orange", "banana", "apple";
+//
+//      Alternatively, symbols may be added dynamically through the
+//      member functor 'add' (see symbol_inserter below). The member
+//      functor 'add' may be attached to a parser as a semantic action
+//      taking in a begin/end pair:
+//
+//          p[sym.add]
+//
+//      where p is a parser (and sym is a symbol table). On success,
+//      the matching portion of the input is added to the symbol table.
+//
+//      'add' may also be used to directly initialize data. Examples:
+//
+//          sym.add("hello", 1)("crazy", 2)("world", 3);
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+class symbols
+:   private SetT
+,   public parser<symbols<T, CharT, SetT> >
+{
+public:
+
+    typedef parser<symbols<T, CharT, SetT> > parser_base_t;
+    typedef symbols<T, CharT, SetT> self_t;
+    typedef self_t const& embed_t;
+    typedef T symbol_data_t;
+    typedef boost::reference_wrapper<T> symbol_ref_t;
+
+    symbols();
+    symbols(symbols const& other);
+    ~symbols();
+
+    symbols&
+    operator=(symbols const& other);
+
+    symbol_inserter<T, SetT> const&
+    operator=(CharT const* str);
+
+    template <typename ScannerT>
+    struct result
+    {
+        typedef typename match_result<ScannerT, symbol_ref_t>::type type;
+    };
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse_main(ScannerT const& scan) const
+    {
+        typedef typename ScannerT::iterator_t iterator_t;
+        iterator_t first = scan.first;
+        typename SetT::search_info result = SetT::find(scan);
+
+        if (result.data)
+            return scan.
+                create_match(
+                    result.length,
+                    symbol_ref_t(*result.data),
+                    first,
+                    scan.first);
+        else
+            return scan.no_match();
+    }
+
+    template <typename ScannerT>
+    typename parser_result<self_t, ScannerT>::type
+    parse(ScannerT const& scan) const
+    {
+        typedef typename parser_result<self_t, ScannerT>::type result_t;
+        return impl::implicit_lexeme_parse<result_t>
+            (*this, scan, scan);
+    }
+
+    template < typename ScannerT >
+    T* find(ScannerT const& scan) const
+    { return SetT::find(scan).data; }
+
+    symbol_inserter<T, SetT> const add;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Symbol table utilities
+//
+//  add
+//
+//      adds a symbol 'sym' (string) to a symbol table 'table' plus an
+//      optional data 'data' associated with the symbol. Returns a pointer to
+//      the data associated with the symbol or NULL if add failed (e.g. when
+//      the symbol is already added before).
+//
+//  find
+//
+//      finds a symbol 'sym' (string) from a symbol table 'table'. Returns a
+//      pointer to the data associated with the symbol or NULL if not found
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename CharT, typename SetT>
+T*  add(symbols<T, CharT, SetT>& table, CharT const* sym, T const& data = T());
+
+template <typename T, typename CharT, typename SetT>
+T*  find(symbols<T, CharT, SetT> const& table, CharT const* sym);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  symbol_inserter class
+//
+//      The symbols class holds an instance of this class named 'add'.
+//      This can be called directly just like a member function,
+//      passing in a first/last iterator and optional data:
+//
+//          sym.add(first, last, data);
+//
+//      Or, passing in a C string and optional data:
+//
+//          sym.add(c_string, data);
+//
+//      where sym is a symbol table. The 'data' argument is optional.
+//      This may also be used as a semantic action since it conforms
+//      to the action interface (see action.hpp):
+//
+//          p[sym.add]
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename SetT>
+class symbol_inserter
+{
+public:
+
+    symbol_inserter(SetT& set_)
+    : set(set_) {}
+
+    typedef symbol_inserter const & result_type;
+
+    template <typename IteratorT>
+    symbol_inserter const&
+    operator()(IteratorT first, IteratorT const& last, T const& data = T()) const
+    {
+        set.add(first, last, data);
+        return *this;
+    }
+
+    template <typename CharT>
+    symbol_inserter const&
+    operator()(CharT const* str, T const& data = T()) const
+    {
+        CharT const* last = str;
+        while (*last)
+            last++;
+        set.add(str, last, data);
+        return *this;
+    }
+
+    template <typename CharT>
+    symbol_inserter const&
+    operator,(CharT const* str) const
+    {
+        CharT const* last = str;
+        while (*last)
+            last++;
+        set.add(str, last, T());
+        return *this;
+    }
+
+private:
+
+    SetT& set;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#include <boost/spirit/home/classic/symbols/impl/symbols.ipp>
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/fixed_size_queue.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/fixed_size_queue.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/fixed_size_queue.hpp	(working copy)
@@ -0,0 +1,402 @@
+/*=============================================================================
+    Copyright (c) 2001, Daniel C. Nuffer
+    Copyright (c) 2003, Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef FIXED_SIZE_QUEUE
+#define FIXED_SIZE_QUEUE
+
+#include <cstdlib>
+#include <iterator>
+#include <cstddef>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/assert.hpp> // for BOOST_SPIRIT_ASSERT
+
+// FIXES for broken compilers
+#include <boost/config.hpp>
+#include <boost/iterator_adaptors.hpp>
+
+#define BOOST_SPIRIT_ASSERT_FSQ_SIZE \
+    BOOST_SPIRIT_ASSERT(((m_tail + N + 1) - m_head) % (N+1) == m_size % (N+1)) \
+    /**/
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+namespace impl {
+
+#if !defined(BOOST_ITERATOR_ADAPTORS_VERSION) || \
+    BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+#error "Please use at least Boost V1.31.0 while compiling the fixed_size_queue class!"
+#else // BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+
+template <typename QueueT, typename T, typename PointerT>
+class fsq_iterator
+:   public boost::iterator_adaptor<
+        fsq_iterator<QueueT, T, PointerT>,
+        PointerT,
+        T,
+        std::random_access_iterator_tag
+    >
+{
+public:
+    typedef typename QueueT::position_t position;
+    typedef boost::iterator_adaptor<
+            fsq_iterator<QueueT, T, PointerT>, PointerT, T,
+            std::random_access_iterator_tag
+        > base_t;
+
+    fsq_iterator() {}
+    fsq_iterator(position const &p_) : p(p_) {}
+
+    position const &get_position() const { return p; }
+
+private:
+    friend class boost::iterator_core_access;
+
+    typename base_t::reference dereference() const
+    {
+        return p.self->m_queue[p.pos];
+    }
+
+    void increment()
+    {
+        ++p.pos;
+        if (p.pos == QueueT::MAX_SIZE+1)
+            p.pos = 0;
+    }
+
+    void decrement()
+    {
+        if (p.pos == 0)
+            p.pos = QueueT::MAX_SIZE;
+        else
+            --p.pos;
+    }
+
+    template <
+        typename OtherDerivedT, typename OtherIteratorT,
+        typename V, typename C, typename R, typename D
+    >
+    bool equal(iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>
+        const &x) const
+    {
+        position const &rhs_pos =
+            static_cast<OtherDerivedT const &>(x).get_position();
+        return (p.self == rhs_pos.self) && (p.pos == rhs_pos.pos);
+    }
+
+    template <
+        typename OtherDerivedT, typename OtherIteratorT,
+        typename V, typename C, typename R, typename D
+    >
+    typename base_t::difference_type distance_to(
+        iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>
+        const &x) const
+    {
+        typedef typename base_t::difference_type diff_t;
+
+        position const &p2 =
+            static_cast<OtherDerivedT const &>(x).get_position();
+        std::size_t pos1 = p.pos;
+        std::size_t pos2 = p2.pos;
+
+        // Undefined behaviour if the iterators come from different
+        //  containers
+        BOOST_SPIRIT_ASSERT(p.self == p2.self);
+
+        if (pos1 < p.self->m_head)
+            pos1 += QueueT::MAX_SIZE;
+        if (pos2 < p2.self->m_head)
+            pos2 += QueueT::MAX_SIZE;
+
+        if (pos2 > pos1)
+            return diff_t(pos2 - pos1);
+        else
+            return -diff_t(pos1 - pos2);
+    }
+
+    void advance(typename base_t::difference_type n)
+    {
+        // Notice that we don't care values of n that can
+        //  wrap around more than one time, since it would
+        //  be undefined behaviour anyway (going outside
+        //  the begin/end range). Negative wrapping is a bit
+        //  cumbersome because we don't want to case p.pos
+        //  to signed.
+        if (n < 0)
+        {
+            n = -n;
+            if (p.pos < (std::size_t)n)
+                p.pos = QueueT::MAX_SIZE+1 - (n - p.pos);
+            else
+                p.pos -= n;
+        }
+        else
+        {
+            p.pos += n;
+            if (p.pos >= QueueT::MAX_SIZE+1)
+                p.pos -= QueueT::MAX_SIZE+1;
+        }
+    }
+
+private:
+    position p;
+};
+
+#endif // BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+
+///////////////////////////////////////////////////////////////////////////////
+} /* namespace impl */
+
+template <typename T, std::size_t N>
+class fixed_size_queue
+{
+private:
+    struct position
+    {
+        fixed_size_queue* self;
+        std::size_t pos;
+
+        position() : self(0), pos(0) {}
+
+        // The const_cast here is just to avoid to have two different
+        //  position structures for the const and non-const case.
+        // The const semantic is guaranteed by the iterator itself
+        position(const fixed_size_queue* s, std::size_t p)
+            : self(const_cast<fixed_size_queue*>(s)), pos(p)
+        {}
+    };
+
+public:
+    // Declare the iterators
+    typedef impl::fsq_iterator<fixed_size_queue<T, N>, T, T*> iterator;
+    typedef impl::fsq_iterator<fixed_size_queue<T, N>, T const, T const*>
+        const_iterator;
+    typedef position position_t;
+
+    friend class impl::fsq_iterator<fixed_size_queue<T, N>, T, T*>;
+    friend class impl::fsq_iterator<fixed_size_queue<T, N>, T const, T const*>;
+
+    fixed_size_queue();
+    fixed_size_queue(const fixed_size_queue& x);
+    fixed_size_queue& operator=(const fixed_size_queue& x);
+    ~fixed_size_queue();
+
+    void push_back(const T& e);
+    void push_front(const T& e);
+    void serve(T& e);
+    void pop_front();
+
+    bool empty() const
+    {
+        return m_size == 0;
+    }
+
+    bool full() const
+    {
+        return m_size == N;
+    }
+
+    iterator begin()
+    {
+        return iterator(position(this, m_head));
+    }
+
+    const_iterator begin() const
+    {
+        return const_iterator(position(this, m_head));
+    }
+
+    iterator end()
+    {
+        return iterator(position(this, m_tail));
+    }
+
+    const_iterator end() const
+    {
+        return const_iterator(position(this, m_tail));
+    }
+
+    std::size_t size() const
+    {
+        return m_size;
+    }
+
+    T& front()
+    {
+        return m_queue[m_head];
+    }
+
+    const T& front() const
+    {
+        return m_queue[m_head];
+    }
+
+private:
+    // Redefine the template parameters to avoid using partial template
+    //  specialization on the iterator policy to extract N.
+    BOOST_STATIC_CONSTANT(std::size_t, MAX_SIZE = N);
+
+    std::size_t m_head;
+    std::size_t m_tail;
+    std::size_t m_size;
+    T m_queue[N+1];
+};
+
+template <typename T, std::size_t N>
+inline
+fixed_size_queue<T, N>::fixed_size_queue()
+    : m_head(0)
+    , m_tail(0)
+    , m_size(0)
+{
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+}
+
+template <typename T, std::size_t N>
+inline
+fixed_size_queue<T, N>::fixed_size_queue(const fixed_size_queue& x)
+    : m_head(x.m_head)
+    , m_tail(x.m_tail)
+    , m_size(x.m_size)
+{
+    copy(x.begin(), x.end(), begin());
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+}
+
+template <typename T, std::size_t N>
+inline fixed_size_queue<T, N>&
+fixed_size_queue<T, N>::operator=(const fixed_size_queue& x)
+{
+    if (this != &x)
+    {
+        m_head = x.m_head;
+        m_tail = x.m_tail;
+        m_size = x.m_size;
+        copy(x.begin(), x.end(), begin());
+    }
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+
+    return *this;
+}
+
+template <typename T, std::size_t N>
+inline
+fixed_size_queue<T, N>::~fixed_size_queue()
+{
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+}
+
+template <typename T, std::size_t N>
+inline void
+fixed_size_queue<T, N>::push_back(const T& e)
+{
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+
+    BOOST_SPIRIT_ASSERT(!full());
+
+    m_queue[m_tail] = e;
+    ++m_size;
+    ++m_tail;
+    if (m_tail == N+1)
+        m_tail = 0;
+
+
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+}
+
+template <typename T, std::size_t N>
+inline void
+fixed_size_queue<T, N>::push_front(const T& e)
+{
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+
+    BOOST_SPIRIT_ASSERT(!full());
+
+    if (m_head == 0)
+        m_head = N;
+    else
+        --m_head;
+
+    m_queue[m_head] = e;
+    ++m_size;
+
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+}
+
+
+template <typename T, std::size_t N>
+inline void
+fixed_size_queue<T, N>::serve(T& e)
+{
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+
+    e = m_queue[m_head];
+    pop_front();
+}
+
+
+
+template <typename T, std::size_t N>
+inline void
+fixed_size_queue<T, N>::pop_front()
+{
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+
+    ++m_head;
+    if (m_head == N+1)
+        m_head = 0;
+    --m_size;
+
+    BOOST_SPIRIT_ASSERT(m_size <= N+1);
+    BOOST_SPIRIT_ASSERT_FSQ_SIZE;
+    BOOST_SPIRIT_ASSERT(m_head <= N+1);
+    BOOST_SPIRIT_ASSERT(m_tail <= N+1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#undef BOOST_SPIRIT_ASSERT_FSQ_SIZE
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/impl/file_iterator.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/impl/file_iterator.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/impl/file_iterator.ipp	(working copy)
@@ -0,0 +1,467 @@
+/*=============================================================================
+    Copyright (c) 2003 Giovanni Bajo
+    Copyright (c) 2003 Martin Wille
+    Copyright (c) 2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+
+#ifndef BOOST_SPIRIT_FILE_ITERATOR_IPP
+#define BOOST_SPIRIT_FILE_ITERATOR_IPP
+
+#ifdef BOOST_SPIRIT_FILEITERATOR_WINDOWS
+#  include <windows.h>
+#endif
+
+#include <cstdio>
+#include <boost/shared_ptr.hpp>
+
+#ifdef BOOST_SPIRIT_FILEITERATOR_WINDOWS
+#  include <boost/type_traits/remove_pointer.hpp>
+#endif
+
+#ifdef BOOST_SPIRIT_FILEITERATOR_POSIX
+#  include <sys/types.h> // open, stat, mmap, munmap
+#  include <sys/stat.h>  // stat
+#  include <fcntl.h>     // open
+#  include <unistd.h>    // stat, mmap, munmap
+#  include <sys/mman.h>  // mmap, mmunmap
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+namespace fileiter_impl {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  std_file_iterator
+//
+//  Base class that implements iteration through a file using standard C
+//  stream library (fopen and friends). This class and the following are
+//  the base components on which the iterator is built (through the
+//  iterator adaptor library).
+//
+//  The opened file stream (FILE) is held with a shared_ptr<>, whose
+//  custom deleter invokes fcose(). This makes the syntax of the class
+//  very easy, especially everything related to copying.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename CharT>
+class std_file_iterator
+{
+public:
+    typedef CharT value_type;
+
+    std_file_iterator()
+    {}
+
+    explicit std_file_iterator(std::string const& fileName)
+    {
+        using namespace std;
+        FILE* f = fopen(fileName.c_str(), "rb");
+
+        // If the file was opened, store it into
+        //  the smart pointer.
+        if (f)
+        {
+            m_file.reset(f, fclose);
+            m_pos = 0;
+            m_eof = false;
+            update_char();
+        }
+    }
+
+    std_file_iterator(const std_file_iterator& iter)
+    { *this = iter; }
+
+    std_file_iterator& operator=(const std_file_iterator& iter)
+    {
+        m_file = iter.m_file;
+        m_curChar = iter.m_curChar;
+        m_eof = iter.m_eof;
+        m_pos = iter.m_pos;
+
+        return *this;
+    }
+
+    // Nasty bug in Comeau up to 4.3.0.1, we need explicit boolean context
+    //  for shared_ptr to evaluate correctly
+    operator bool() const
+    { return m_file ? true : false; }
+
+    bool operator==(const std_file_iterator& iter) const
+    {
+        return (m_file == iter.m_file) && (m_eof == iter.m_eof) &&
+            (m_pos == iter.m_pos);
+    }
+
+    const CharT& get_cur_char(void) const
+    {
+        return m_curChar;
+    }
+
+    void prev_char(void)
+    {
+        m_pos -= sizeof(CharT);
+        update_char();
+    }
+
+    void next_char(void)
+    {
+        m_pos += sizeof(CharT);
+        update_char();
+    }
+
+    void seek_end(void)
+    {
+        using namespace std;
+        fseek(m_file.get(), 0, SEEK_END);
+        m_pos = ftell(m_file.get()) / sizeof(CharT);
+        m_eof = true;
+    }
+
+    void advance(std::ptrdiff_t n)
+    {
+        m_pos += n * sizeof(CharT);
+        update_char();
+    }
+
+    std::ptrdiff_t distance(const std_file_iterator& iter) const
+    {
+        return (std::ptrdiff_t)(m_pos - iter.m_pos) / sizeof(CharT);
+    }
+
+private:
+    boost::shared_ptr<std::FILE> m_file;
+    std::size_t m_pos;
+    CharT m_curChar;
+    bool m_eof;
+
+    void update_char(void)
+    {
+        using namespace std;
+        if ((std::size_t)ftell(m_file.get()) != m_pos)
+            fseek(m_file.get(), m_pos, SEEK_SET);
+
+        m_eof = (fread(&m_curChar, sizeof(CharT), 1, m_file.get()) < 1);
+    }
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  mmap_file_iterator
+//
+//  File iterator for memory mapped files, for now implemented on Windows and
+//  POSIX  platforms. This class has the same interface of std_file_iterator,
+//  and can be used in its place (in fact, it's the default for Windows and
+//  POSIX).
+//
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+// mmap_file_iterator, Windows version
+#ifdef BOOST_SPIRIT_FILEITERATOR_WINDOWS
+template <typename CharT>
+class mmap_file_iterator
+{
+public:
+    typedef CharT value_type;
+
+    mmap_file_iterator()
+      : m_filesize(0), m_curChar(0)
+    {}
+
+    explicit mmap_file_iterator(std::string const& fileName)
+      : m_filesize(0), m_curChar(0)
+    {
+        HANDLE hFile = ::CreateFileA(
+            fileName.c_str(),
+            GENERIC_READ,
+            FILE_SHARE_READ,
+            NULL,
+            OPEN_EXISTING,
+            FILE_FLAG_SEQUENTIAL_SCAN,
+            NULL
+        );
+
+        if (hFile == INVALID_HANDLE_VALUE)
+            return;
+
+        // Store the size of the file, it's used to construct
+        //  the end iterator
+        m_filesize = ::GetFileSize(hFile, NULL);
+
+        HANDLE hMap = ::CreateFileMapping(
+            hFile,
+            NULL,
+            PAGE_READONLY,
+            0, 0,
+            NULL
+        );
+
+        if (hMap == NULL)
+        {
+            ::CloseHandle(hFile);
+            return;
+        }
+
+        LPVOID pMem = ::MapViewOfFile(
+            hMap,
+            FILE_MAP_READ,
+            0, 0, 0
+        );
+
+        if (pMem == NULL)
+        {
+            ::CloseHandle(hMap);
+            ::CloseHandle(hFile);
+            return;
+        }
+
+        // We hold both the file handle and the memory pointer.
+        // We can close the hMap handle now because Windows holds internally
+        //  a reference to it since there is a view mapped.
+        ::CloseHandle(hMap);
+
+        // It seems like we can close the file handle as well (because
+        //  a reference is hold by the filemap object).
+        ::CloseHandle(hFile);
+
+        // Store the handles inside the shared_ptr (with the custom destructors)
+        m_mem.reset(static_cast<CharT*>(pMem), ::UnmapViewOfFile);
+
+        // Start of the file
+        m_curChar = m_mem.get();
+    }
+
+    mmap_file_iterator(const mmap_file_iterator& iter)
+    { *this = iter; }
+
+    mmap_file_iterator& operator=(const mmap_file_iterator& iter)
+    {
+        m_curChar = iter.m_curChar;
+        m_mem = iter.m_mem;
+        m_filesize = iter.m_filesize;
+
+        return *this;
+    }
+
+    // Nasty bug in Comeau up to 4.3.0.1, we need explicit boolean context
+    //  for shared_ptr to evaluate correctly
+    operator bool() const
+    { return m_mem ? true : false; }
+
+    bool operator==(const mmap_file_iterator& iter) const
+    { return m_curChar == iter.m_curChar; }
+
+    const CharT& get_cur_char(void) const
+    { return *m_curChar; }
+
+    void next_char(void)
+    { m_curChar++; }
+
+    void prev_char(void)
+    { m_curChar--; }
+
+    void advance(std::ptrdiff_t n)
+    { m_curChar += n; }
+
+    std::ptrdiff_t distance(const mmap_file_iterator& iter) const
+    { return m_curChar - iter.m_curChar; }
+
+    void seek_end(void)
+    {
+        m_curChar = m_mem.get() +
+            (m_filesize / sizeof(CharT));
+    }
+
+private:
+#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+    typedef boost::remove_pointer<HANDLE>::type handle_t;
+#else
+    typedef void handle_t;
+#endif
+
+    boost::shared_ptr<CharT> m_mem;
+    std::size_t m_filesize;
+    CharT* m_curChar;
+};
+
+#endif // BOOST_SPIRIT_FILEITERATOR_WINDOWS
+
+///////////////////////////////////////////////////////////////////////////////
+// mmap_file_iterator, POSIX version
+#ifdef BOOST_SPIRIT_FILEITERATOR_POSIX
+template <typename CharT>
+class mmap_file_iterator
+{
+private:
+    struct mapping
+    {
+        mapping(void *p, off_t len)
+            : data(p)
+            , size(len)
+        { }
+
+        CharT const *begin() const
+        {
+            return static_cast<CharT *>(data);
+        }
+
+        CharT const *end() const
+        {
+            return static_cast<CharT *>(data) + size/sizeof(CharT);
+        }
+
+        ~mapping()
+        {
+            munmap(static_cast<char*>(data), size);
+        }
+
+    private:
+        void *data;
+        off_t size;
+    };
+
+public:
+    typedef CharT value_type;
+
+    mmap_file_iterator()
+      : m_curChar(0)
+    {}
+
+    explicit mmap_file_iterator(std::string const& file_name)
+      : m_curChar(0)
+    {
+        // open the file
+       int fd = open(file_name.c_str(),
+#ifdef O_NOCTTY
+            O_NOCTTY | // if stdin was closed then opening a file
+                       // would cause the file to become the controlling
+                       // terminal if the filename refers to a tty. Setting
+                       // O_NOCTTY inhibits this.
+#endif
+            O_RDONLY);
+
+        if (fd == -1)
+            return;
+
+        // call fstat to find get information about the file just
+        // opened (size and file type)
+        struct stat stat_buf;
+        if ((fstat(fd, &stat_buf) != 0) || !S_ISREG(stat_buf.st_mode))
+        {   // if fstat returns an error or if the file isn't a
+            // regular file we give up.
+            close(fd);
+            return;
+        }
+
+        // perform the actual mapping
+        void *p = mmap(0, stat_buf.st_size, PROT_READ, MAP_SHARED, fd, 0);
+        // it is safe to close() here. POSIX requires that the OS keeps a
+        // second handle to the file while the file is mmapped.
+        close(fd);
+
+        if (p == MAP_FAILED)
+            return;
+
+        mapping *m = 0;
+        try
+        {
+            m = new mapping(p, stat_buf.st_size);
+        }
+        catch(...)
+        {
+            munmap(static_cast<char*>(p), stat_buf.st_size);
+            throw;
+        }
+
+        m_mem.reset(m);
+
+        // Start of the file
+        m_curChar = m_mem->begin();
+    }
+
+    mmap_file_iterator(const mmap_file_iterator& iter)
+    { *this = iter; }
+
+    mmap_file_iterator& operator=(const mmap_file_iterator& iter)
+    {
+        m_curChar = iter.m_curChar;
+        m_mem = iter.m_mem;
+
+        return *this;
+    }
+
+    // Nasty bug in Comeau up to 4.3.0.1, we need explicit boolean context
+    //  for shared_ptr to evaluate correctly
+    operator bool() const
+    { return m_mem ? true : false; }
+
+    bool operator==(const mmap_file_iterator& iter) const
+    { return m_curChar == iter.m_curChar; }
+
+    const CharT& get_cur_char(void) const
+    { return *m_curChar; }
+
+    void next_char(void)
+    { m_curChar++; }
+
+    void prev_char(void)
+    { m_curChar--; }
+
+    void advance(signed long n)
+    { m_curChar += n; }
+
+    long distance(const mmap_file_iterator& iter) const
+    { return m_curChar - iter.m_curChar; }
+
+    void seek_end(void)
+    {
+        m_curChar = m_mem->end();
+    }
+
+private:
+
+    boost::shared_ptr<mapping> m_mem;
+    CharT const* m_curChar;
+};
+
+#endif // BOOST_SPIRIT_FILEITERATOR_POSIX
+
+///////////////////////////////////////////////////////////////////////////////
+} /* namespace boost::spirit::fileiter_impl */
+
+template <typename CharT, typename BaseIteratorT>
+file_iterator<CharT,BaseIteratorT>
+file_iterator<CharT,BaseIteratorT>::make_end(void)
+{
+    file_iterator iter(*this);
+    iter.base_reference().seek_end();
+    return iter;
+}
+
+template <typename CharT, typename BaseIteratorT>
+file_iterator<CharT,BaseIteratorT>&
+file_iterator<CharT,BaseIteratorT>::operator=(const base_t& iter)
+{
+    base_t::operator=(iter);
+    return *this;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} /* namespace boost::spirit */
+
+
+#endif /* BOOST_SPIRIT_FILE_ITERATOR_IPP */
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/impl/position_iterator.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/impl/position_iterator.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/impl/position_iterator.ipp	(working copy)
@@ -0,0 +1,138 @@
+/*=============================================================================
+    Copyright (c) 2002 Juan Carlos Arevalo-Baeza
+    Copyright (c) 2002-2006 Hartmut Kaiser
+    Copyright (c) 2003 Giovanni Bajo
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef POSITION_ITERATOR_IPP
+#define POSITION_ITERATOR_IPP
+
+#include <boost/config.hpp>
+#include <boost/iterator_adaptors.hpp>
+#include <boost/type_traits/add_const.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/type_traits/is_same.hpp>
+#include <boost/spirit/home/classic/core/nil.hpp>  // for nil_t
+#include <boost/detail/iterator.hpp> // for boost::detail::iterator_traits
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  position_policy<file_position_without_column>
+//
+//  Specialization to handle file_position_without_column. Only take care of
+//  newlines since no column tracking is needed.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename String>
+class position_policy<file_position_without_column_base<String> > {
+
+public:
+    void next_line(file_position_without_column_base<String>& pos)
+    {
+        ++pos.line;
+    }
+
+    void set_tab_chars(unsigned int /*chars*/){}
+    void next_char(file_position_without_column_base<String>& /*pos*/)    {}
+    void tabulation(file_position_without_column_base<String>& /*pos*/)   {}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  position_policy<file_position>
+//
+//  Specialization to handle file_position. Track characters and tabulation
+//  to compute the current column correctly.
+//
+//  Default tab size is 4. You can change this with the set_tabchars member
+//  of position_iterator.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename String>
+class position_policy<file_position_base<String> > {
+
+public:
+    position_policy()
+        : m_CharsPerTab(4)
+    {}
+
+    void next_line(file_position_base<String>& pos)
+    {
+        ++pos.line;
+        pos.column = 1;
+    }
+
+    void set_tab_chars(unsigned int chars)
+    {
+        m_CharsPerTab = chars;
+    }
+
+    void next_char(file_position_base<String>& pos)
+    {
+        ++pos.column;
+    }
+
+    void tabulation(file_position_base<String>& pos)
+    {
+        pos.column += m_CharsPerTab - (pos.column - 1) % m_CharsPerTab;
+    }
+
+private:
+    unsigned int m_CharsPerTab;
+};
+
+/* namespace boost::spirit { */ namespace iterator_ { namespace impl {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  position_iterator_base_generator
+//
+//  Metafunction to generate the iterator type using boost::iterator_adaptors,
+//  hiding all the metaprogramming thunking code in it. It is used
+//  mainly to keep the public interface (position_iterator) cleanear.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename MainIterT, typename ForwardIterT, typename PositionT>
+struct position_iterator_base_generator
+{
+private:
+    typedef boost::detail::iterator_traits<ForwardIterT> traits;
+    typedef typename traits::value_type value_type;
+    typedef typename traits::iterator_category iter_category_t;
+
+    // Position iterator is always a non-mutable iterator
+    typedef typename boost::add_const<value_type>::type const_value_type;
+
+public:
+    // Check if the MainIterT is nil. If it's nil, it means that the actual
+    //  self type is position_iterator. Otherwise, it's a real type we
+    //  must use
+    typedef typename boost::mpl::if_<
+        typename boost::is_same<MainIterT, nil_t>::type,
+        position_iterator<ForwardIterT, PositionT, nil_t>,
+        MainIterT
+    >::type main_iter_t;
+
+    typedef boost::iterator_adaptor<
+        main_iter_t,
+        ForwardIterT,
+        const_value_type,
+        boost::forward_traversal_tag
+    > type;
+};
+
+}}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} /* namespace boost::spirit::iterator_::impl */
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/position_iterator_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/position_iterator_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/position_iterator_fwd.hpp	(working copy)
@@ -0,0 +1,60 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    Copyright (c) 2002-2006 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_POSITION_ITERATOR_FWD_HPP)
+#define BOOST_SPIRIT_POSITION_ITERATOR_FWD_HPP
+
+#include <string>
+#include <boost/detail/iterator.hpp> // for boost::detail::iterator_traits
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/nil.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename String = std::string>
+    struct file_position_base;
+
+    typedef file_position_base<std::string> file_position;
+
+    template <typename String = std::string>
+    struct file_position_without_column_base;
+
+    typedef file_position_without_column_base<std::string> file_position_without_column;
+
+    template <
+        typename ForwardIteratorT,
+        typename PositionT = file_position_base<
+            std::basic_string<
+                typename boost::detail::iterator_traits<ForwardIteratorT>::value_type
+            >
+        >,
+        typename SelfT = nil_t
+    >
+    class position_iterator;
+
+    template
+    <
+        typename ForwardIteratorT,
+        typename PositionT = file_position_base<
+            std::basic_string<
+                typename boost::detail::iterator_traits<ForwardIteratorT>::value_type
+            >
+        >
+    >
+    class position_iterator2;
+
+    template <typename PositionT> class position_policy;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/position_iterator.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/position_iterator.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/position_iterator.hpp	(working copy)
@@ -0,0 +1,436 @@
+/*=============================================================================
+    Copyright (c) 2002 Juan Carlos Arevalo-Baeza
+    Copyright (c) 2002-2006 Hartmut Kaiser
+    Copyright (c) 2003 Giovanni Bajo
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_POSITION_ITERATOR_HPP
+#define BOOST_SPIRIT_POSITION_ITERATOR_HPP
+
+#include <string>
+#include <boost/config.hpp>
+#include <boost/concept_check.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/iterator/position_iterator_fwd.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  file_position_without_column
+//
+//  A structure to hold positional information. This includes the file,
+//  and the line number
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename String>
+struct file_position_without_column_base {
+    String file;
+    int line;
+
+    file_position_without_column_base(String const& file_ = String(),
+                  int line_ = 1):
+        file    (file_),
+        line    (line_)
+    {}
+
+    bool operator==(const file_position_without_column_base& fp) const
+    { return line == fp.line && file == fp.file; }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  file_position
+//
+//  This structure holds complete file position, including file name,
+//  line and column number
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename String>
+struct file_position_base : public file_position_without_column_base<String> {
+    int column;
+
+    file_position_base(String const& file_ = String(),
+                       int line_ = 1, int column_ = 1):
+        file_position_without_column_base<String> (file_, line_),
+        column                       (column_)
+    {}
+
+    bool operator==(const file_position_base& fp) const
+    { return column == fp.column && this->line == fp.line && this->file == fp.file; }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  position_policy<>
+//
+//  This template is the policy to handle the file position. It is specialized
+//  on the position type. Providing a custom file_position also requires
+//  providing a specialization of this class.
+//
+//  Policy interface:
+//
+//    Default constructor of the custom position class must be accessible.
+//    set_tab_chars(unsigned int chars) - Set the tabstop width
+//    next_char(PositionT& pos)  - Notify that a new character has been
+//      processed
+//    tabulation(PositionT& pos) - Notify that a tab character has been
+//      processed
+//    next_line(PositionT& pos)  - Notify that a new line delimiter has
+//      been reached.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename PositionT> class position_policy;
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} /* namespace BOOST_SPIRIT_CLASSIC_NS */
+
+
+// This must be included here for full compatibility with old MSVC
+#include "boost/spirit/home/classic/iterator/impl/position_iterator.ipp"
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  position_iterator
+//
+//  It wraps an iterator, and keeps track of the current position in the input,
+//  as it gets incremented.
+//
+//  The wrapped iterator must be at least a Forward iterator. The position
+//  iterator itself will always be a non-mutable Forward iterator.
+//
+//  In order to have begin/end iterators constructed, the end iterator must be
+//  empty constructed. Similar to what happens with stream iterators. The begin
+//  iterator must be constructed from both, the begin and end iterators of the
+//  wrapped iterator type. This is necessary to implement the lookahead of
+//  characters necessary to parse CRLF sequences.
+//
+//  In order to extract the current positional data from the iterator, you may
+//  use the get_position member function.
+//
+//  You can also use the set_position member function to reset the current
+//  position to something new.
+//
+//  The structure that holds the current position can be customized through a
+//  template parameter, and the class position_policy must be specialized
+//  on the new type to define how to handle it. Currently, it's possible
+//  to choose between the file_position and file_position_without_column
+//  (which saves some overhead if managing current column is not required).
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#if !defined(BOOST_ITERATOR_ADAPTORS_VERSION) || \
+     BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+#error "Please use at least Boost V1.31.0 while compiling the position_iterator class!"
+#else // BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Uses the newer iterator_adaptor version (should be released with
+//  Boost V1.31.0)
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename ForwardIteratorT,
+    typename PositionT,
+    typename SelfT
+>
+class position_iterator
+:   public iterator_::impl::position_iterator_base_generator<
+        SelfT,
+        ForwardIteratorT,
+        PositionT
+    >::type,
+    public position_policy<PositionT>
+{
+private:
+
+    typedef position_policy<PositionT> position_policy_t;
+    typedef typename iterator_::impl::position_iterator_base_generator<
+            SelfT,
+            ForwardIteratorT,
+            PositionT
+        >::type base_t;
+    typedef typename iterator_::impl::position_iterator_base_generator<
+            SelfT,
+            ForwardIteratorT,
+            PositionT
+        >::main_iter_t main_iter_t;
+
+public:
+
+    typedef PositionT position_t;
+
+    position_iterator()
+    :   _isend(true)
+    {}
+
+    position_iterator(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end)
+    :   base_t(begin), _end(end), _pos(PositionT()), _isend(begin == end)
+    {}
+
+    template <typename FileNameT>
+    position_iterator(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        FileNameT fileName)
+    :   base_t(begin), _end(end), _pos(PositionT(fileName)),
+        _isend(begin == end)
+    {}
+
+    template <typename FileNameT, typename LineT>
+    position_iterator(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        FileNameT fileName, LineT line)
+    :   base_t(begin), _end(end), _pos(PositionT(fileName, line)),
+        _isend(begin == end)
+    {}
+
+    template <typename FileNameT, typename LineT, typename ColumnT>
+    position_iterator(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        FileNameT fileName, LineT line, ColumnT column)
+    :   base_t(begin), _end(end), _pos(PositionT(fileName, line, column)),
+        _isend(begin == end)
+    {}
+
+    position_iterator(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        const PositionT& pos)
+    :   base_t(begin), _end(end), _pos(pos), _isend(begin == end)
+    {}
+
+    position_iterator(const position_iterator& iter)
+    :   base_t(iter.base()), position_policy_t(iter),
+        _end(iter._end), _pos(iter._pos), _isend(iter._isend)
+    {}
+
+    position_iterator& operator=(const position_iterator& iter)
+    {
+        base_t::operator=(iter);
+        position_policy_t::operator=(iter);
+        _end = iter._end;
+        _pos = iter._pos;
+        _isend = iter._isend;
+        return *this;
+    }
+
+    void set_position(PositionT const& newpos) { _pos = newpos; }
+    PositionT& get_position() { return _pos; }
+    PositionT const& get_position() const { return _pos; }
+
+    void set_tabchars(unsigned int chars)
+    {
+        // This function (which comes from the position_policy) has a
+        //  different name on purpose, to avoid messing with using
+        //  declarations or qualified calls to access the base template
+        //  function, which might break some compilers.
+        this->position_policy_t::set_tab_chars(chars);
+    }
+
+private:
+    friend class boost::iterator_core_access;
+
+    void increment()
+    {
+        typename base_t::reference val = *(this->base());
+        if (val == '\n') {
+            ++this->base_reference();
+            this->next_line(_pos);
+            static_cast<main_iter_t &>(*this).newline();
+        }
+        else if ( val == '\r') {
+            ++this->base_reference();
+            if (this->base_reference() == _end || *(this->base()) != '\n')
+            {
+                this->next_line(_pos);
+                static_cast<main_iter_t &>(*this).newline();
+            }
+        }
+        else if (val == '\t') {
+            this->tabulation(_pos);
+            ++this->base_reference();
+        }
+        else {
+            this->next_char(_pos);
+            ++this->base_reference();
+        }
+
+        // The iterator is at the end only if it's the same
+        //  of the
+        _isend = (this->base_reference() == _end);
+    }
+
+    template <
+        typename OtherDerivedT, typename OtherIteratorT,
+        typename V, typename C, typename R, typename D
+    >
+    bool equal(iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>
+        const &x) const
+    {
+        OtherDerivedT const &rhs = static_cast<OtherDerivedT const &>(x);
+        bool x_is_end = rhs._isend;
+
+        return (_isend == x_is_end) && (_isend || this->base() == rhs.base());
+    }
+
+protected:
+
+    void newline(void)
+    {}
+
+    ForwardIteratorT _end;
+    PositionT _pos;
+    bool _isend;
+};
+
+#endif // BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  position_iterator2
+//
+//  Equivalent to position_iterator, but it is able to extract the current
+//  line into a string. This is very handy for error reports.
+//
+//  Notice that the footprint of this class is higher than position_iterator,
+//  (how much depends on how bulky the underlying iterator is), so it should
+//  be used only if necessary.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template
+<
+    typename ForwardIteratorT,
+    typename PositionT
+>
+class position_iterator2
+    : public position_iterator
+    <
+        ForwardIteratorT,
+        PositionT,
+        position_iterator2<ForwardIteratorT, PositionT>
+    >
+{
+    typedef position_iterator
+    <
+        ForwardIteratorT,
+        PositionT,
+        position_iterator2<ForwardIteratorT, PositionT> // JDG 4-15-03
+    >  base_t;
+
+public:
+    typedef typename base_t::value_type value_type;
+    typedef PositionT position_t;
+
+    position_iterator2()
+    {}
+
+    position_iterator2(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end):
+        base_t(begin, end),
+        _startline(begin)
+    {}
+
+    template <typename FileNameT>
+    position_iterator2(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        FileNameT file):
+        base_t(begin, end, file),
+        _startline(begin)
+    {}
+
+    template <typename FileNameT, typename LineT>
+    position_iterator2(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        FileNameT file, LineT line):
+        base_t(begin, end, file, line),
+        _startline(begin)
+    {}
+
+    template <typename FileNameT, typename LineT, typename ColumnT>
+    position_iterator2(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        FileNameT file, LineT line, ColumnT column):
+        base_t(begin, end, file, line, column),
+        _startline(begin)
+    {}
+
+    position_iterator2(
+        const ForwardIteratorT& begin,
+        const ForwardIteratorT& end,
+        const PositionT& pos):
+        base_t(begin, end, pos),
+        _startline(begin)
+    {}
+
+    position_iterator2(const position_iterator2& iter)
+        : base_t(iter), _startline(iter._startline)
+    {}
+
+    position_iterator2& operator=(const position_iterator2& iter)
+    {
+        base_t::operator=(iter);
+        _startline = iter._startline;
+        return *this;
+    }
+
+    ForwardIteratorT get_currentline_begin(void) const
+    { return _startline; }
+
+    ForwardIteratorT get_currentline_end(void) const
+    { return get_endline(); }
+
+    std::basic_string<value_type> get_currentline(void) const
+    {
+        return std::basic_string<value_type>
+            (get_currentline_begin(), get_currentline_end());
+    }
+
+protected:
+    ForwardIteratorT _startline;
+
+    friend class position_iterator<ForwardIteratorT, PositionT,
+        position_iterator2<ForwardIteratorT, PositionT> >;
+
+    ForwardIteratorT get_endline() const
+    {
+        ForwardIteratorT endline = _startline;
+        while (endline != this->_end && *endline != '\r' && *endline != '\n')
+        {
+            ++endline;
+        }
+        return endline;
+    }
+
+    void newline(void)
+    { _startline = this->base(); }
+};
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/multi_pass_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/multi_pass_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/multi_pass_fwd.hpp	(working copy)
@@ -0,0 +1,47 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_ITERATOR_MULTI_PASS_FWD_HPP)
+#define BOOST_SPIRIT_ITERATOR_MULTI_PASS_FWD_HPP
+
+#include <cstddef>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace multi_pass_policies
+    {
+        class ref_counted;
+        class first_owner;
+        class buf_id_check;
+        class no_check;
+        class std_deque;
+        template<std::size_t N> class fixed_size_queue;
+        class input_iterator;
+        class lex_input;
+        class functor_input;
+    }
+
+    template
+    <
+        typename InputT,
+        typename InputPolicy = multi_pass_policies::input_iterator,
+        typename OwnershipPolicy = multi_pass_policies::ref_counted,
+        typename CheckingPolicy = multi_pass_policies::buf_id_check,
+        typename StoragePolicy = multi_pass_policies::std_deque
+    >
+    class multi_pass;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/multi_pass.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/multi_pass.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/multi_pass.hpp	(working copy)
@@ -0,0 +1,1307 @@
+/*=============================================================================
+    Copyright (c) 2001, Daniel C. Nuffer
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_ITERATOR_MULTI_PASS_HPP
+#define BOOST_SPIRIT_ITERATOR_MULTI_PASS_HPP
+
+#include <boost/config.hpp>
+#include <boost/throw_exception.hpp>
+#include <deque>
+#include <iterator>
+#include <iostream>
+#include <algorithm>    // for std::swap
+#include <exception>    // for std::exception
+#include <boost/limits.hpp>
+#include <boost/iterator.hpp>
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/assert.hpp> // for BOOST_SPIRIT_ASSERT
+#include <boost/spirit/home/classic/iterator/fixed_size_queue.hpp>
+#include <boost/detail/iterator.hpp> // for boost::detail::iterator_traits
+
+#include <boost/spirit/home/classic/iterator/multi_pass_fwd.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+namespace impl {
+    template <typename T>
+    inline void mp_swap(T& t1, T& t2);
+}
+
+namespace multi_pass_policies
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// class ref_counted
+// Implementation of an OwnershipPolicy used by multi_pass.
+//
+// Implementation modified from RefCounted class from the Loki library by
+// Andrei Alexandrescu
+///////////////////////////////////////////////////////////////////////////////
+class ref_counted
+{
+    protected:
+        ref_counted()
+            : count(new std::size_t(1))
+        {}
+
+        ref_counted(ref_counted const& x)
+            : count(x.count)
+        {}
+
+        // clone is called when a copy of the iterator is made, so increment
+        // the ref-count.
+        void clone()
+        {
+            ++*count;
+        }
+
+        // called when a copy is deleted.  Decrement the ref-count.  Return
+        // value of true indicates that the last copy has been released.
+        bool release()
+        {
+            if (!--*count)
+            {
+                delete count;
+                count = 0;
+                return true;
+            }
+            return false;
+        }
+
+        void swap(ref_counted& x)
+        {
+            impl::mp_swap(count, x.count);
+        }
+
+    public:
+        // returns true if there is only one iterator in existence.
+        // std_deque StoragePolicy will free it's buffered data if this
+        // returns true.
+        bool unique() const
+        {
+            return *count == 1;
+        }
+
+    private:
+        std::size_t* count;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class first_owner
+// Implementation of an OwnershipPolicy used by multi_pass
+// This ownership policy dictates that the first iterator created will
+// determine the lifespan of the shared components.  This works well for
+// spirit, since no dynamic allocation of iterators is done, and all copies
+// are make on the stack.
+//
+// There is a caveat about using this policy together with the std_deque
+// StoragePolicy. Since first_owner always returns false from unique(),
+// std_deque will only release the queued data if clear_queue() is called.
+///////////////////////////////////////////////////////////////////////////////
+class first_owner
+{
+    protected:
+        first_owner()
+            : first(true)
+        {}
+
+        first_owner(first_owner const&)
+            : first(false)
+        {}
+
+        void clone()
+        {
+        }
+
+        // return true to indicate deletion of resources
+        bool release()
+        {
+            return first;
+        }
+
+        void swap(first_owner&)
+        {
+            // if we're the first, we still remain the first, even if assigned
+            // to, so don't swap first_.  swap is only called from operator=
+        }
+
+    public:
+        bool unique() const
+        {
+            return false; // no way to know, so always return false
+        }
+
+    private:
+        bool first;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class illegal_backtracking
+// thrown by buf_id_check CheckingPolicy if an instance of an iterator is
+// used after another one has invalidated the queue
+///////////////////////////////////////////////////////////////////////////////
+class illegal_backtracking : public std::exception
+{
+public:
+
+    illegal_backtracking() throw() {}
+    ~illegal_backtracking() throw() {}
+
+    virtual const char*
+    what() const throw()
+    { return "BOOST_SPIRIT_CLASSIC_NS::illegal_backtracking"; }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class buf_id_check
+// Implementation of the CheckingPolicy used by multi_pass
+// This policy is most effective when used together with the std_deque
+// StoragePolicy.
+// If used with the fixed_size_queue StoragePolicy, it will not detect
+// iterator derefereces that are out of the range of the queue.
+///////////////////////////////////////////////////////////////////////////////
+class buf_id_check
+{
+    protected:
+        buf_id_check()
+            : shared_buf_id(new unsigned long(0))
+            , buf_id(0)
+        {}
+
+        buf_id_check(buf_id_check const& x)
+            : shared_buf_id(x.shared_buf_id)
+            , buf_id(x.buf_id)
+        {}
+
+        // will be called from the destructor of the last iterator.
+        void destroy()
+        {
+            delete shared_buf_id;
+            shared_buf_id = 0;
+        }
+
+        void swap(buf_id_check& x)
+        {
+            impl::mp_swap(shared_buf_id, x.shared_buf_id);
+            impl::mp_swap(buf_id, x.buf_id);
+        }
+
+        // called to verify that everything is okay.
+        void check() const
+        {
+            if (buf_id != *shared_buf_id)
+            {
+                boost::throw_exception(illegal_backtracking());
+            }
+        }
+
+        // called from multi_pass::clear_queue, so we can increment the count
+        void clear_queue()
+        {
+            ++*shared_buf_id;
+            ++buf_id;
+        }
+
+    private:
+        unsigned long* shared_buf_id;
+        unsigned long buf_id;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class no_check
+// Implementation of the CheckingPolicy used by multi_pass
+// It does not do anything :-)
+///////////////////////////////////////////////////////////////////////////////
+class no_check
+{
+    protected:
+        no_check() {}
+        no_check(no_check const&) {}
+        void destroy() {}
+        void swap(no_check&) {}
+        void check() const {}
+        void clear_queue() {}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class std_deque
+// Implementation of the StoragePolicy used by multi_pass
+// This stores all data in a std::deque, and keeps an offset to the current
+// position. It stores all the data unless there is only one
+// iterator using the queue.
+// Note: a position is used instead of an iterator, because a push_back on
+// a deque can invalidate any iterators.
+///////////////////////////////////////////////////////////////////////////////
+class std_deque
+{
+    public:
+
+template <typename ValueT>
+class inner
+{
+    private:
+
+        typedef std::deque<ValueT> queue_type;
+        queue_type* queuedElements;
+        mutable typename queue_type::size_type queuePosition;
+
+    protected:
+        inner()
+            : queuedElements(new queue_type)
+            , queuePosition(0)
+        {}
+
+        inner(inner const& x)
+            : queuedElements(x.queuedElements)
+            , queuePosition(x.queuePosition)
+        {}
+
+        // will be called from the destructor of the last iterator.
+        void destroy()
+        {
+            BOOST_SPIRIT_ASSERT(NULL != queuedElements);
+            delete queuedElements;
+            queuedElements = 0;
+        }
+
+        void swap(inner& x)
+        {
+            impl::mp_swap(queuedElements, x.queuedElements);
+            impl::mp_swap(queuePosition, x.queuePosition);
+        }
+
+        // This is called when the iterator is dereferenced.  It's a template
+        // method so we can recover the type of the multi_pass iterator
+        // and call unique and access the m_input data member.
+        template <typename MultiPassT>
+        static typename MultiPassT::reference dereference(MultiPassT const& mp)
+        {
+            if (mp.queuePosition == mp.queuedElements->size())
+            {
+                // check if this is the only iterator
+                if (mp.unique())
+                {
+                    // free up the memory used by the queue.
+                    if (mp.queuedElements->size() > 0)
+                    {
+                        mp.queuedElements->clear();
+                        mp.queuePosition = 0;
+                    }
+                }
+                return mp.get_input();
+            }
+            else
+            {
+                return (*mp.queuedElements)[mp.queuePosition];
+            }
+        }
+
+        // This is called when the iterator is incremented.  It's a template
+        // method so we can recover the type of the multi_pass iterator
+        // and call unique and access the m_input data member.
+        template <typename MultiPassT>
+        static void increment(MultiPassT& mp)
+        {
+            if (mp.queuePosition == mp.queuedElements->size())
+            {
+                // check if this is the only iterator
+                if (mp.unique())
+                {
+                    // free up the memory used by the queue.
+                    if (mp.queuedElements->size() > 0)
+                    {
+                        mp.queuedElements->clear();
+                        mp.queuePosition = 0;
+                    }
+                }
+                else
+                {
+                    mp.queuedElements->push_back(mp.get_input());
+                    ++mp.queuePosition;
+                }
+                mp.advance_input();
+            }
+            else
+            {
+                ++mp.queuePosition;
+            }
+
+        }
+
+        // called to forcibly clear the queue
+        void clear_queue()
+        {
+            queuedElements->clear();
+            queuePosition = 0;
+        }
+
+        // called to determine whether the iterator is an eof iterator
+        template <typename MultiPassT>
+        static bool is_eof(MultiPassT const& mp)
+        {
+            return mp.queuePosition == mp.queuedElements->size() &&
+                mp.input_at_eof();
+        }
+
+        // called by operator==
+        bool equal_to(inner const& x) const
+        {
+            return queuePosition == x.queuePosition;
+        }
+
+        // called by operator<
+        bool less_than(inner const& x) const
+        {
+            return queuePosition < x.queuePosition;
+        }
+}; // class inner
+
+}; // class std_deque
+
+
+///////////////////////////////////////////////////////////////////////////////
+// class fixed_size_queue
+// Implementation of the StoragePolicy used by multi_pass
+// fixed_size_queue keeps a circular buffer (implemented by
+// BOOST_SPIRIT_CLASSIC_NS::fixed_size_queue class) that is size N+1 and stores N elements.
+// It is up to the user to ensure that there is enough look ahead for their
+// grammar.  Currently there is no way to tell if an iterator is pointing
+// to forgotten data.  The leading iterator will put an item in the queue
+// and remove one when it is incremented.  No dynamic allocation is done,
+// except on creation of the queue (fixed_size_queue constructor).
+///////////////////////////////////////////////////////////////////////////////
+template < std::size_t N>
+class fixed_size_queue
+{
+    public:
+
+template <typename ValueT>
+class inner
+{
+    private:
+
+        typedef BOOST_SPIRIT_CLASSIC_NS::fixed_size_queue<ValueT, N> queue_type;
+        queue_type * queuedElements;
+        mutable typename queue_type::iterator queuePosition;
+
+    protected:
+        inner()
+            : queuedElements(new queue_type)
+            , queuePosition(queuedElements->begin())
+        {}
+
+        inner(inner const& x)
+            : queuedElements(x.queuedElements)
+            , queuePosition(x.queuePosition)
+        {}
+
+        // will be called from the destructor of the last iterator.
+        void destroy()
+        {
+            BOOST_SPIRIT_ASSERT(NULL != queuedElements);
+            delete queuedElements;
+            queuedElements = 0;
+        }
+
+        void swap(inner& x)
+        {
+            impl::mp_swap(queuedElements, x.queuedElements);
+            impl::mp_swap(queuePosition, x.queuePosition);
+        }
+
+        // This is called when the iterator is dereferenced.  It's a template
+        // method so we can recover the type of the multi_pass iterator
+        // and access the m_input data member.
+        template <typename MultiPassT>
+        static typename MultiPassT::reference dereference(MultiPassT const& mp)
+        {
+            if (mp.queuePosition == mp.queuedElements->end())
+            {
+                return mp.get_input();
+            }
+            else
+            {
+                return *mp.queuePosition;
+            }
+        }
+
+        // This is called when the iterator is incremented.  It's a template
+        // method so we can recover the type of the multi_pass iterator
+        // and access the m_input data member.
+        template <typename MultiPassT>
+        static void increment(MultiPassT& mp)
+        {
+            if (mp.queuePosition == mp.queuedElements->end())
+            {
+                // don't let the queue get larger than N
+                if (mp.queuedElements->size() >= N)
+                    mp.queuedElements->pop_front();
+
+                mp.queuedElements->push_back(mp.get_input());
+                mp.advance_input();
+            }
+            ++mp.queuePosition;
+        }
+
+        // no-op
+        void clear_queue()
+        {}
+
+        // called to determine whether the iterator is an eof iterator
+        template <typename MultiPassT>
+        static bool is_eof(MultiPassT const& mp)
+        {
+            return mp.queuePosition == mp.queuedElements->end() &&
+                mp.input_at_eof();
+        }
+
+        // called by operator==
+        bool equal_to(inner const& x) const
+        {
+            return queuePosition == x.queuePosition;
+        }
+
+        // called by operator<
+        bool less_than(inner const& x) const
+        {
+            return queuePosition < x.queuePosition;
+        }
+}; // class inner
+
+}; // class fixed_size_queue
+
+
+///////////////////////////////////////////////////////////////////////////////
+// class input_iterator
+// Implementation of the InputPolicy used by multi_pass
+// input_iterator encapsulates an input iterator of type InputT
+///////////////////////////////////////////////////////////////////////////////
+class input_iterator
+{
+    public:
+
+template <typename InputT>
+class inner
+{
+    private:
+        typedef
+            typename boost::detail::iterator_traits<InputT>::value_type
+            result_type;
+
+    public:
+        typedef result_type value_type;
+
+    private:
+        struct Data {
+            Data(InputT const &input_)
+            :   input(input_), was_initialized(false)
+            {}
+
+            InputT input;
+            value_type curtok;
+            bool was_initialized;
+        };
+
+       // Needed by compilers not implementing the resolution to DR45. For
+       // reference, see
+       // http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#45.
+
+       friend struct Data;
+
+    public:
+        typedef
+            typename boost::detail::iterator_traits<InputT>::difference_type
+            difference_type;
+        typedef
+            typename boost::detail::iterator_traits<InputT>::pointer
+            pointer;
+        typedef
+            typename boost::detail::iterator_traits<InputT>::reference
+            reference;
+
+    protected:
+        inner()
+            : data(0)
+        {}
+
+        inner(InputT x)
+            : data(new Data(x))
+        {}
+
+        inner(inner const& x)
+            : data(x.data)
+        {}
+
+        void destroy()
+        {
+            delete data;
+            data = 0;
+        }
+
+        bool same_input(inner const& x) const
+        {
+            return data == x.data;
+        }
+
+        typedef
+            typename boost::detail::iterator_traits<InputT>::value_type
+            value_t;
+        void swap(inner& x)
+        {
+            impl::mp_swap(data, x.data);
+        }
+
+        void ensure_initialized() const
+        {
+            if (data && !data->was_initialized) {
+                data->curtok = *data->input;      // get the first token
+                data->was_initialized = true;
+            }
+        }
+
+    public:
+        reference get_input() const
+        {
+            BOOST_SPIRIT_ASSERT(NULL != data);
+            ensure_initialized();
+            return data->curtok;
+        }
+
+        void advance_input()
+        {
+            BOOST_SPIRIT_ASSERT(NULL != data);
+            data->was_initialized = false;        // should get the next token
+            ++data->input;
+        }
+
+        bool input_at_eof() const
+        {
+            return !data || data->input == InputT();
+        }
+
+    private:
+        Data *data;
+};
+
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class lex_input
+// Implementation of the InputPolicy used by multi_pass
+// lex_input gets tokens (ints) from yylex()
+///////////////////////////////////////////////////////////////////////////////
+class lex_input
+{
+    public:
+
+template <typename InputT>
+class inner
+{
+    public:
+        typedef int value_type;
+    typedef std::ptrdiff_t difference_type;
+        typedef int* pointer;
+        typedef int& reference;
+
+    protected:
+        inner()
+            : curtok(new int(0))
+        {}
+
+        inner(InputT x)
+            : curtok(new int(x))
+        {}
+
+        inner(inner const& x)
+            : curtok(x.curtok)
+        {}
+
+        void destroy()
+        {
+            delete curtok;
+            curtok = 0;
+        }
+
+        bool same_input(inner const& x) const
+        {
+            return curtok == x.curtok;
+        }
+
+        void swap(inner& x)
+        {
+            impl::mp_swap(curtok, x.curtok);
+        }
+
+    public:
+        reference get_input() const
+        {
+            return *curtok;
+        }
+
+        void advance_input()
+        {
+            extern int yylex();
+            *curtok = yylex();
+        }
+
+        bool input_at_eof() const
+        {
+            return *curtok == 0;
+        }
+
+    private:
+        int* curtok;
+
+};
+
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// class functor_input
+// Implementation of the InputPolicy used by multi_pass
+// functor_input gets tokens from a functor
+// Note: the functor must have a typedef for result_type
+// It also must have a static variable of type result_type defined to
+// represent eof that is called eof.
+///////////////////////////////////////////////////////////////////////////////
+class functor_input
+{
+    public:
+
+template <typename FunctorT>
+class inner
+{
+    typedef typename FunctorT::result_type result_type;
+    public:
+        typedef result_type value_type;
+    typedef std::ptrdiff_t difference_type;
+        typedef result_type* pointer;
+        typedef result_type& reference;
+
+    protected:
+        inner()
+            : ftor(0)
+            , curtok(0)
+        {}
+
+        inner(FunctorT const& x)
+            : ftor(new FunctorT(x))
+            , curtok(new result_type((*ftor)()))
+        {}
+
+        inner(inner const& x)
+            : ftor(x.ftor)
+            , curtok(x.curtok)
+        {}
+
+        void destroy()
+        {
+            delete ftor;
+            ftor = 0;
+            delete curtok;
+            curtok = 0;
+        }
+
+        bool same_input(inner const& x) const
+        {
+            return ftor == x.ftor;
+        }
+
+        void swap(inner& x)
+        {
+            impl::mp_swap(curtok, x.curtok);
+            impl::mp_swap(ftor, x.ftor);
+        }
+
+    public:
+        reference get_input() const
+        {
+            return *curtok;
+        }
+
+        void advance_input()
+        {
+            if (curtok) {
+                *curtok = (*ftor)();
+            }
+        }
+
+        bool input_at_eof() const
+        {
+            return !curtok || *curtok == ftor->eof;
+        }
+
+        FunctorT& get_functor() const
+        {
+            return *ftor;
+        }
+
+
+    private:
+        FunctorT* ftor;
+        result_type* curtok;
+
+};
+
+};
+
+} // namespace multi_pass_policies
+
+///////////////////////////////////////////////////////////////////////////////
+// iterator_base_creator
+///////////////////////////////////////////////////////////////////////////////
+
+namespace iterator_ { namespace impl {
+
+// Meta-function to generate a std::iterator<> base class for multi_pass. This
+//  is used mainly to improve conformance of compilers not supporting PTS
+//  and thus relying on inheritance to recognize an iterator.
+// We are using boost::iterator<> because it offers an automatic workaround
+//  for broken std::iterator<> implementations.
+template <typename InputPolicyT, typename InputT>
+struct iterator_base_creator
+{
+    typedef typename InputPolicyT::BOOST_NESTED_TEMPLATE inner<InputT> input_t;
+
+    typedef boost::iterator
+    <
+        std::forward_iterator_tag,
+        typename input_t::value_type,
+        typename input_t::difference_type,
+        typename input_t::pointer,
+        typename input_t::reference
+    > type;
+};
+
+}}
+
+///////////////////////////////////////////////////////////////////////////////
+// class template multi_pass
+///////////////////////////////////////////////////////////////////////////////
+
+// The default multi_pass instantiation uses a ref-counted std_deque scheme.
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+class multi_pass
+    : public OwnershipPolicy
+    , public CheckingPolicy
+    , public StoragePolicy::template inner<
+                typename InputPolicy::template inner<InputT>::value_type>
+    , public InputPolicy::template inner<InputT>
+    , public iterator_::impl::iterator_base_creator<InputPolicy, InputT>::type
+{
+        typedef OwnershipPolicy OP;
+        typedef CheckingPolicy CHP;
+        typedef typename StoragePolicy::template inner<
+            typename InputPolicy::template inner<InputT>::value_type> SP;
+        typedef typename InputPolicy::template inner<InputT> IP;
+        typedef typename
+            iterator_::impl::iterator_base_creator<InputPolicy, InputT>::type
+            IB;
+
+    public:
+        typedef typename IB::value_type value_type;
+        typedef typename IB::difference_type difference_type;
+        typedef typename IB::reference reference;
+        typedef typename IB::pointer pointer;
+        typedef InputT iterator_type;
+
+        multi_pass();
+        explicit multi_pass(InputT input);
+
+#if BOOST_WORKAROUND(__GLIBCPP__, == 20020514)
+        multi_pass(int);
+#endif // BOOST_WORKAROUND(__GLIBCPP__, == 20020514)
+
+        ~multi_pass();
+
+        multi_pass(multi_pass const&);
+        multi_pass& operator=(multi_pass const&);
+
+        void swap(multi_pass& x);
+
+        reference operator*() const;
+        pointer operator->() const;
+        multi_pass& operator++();
+        multi_pass operator++(int);
+
+        void clear_queue();
+
+        bool operator==(const multi_pass& y) const;
+        bool operator<(const multi_pass& y) const;
+
+    private: // helper functions
+        bool is_eof() const;
+};
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+multi_pass()
+    : OP()
+    , CHP()
+    , SP()
+    , IP()
+{
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+multi_pass(InputT input)
+    : OP()
+    , CHP()
+    , SP()
+    , IP(input)
+{
+}
+
+#if BOOST_WORKAROUND(__GLIBCPP__, == 20020514)
+    // The standard library shipped with gcc-3.1 has a bug in
+    // bits/basic_string.tcc. It tries  to use iter::iter(0) to
+    // construct an iterator. Ironically, this  happens in sanity
+    // checking code that isn't required by the standard.
+    // The workaround is to provide an additional constructor that
+    // ignores its int argument and behaves like the default constructor.
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+multi_pass(int)
+    : OP()
+    , CHP()
+    , SP()
+    , IP()
+{
+}
+#endif // BOOST_WORKAROUND(__GLIBCPP__, == 20020514)
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+~multi_pass()
+{
+    if (OP::release())
+    {
+        CHP::destroy();
+        SP::destroy();
+        IP::destroy();
+    }
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+multi_pass(
+        multi_pass const& x)
+    : OP(x)
+    , CHP(x)
+    , SP(x)
+    , IP(x)
+{
+    OP::clone();
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator=(
+        multi_pass const& x)
+{
+    multi_pass temp(x);
+    temp.swap(*this);
+    return *this;
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline void
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+swap(multi_pass& x)
+{
+    OP::swap(x);
+    CHP::swap(x);
+    SP::swap(x);
+    IP::swap(x);
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+typename multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+reference
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator*() const
+{
+    CHP::check();
+    return SP::dereference(*this);
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+typename multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+pointer
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator->() const
+{
+    return &(operator*());
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>&
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator++()
+{
+    CHP::check();
+    SP::increment(*this);
+    return *this;
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator++(int)
+{
+    multi_pass
+    <
+        InputT,
+        InputPolicy,
+        OwnershipPolicy,
+        CheckingPolicy,
+        StoragePolicy
+    > tmp(*this);
+
+    ++*this;
+
+    return tmp;
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline void
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+clear_queue()
+{
+    SP::clear_queue();
+    CHP::clear_queue();
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline bool
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+is_eof() const
+{
+    return SP::is_eof(*this);
+}
+
+///// Comparisons
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline bool
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator==(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+        StoragePolicy>& y) const
+{
+    bool is_eof_ = SP::is_eof(*this);
+    bool y_is_eof_ = SP::is_eof(y);
+
+    if (is_eof_ && y_is_eof_)
+    {
+        return true;  // both are EOF
+    }
+    else if (is_eof_ ^ y_is_eof_)
+    {
+        return false; // one is EOF, one isn't
+    }
+    else if (!IP::same_input(y))
+    {
+        return false;
+    }
+    else
+    {
+        return SP::equal_to(y);
+    }
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline bool
+multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy>::
+operator<(const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+        StoragePolicy>& y) const
+{
+    return SP::less_than(y);
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+bool operator!=(
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& x,
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& y)
+{
+    return !(x == y);
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+bool operator>(
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& x,
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& y)
+{
+    return y < x;
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+bool operator>=(
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& x,
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& y)
+{
+    return !(x < y);
+}
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+inline
+bool operator<=(
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& x,
+        const multi_pass<InputT, InputPolicy, OwnershipPolicy, CheckingPolicy,
+                        StoragePolicy>& y)
+{
+    return !(y < x);
+}
+
+///// Generator function
+template <typename InputT>
+inline multi_pass<InputT,
+    multi_pass_policies::input_iterator, multi_pass_policies::ref_counted,
+    multi_pass_policies::buf_id_check, multi_pass_policies::std_deque>
+make_multi_pass(InputT i)
+{
+    return multi_pass<InputT,
+        multi_pass_policies::input_iterator, multi_pass_policies::ref_counted,
+        multi_pass_policies::buf_id_check, multi_pass_policies::std_deque>(i);
+}
+
+// this could be a template typedef, since such a thing doesn't
+// exist in C++, we'll use inheritance to accomplish the same thing.
+
+template <typename InputT, std::size_t N>
+class look_ahead :
+    public multi_pass<
+        InputT,
+        multi_pass_policies::input_iterator,
+        multi_pass_policies::first_owner,
+        multi_pass_policies::no_check,
+        multi_pass_policies::fixed_size_queue<N> >
+{
+        typedef multi_pass<
+            InputT,
+            multi_pass_policies::input_iterator,
+            multi_pass_policies::first_owner,
+            multi_pass_policies::no_check,
+            multi_pass_policies::fixed_size_queue<N> > base_t;
+    public:
+        look_ahead()
+            : base_t() {}
+
+        explicit look_ahead(InputT x)
+            : base_t(x) {}
+
+        look_ahead(look_ahead const& x)
+            : base_t(x) {}
+
+#if BOOST_WORKAROUND(__GLIBCPP__, == 20020514)
+        look_ahead(int)         // workaround for a bug in the library
+            : base_t() {}       // shipped with gcc 3.1
+#endif // BOOST_WORKAROUND(__GLIBCPP__, == 20020514)
+
+    // default generated operators destructor and assignment operator are okay.
+};
+
+template
+<
+    typename InputT,
+    typename InputPolicy,
+    typename OwnershipPolicy,
+    typename CheckingPolicy,
+    typename StoragePolicy
+>
+void swap(
+    multi_pass<
+        InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy
+    > &x,
+    multi_pass<
+        InputT, InputPolicy, OwnershipPolicy, CheckingPolicy, StoragePolicy
+    > &y)
+{
+    x.swap(y);
+}
+
+namespace impl {
+
+    template <typename T>
+    inline void mp_swap(T& t1, T& t2)
+    {
+        using std::swap;
+        using BOOST_SPIRIT_CLASSIC_NS::swap;
+        swap(t1, t2);
+    }
+}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif // BOOST_SPIRIT_ITERATOR_MULTI_PASS_HPP
+
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/file_iterator_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/file_iterator_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/file_iterator_fwd.hpp	(working copy)
@@ -0,0 +1,39 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+
+#if !defined(BOOST_SPIRIT_FILE_ITERATOR_FWD_HPP)
+#define BOOST_SPIRIT_FILE_ITERATOR_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    namespace fileiter_impl
+    {
+        template <typename CharT = char>
+        class std_file_iterator;
+
+        // may never be defined -- so what...
+        template <typename CharT = char>
+        class mmap_file_iterator;
+    }
+
+    // no defaults here -- too much dependencies
+    template <
+        typename CharT,
+        typename BaseIterator
+    > class file_iterator;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/file_iterator.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/file_iterator.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/iterator/file_iterator.hpp	(working copy)
@@ -0,0 +1,229 @@
+/*=============================================================================
+    Copyright (c) 2003 Giovanni Bajo
+    Copyright (c) 2003 Thomas Witt
+    Copyright (c) 2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  File Iterator structure
+//
+//  The new structure is designed on layers. The top class (used by the user)
+//  is file_iterator, which implements a full random access iterator through
+//  the file, and some specific member functions (constructor that opens
+//  the file, make_end() to generate the end iterator, operator bool to check
+//  if the file was opened correctly).
+//
+//  file_iterator implements the random access iterator interface by the means
+//  of boost::iterator_adaptor, that is inhering an object created with it.
+//  iterator_adaptor gets a low-level file iterator implementation (with just
+//  a few member functions) and a policy (that basically describes to it how
+//  the low-level file iterator interface is). The advantage is that
+//  with boost::iterator_adaptor only 5 functions are needed to implement
+//  a fully conformant random access iterator, instead of dozens of functions
+//  and operators.
+//
+//  There are two low-level file iterators implemented in this module. The
+//  first (std_file_iterator) uses cstdio stream functions (fopen/fread), which
+//  support full buffering, and is available everywhere (it's standard C++).
+//  The second (mmap_file_iterator) is currently available only on Windows
+//  platforms, and uses memory mapped files, which gives a decent speed boost.
+//
+///////////////////////////////////////////////////////////////////////////////
+//
+//  TODO LIST:
+//
+//  - In the Win32 mmap iterator, we could check if keeping a handle to the
+//    opened file is really required. If it's not, we can just store the file
+//    length (for make_end()) and save performance. Notice that this should be
+//    tested under different Windows versions, the behaviour might change.
+//  - Add some error support (by the means of some exceptions) in case of
+//    low-level I/O failure.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef BOOST_SPIRIT_FILE_ITERATOR_HPP
+#define BOOST_SPIRIT_FILE_ITERATOR_HPP
+
+#include <string>
+#include <boost/config.hpp>
+#include <boost/iterator_adaptors.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/safe_bool.hpp>
+
+#include <boost/spirit/home/classic/iterator/file_iterator_fwd.hpp>
+
+#if !defined(BOOST_SPIRIT_FILEITERATOR_STD)
+#  if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) \
+      && !defined(BOOST_DISABLE_WIN32)
+#    define BOOST_SPIRIT_FILEITERATOR_WINDOWS
+#  elif defined(BOOST_HAS_UNISTD_H)
+extern "C"
+{
+#    include <unistd.h>
+}
+#    ifdef _POSIX_MAPPED_FILES
+#      define BOOST_SPIRIT_FILEITERATOR_POSIX
+#    endif // _POSIX_MAPPED_FILES
+#  endif // BOOST_HAS_UNISTD_H
+
+#  if !defined(BOOST_SPIRIT_FILEITERATOR_WINDOWS) && \
+      !defined(BOOST_SPIRIT_FILEITERATOR_POSIX)
+#    define BOOST_SPIRIT_FILEITERATOR_STD
+#  endif
+#endif // BOOST_SPIRIT_FILEITERATOR_STD
+
+///////////////////////////////////////////////////////////////////////////////
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+template <
+    typename CharT = char,
+    typename BaseIterator =
+#ifdef BOOST_SPIRIT_FILEITERATOR_STD
+        fileiter_impl::std_file_iterator<CharT>
+#else
+        fileiter_impl::mmap_file_iterator<CharT>
+#endif
+> class file_iterator;
+
+///////////////////////////////////////////////////////////////////////////////
+namespace fileiter_impl {
+
+    /////////////////////////////////////////////////////////////////////////
+    //
+    //  file_iter_generator
+    //
+    //  Template meta-function to invoke boost::iterator_adaptor
+    //  NOTE: This cannot be moved into the implementation file because of
+    //  a bug of MSVC 7.0 and previous versions (base classes types are
+    //  looked up at compilation time, not instantion types, and
+    //  file_iterator would break).
+    //
+    /////////////////////////////////////////////////////////////////////////
+
+#if !defined(BOOST_ITERATOR_ADAPTORS_VERSION) || \
+     BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+#error "Please use at least Boost V1.31.0 while compiling the file_iterator class!"
+#else // BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+
+    template <typename CharT, typename BaseIteratorT>
+    struct file_iter_generator
+    {
+    public:
+        typedef BaseIteratorT adapted_t;
+        typedef typename adapted_t::value_type value_type;
+
+        typedef boost::iterator_adaptor <
+            file_iterator<CharT, BaseIteratorT>,
+            adapted_t,
+            value_type const,
+            std::random_access_iterator_tag,
+            boost::use_default,
+            std::ptrdiff_t
+        > type;
+    };
+
+#endif // BOOST_ITERATOR_ADAPTORS_VERSION < 0x0200
+
+///////////////////////////////////////////////////////////////////////////////
+} /* namespace impl */
+
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  file_iterator
+//
+//  Iterates through an opened file.
+//
+//  The main iterator interface is implemented by the iterator_adaptors
+//  library, which wraps a conforming iterator interface around the
+//  impl::BaseIterator class. This class merely derives the iterator_adaptors
+//  generated class to implement the custom constructors and make_end()
+//  member function.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+template<typename CharT, typename BaseIteratorT>
+class file_iterator
+    : public fileiter_impl::file_iter_generator<CharT, BaseIteratorT>::type,
+      public safe_bool<file_iterator<CharT, BaseIteratorT> >
+{
+private:
+    typedef typename
+        fileiter_impl::file_iter_generator<CharT, BaseIteratorT>::type
+        base_t;
+    typedef typename
+        fileiter_impl::file_iter_generator<CharT, BaseIteratorT>::adapted_t
+        adapted_t;
+
+public:
+    file_iterator()
+    {}
+
+    file_iterator(std::string const& fileName)
+    :   base_t(adapted_t(fileName))
+    {}
+
+    file_iterator(const base_t& iter)
+    :   base_t(iter)
+    {}
+
+    inline file_iterator& operator=(const base_t& iter);
+    file_iterator make_end(void);
+
+    // operator bool. This borrows a trick from boost::shared_ptr to avoid
+    //   to interfere with arithmetic operations.
+    bool operator_bool(void) const
+    { return this->base(); }
+
+private:
+    friend class ::boost::iterator_core_access;
+
+    typename base_t::reference dereference() const
+    {
+        return this->base_reference().get_cur_char();
+    }
+
+    void increment()
+    {
+        this->base_reference().next_char();
+    }
+
+    void decrement()
+    {
+        this->base_reference().prev_char();
+    }
+
+    void advance(typename base_t::difference_type n)
+    {
+        this->base_reference().advance(n);
+    }
+
+    template <
+        typename OtherDerivedT, typename OtherIteratorT,
+        typename V, typename C, typename R, typename D
+    >
+    typename base_t::difference_type distance_to(
+        iterator_adaptor<OtherDerivedT, OtherIteratorT, V, C, R, D>
+        const &x) const
+    {
+        return x.base().distance(this->base_reference());
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} /* namespace BOOST_SPIRIT_CLASSIC_NS */
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/iterator/impl/file_iterator.ipp> /* implementation */
+
+#endif /* BOOST_SPIRIT_FILE_ITERATOR_HPP */
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/impl/exceptions.ipp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/impl/exceptions.ipp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/impl/exceptions.ipp	(working copy)
@@ -0,0 +1,93 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+    Use, modification and distribution is subject to the Boost Software
+    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_EXCEPTIONS_IPP
+#define BOOST_SPIRIT_EXCEPTIONS_IPP
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+namespace impl {
+
+#ifdef __BORLANDC__
+    template <typename ParserT, typename ScannerT>
+    typename parser_result<ParserT, ScannerT>::type
+    fallback_parser_helper(ParserT const& subject, ScannerT const& scan);
+#endif
+
+    template <typename RT, typename ParserT, typename ScannerT>
+    RT fallback_parser_parse(ParserT const& p, ScannerT const& scan)
+    {
+        typedef typename ScannerT::iterator_t iterator_t;
+        typedef typename RT::attr_t attr_t;
+        typedef error_status<attr_t> error_status_t;
+        typedef typename ParserT::error_descr_t error_descr_t;
+
+        iterator_t save = scan.first;
+        error_status_t hr(error_status_t::retry);
+
+        while (hr.result == error_status_t::retry)
+        {
+            try
+            {
+            #ifndef __BORLANDC__
+                return p.subject().parse(scan);
+            #else
+                return impl::fallback_parser_helper(p, scan);
+            #endif
+            }
+
+            catch (parser_error<error_descr_t, iterator_t>& error)
+            {
+                scan.first = save;
+                hr = p.handler(scan, error);
+                switch (hr.result)
+                {
+                    case error_status_t::fail:
+                        return scan.no_match();
+                    case error_status_t::accept:
+                        return scan.create_match
+                            (std::size_t(hr.length), hr.value, save, scan.first);
+                    case error_status_t::rethrow:
+                         boost::throw_exception(error);
+                    default:
+                        continue;
+                }
+            }
+        }
+        return scan.no_match();
+    }
+
+///////////////////////////////////////////////////////////////////////////
+//
+//  Borland does not like calling the subject directly in the try block.
+//  Removing the #ifdef __BORLANDC__ code makes Borland complain that
+//  some variables and types cannot be found in the catch block. Weird!
+//
+///////////////////////////////////////////////////////////////////////////
+#ifdef __BORLANDC__
+
+    template <typename ParserT, typename ScannerT>
+    typename parser_result<ParserT, ScannerT>::type
+    fallback_parser_helper(ParserT const& p, ScannerT const& scan)
+    {
+        return p.subject().parse(scan);
+    }
+
+#endif
+
+}
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace boost::spirit::impl
+
+///////////////////////////////////////////////////////////////////////////////
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/exceptions_fwd.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/exceptions_fwd.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/exceptions_fwd.hpp	(working copy)
@@ -0,0 +1,41 @@
+/*=============================================================================
+    Copyright (c) 2006 Tobias Schwinger
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_EXCEPTIONS_FWD_HPP)
+#define BOOST_SPIRIT_EXCEPTIONS_FWD_HPP
+
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/nil.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    template <typename ErrorDescrT, typename IteratorT = char const*>
+    struct parser_error;
+
+    template <typename ErrorDescrT, typename ParserT>
+    struct assertive_parser;
+
+    template <typename ErrorDescrT>
+    struct assertion;
+
+    template <typename T = nil_t>
+    struct error_status;
+
+    template <typename ErrorDescrT, typename ParserT, typename HandlerT>
+    struct fallback_parser;
+
+    template <typename ErrorDescrT>
+    struct guard;
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/exceptions.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/exceptions.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/error_handling/exceptions.hpp	(working copy)
@@ -0,0 +1,365 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_EXCEPTIONS_HPP
+#define BOOST_SPIRIT_EXCEPTIONS_HPP
+
+#include <boost/config.hpp>
+#include <boost/throw_exception.hpp>
+#include <boost/spirit/home/classic/namespace.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <exception>
+
+#include <boost/spirit/home/classic/error_handling/exceptions_fwd.hpp>
+
+namespace boost { namespace spirit {
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_BEGIN
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_error_base class
+    //
+    //      This is the base class of parser_error (see below). This may be
+    //      used to catch any type of parser error.
+    //
+    //      This exception shouldn't propagate outside the parser. However to
+    //      avoid quirks of many platforms/implementations which fall outside
+    //      the C++ standard, we derive parser_error_base from std::exception
+    //      to allow a single catch handler to catch all exceptions.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    class parser_error_base : public std::exception
+    {
+    protected:
+
+        parser_error_base() {}
+        virtual ~parser_error_base() throw() {}
+
+    public:
+
+        parser_error_base(parser_error_base const& rhs)
+            : std::exception(rhs) {}
+        parser_error_base& operator=(parser_error_base const&)
+        {
+            return *this;
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  parser_error class
+    //
+    //      Generic parser exception class. This is the base class for all
+    //      parser exceptions. The exception holds the iterator position
+    //      where the error was encountered in its member variable "where".
+    //      The parser_error also holds information regarding the error
+    //      (error descriptor) in its member variable "descriptor".
+    //
+    //      The throw_ function creates and throws a parser_error given
+    //      an iterator and an error descriptor.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ErrorDescrT, typename IteratorT>
+    struct parser_error : public parser_error_base
+    {
+        typedef ErrorDescrT error_descr_t;
+        typedef IteratorT iterator_t;
+
+        parser_error(IteratorT where_, ErrorDescrT descriptor_)
+        : where(where_), descriptor(descriptor_) {}
+
+        parser_error(parser_error const& rhs)
+        : parser_error_base(rhs)
+        , where(rhs.where), descriptor(rhs.descriptor) {}
+
+        parser_error&
+        operator=(parser_error const& rhs)
+        {
+            where = rhs.where;
+            descriptor = rhs.descriptor;
+            return *this;
+        }
+
+        virtual
+        ~parser_error() throw() {}
+
+        virtual const char*
+        what() const throw()
+        {
+            return "BOOST_SPIRIT_CLASSIC_NS::parser_error";
+        }
+
+        IteratorT where;
+        ErrorDescrT descriptor;
+    };
+
+    //////////////////////////////////
+    template <typename ErrorDescrT, typename IteratorT>
+    inline void
+    throw_(IteratorT where, ErrorDescrT descriptor)
+    {
+         boost::throw_exception(
+            parser_error<ErrorDescrT, IteratorT>(where, descriptor));
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  assertive_parser class
+    //
+    //      An assertive_parser class is a parser that throws an exception
+    //      in response to a parsing failure. The assertive_parser throws a
+    //      parser_error exception rather than returning an unsuccessful
+    //      match to signal that the parser failed to match the input.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ErrorDescrT, typename ParserT>
+    struct assertive_parser
+    :   public unary<ParserT, parser<assertive_parser<ErrorDescrT, ParserT> > >
+    {
+        typedef assertive_parser<ErrorDescrT, ParserT>  self_t;
+        typedef unary<ParserT, parser<self_t> >         base_t;
+        typedef unary_parser_category                   parser_category_t;
+
+        assertive_parser(ParserT const& parser, ErrorDescrT descriptor_)
+        : base_t(parser), descriptor(descriptor_) {}
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type result_t;
+            typedef typename ScannerT::iterator_t iterator_t;
+
+            result_t hit = this->subject().parse(scan);
+            if (!hit)
+            {
+                throw_(scan.first, descriptor);
+            }
+            return hit;
+        }
+
+        ErrorDescrT descriptor;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  assertion class
+    //
+    //      assertive_parsers are never instantiated directly. The assertion
+    //      class is used to indirectly create an assertive_parser object.
+    //      Before declaring the grammar, we declare some assertion objects.
+    //      Examples:
+    //
+    //          enum Errors
+    //          {
+    //              program_expected, begin_expected, end_expected
+    //          };
+    //
+    //          assertion<Errors>   expect_program(program_expected);
+    //          assertion<Errors>   expect_begin(begin_expected);
+    //          assertion<Errors>   expect_end(end_expected);
+    //
+    //      Now, we can use these assertions as wrappers around parsers:
+    //
+    //          expect_end(str_p("end"))
+    //
+    //      Take note that although the example uses enums to hold the
+    //      information regarding the error (error desccriptor), we are free
+    //      to use other types such as integers and strings. Enums are
+    //      convenient for error handlers to easily catch since C++ treats
+    //      enums as unique types.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ErrorDescrT>
+    struct assertion
+    {
+        assertion(ErrorDescrT descriptor_)
+        : descriptor(descriptor_) {}
+
+        template <typename ParserT>
+        assertive_parser<ErrorDescrT, ParserT>
+        operator()(ParserT const& parser) const
+        {
+            return assertive_parser<ErrorDescrT, ParserT>(parser, descriptor);
+        }
+
+        ErrorDescrT descriptor;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  error_status<T>
+    //
+    //      Where T is an attribute type compatible with the match attribute
+    //      of the fallback_parser's subject (defaults to nil_t). The class
+    //      error_status reports the result of an error handler (see
+    //      fallback_parser). result can be one of:
+    //
+    //          fail:       quit and fail (return a no_match)
+    //          retry:      attempt error recovery, possibly moving the scanner
+    //          accept:     force success returning a matching length, moving
+    //                      the scanner appropriately and returning an attribute
+    //                      value
+    //          rethrow:    rethrows the error.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename T>
+    struct error_status
+    {
+        enum result_t { fail, retry, accept, rethrow };
+
+        error_status(
+            result_t result_ = fail,
+            std::ptrdiff_t length_ = -1,
+            T const& value_ = T())
+        : result(result_), length(length_), value(value_) {}
+
+        result_t        result;
+        std::ptrdiff_t  length;
+        T               value;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  fallback_parser class
+    //
+    //      Handles exceptions of type parser_error<ErrorDescrT, IteratorT>
+    //      thrown somewhere inside its embedded ParserT object. The class
+    //      sets up a try block before delegating parsing to its subject.
+    //      When an exception is caught, the catch block then calls the
+    //      HandlerT object. HandlerT may be a function or a functor (with
+    //      an operator() member function) compatible with the interface:
+    //
+    //          error_status<T>
+    //          handler(ScannerT const& scan, ErrorT error);
+    //
+    //      Where scan points to the scanner state prior to parsing and error
+    //      is the error that arose (see parser_error). The handler must
+    //      return an error_status<T> object (see above).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    namespace impl
+    {
+        template <typename RT, typename ParserT, typename ScannerT>
+        RT fallback_parser_parse(ParserT const& p, ScannerT const& scan);
+    }
+
+    template <typename ErrorDescrT, typename ParserT, typename HandlerT>
+    struct fallback_parser
+    :   public unary<ParserT,
+        parser<fallback_parser<ErrorDescrT, ParserT, HandlerT> > >
+    {
+        typedef fallback_parser<ErrorDescrT, ParserT, HandlerT>
+            self_t;
+        typedef ErrorDescrT
+            error_descr_t;
+        typedef unary<ParserT, parser<self_t> >
+            base_t;
+        typedef unary_parser_category
+            parser_category_t;
+
+        fallback_parser(ParserT const& parser, HandlerT const& handler_)
+        : base_t(parser), handler(handler_) {}
+
+        template <typename ScannerT>
+        struct result
+        {
+            typedef typename parser_result<ParserT, ScannerT>::type type;
+        };
+
+        template <typename ScannerT>
+        typename parser_result<self_t, ScannerT>::type
+        parse(ScannerT const& scan) const
+        {
+            typedef typename parser_result<self_t, ScannerT>::type result_t;
+            return impl::fallback_parser_parse<result_t>(*this, scan);
+        }
+
+        HandlerT handler;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  guard class
+    //
+    //      fallback_parser objects are not instantiated directly. The guard
+    //      class is used to indirectly create a fallback_parser object.
+    //      guards are typically predeclared just like assertions (see the
+    //      assertion class above; the example extends the previous example
+    //      introduced in the assertion class above):
+    //
+    //          guard<Errors>   my_guard;
+    //
+    //      Errors, in this example is the error descriptor type we want to
+    //      detect; This is essentially the ErrorDescrT template parameter
+    //      of the fallback_parser class.
+    //
+    //      my_guard may now be used in a grammar declaration as:
+    //
+    //          my_guard(p)[h]
+    //
+    //      where p is a parser, h is a function or functor compatible with
+    //      fallback_parser's HandlerT (see above).
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <typename ErrorDescrT, typename ParserT>
+    struct guard_gen : public unary<ParserT, nil_t>
+    {
+        typedef guard<ErrorDescrT>      parser_generator_t;
+        typedef unary_parser_category   parser_category_t;
+
+        guard_gen(ParserT const& p)
+        : unary<ParserT, nil_t>(p) {}
+
+        template <typename HandlerT>
+        fallback_parser<ErrorDescrT, ParserT, HandlerT>
+        operator[](HandlerT const& handler) const
+        {
+            return fallback_parser<ErrorDescrT, ParserT, HandlerT>
+                (this->subject(), handler);
+        }
+    };
+
+    template <typename ErrorDescrT>
+    struct guard
+    {
+        template <typename ParserT>
+        struct result
+        {
+            typedef guard_gen<ErrorDescrT, ParserT> type;
+        };
+
+        template <typename ParserT>
+        static guard_gen<ErrorDescrT, ParserT>
+        generate(ParserT const& parser)
+        {
+            return guard_gen<ErrorDescrT, ParserT>(parser);
+        }
+
+        template <typename ParserT>
+        guard_gen<ErrorDescrT, ParserT>
+        operator()(ParserT const& parser) const
+        {
+            return guard_gen<ErrorDescrT, ParserT>(parser);
+        }
+    };
+
+BOOST_SPIRIT_CLASSIC_NAMESPACE_END
+
+}} // namespace BOOST_SPIRIT_CLASSIC_NS
+
+#include <boost/spirit/home/classic/error_handling/impl/exceptions.ipp>
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/primitives.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/primitives.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/primitives.hpp	(working copy)
@@ -0,0 +1,256 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2001-2002 Joel de Guzman
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef PHOENIX_PRIMITIVES_HPP
+#define PHOENIX_PRIMITIVES_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/phoenix/actor.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  argument class
+//
+//      Lazy arguments
+//
+//      An actor base class that extracts and returns the Nth argument
+//      from the argument list passed in the 'args' tuple in the eval
+//      member function (see actor.hpp). There are some predefined
+//      argument constants that can be used as actors (arg1..argN).
+//
+//      The argument actor is a place-holder for the actual arguments
+//      passed by the client. For example, wherever arg1 is seen placed
+//      in a lazy function (see functions.hpp) or lazy operator (see
+//      operators.hpp), this will be replaced by the actual first
+//      argument in the actual function evaluation. Argument actors are
+//      essentially lazy arguments. A lazy argument is a full actor in
+//      its own right and can be evaluated through the actor's operator().
+//
+//      Example:
+//
+//          char        c = 'A';
+//          int         i = 123;
+//          const char* s = "Hello World";
+//
+//          cout << arg1(c) << ' ';
+//          cout << arg1(i, s) << ' ';
+//          cout << arg2(i, s) << ' ';
+//
+//       will print out "A 123 Hello World"
+//
+///////////////////////////////////////////////////////////////////////////////
+template <int N>
+struct argument {
+
+    template <typename TupleT>
+    struct result { typedef typename tuple_element<N, TupleT>::type type; };
+
+    template <typename TupleT>
+    typename tuple_element<N, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        return args[tuple_index<N>()];
+    }
+};
+
+//////////////////////////////////
+actor<argument<0> > const arg1 = argument<0>();
+actor<argument<1> > const arg2 = argument<1>();
+actor<argument<2> > const arg3 = argument<2>();
+
+#if PHOENIX_LIMIT > 3
+actor<argument<3> > const arg4 = argument<3>();
+actor<argument<4> > const arg5 = argument<4>();
+actor<argument<5> > const arg6 = argument<5>();
+
+#if PHOENIX_LIMIT > 6
+actor<argument<6> > const arg7 = argument<6>();
+actor<argument<7> > const arg8 = argument<7>();
+actor<argument<8> > const arg9 = argument<8>();
+
+#if PHOENIX_LIMIT > 9
+actor<argument<9> > const arg10 = argument<9>();
+actor<argument<10> > const arg11 = argument<10>();
+actor<argument<11> > const arg12 = argument<11>();
+
+#if PHOENIX_LIMIT > 12
+actor<argument<12> > const arg13 = argument<12>();
+actor<argument<13> > const arg14 = argument<13>();
+actor<argument<14> > const arg15 = argument<14>();
+
+#endif
+#endif
+#endif
+#endif
+///////////////////////////////////////////////////////////////////////////////
+//
+//  value class
+//
+//      Lazy values
+//
+//      A bound actual parameter is kept in a value class for deferred
+//      access later when needed. A value object is immutable. Value
+//      objects are typically created through the val(x) free function
+//      which returns a value<T> with T deduced from the type of x. x is
+//      held in the value<T> object by value.
+//
+//      Lazy values are actors. As such, lazy values can be evaluated
+//      through the actor's operator(). Such invocation gives the value's
+//      identity. Example:
+//
+//          cout << val(3)() << val("Hello World")();
+//
+//      prints out "3 Hello World"
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T>
+struct value {
+
+    typedef typename boost::remove_reference<T>::type plain_t;
+
+    template <typename TupleT>
+    struct result { typedef plain_t const type; };
+
+    value(plain_t val_)
+    :   val(val_) {}
+
+    template <typename TupleT>
+    plain_t const
+    eval(TupleT const& /*args*/) const
+    {
+        return val;
+    }
+
+    plain_t val;
+};
+
+//////////////////////////////////
+template <typename T>
+inline actor<value<T> > const
+val(T v)
+{
+    return value<T>(v);
+}
+
+//////////////////////////////////
+template <typename BaseT>
+void
+val(actor<BaseT> const& v);     //  This is undefined and not allowed.
+
+///////////////////////////////////////////////////////////////////////////
+//
+//  Arbitrary types T are typically converted to a actor<value<T> >
+//  (see as_actor<T> in actor.hpp). A specialization is also provided
+//  for arrays. T[N] arrays are converted to actor<value<T const*> >.
+//
+///////////////////////////////////////////////////////////////////////////
+template <typename T>
+struct as_actor {
+
+    typedef actor<value<T> > type;
+    static type convert(T const& x)
+    { return value<T>(x); }
+};
+
+//////////////////////////////////
+template <typename T, int N>
+struct as_actor<T[N]> {
+
+    typedef actor<value<T const*> > type;
+    static type convert(T const x[N])
+    { return value<T const*>(x); }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  variable class
+//
+//      Lazy variables
+//
+//      A bound actual parameter may also be held by non-const reference
+//      in a variable class for deferred access later when needed. A
+//      variable object is mutable, i.e. its referenced variable can be
+//      modified. Variable objects are typically created through the
+//      var(x) free function which returns a variable<T> with T deduced
+//      from the type of x. x is held in the value<T> object by
+//      reference.
+//
+//      Lazy variables are actors. As such, lazy variables can be
+//      evaluated through the actor's operator(). Such invocation gives
+//      the variables's identity. Example:
+//
+//          int i = 3;
+//          char const* s = "Hello World";
+//          cout << var(i)() << var(s)();
+//
+//      prints out "3 Hello World"
+//
+//      Another free function const_(x) may also be used. const_(x) creates
+//      a variable<T const&> object using a constant reference.
+//
+///////////////////////////////////////////////////////////////////////////////
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+template <typename T>
+struct variable {
+
+    template <typename TupleT>
+    struct result { typedef T& type; };
+
+    variable(T& var_)
+    :   var(var_) {}
+
+    template <typename TupleT>
+    T&
+    eval(TupleT const& /*args*/) const
+    {
+        return var;
+    }
+
+    T& var;
+};
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+//////////////////////////////////
+template <typename T>
+inline actor<variable<T> > const
+var(T& v)
+{
+    return variable<T>(v);
+}
+
+//////////////////////////////////
+template <typename T>
+inline actor<variable<T const> > const
+const_(T const& v)
+{
+    return variable<T const>(v);
+}
+
+//////////////////////////////////
+template <typename BaseT>
+void
+var(actor<BaseT> const& v);     //  This is undefined and not allowed.
+
+//////////////////////////////////
+template <typename BaseT>
+void
+const_(actor<BaseT> const& v);  //  This is undefined and not allowed.
+
+///////////////////////////////////////////////////////////////////////////////
+}   //  namespace phoenix
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/closures.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/closures.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/closures.hpp	(working copy)
@@ -0,0 +1,446 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2001-2002 Joel de Guzman
+    MT code Copyright (c) 2002-2003 Martin Wille
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef CLASSIC_PHOENIX_CLOSURES_HPP
+#define CLASSIC_PHOENIX_CLOSURES_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/phoenix/actor.hpp>
+#include <boost/assert.hpp>
+
+#ifdef PHOENIX_THREADSAFE
+#include <boost/thread/tss.hpp>
+#include <boost/thread/once.hpp>
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Adaptable closures
+//
+//      The framework will not be complete without some form of closures
+//      support. Closures encapsulate a stack frame where local
+//      variables are created upon entering a function and destructed
+//      upon exiting. Closures provide an environment for local
+//      variables to reside. Closures can hold heterogeneous types.
+//
+//      Phoenix closures are true hardware stack based closures. At the
+//      very least, closures enable true reentrancy in lambda functions.
+//      A closure provides access to a function stack frame where local
+//      variables reside. Modeled after Pascal nested stack frames,
+//      closures can be nested just like nested functions where code in
+//      inner closures may access local variables from in-scope outer
+//      closures (accessing inner scopes from outer scopes is an error
+//      and will cause a run-time assertion failure).
+//
+//      There are three (3) interacting classes:
+//
+//      1) closure:
+//
+//      At the point of declaration, a closure does not yet create a
+//      stack frame nor instantiate any variables. A closure declaration
+//      declares the types and names[note] of the local variables. The
+//      closure class is meant to be subclassed. It is the
+//      responsibility of a closure subclass to supply the names for
+//      each of the local variable in the closure. Example:
+//
+//          struct my_closure : closure<int, string, double> {
+//
+//              member1 num;        // names the 1st (int) local variable
+//              member2 message;    // names the 2nd (string) local variable
+//              member3 real;       // names the 3rd (double) local variable
+//          };
+//
+//          my_closure clos;
+//
+//      Now that we have a closure 'clos', its local variables can be
+//      accessed lazily using the dot notation. Each qualified local
+//      variable can be used just like any primitive actor (see
+//      primitives.hpp). Examples:
+//
+//          clos.num = 30
+//          clos.message = arg1
+//          clos.real = clos.num * 1e6
+//
+//      The examples above are lazily evaluated. As usual, these
+//      expressions return composite actors that will be evaluated
+//      through a second function call invocation (see operators.hpp).
+//      Each of the members (clos.xxx) is an actor. As such, applying
+//      the operator() will reveal its identity:
+//
+//          clos.num() // will return the current value of clos.num
+//
+//      *** [note] Acknowledgement: Juan Carlos Arevalo-Baeza (JCAB)
+//      introduced and initilally implemented the closure member names
+//      that uses the dot notation.
+//
+//      2) closure_member
+//
+//      The named local variables of closure 'clos' above are actually
+//      closure members. The closure_member class is an actor and
+//      conforms to its conceptual interface. member1..memberN are
+//      predefined typedefs that correspond to each of the listed types
+//      in the closure template parameters.
+//
+//      3) closure_frame
+//
+//      When a closure member is finally evaluated, it should refer to
+//      an actual instance of the variable in the hardware stack.
+//      Without doing so, the process is not complete and the evaluated
+//      member will result to an assertion failure. Remember that the
+//      closure is just a declaration. The local variables that a
+//      closure refers to must still be instantiated.
+//
+//      The closure_frame class does the actual instantiation of the
+//      local variables and links these variables with the closure and
+//      all its members. There can be multiple instances of
+//      closure_frames typically situated in the stack inside a
+//      function. Each closure_frame instance initiates a stack frame
+//      with a new set of closure local variables. Example:
+//
+//          void foo()
+//          {
+//              closure_frame<my_closure> frame(clos);
+//              /* do something */
+//          }
+//
+//      where 'clos' is an instance of our closure 'my_closure' above.
+//      Take note that the usage above precludes locally declared
+//      classes. If my_closure is a locally declared type, we can still
+//      use its self_type as a paramater to closure_frame:
+//
+//          closure_frame<my_closure::self_type> frame(clos);
+//
+//      Upon instantiation, the closure_frame links the local variables
+//      to the closure. The previous link to another closure_frame
+//      instance created before is saved. Upon destruction, the
+//      closure_frame unlinks itself from the closure and relinks the
+//      preceding closure_frame prior to this instance.
+//
+//      The local variables in the closure 'clos' above is default
+//      constructed in the stack inside function 'foo'. Once 'foo' is
+//      exited, all of these local variables are destructed. In some
+//      cases, default construction is not desirable and we need to
+//      initialize the local closure variables with some values. This
+//      can be done by passing in the initializers in a compatible
+//      tuple. A compatible tuple is one with the same number of
+//      elements as the destination and where each element from the
+//      destination can be constructed from each corresponding element
+//      in the source. Example:
+//
+//          tuple<int, char const*, int> init(123, "Hello", 1000);
+//          closure_frame<my_closure> frame(clos, init);
+//
+//      Here now, our closure_frame's variables are initialized with
+//      int: 123, char const*: "Hello" and int: 1000.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+namespace impl
+{
+    ///////////////////////////////////////////////////////////////////////
+    // closure_frame_holder is a simple class that encapsulates the
+    // storage for a frame pointer. It uses thread specific data in
+    // case when multithreading is enabled, an ordinary pointer otherwise
+    //
+    // it has get() and set() member functions. set() has to be used
+    // _after_ get(). get() contains intialisation code in the multi
+    // threading case
+    //
+    // closure_frame_holder is used by the closure<> class to store
+    // the pointer to the current frame.
+    //
+#ifndef PHOENIX_THREADSAFE
+    template <typename FrameT>
+    struct closure_frame_holder
+    {
+        typedef FrameT frame_t;
+        typedef frame_t *frame_ptr;
+
+        closure_frame_holder() : frame(0) {}
+
+        frame_ptr &get() { return frame; }
+        void set(frame_t *f) { frame = f; }
+
+    private:
+        frame_ptr frame;
+
+        // no copies, no assignments
+        closure_frame_holder(closure_frame_holder const &);
+        closure_frame_holder &operator=(closure_frame_holder const &);
+    };
+#else
+    template <typename FrameT>
+    struct closure_frame_holder
+    {
+        typedef FrameT   frame_t;
+        typedef frame_t *frame_ptr;
+
+        closure_frame_holder() : tsp_frame() {}
+
+        frame_ptr &get()
+        {
+            if (!tsp_frame.get())
+                tsp_frame.reset(new frame_ptr(0));
+            return *tsp_frame;
+        }
+        void set(frame_ptr f)
+        {
+            *tsp_frame = f;
+        }
+
+    private:
+        boost::thread_specific_ptr<frame_ptr> tsp_frame;
+
+        // no copies, no assignments
+        closure_frame_holder(closure_frame_holder const &);
+        closure_frame_holder &operator=(closure_frame_holder const &);
+    };
+#endif
+} // namespace phoenix::impl
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  closure_frame class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ClosureT>
+class closure_frame : public ClosureT::tuple_t {
+
+public:
+
+    closure_frame(ClosureT const& clos)
+    : ClosureT::tuple_t(), save(clos.frame.get()), frame(clos.frame)
+    { clos.frame.set(this); }
+
+    template <typename TupleT>
+    closure_frame(ClosureT const& clos, TupleT const& init)
+    : ClosureT::tuple_t(init), save(clos.frame.get()), frame(clos.frame)
+    { clos.frame.set(this); }
+
+    ~closure_frame()
+    { frame.set(save); }
+
+private:
+
+    closure_frame(closure_frame const&);            // no copy
+    closure_frame& operator=(closure_frame const&); // no assign
+
+    closure_frame* save;
+    impl::closure_frame_holder<closure_frame>& frame;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  closure_member class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <int N, typename ClosureT>
+class closure_member {
+
+public:
+
+    typedef typename ClosureT::tuple_t tuple_t;
+
+    closure_member()
+    : frame(ClosureT::closure_frame_holder_ref()) {}
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename tuple_element<
+            N, typename ClosureT::tuple_t
+        >::rtype type;
+    };
+
+    template <typename TupleT>
+    typename tuple_element<N, typename ClosureT::tuple_t>::rtype
+    eval(TupleT const& /*args*/) const
+    {
+        using namespace std;
+        BOOST_ASSERT(frame.get() != 0);
+        return (*frame.get())[tuple_index<N>()];
+    }
+
+private:
+    impl::closure_frame_holder<typename ClosureT::closure_frame_t> &frame;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  closure class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+        typename T0 = nil_t
+    ,   typename T1 = nil_t
+    ,   typename T2 = nil_t
+
+#if PHOENIX_LIMIT > 3
+    ,   typename T3 = nil_t
+    ,   typename T4 = nil_t
+    ,   typename T5 = nil_t
+
+#if PHOENIX_LIMIT > 6
+    ,   typename T6 = nil_t
+    ,   typename T7 = nil_t
+    ,   typename T8 = nil_t
+
+#if PHOENIX_LIMIT > 9
+    ,   typename T9 = nil_t
+    ,   typename T10 = nil_t
+    ,   typename T11 = nil_t
+
+#if PHOENIX_LIMIT > 12
+    ,   typename T12 = nil_t
+    ,   typename T13 = nil_t
+    ,   typename T14 = nil_t
+
+#endif
+#endif
+#endif
+#endif
+>
+class closure {
+
+public:
+
+    typedef tuple<
+            T0, T1, T2
+#if PHOENIX_LIMIT > 3
+        ,   T3, T4, T5
+#if PHOENIX_LIMIT > 6
+        ,   T6, T7, T8
+#if PHOENIX_LIMIT > 9
+        ,   T9, T10, T11
+#if PHOENIX_LIMIT > 12
+        ,   T12, T13, T14
+#endif
+#endif
+#endif
+#endif
+        > tuple_t;
+
+    typedef closure<
+            T0, T1, T2
+#if PHOENIX_LIMIT > 3
+        ,   T3, T4, T5
+#if PHOENIX_LIMIT > 6
+        ,   T6, T7, T8
+#if PHOENIX_LIMIT > 9
+        ,   T9, T10, T11
+#if PHOENIX_LIMIT > 12
+        ,   T12, T13, T14
+#endif
+#endif
+#endif
+#endif
+        > self_t;
+
+    typedef closure_frame<self_t> closure_frame_t;
+
+                            closure()
+                            : frame()       { closure_frame_holder_ref(&frame); }
+
+    typedef actor<closure_member<0, self_t> > member1;
+    typedef actor<closure_member<1, self_t> > member2;
+    typedef actor<closure_member<2, self_t> > member3;
+
+#if PHOENIX_LIMIT > 3
+    typedef actor<closure_member<3, self_t> > member4;
+    typedef actor<closure_member<4, self_t> > member5;
+    typedef actor<closure_member<5, self_t> > member6;
+
+#if PHOENIX_LIMIT > 6
+    typedef actor<closure_member<6, self_t> > member7;
+    typedef actor<closure_member<7, self_t> > member8;
+    typedef actor<closure_member<8, self_t> > member9;
+
+#if PHOENIX_LIMIT > 9
+    typedef actor<closure_member<9, self_t> > member10;
+    typedef actor<closure_member<10, self_t> > member11;
+    typedef actor<closure_member<11, self_t> > member12;
+
+#if PHOENIX_LIMIT > 12
+    typedef actor<closure_member<12, self_t> > member13;
+    typedef actor<closure_member<13, self_t> > member14;
+    typedef actor<closure_member<14, self_t> > member15;
+
+#endif
+#endif
+#endif
+#endif
+
+#if !defined(__MWERKS__) || (__MWERKS__ > 0x3002)
+private:
+#endif
+
+    closure(closure const&);            // no copy
+    closure& operator=(closure const&); // no assign
+
+#if !defined(__MWERKS__) || (__MWERKS__ > 0x3002)
+    template <int N, typename ClosureT>
+    friend class closure_member;
+
+    template <typename ClosureT>
+    friend class closure_frame;
+#endif
+
+    typedef impl::closure_frame_holder<closure_frame_t> holder_t;
+
+#ifdef PHOENIX_THREADSAFE
+    static boost::thread_specific_ptr<holder_t*> &
+    tsp_frame_instance()
+    {
+        static boost::thread_specific_ptr<holder_t*> the_instance;
+        return the_instance;
+    }
+
+    static void
+    tsp_frame_instance_init()
+    {
+        tsp_frame_instance();
+    }
+#endif
+
+    static holder_t &
+    closure_frame_holder_ref(holder_t* holder_ = 0)
+    {
+#ifdef PHOENIX_THREADSAFE
+        static boost::once_flag been_here = BOOST_ONCE_INIT;
+        boost::call_once(been_here, tsp_frame_instance_init);
+        boost::thread_specific_ptr<holder_t*> &tsp_frame = tsp_frame_instance();
+        if (!tsp_frame.get())
+            tsp_frame.reset(new holder_t *(0));
+        holder_t *& holder = *tsp_frame;
+#else
+        static holder_t* holder = 0;
+#endif
+        if (holder_ != 0)
+            holder = holder_;
+        return *holder;
+    }
+
+    mutable holder_t frame;
+};
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+}
+   //  namespace phoenix
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/composite.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/composite.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/composite.hpp	(working copy)
@@ -0,0 +1,1431 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2001-2002 Joel de Guzman
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef PHOENIX_COMPOSITE_HPP
+#define PHOENIX_COMPOSITE_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/phoenix/actor.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite class
+//
+//      A composite is an actor base class composed of zero or more
+//      actors (see actor.hpp) and an operation. A composite is itself
+//      an actor superclass and conforms to its conceptual interface.
+//      Its eval member function un-funnels the tupled actual arguments
+//      from the tuple by invoking each of the actors' eval member
+//      function. The results of each are then passed on as arguments to
+//      the operation. Specializations are provided to handle different
+//      numbers of actors.
+//
+//      Schematically:
+//
+//          actor0.eval(tupled_args) --> arg0 --> |
+//          actor1.eval(tupled_args) --> arg1 --> |
+//          actor2.eval(tupled_args) --> arg3 --> | --> operation(arg0...argN)
+//            ...                                 |
+//          actorN.eval(tupled_args) --> argN --> |
+//
+//      The operation can be any suitable functor that can accept the
+//      arguments passed in by the composite. The operation is expected
+//      to have a member operator() that carries out the actual
+//      operation. There should be a one to one correspondence between
+//      actors of the composite and the arguments of the operation's
+//      member operator().
+//
+//      The operation is also expected to have a nested template class
+//      result<T0...TN>. The nested template class result should have a
+//      typedef 'type' that reflects the return type of its member
+//      operator(). This is essentially a type computer that answers the
+//      metaprogramming question "Given arguments of type T0...TN, what
+//      will be its operator()'s return type?".
+//
+//      There is a special case for operations that accept no arguments.
+//      Such nullary operations are only required to define a typedef
+//      result_type that reflects the return type of its operator().
+//
+//      Here's an example of a simple operation that squares a number:
+//
+//          struct square {
+//
+//              template <typename ArgT>
+//              struct result { typedef ArgT type; };
+//
+//              template <typename ArgT>
+//              ArgT operator()(ArgT n) const { return n * n; }
+//          };
+//
+//      As can be seen, operations can be polymorphic. Its arguments and
+//      return type are not fixed to a particular type. The example
+//      above for example, can handle any ArgT type as long as it has a
+//      multiplication operator.
+//
+//      Composites are not created directly. Instead, there are meta-
+//      programs provided that indirectly create composites. See
+//      operators.hpp, binders.hpp and functions.hpp for examples.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename OperationT
+    ,   typename A = nil_t
+    ,   typename B = nil_t
+    ,   typename C = nil_t
+
+#if PHOENIX_LIMIT > 3
+    ,   typename D = nil_t
+    ,   typename E = nil_t
+    ,   typename F = nil_t
+
+#if PHOENIX_LIMIT > 6
+    ,   typename G = nil_t
+    ,   typename H = nil_t
+    ,   typename I = nil_t
+
+#if PHOENIX_LIMIT > 9
+    ,   typename J = nil_t
+    ,   typename K = nil_t
+    ,   typename L = nil_t
+
+#if PHOENIX_LIMIT > 12
+    ,   typename M = nil_t
+    ,   typename N = nil_t
+    ,   typename O = nil_t
+
+#endif
+#endif
+#endif
+#endif
+
+    ,   typename NU = nil_t  // Not used
+>
+struct composite;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <0 actor> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT>
+struct composite0_result {
+
+    typedef typename OperationT::result_type type;
+};
+
+//////////////////////////////////
+template <typename OperationT>
+struct composite<OperationT,
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite0_result<
+            OperationT, TupleT
+        >::type type;
+    };
+
+    composite(OperationT const& op_)
+    :   op(op_) {}
+
+    template <typename TupleT>
+    typename OperationT::result_type
+    eval(TupleT const& /*args*/) const
+    {
+        return op();
+    }
+
+    mutable OperationT op; //  operation
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <1 actor> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A>
+struct composite1_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A>
+struct composite<OperationT,
+    A, nil_t, nil_t,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite1_result<
+            OperationT, TupleT, A
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_)
+    :   op(op_), a(a_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        return op(ra);
+    }
+
+    mutable OperationT op; //  operation
+    A a; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <2 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B>
+struct composite2_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B>
+struct composite<OperationT,
+    A, B, nil_t,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite2_result<
+            OperationT, TupleT, A, B
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_)
+    :   op(op_), a(a_), b(b_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        return op(ra, rb);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <3 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C>
+struct composite3_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C>
+struct composite<OperationT,
+    A, B, C,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite3_result<
+            OperationT, TupleT, A, B, C
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_)
+    :   op(op_), a(a_), b(b_), c(c_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        return op(ra, rb, rc);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; //  actors
+};
+
+#if PHOENIX_LIMIT > 3
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <4 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D>
+struct composite4_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D>
+struct composite<OperationT,
+    A, B, C, D, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite4_result<
+            OperationT, TupleT, A, B, C, D
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        return op(ra, rb, rc, rd);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <5 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E>
+struct composite5_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E>
+struct composite<OperationT,
+    A, B, C, D, E, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D, E> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite5_result<
+            OperationT, TupleT, A, B, C, D, E
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        return op(ra, rb, rc, rd, re);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <6 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F>
+struct composite6_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F>
+struct composite<OperationT,
+    A, B, C, D, E, F,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D, E, F> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite6_result<
+            OperationT, TupleT, A, B, C, D, E, F
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        return op(ra, rb, rc, rd, re, rf);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; //  actors
+};
+
+#if PHOENIX_LIMIT > 6
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <7 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G>
+struct composite7_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D, E, F, G> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite7_result<
+            OperationT, TupleT, A, B, C, D, E, F, G
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <8 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H>
+struct composite8_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D, E, F, G, H> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite8_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <9 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I>
+struct composite9_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D, E, F, G, H, I> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite9_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; //  actors
+};
+
+#if PHOENIX_LIMIT > 9
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <10 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J>
+struct composite10_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type,
+        typename actor_result<J, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I, J, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT, A, B, C, D, E, F, G, H, I, J> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite10_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I, J
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_, J const& j_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        typename actor_result<J, TupleT>::type rj = j.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri, rj);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; J j; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <11 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K>
+struct composite11_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type,
+        typename actor_result<J, TupleT>::plain_type,
+        typename actor_result<K, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I, J, K, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT,
+        A, B, C, D, E, F, G, H, I, J, K> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite11_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I, J, K
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_, J const& j_,
+        K const& k_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        typename actor_result<J, TupleT>::type rj = j.eval(args);
+        typename actor_result<K, TupleT>::type rk = k.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; J j;
+    K k;//  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <12 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L>
+struct composite12_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type,
+        typename actor_result<J, TupleT>::plain_type,
+        typename actor_result<K, TupleT>::plain_type,
+        typename actor_result<L, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I, J, K, L,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+    nil_t   //  Unused
+> {
+
+    typedef composite<OperationT,
+        A, B, C, D, E, F, G, H, I, J, K, L> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite12_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I, J, K, L
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_, J const& j_,
+        K const& k_, L const& l_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        typename actor_result<J, TupleT>::type rj = j.eval(args);
+        typename actor_result<K, TupleT>::type rk = k.eval(args);
+        typename actor_result<L, TupleT>::type rl = l.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; J j;
+    K k; L l;//  actors
+};
+
+#if PHOENIX_LIMIT > 12
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <13 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M>
+struct composite13_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type,
+        typename actor_result<J, TupleT>::plain_type,
+        typename actor_result<K, TupleT>::plain_type,
+        typename actor_result<L, TupleT>::plain_type,
+        typename actor_result<M, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I, J, K, L, M, nil_t, nil_t, nil_t
+> {
+
+    typedef composite<OperationT,
+        A, B, C, D, E, F, G, H, I, J, K, L, M> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite13_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I, J, K, L, M
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_, J const& j_,
+        K const& k_, L const& l_, M const& m_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_), m(m_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        typename actor_result<J, TupleT>::type rj = j.eval(args);
+        typename actor_result<K, TupleT>::type rk = k.eval(args);
+        typename actor_result<L, TupleT>::type rl = l.eval(args);
+        typename actor_result<M, TupleT>::type rm = m.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; J j;
+    K k; L l; M m; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <14 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N>
+struct composite14_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type,
+        typename actor_result<J, TupleT>::plain_type,
+        typename actor_result<K, TupleT>::plain_type,
+        typename actor_result<L, TupleT>::plain_type,
+        typename actor_result<M, TupleT>::plain_type,
+        typename actor_result<N, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I, J, K, L, M, N, nil_t, nil_t
+> {
+
+    typedef composite<OperationT,
+        A, B, C, D, E, F, G, H, I, J, K, L, M, N> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite14_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I, J, K, L, M, N
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_, J const& j_,
+        K const& k_, L const& l_, M const& m_, N const& n_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_), m(m_), n(n_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        typename actor_result<J, TupleT>::type rj = j.eval(args);
+        typename actor_result<K, TupleT>::type rk = k.eval(args);
+        typename actor_result<L, TupleT>::type rl = l.eval(args);
+        typename actor_result<M, TupleT>::type rm = m.eval(args);
+        typename actor_result<N, TupleT>::type rn = n.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm, rn);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; J j;
+    K k; L l; M m; N n; //  actors
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  composite <15 actors> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename OperationT, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N, typename O>
+struct composite15_result {
+
+    typedef typename OperationT::template result<
+        typename actor_result<A, TupleT>::plain_type,
+        typename actor_result<B, TupleT>::plain_type,
+        typename actor_result<C, TupleT>::plain_type,
+        typename actor_result<D, TupleT>::plain_type,
+        typename actor_result<E, TupleT>::plain_type,
+        typename actor_result<F, TupleT>::plain_type,
+        typename actor_result<G, TupleT>::plain_type,
+        typename actor_result<H, TupleT>::plain_type,
+        typename actor_result<I, TupleT>::plain_type,
+        typename actor_result<J, TupleT>::plain_type,
+        typename actor_result<K, TupleT>::plain_type,
+        typename actor_result<L, TupleT>::plain_type,
+        typename actor_result<M, TupleT>::plain_type,
+        typename actor_result<N, TupleT>::plain_type,
+        typename actor_result<O, TupleT>::plain_type
+    >::type type;
+};
+
+//////////////////////////////////
+template <typename OperationT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N, typename O>
+struct composite<OperationT,
+    A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, nil_t
+> {
+
+    typedef composite<OperationT,
+        A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename composite15_result<
+            OperationT, TupleT, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O
+        >::type type;
+    };
+
+    composite(OperationT const& op_,
+        A const& a_, B const& b_, C const& c_, D const& d_, E const& e_,
+        F const& f_, G const& g_, H const& h_, I const& i_, J const& j_,
+        K const& k_, L const& l_, M const& m_, N const& n_, O const& o_)
+    :   op(op_), a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_), m(m_), n(n_), o(o_) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        typename actor_result<A, TupleT>::type ra = a.eval(args);
+        typename actor_result<B, TupleT>::type rb = b.eval(args);
+        typename actor_result<C, TupleT>::type rc = c.eval(args);
+        typename actor_result<D, TupleT>::type rd = d.eval(args);
+        typename actor_result<E, TupleT>::type re = e.eval(args);
+        typename actor_result<F, TupleT>::type rf = f.eval(args);
+        typename actor_result<G, TupleT>::type rg = g.eval(args);
+        typename actor_result<H, TupleT>::type rh = h.eval(args);
+        typename actor_result<I, TupleT>::type ri = i.eval(args);
+        typename actor_result<J, TupleT>::type rj = j.eval(args);
+        typename actor_result<K, TupleT>::type rk = k.eval(args);
+        typename actor_result<L, TupleT>::type rl = l.eval(args);
+        typename actor_result<M, TupleT>::type rm = m.eval(args);
+        typename actor_result<N, TupleT>::type rn = n.eval(args);
+        typename actor_result<O, TupleT>::type ro = o.eval(args);
+        return op(ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm, rn, ro);
+    }
+
+    mutable OperationT op; //  operation
+    A a; B b; C c; D d; E e; F f; G g; H h; I i; J j;
+    K k; L l; M m; N n; O o; //  actors
+};
+
+#endif
+#endif
+#endif
+#endif
+
+namespace impl {
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //      make_composite is basically a type computer that answers the
+    //      question "Given types T0..TN, what composite type should I
+    //      create <composite_type> and if I were to generate an actual
+    //      composite, what type <type> should I return?"
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    template <
+        typename OperationT
+        ,   typename A = nil_t
+        ,   typename B = nil_t
+        ,   typename C = nil_t
+
+#if PHOENIX_LIMIT > 3
+        ,   typename D = nil_t
+        ,   typename E = nil_t
+        ,   typename F = nil_t
+
+#if PHOENIX_LIMIT > 6
+        ,   typename G = nil_t
+        ,   typename H = nil_t
+        ,   typename I = nil_t
+
+#if PHOENIX_LIMIT > 9
+        ,   typename J = nil_t
+        ,   typename K = nil_t
+        ,   typename L = nil_t
+
+#if PHOENIX_LIMIT > 12
+        ,   typename M = nil_t
+        ,   typename N = nil_t
+        ,   typename O = nil_t
+
+#endif
+#endif
+#endif
+#endif
+    >
+    struct make_composite {
+
+        typedef composite<OperationT
+            ,   typename as_actor<A>::type
+            ,   typename as_actor<B>::type
+            ,   typename as_actor<C>::type
+
+#if PHOENIX_LIMIT > 3
+            ,   typename as_actor<D>::type
+            ,   typename as_actor<E>::type
+            ,   typename as_actor<F>::type
+
+#if PHOENIX_LIMIT > 6
+            ,   typename as_actor<G>::type
+            ,   typename as_actor<H>::type
+            ,   typename as_actor<I>::type
+
+#if PHOENIX_LIMIT > 9
+            ,   typename as_actor<J>::type
+            ,   typename as_actor<K>::type
+            ,   typename as_actor<L>::type
+
+#if PHOENIX_LIMIT > 12
+            ,   typename as_actor<M>::type
+            ,   typename as_actor<N>::type
+            ,   typename as_actor<O>::type
+
+#endif
+#endif
+#endif
+#endif
+        > composite_type;
+
+        typedef actor<composite_type> type;
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //      make_unary, make_binary, make_binary1, make_binary2 and
+    //      make_binary3 utilities are provided here for easy creation of
+    //      unary and binary composites.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+
+    //////////////////////////////////  input is an actor
+    template <typename OperationT, typename BaseT>
+    struct make_unary {
+
+        typedef typename make_composite
+            <OperationT, actor<BaseT> >::type type;
+
+        static type
+        construct(actor<BaseT> const& _0)
+        {
+            typedef typename make_composite
+                    <OperationT, actor<BaseT> >::composite_type
+                ret_t;
+
+            return ret_t(OperationT(), _0);
+        }
+    };
+
+    //////////////////////////////////  LHS is an actor, RHS is unknown
+    template <typename OperationT, typename BaseT, typename B>
+    struct make_binary1 {
+
+        typedef typename make_composite
+            <OperationT, actor<BaseT>, B>::type type;
+
+        static type
+        construct(actor<BaseT> const& _0, B const& _1)
+        {
+            typedef typename make_composite
+                    <OperationT, actor<BaseT>, B>::composite_type
+                ret_t;
+
+            return ret_t(OperationT(), _0, as_actor<B>::convert(_1));
+        }
+    };
+
+    //////////////////////////////////  LHS is unknown, RHS is an actor
+    template <typename OperationT, typename A, typename BaseT>
+    struct make_binary2 {
+
+        typedef typename make_composite
+            <OperationT, A, actor<BaseT> >::type type;
+
+        static type
+        construct(A const& _0, actor<BaseT> const& _1)
+        {
+            typedef typename make_composite
+                    <OperationT, A, actor<BaseT> >::composite_type
+                ret_t;
+
+            return ret_t(OperationT(), as_actor<A>::convert(_0), _1);
+        }
+    };
+
+    //////////////////////////////////  Both LHS and RHS are actors
+    template <typename OperationT, typename BaseA, typename BaseB>
+    struct make_binary3 {
+
+        typedef typename make_composite
+            <OperationT, actor<BaseA>, actor<BaseB> >::type type;
+
+        static type
+        construct(actor<BaseA> const& _0, actor<BaseB> const& _1)
+        {
+            typedef typename make_composite
+                    <OperationT, actor<BaseA>, actor<BaseB> >::composite_type
+                ret_t;
+
+            return ret_t(OperationT(), _0, _1);
+        }
+    };
+
+}   // namespace impl
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+}   //  namespace phoenix
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/actor.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/actor.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/actor.hpp	(working copy)
@@ -0,0 +1,604 @@
+/*=============================================================================
+    Phoenix v1.2
+    Copyright (c) 2001-2002 Joel de Guzman
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef PHOENIX_ACTOR_HPP
+#define PHOENIX_ACTOR_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/phoenix/tuples.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+//  These are forward declared here because we cannot include impl.hpp
+//  or operators.hpp yet but the actor's assignment operator and index
+//  operator are required to be members.
+
+//////////////////////////////////
+struct assign_op;
+struct index_op;
+
+//////////////////////////////////
+namespace impl {
+
+    template <typename OperationT, typename BaseT, typename B>
+    struct make_binary1;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  unpack_tuple class
+//
+//      This class is used to unpack a supplied tuple such, that the members of
+//      this tuple will be handled as if they would be supplied separately.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename TupleT>
+struct unpack_tuple : public TupleT {
+
+    typedef TupleT tuple_t;
+
+    unpack_tuple() {}
+    unpack_tuple(tuple_t const &tuple_) : TupleT(tuple_) {}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  actor class
+//
+//      This class is a protocol class for all actors. This class is
+//      essentially an interface contract. The actor class does not
+//      really know how how to act on anything but instead relies on the
+//      template parameter BaseT (from which the actor will derive from)
+//      to do the actual action.
+//
+//      An actor is a functor that is capable of accepting arguments up
+//      to a predefined maximum. It is up to the base class to do the
+//      actual processing or possibly to limit the arity (no. of
+//      arguments) passed in. Upon invocation of the functor through a
+//      supplied operator(), the actor funnels the arguments passed in
+//      by the client into a tuple and calls the base eval member
+//      function.
+//
+//      Schematically:
+//
+//          arg0 ---------|
+//          arg1 ---------|
+//          arg2 ---------|---> tupled_args ---> base.eval
+//          ...           |
+//          argN ---------|
+//
+//          actor::operator()(arg0, arg1... argN)
+//              ---> BaseT::eval(tupled_args);
+//
+//      Actor base classes from which this class inherits from are
+//      expected to have a corresponding member function eval compatible
+//      with the conceptual Interface:
+//
+//          template <typename TupleT>
+//          actor_return_type
+//          eval(TupleT const& args) const;
+//
+//      where args are the actual arguments passed in by the client
+//      funneled into a tuple (see tuple.hpp for details).
+//
+//      The actor_return_type can be anything. Base classes are free to
+//      return any type, even argument dependent types (types that are
+//      deduced from the types of the arguments). After evaluating the
+//      parameters and doing some computations or actions, the eval
+//      member function concludes by returning something back to the
+//      client. To do this, the forwarding function (the actor's
+//      operator()) needs to know the return type of the eval member
+//      function that it is calling. For this purpose, actor base
+//      classes are required to provide a nested template class:
+//
+//          template <typename TupleT>
+//          struct result;
+//
+//      This auxiliary class provides the result type information
+//      returned by the eval member function of a base actor class. The
+//      nested template class result should have a typedef 'type' that
+//      reflects the return type of its member function eval. It is
+//      basically a type computer that answers the question "given
+//      arguments packed into a TupleT type, what will be the result
+//      type of the eval member function of ActorT?". The template class
+//      actor_result queries this to extract the return type of an
+//      actor. Example:
+//
+//          typedef typename actor_result<ActorT, TupleT>::type
+//              actor_return_type;
+//
+//      where actor_return_type is the actual type returned by ActorT's
+//      eval member function given some arguments in a TupleT.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActorT, typename TupleT>
+struct actor_result {
+
+    typedef typename ActorT::template result<TupleT>::type type;
+    typedef typename remove_reference<type>::type plain_type;
+};
+
+//////////////////////////////////
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+template <typename BaseT>
+struct actor : public BaseT {
+
+    actor();
+    actor(BaseT const& base);
+
+    typename actor_result<BaseT, tuple<> >::type
+    operator()() const;
+
+    template <typename A>
+    typename actor_result<BaseT, tuple<A&> >::type
+    operator()(A& a) const;
+
+    template <typename A, typename B>
+    typename actor_result<BaseT, tuple<A&, B&> >::type
+    operator()(A& a, B& b) const;
+
+    template <typename A, typename B, typename C>
+    typename actor_result<BaseT, tuple<A&, B&, C&> >::type
+    operator()(A& a, B& b, C& c) const;
+
+#if PHOENIX_LIMIT > 3
+    template <typename A, typename B, typename C, typename D>
+    typename actor_result<BaseT, tuple<A&, B&, C&, D&> >::type
+    operator()(A& a, B& b, C& c, D& d) const;
+
+    template <typename A, typename B, typename C, typename D, typename E>
+    typename actor_result<BaseT, tuple<A&, B&, C&, D&, E&> >::type
+    operator()(A& a, B& b, C& c, D& d, E& e) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F>
+    typename actor_result<BaseT, tuple<A&, B&, C&, D&, E&, F&> >::type
+    operator()(A& a, B& b, C& c, D& d, E& e, F& f) const;
+
+#if PHOENIX_LIMIT > 6
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G>
+    typename actor_result<BaseT, tuple<A&, B&, C&, D&, E&, F&, G&> >::type
+    operator()(A& a, B& b, C& c, D& d, E& e, F& f, G& g) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&>
+    >::type
+    operator()(A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&>
+    >::type
+    operator()(A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i) const;
+
+#if PHOENIX_LIMIT > 9
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&>
+    >::type
+    operator()(
+        A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i, J& j) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&>
+    >::type
+    operator()(
+        A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i, J& j,
+        K& k) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&>
+    >::type
+    operator()(
+        A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i, J& j,
+        K& k, L& l) const;
+
+#if PHOENIX_LIMIT > 12
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&>
+    >::type
+    operator()(
+        A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i, J& j,
+        K& k, L& l, M& m) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M, typename N>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&, N&>
+    >::type
+    operator()(
+        A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i, J& j,
+        K& k, L& l, M& m, N& n) const;
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M, typename N, typename O>
+    typename actor_result<BaseT,
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&, N&, O&>
+    >::type
+    operator()(
+        A& a, B& b, C& c, D& d, E& e, F& f, G& g, H& h, I& i, J& j,
+        K& k, L& l, M& m, N& n, O& o) const;
+
+#endif
+#endif
+#endif
+#endif
+
+    template <typename TupleT>
+    typename actor_result<BaseT, unpack_tuple<TupleT> >::type
+    operator()(unpack_tuple<TupleT> const &t) const;
+
+    template <typename B>
+    typename impl::make_binary1<assign_op, BaseT, B>::type
+    operator=(B const& b) const;
+
+    template <typename B>
+    typename impl::make_binary1<index_op, BaseT, B>::type
+    operator[](B const& b) const;
+};
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+//
+//  as_actor
+//
+//      as_actor is a meta-program that converts an arbitrary type into
+//      an actor. All participants in the framework must be first-class
+//      actors. This meta-program is used all throughout the framework
+//      whenever an unknown type needs to be converted to an actor.
+//      as_actor specializations are expected to have a typedef 'type'.
+//      This is the destination actor type. A static member function
+//      'convert' converts an object to this target type.
+//
+//      The meta-program does no conversion if the object to be
+//      converted is already an actor.
+//
+///////////////////////////////////////////////////////////////////////////
+template <typename T>
+struct as_actor;
+
+//////////////////////////////////
+template <typename BaseT>
+struct as_actor<actor<BaseT> > {
+
+    typedef actor<BaseT> type;
+    static type convert(actor<BaseT> const& x) { return x; }
+};
+
+//////////////////////////////////
+template <>
+struct as_actor<nil_t> {
+
+    typedef nil_t type;
+    static nil_t convert(nil_t /*x*/)
+    { return nil_t(); }
+};
+
+//////////////////////////////////
+template <>
+struct as_actor<void> {
+
+    typedef void type;
+    //  ERROR!!!
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  actor class implementation
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename BaseT>
+actor<BaseT>::actor()
+:   BaseT() {}
+
+//////////////////////////////////
+template <typename BaseT>
+actor<BaseT>::actor(BaseT const& base)
+:   BaseT(base) {}
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename actor_result<BaseT, tuple<> >::type
+actor<BaseT>::operator()() const
+{
+    return BaseT::eval(tuple<>());
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename A>
+inline typename actor_result<BaseT, tuple<A&> >::type
+actor<BaseT>::operator()(A& a_) const
+{
+    return BaseT::eval(tuple<A&>(a_));
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename A, typename B>
+inline typename actor_result<BaseT, tuple<A&, B&> >::type
+actor<BaseT>::operator()(A& a_, B& b_) const
+{
+    return BaseT::eval(tuple<A&, B&>(a_, b_));
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename A, typename B, typename C>
+inline typename actor_result<BaseT, tuple<A&, B&, C&> >::type
+actor<BaseT>::operator()(A& a_, B& b_, C& c_) const
+{
+    return BaseT::eval(tuple<A&, B&, C&>(a_, b_, c_));
+}
+
+#if PHOENIX_LIMIT > 3
+//////////////////////////////////
+template <typename BaseT>
+template <typename A, typename B, typename C, typename D>
+inline typename actor_result<BaseT, tuple<A&, B&, C&, D&> >::type
+actor<BaseT>::operator()(A& a_, B& b_, C& c_, D& d_) const
+{
+    return BaseT::eval(tuple<A&, B&, C&, D&>(a_, b_, c_, d_));
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename A, typename B, typename C, typename D, typename E>
+inline typename actor_result<BaseT, tuple<A&, B&, C&, D&, E&> >::type
+actor<BaseT>::operator()(A& a_, B& b_, C& c_, D& d_, E& e_) const
+{
+    return BaseT::eval(tuple<A&, B&, C&, D&, E&>(a_, b_, c_, d_, e_));
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&>
+        (a_, b_, c_, d_, e_, f_)
+    );
+}
+
+#if PHOENIX_LIMIT > 6
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&>
+        (a_, b_, c_, d_, e_, f_, g_)
+    );
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&>
+        (a_, b_, c_, d_, e_, f_, g_, h_)
+    );
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_)
+    );
+}
+
+#if PHOENIX_LIMIT > 9
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_, J& j_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_, j_)
+    );
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_, J& j_,
+    K& k_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_, j_, k_)
+    );
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_, J& j_,
+    K& k_, L& l_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_, j_, k_, l_)
+    );
+}
+
+#if PHOENIX_LIMIT > 12
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_, J& j_,
+    K& k_, L& l_, M& m_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_, j_, k_, l_, m_)
+    );
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&, N&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_, J& j_,
+    K& k_, L& l_, M& m_, N& n_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&, N&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_, j_, k_, l_, m_, n_)
+    );
+}
+
+//////////////////////////////////
+template <typename BaseT>
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N, typename O>
+inline typename actor_result<BaseT,
+    tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&, N&, O&>
+>::type
+actor<BaseT>::operator()(
+    A& a_, B& b_, C& c_, D& d_, E& e_, F& f_, G& g_, H& h_, I& i_, J& j_,
+    K& k_, L& l_, M& m_, N& n_, O& o_
+) const
+{
+    return BaseT::eval(
+        tuple<A&, B&, C&, D&, E&, F&, G&, H&, I&, J&, K&, L&, M&, N&, O&>
+        (a_, b_, c_, d_, e_, f_, g_, h_, i_, j_, k_, l_, m_, n_, o_)
+    );
+}
+
+#endif
+#endif
+#endif
+#endif
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename TupleT>
+typename actor_result<BaseT, unpack_tuple<TupleT> >::type
+actor<BaseT>::operator()(unpack_tuple<TupleT> const &t) const
+{
+    return BaseT::eval(t);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+}   //  namespace phoenix
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/tuple_helpers.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/tuple_helpers.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/tuple_helpers.hpp	(working copy)
@@ -0,0 +1,1075 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2002 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef PHOENIX_TUPLEHELPERS_HPP
+#define PHOENIX_TUPLEHELPERS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <cassert>
+#include <boost/spirit/home/classic/phoenix/tuples.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix
+{
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  make_tuple template class
+//
+//      This template class is used to calculate a tuple type required to hold
+//      the given template parameter type
+//
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+//  normal (non-tuple types are wrapped into a tuple)
+template <typename ResultT>
+struct make_tuple {
+
+    typedef tuple<ResultT> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//  nil_t is converted to an empty tuple type
+template <>
+struct make_tuple<nil_t> {
+
+    typedef tuple<> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//  tuple types are left alone without any refactoring
+template <
+      typename A, typename B, typename C
+#if PHOENIX_LIMIT > 3
+    , typename D, typename E, typename F
+#if PHOENIX_LIMIT > 6
+    , typename G, typename H, typename I
+#if PHOENIX_LIMIT > 9
+    , typename J, typename K, typename L
+#if PHOENIX_LIMIT > 12
+    , typename M, typename N, typename O
+#endif
+#endif
+#endif
+#endif
+>
+struct make_tuple<tuple<A, B, C
+#if PHOENIX_LIMIT > 3
+    , D, E, F
+#if PHOENIX_LIMIT > 6
+    , G, H, I
+#if PHOENIX_LIMIT > 9
+    , J, K, L
+#if PHOENIX_LIMIT > 12
+    , M, N, O
+#endif
+#endif
+#endif
+#endif
+    > > {
+
+// the tuple parameter itself is the required tuple type
+    typedef tuple<A, B, C
+#if PHOENIX_LIMIT > 3
+        , D, E, F
+#if PHOENIX_LIMIT > 6
+        , G, H, I
+#if PHOENIX_LIMIT > 9
+        , J, K, L
+#if PHOENIX_LIMIT > 12
+        , M, N, O
+#endif
+#endif
+#endif
+#endif
+        > type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat_tuple type computer
+//
+//      This class returns the type of a tuple, which is constructed by
+//      concatenating a tuple with a given type
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename TupleT, typename AppendT>
+struct concat_tuple;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <0 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename AppendT>
+struct concat_tuple<tuple<>, AppendT> {
+
+    typedef tuple<AppendT> type;
+};
+
+template <>
+struct concat_tuple<tuple<>, nil_t> {
+
+    typedef tuple<> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <1 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A, typename AppendT>
+struct concat_tuple<tuple<A>, AppendT> {
+
+    typedef tuple<A, AppendT> type;
+};
+
+template <typename A>
+struct concat_tuple<tuple<A>, nil_t> {
+
+    typedef tuple<A> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <2 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A, typename B, typename AppendT>
+struct concat_tuple<tuple<A, B>, AppendT> {
+
+    typedef tuple<A, B, AppendT> type;
+};
+
+template <typename A, typename B>
+struct concat_tuple<tuple<A, B>, nil_t> {
+
+    typedef tuple<A, B> type;
+};
+
+#if PHOENIX_LIMIT > 3
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <3 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C>, AppendT> {
+
+    typedef tuple<A, B, C, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C
+>
+struct concat_tuple<tuple<A, B, C>, nil_t> {
+
+    typedef tuple<A, B, C> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <4 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D>, AppendT> {
+
+    typedef tuple<A, B, C, D, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D
+>
+struct concat_tuple<tuple<A, B, C, D>, nil_t> {
+
+    typedef tuple<A, B, C, D> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <5 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E
+>
+struct concat_tuple<tuple<A, B, C, D, E>, nil_t> {
+
+    typedef tuple<A, B, C, D, E> type;
+};
+
+#if PHOENIX_LIMIT > 6
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <6 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F
+>
+struct concat_tuple<tuple<A, B, C, D, E, F>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <7 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <8 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H> type;
+};
+
+#if PHOENIX_LIMIT > 9
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <9 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <10 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <11 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K> type;
+};
+
+#if PHOENIX_LIMIT > 12
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <12 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K, typename L,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K, L>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, L, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K, typename L
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K, L>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, L> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <13 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K, typename L,
+    typename M,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K, typename L,
+    typename M
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, L, M> type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat tuple <14 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K, typename L,
+    typename M, typename N,
+    typename AppendT
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>, AppendT> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, AppendT> type;
+};
+
+template <
+    typename A, typename B, typename C, typename D, typename E, typename F,
+    typename G, typename H, typename I, typename J, typename K, typename L,
+    typename M, typename N
+>
+struct concat_tuple<tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>, nil_t> {
+
+    typedef tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N> type;
+};
+
+#endif
+#endif
+#endif
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  concat_tuples type computer
+//
+//      This template class returns the type of a tuple built from the
+//      concatenation of two given tuples.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename TupleT1, typename TupleT2, int N, typename AppendT>
+struct concat_tuple_element {
+
+    typedef
+        typename concat_tuple_element<
+                typename concat_tuple<TupleT1, AppendT>::type, TupleT2, N+1,
+                typename tuple_element<N+1, TupleT2>::type
+            >::type
+        type;
+};
+
+template <typename TupleT1, typename TupleT2, int N>
+struct concat_tuple_element<TupleT1, TupleT2, N, nil_t> {
+
+    typedef TupleT1 type;
+};
+
+template <typename TupleT1, typename TupleT2>
+struct concat_tuples {
+
+    typedef
+        typename concat_tuple_element<
+                TupleT1, TupleT2, 0,
+                typename tuple_element<0, TupleT2>::type
+            >::type
+        type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  convert_actors template function
+//
+//      The convert_actors template functions constructs a new tuple object
+//      composed of the elements returned by the actors contained in the
+//      input tuple. (i.e. the given tuple type 'actor_tuple' contains a set
+//      of actors to evaluate and the resulting tuple contains the results of
+//      evaluating the actors.)
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename ActorT, typename TupleT>
+struct actor_result; // forward declaration
+
+namespace impl
+{
+    template <unsigned N>
+    struct convert_actors_ {};
+}
+
+template <typename TupleResultT, typename ActorTupleT>
+TupleResultT
+convert_actors(ActorTupleT const& actor_tuple)
+{
+    BOOST_STATIC_ASSERT(ActorTupleT::length <= TupleResultT::length);
+    BOOST_STATIC_CONSTANT(int, length = TupleResultT::length);
+    return impl::convert_actors_<length>
+        ::template apply<TupleResultT, ActorTupleT>::do_(actor_tuple);
+}
+
+namespace impl
+{
+    template <int N, typename TupleResultT, typename ActorTupleT>
+    struct convert_actor
+    {
+        typedef typename tuple_element<N, TupleResultT>::type type;
+
+        template <bool C>
+        struct is_default_t {};
+        typedef is_default_t<true>  is_default;
+        typedef is_default_t<false> is_not_default;
+
+        static type
+        actor_element(ActorTupleT const& /*actor_tuple*/, is_default)
+        {
+            return type(); // default construct
+        }
+
+        static type
+        actor_element(ActorTupleT const& actor_tuple, is_not_default)
+        {
+            BOOST_STATIC_ASSERT(ActorTupleT::length <= TupleResultT::length);
+            return actor_tuple[tuple_index<N>()](); // apply the actor
+        }
+
+        static type
+        do_(ActorTupleT const& actor_tuple)
+        {
+            return actor_element(
+                actor_tuple, is_default_t<(N >= ActorTupleT::length)>());
+        }
+    };
+
+    ///////////////////////////////////////
+    template <>
+    struct convert_actors_<1>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+
+                return TupleResultT(
+                    converter0::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    ///////////////////////////////////////
+    template <>
+    struct convert_actors_<2>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    ///////////////////////////////////////
+    template <>
+    struct convert_actors_<3>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    #if PHOENIX_LIMIT > 3
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<4>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<5>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<6>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    #if PHOENIX_LIMIT > 6
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<7>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<8>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<9>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    #if PHOENIX_LIMIT > 9
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<10>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+                typedef impl::convert_actor<9, TupleResultT, ActorTupleT> converter9;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                    ,   converter9::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<11>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+                typedef impl::convert_actor<9, TupleResultT, ActorTupleT> converter9;
+                typedef impl::convert_actor<10, TupleResultT, ActorTupleT> converter10;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                    ,   converter9::do_(actor_tuple)
+                    ,   converter10::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<12>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+                typedef impl::convert_actor<9, TupleResultT, ActorTupleT> converter9;
+                typedef impl::convert_actor<10, TupleResultT, ActorTupleT> converter10;
+                typedef impl::convert_actor<11, TupleResultT, ActorTupleT> converter11;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                    ,   converter9::do_(actor_tuple)
+                    ,   converter10::do_(actor_tuple)
+                    ,   converter11::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    #if PHOENIX_LIMIT > 12
+
+    /////////////////////////////////////
+    template <>
+    struct convert_actors_<13>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+                typedef impl::convert_actor<9, TupleResultT, ActorTupleT> converter9;
+                typedef impl::convert_actor<10, TupleResultT, ActorTupleT> converter10;
+                typedef impl::convert_actor<11, TupleResultT, ActorTupleT> converter11;
+                typedef impl::convert_actor<12, TupleResultT, ActorTupleT> converter12;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                    ,   converter9::do_(actor_tuple)
+                    ,   converter10::do_(actor_tuple)
+                    ,   converter11::do_(actor_tuple)
+                    ,   converter12::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    ///////////////////////////////////////
+    template <>
+    struct convert_actors_<14>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+                typedef impl::convert_actor<9, TupleResultT, ActorTupleT> converter9;
+                typedef impl::convert_actor<10, TupleResultT, ActorTupleT> converter10;
+                typedef impl::convert_actor<11, TupleResultT, ActorTupleT> converter11;
+                typedef impl::convert_actor<12, TupleResultT, ActorTupleT> converter12;
+                typedef impl::convert_actor<13, TupleResultT, ActorTupleT> converter13;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                    ,   converter9::do_(actor_tuple)
+                    ,   converter10::do_(actor_tuple)
+                    ,   converter11::do_(actor_tuple)
+                    ,   converter12::do_(actor_tuple)
+                    ,   converter13::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    ///////////////////////////////////////
+    template <>
+    struct convert_actors_<15>
+    {
+        template <typename TupleResultT, typename ActorTupleT>
+        struct apply
+        {
+            static TupleResultT
+            do_(ActorTupleT const& actor_tuple)
+            {
+                typedef impl::convert_actor<0, TupleResultT, ActorTupleT> converter0;
+                typedef impl::convert_actor<1, TupleResultT, ActorTupleT> converter1;
+                typedef impl::convert_actor<2, TupleResultT, ActorTupleT> converter2;
+                typedef impl::convert_actor<3, TupleResultT, ActorTupleT> converter3;
+                typedef impl::convert_actor<4, TupleResultT, ActorTupleT> converter4;
+                typedef impl::convert_actor<5, TupleResultT, ActorTupleT> converter5;
+                typedef impl::convert_actor<6, TupleResultT, ActorTupleT> converter6;
+                typedef impl::convert_actor<7, TupleResultT, ActorTupleT> converter7;
+                typedef impl::convert_actor<8, TupleResultT, ActorTupleT> converter8;
+                typedef impl::convert_actor<9, TupleResultT, ActorTupleT> converter9;
+                typedef impl::convert_actor<10, TupleResultT, ActorTupleT> converter10;
+                typedef impl::convert_actor<11, TupleResultT, ActorTupleT> converter11;
+                typedef impl::convert_actor<12, TupleResultT, ActorTupleT> converter12;
+                typedef impl::convert_actor<13, TupleResultT, ActorTupleT> converter13;
+                typedef impl::convert_actor<14, TupleResultT, ActorTupleT> converter14;
+
+                using namespace tuple_index_names;
+                return TupleResultT(
+                        converter0::do_(actor_tuple)
+                    ,   converter1::do_(actor_tuple)
+                    ,   converter2::do_(actor_tuple)
+                    ,   converter3::do_(actor_tuple)
+                    ,   converter4::do_(actor_tuple)
+                    ,   converter5::do_(actor_tuple)
+                    ,   converter6::do_(actor_tuple)
+                    ,   converter7::do_(actor_tuple)
+                    ,   converter8::do_(actor_tuple)
+                    ,   converter9::do_(actor_tuple)
+                    ,   converter10::do_(actor_tuple)
+                    ,   converter11::do_(actor_tuple)
+                    ,   converter12::do_(actor_tuple)
+                    ,   converter13::do_(actor_tuple)
+                    ,   converter14::do_(actor_tuple)
+                );
+            }
+        };
+    };
+
+    #endif
+    #endif
+    #endif
+    #endif
+}   //  namespace impl
+
+
+///////////////////////////////////////////////////////////////////////////////
+}   //  namespace phoenix
+
+#endif // PHOENIX_TUPLEHELPERS_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/tuples.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/tuples.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/tuples.hpp	(working copy)
@@ -0,0 +1,1338 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2001-2002 Joel de Guzman
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef PHOENIX_TUPLES_HPP
+#define PHOENIX_TUPLES_HPP
+
+#if defined(BOOST_MSVC) && (BOOST_MSVC <= 1300)
+#error "Sorry, Phoenix does not support VC6 and VC7. Please upgrade to at least VC7.1"
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Phoenix predefined maximum limit. This limit defines the maximum
+//  number of elements a tuple can hold. This number defaults to 3. The
+//  actual maximum is rounded up in multiples of 3. Thus, if this value
+//  is 4, the actual limit is 6. The ultimate maximum limit in this
+//  implementation is 15.
+//
+///////////////////////////////////////////////////////////////////////////////
+#ifndef PHOENIX_LIMIT
+#define PHOENIX_LIMIT 3
+#endif
+
+#if defined(__BORLANDC__) && (__BORLANDC__ <= 0x561)
+namespace phoenix { namespace borland_only
+{
+    namespace ftors
+    {
+        //  We define these dummy template functions. Borland complains when
+        //  a template class has the same name as a template function,
+        //  regardless if they are in different namespaces.
+
+        template <typename T> void if_(T) {}
+        template <typename T> void for_(T) {}
+        template <typename T> void while_(T) {}
+        template <typename T> void do_(T) {}
+    }
+
+    namespace tmpls
+    {
+        //  We define these dummy template functions. Borland complains when
+        //  a template class has the same name as a template function,
+        //  regardless if they are in different namespaces.
+
+        template <typename T> struct if_ {};
+        template <typename T> struct for_ {};
+        template <typename T> struct while_ {};
+        template <typename T> struct do_ {};
+    }
+
+}} // namespace phoenix::borland_only
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/static_assert.hpp>
+#include <boost/call_traits.hpp>
+#include <boost/type_traits/remove_reference.hpp>
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(push)
+#pragma warning(disable:4512) //assignment operator could not be generated
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple
+//
+//      Tuples hold heterogeneous types up to a predefined maximum. Only
+//      the most basic functionality needed is provided. Unlike other
+//      recursive list-like tuple implementations, this tuple
+//      implementation uses simple structs similar to std::pair with
+//      specialization for 0 to N tuple elements.
+//
+//          1)  Construction
+//              Here are examples on how to construct tuples:
+//
+//                  typedef tuple<int, char> t1_t;
+//                  typedef tuple<int, std::string, double> t2_t;
+//
+//                  // this tuple has an int and char members
+//                  t1_t t1(3, 'c');
+//
+//                  // this tuple has an int, std::string and double members
+//                  t2_t t2(3, "hello", 3.14);
+//
+//              Tuples can also be constructed from other tuples. The
+//              source and destination tuples need not have exactly the
+//              same element types. The only requirement is that the
+//              source tuple have the same number of elements as the
+//              destination and that each element slot in the
+//              destination can be copy constructed from the source
+//              element. For example:
+//
+//                  tuple<double, double> t3(t1); // OK. Compatible tuples
+//                  tuple<double, double> t4(t2); // Error! Incompatible tuples
+//
+//          2)  Member access
+//                  A member in a tuple can be accessed using the
+//                  tuple's [] operator by specifying the Nth
+//                  tuple_index. Here are some examples:
+//
+//                      tuple_index<0> ix0; // 0th index == 1st item
+//                      tuple_index<1> ix1; // 1st index == 2nd item
+//                      tuple_index<2> ix2; // 2nd index == 3rd item
+//
+//                      t1[ix0] = 33;  // sets the int member of the tuple t1
+//                      t2[ix2] = 6e6; // sets the double member of the tuple t2
+//                      t1[ix1] = 'a'; // sets the char member of the tuple t1
+//
+//                  There are some predefined names are provided in sub-
+//                  namespace tuple_index_names:
+//
+//                      tuple_index<0> _1;
+//                      tuple_index<1> _2;
+//                      ...
+//                      tuple_index<N> _N;
+//
+//                  These indexes may be used by 'using' namespace
+//                  phoenix::tuple_index_names.
+//
+//                  Access to out of bound indexes returns a nil_t value.
+//
+//          3)  Member type inquiry
+//                  The type of an individual member can be queried.
+//                  Example:
+//
+//                      tuple_element<1, t2_t>::type
+//
+//                  Refers to the type of the second member (note zero based,
+//                  thus 0 = 1st item, 1 = 2nd item) of the tuple.
+//
+//                  Aside from tuple_element<N, T>::type, there are two
+//                  more types that tuple_element provides: rtype and
+//                  crtype. While 'type' is the plain underlying type,
+//                  'rtype' is the reference type, or type& and 'crtype'
+//                  is the constant reference type or type const&. The
+//                  latter two are provided to make it easy for the
+//                  client in dealing with the possibility of reference
+//                  to reference when type is already a reference, which
+//                  is illegal in C++.
+//
+//                  Access to out of bound indexes returns a nil_t type.
+//
+//          4)  Tuple length
+//                  The number of elements in a tuple can be queried.
+//                  Example:
+//
+//                      int n = t1.length;
+//
+//                  gets the number of elements in tuple t1.
+//
+//                  length is a static constant. Thus, TupleT::length
+//                  also works. Example:
+//
+//                      int n = t1_t::length;
+//
+///////////////////////////////////////////////////////////////////////////////
+struct nil_t {};
+using boost::remove_reference;
+using boost::call_traits;
+
+//////////////////////////////////
+namespace impl {
+
+    template <typename T>
+    struct access {
+
+        typedef const T& ctype;
+        typedef T& type;
+    };
+
+    template <typename T>
+    struct access<T&> {
+
+        typedef T& ctype;
+        typedef T& type;
+    };
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple_element
+//
+//      A query class that gets the Nth element inside a tuple.
+//      Examples:
+//
+//          tuple_element<1, tuple<int, char, void*> >::type    //  plain
+//          tuple_element<1, tuple<int, char, void*> >::rtype   //  ref
+//          tuple_element<1, tuple<int, char, void*> >::crtype  //  const ref
+//
+//      Has type char which is the 2nd type in the tuple
+//      (note zero based, thus 0 = 1st item, 1 = 2nd item).
+//
+//          Given a tuple object, the static function tuple_element<N,
+//          TupleT>::get(tuple) gets the Nth element in the tuple. The
+//          tuple class' tuple::operator[] uses this to get its Nth
+//          element.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <int N, typename TupleT>
+struct tuple_element
+{
+    typedef nil_t type;
+    typedef nil_t& rtype;
+    typedef nil_t const& crtype;
+
+    static nil_t    get(TupleT const& t)    { return nil_t(); }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<0, TupleT>
+{
+    typedef typename TupleT::a_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.a; }
+    static crtype   get(TupleT const& t)    { return t.a; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<1, TupleT>
+{
+    typedef typename TupleT::b_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.b; }
+    static crtype   get(TupleT const& t)    { return t.b; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<2, TupleT>
+{
+    typedef typename TupleT::c_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.c; }
+    static crtype   get(TupleT const& t)    { return t.c; }
+};
+
+#if PHOENIX_LIMIT > 3
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<3, TupleT>
+{
+    typedef typename TupleT::d_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.d; }
+    static crtype   get(TupleT const& t)    { return t.d; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<4, TupleT>
+{
+    typedef typename TupleT::e_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.e; }
+    static crtype   get(TupleT const& t)    { return t.e; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<5, TupleT>
+{
+    typedef typename TupleT::f_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.f; }
+    static crtype   get(TupleT const& t)    { return t.f; }
+};
+
+#if PHOENIX_LIMIT > 6
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<6, TupleT>
+{
+    typedef typename TupleT::g_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.g; }
+    static crtype   get(TupleT const& t)    { return t.g; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<7, TupleT>
+{
+    typedef typename TupleT::h_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.h; }
+    static crtype   get(TupleT const& t)    { return t.h; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<8, TupleT>
+{
+    typedef typename TupleT::i_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.i; }
+    static crtype   get(TupleT const& t)    { return t.i; }
+};
+
+#if PHOENIX_LIMIT > 9
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<9, TupleT>
+{
+    typedef typename TupleT::j_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.j; }
+    static crtype   get(TupleT const& t)    { return t.j; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<10, TupleT>
+{
+    typedef typename TupleT::k_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.k; }
+    static crtype   get(TupleT const& t)    { return t.k; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<11, TupleT>
+{
+    typedef typename TupleT::l_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.l; }
+    static crtype   get(TupleT const& t)    { return t.l; }
+};
+
+#if PHOENIX_LIMIT > 12
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<12, TupleT>
+{
+    typedef typename TupleT::m_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.m; }
+    static crtype   get(TupleT const& t)    { return t.m; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<13, TupleT>
+{
+    typedef typename TupleT::n_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.n; }
+    static crtype   get(TupleT const& t)    { return t.n; }
+};
+
+//////////////////////////////////
+template <typename TupleT>
+struct tuple_element<14, TupleT>
+{
+    typedef typename TupleT::o_type type;
+    typedef typename impl::access<type>::type rtype;
+    typedef typename impl::access<type>::ctype crtype;
+
+    static rtype    get(TupleT& t)          { return t.o; }
+    static crtype   get(TupleT const& t)    { return t.o; }
+};
+
+#endif
+#endif
+#endif
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple forward declaration.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+        typename A = nil_t
+    ,   typename B = nil_t
+    ,   typename C = nil_t
+
+#if PHOENIX_LIMIT > 3
+    ,   typename D = nil_t
+    ,   typename E = nil_t
+    ,   typename F = nil_t
+
+#if PHOENIX_LIMIT > 6
+    ,   typename G = nil_t
+    ,   typename H = nil_t
+    ,   typename I = nil_t
+
+#if PHOENIX_LIMIT > 9
+    ,   typename J = nil_t
+    ,   typename K = nil_t
+    ,   typename L = nil_t
+
+#if PHOENIX_LIMIT > 12
+    ,   typename M = nil_t
+    ,   typename N = nil_t
+    ,   typename O = nil_t
+
+#endif
+#endif
+#endif
+#endif
+
+    ,   typename NU = nil_t  // Not used
+>
+struct tuple;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple_index
+//
+//      This class wraps an integer in a type to be used for indexing
+//      the Nth element in a tuple. See tuple operator[]. Some
+//      predefined names are provided in sub-namespace
+//      tuple_index_names.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <int N>
+struct tuple_index {};
+
+//////////////////////////////////
+namespace tuple_index_names {
+
+    tuple_index<0> const _1 = tuple_index<0>();
+    tuple_index<1> const _2 = tuple_index<1>();
+    tuple_index<2> const _3 = tuple_index<2>();
+
+#if PHOENIX_LIMIT > 3
+    tuple_index<3> const _4 = tuple_index<3>();
+    tuple_index<4> const _5 = tuple_index<4>();
+    tuple_index<5> const _6 = tuple_index<5>();
+
+#if PHOENIX_LIMIT > 6
+    tuple_index<6> const _7 = tuple_index<6>();
+    tuple_index<7> const _8 = tuple_index<7>();
+    tuple_index<8> const _9 = tuple_index<8>();
+
+#if PHOENIX_LIMIT > 9
+    tuple_index<9> const _10 = tuple_index<9>();
+    tuple_index<10> const _11 = tuple_index<10>();
+    tuple_index<11> const _12 = tuple_index<11>();
+
+#if PHOENIX_LIMIT > 12
+    tuple_index<12> const _13 = tuple_index<12>();
+    tuple_index<13> const _14 = tuple_index<13>();
+    tuple_index<14> const _15 = tuple_index<14>();
+
+#endif
+#endif
+#endif
+#endif
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple_common class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename DerivedT>
+struct tuple_base {
+
+    typedef nil_t   a_type;
+    typedef nil_t   b_type;
+    typedef nil_t   c_type;
+
+#if PHOENIX_LIMIT > 3
+    typedef nil_t   d_type;
+    typedef nil_t   e_type;
+    typedef nil_t   f_type;
+
+#if PHOENIX_LIMIT > 6
+    typedef nil_t   g_type;
+    typedef nil_t   h_type;
+    typedef nil_t   i_type;
+
+#if PHOENIX_LIMIT > 9
+    typedef nil_t   j_type;
+    typedef nil_t   k_type;
+    typedef nil_t   l_type;
+
+#if PHOENIX_LIMIT > 12
+    typedef nil_t   m_type;
+    typedef nil_t   n_type;
+    typedef nil_t   o_type;
+
+#endif
+#endif
+#endif
+#endif
+
+    template <int N>
+    typename tuple_element<N, DerivedT>::crtype
+    operator[](tuple_index<N>) const
+    {
+        return tuple_element<N, DerivedT>
+            ::get(*static_cast<DerivedT const*>(this));
+    }
+
+    template <int N>
+    typename tuple_element<N, DerivedT>::rtype
+    operator[](tuple_index<N>)
+    {
+        return tuple_element<N, DerivedT>
+            ::get(*static_cast<DerivedT*>(this));
+    }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <0 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <>
+struct tuple<>
+:   public tuple_base<tuple<> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 0);
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <1 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A>
+struct tuple<A, nil_t, nil_t,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 1);
+    typedef A a_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_
+    ):  a(a_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <2 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A, typename B>
+struct tuple<A, B, nil_t,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 2);
+    typedef A a_type; typedef B b_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_
+    ):  a(a_), b(b_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <3 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A, typename B, typename C>
+struct tuple<A, B, C,
+#if PHOENIX_LIMIT > 3
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 3);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_
+    ):  a(a_), b(b_), c(c_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c;
+};
+
+#if PHOENIX_LIMIT > 3
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <4 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A, typename B, typename C, typename D>
+struct tuple<A, B, C, D, nil_t, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 4);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_
+    ):  a(a_), b(b_), c(c_), d(d_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <5 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A, typename B, typename C, typename D, typename E>
+struct tuple<A, B, C, D, E, nil_t,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 5);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <6 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F>
+struct tuple<A, B, C, D, E, F,
+#if PHOENIX_LIMIT > 6
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 6);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f;
+};
+
+#if PHOENIX_LIMIT > 6
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <7 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G>
+struct tuple<A, B, C, D, E, F, G, nil_t, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F, G> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 7);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <8 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H>
+struct tuple<A, B, C, D, E, F, G, H, nil_t,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F, G, H> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 8);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <9 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I>
+struct tuple<A, B, C, D, E, F, G, H, I,
+#if PHOENIX_LIMIT > 9
+    nil_t, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F, G, H, I> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 9);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i;
+};
+
+#if PHOENIX_LIMIT > 9
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <10 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J>
+struct tuple<A, B, C, D, E, F, G, H, I, J, nil_t, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F, G, H, I, J> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 10);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type; typedef J j_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_,
+        typename call_traits<J>::param_type j_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()]), j(init[tuple_index<9>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i; J j;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <11 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K>
+struct tuple<A, B, C, D, E, F, G, H, I, J, K, nil_t,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F, G, H, I, J, K> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 11);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type; typedef J j_type;
+    typedef K k_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_,
+        typename call_traits<J>::param_type j_,
+        typename call_traits<K>::param_type k_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()]), j(init[tuple_index<9>()]),
+        k(init[tuple_index<10>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i; J j;
+    K k;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <12 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L>
+struct tuple<A, B, C, D, E, F, G, H, I, J, K, L,
+#if PHOENIX_LIMIT > 12
+    nil_t, nil_t, nil_t,
+#endif
+    nil_t   //  Unused
+>
+:   public tuple_base<tuple<A, B, C, D, E, F, G, H, I, J, K, L> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 12);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type; typedef J j_type;
+    typedef K k_type; typedef L l_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_,
+        typename call_traits<J>::param_type j_,
+        typename call_traits<K>::param_type k_,
+        typename call_traits<L>::param_type l_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()]), j(init[tuple_index<9>()]),
+        k(init[tuple_index<10>()]), l(init[tuple_index<11>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i; J j;
+    K k; L l;
+};
+
+#if PHOENIX_LIMIT > 12
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <13 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M>
+struct tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, nil_t, nil_t, nil_t>
+:   public tuple_base<
+        tuple<A, B, C, D, E, F, G, H, I, J, K, L, M> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 13);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type; typedef J j_type;
+    typedef K k_type; typedef L l_type;
+    typedef M m_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_,
+        typename call_traits<J>::param_type j_,
+        typename call_traits<K>::param_type k_,
+        typename call_traits<L>::param_type l_,
+        typename call_traits<M>::param_type m_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_), m(m_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()]), j(init[tuple_index<9>()]),
+        k(init[tuple_index<10>()]), l(init[tuple_index<11>()]),
+        m(init[tuple_index<12>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i; J j;
+    K k; L l; M m;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <14 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N>
+struct tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, nil_t, nil_t>
+:   public tuple_base<
+        tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 14);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type; typedef J j_type;
+    typedef K k_type; typedef L l_type;
+    typedef M m_type; typedef N n_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_,
+        typename call_traits<J>::param_type j_,
+        typename call_traits<K>::param_type k_,
+        typename call_traits<L>::param_type l_,
+        typename call_traits<M>::param_type m_,
+        typename call_traits<N>::param_type n_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_), m(m_), n(n_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()]), j(init[tuple_index<9>()]),
+        k(init[tuple_index<10>()]), l(init[tuple_index<11>()]),
+        m(init[tuple_index<12>()]), n(init[tuple_index<13>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i; J j;
+    K k; L l; M m; N n;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  tuple <15 member> class
+//
+///////////////////////////////////////////////////////////////////////////////
+template <
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N, typename O>
+struct tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, nil_t>
+:   public tuple_base<
+        tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> > {
+
+    BOOST_STATIC_CONSTANT(int, length = 15);
+    typedef A a_type; typedef B b_type;
+    typedef C c_type; typedef D d_type;
+    typedef E e_type; typedef F f_type;
+    typedef G g_type; typedef H h_type;
+    typedef I i_type; typedef J j_type;
+    typedef K k_type; typedef L l_type;
+    typedef M m_type; typedef N n_type;
+    typedef O o_type;
+
+    tuple() {}
+
+    tuple(
+        typename call_traits<A>::param_type a_,
+        typename call_traits<B>::param_type b_,
+        typename call_traits<C>::param_type c_,
+        typename call_traits<D>::param_type d_,
+        typename call_traits<E>::param_type e_,
+        typename call_traits<F>::param_type f_,
+        typename call_traits<G>::param_type g_,
+        typename call_traits<H>::param_type h_,
+        typename call_traits<I>::param_type i_,
+        typename call_traits<J>::param_type j_,
+        typename call_traits<K>::param_type k_,
+        typename call_traits<L>::param_type l_,
+        typename call_traits<M>::param_type m_,
+        typename call_traits<N>::param_type n_,
+        typename call_traits<O>::param_type o_
+    ):  a(a_), b(b_), c(c_), d(d_), e(e_),
+        f(f_), g(g_), h(h_), i(i_), j(j_),
+        k(k_), l(l_), m(m_), n(n_), o(o_) {}
+
+    template <typename TupleT>
+    tuple(TupleT const& init)
+    :   a(init[tuple_index<0>()]), b(init[tuple_index<1>()]),
+        c(init[tuple_index<2>()]), d(init[tuple_index<3>()]),
+        e(init[tuple_index<4>()]), f(init[tuple_index<5>()]),
+        g(init[tuple_index<6>()]), h(init[tuple_index<7>()]),
+        i(init[tuple_index<8>()]), j(init[tuple_index<9>()]),
+        k(init[tuple_index<10>()]), l(init[tuple_index<11>()]),
+        m(init[tuple_index<12>()]), n(init[tuple_index<13>()]),
+        o(init[tuple_index<14>()])
+    { BOOST_STATIC_ASSERT(TupleT::length == length); }
+
+    A a; B b; C c; D d; E e;
+    F f; G g; H h; I i; J j;
+    K k; L l; M m; N n; O o;
+};
+
+#endif
+#endif
+#endif
+#endif
+
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)
+#pragma warning(pop)
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+}   //  namespace phoenix
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/casts.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/casts.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/casts.hpp	(working copy)
@@ -0,0 +1,1470 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Hartmut Kaiser
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+
+#ifndef PHOENIX_CASTS_HPP
+#define PHOENIX_CASTS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#include <boost/spirit/home/classic/phoenix/actor.hpp>
+#include <boost/spirit/home/classic/phoenix/composite.hpp>
+#include <boost/static_assert.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Phoenix predefined maximum construct_ limit. This limit defines the maximum
+//  number of parameters supported for calles to the set of construct_ template
+//  functions (lazy object construction, see below). This number defaults to 3.
+//  The actual maximum is rounded up in multiples of 3. Thus, if this value
+//  is 4, the actual limit is 6. The ultimate maximum limit in this
+//  implementation is 15.
+//  PHOENIX_CONSTRUCT_LIMIT should NOT be greater than PHOENIX_LIMIT!
+
+#if !defined(PHOENIX_CONSTRUCT_LIMIT)
+#define PHOENIX_CONSTRUCT_LIMIT PHOENIX_LIMIT
+#endif
+
+// ensure PHOENIX_CONSTRUCT_LIMIT <= PHOENIX_LIMIT
+BOOST_STATIC_ASSERT(PHOENIX_CONSTRUCT_LIMIT <= PHOENIX_LIMIT);
+
+// ensure PHOENIX_CONSTRUCT_LIMIT <= 15
+BOOST_STATIC_ASSERT(PHOENIX_CONSTRUCT_LIMIT <= 15);
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Lazy C++ casts
+//
+//      The set of lazy C++ cast template classes and functions provide a way
+//      of lazily casting certain type to another during parsing.
+//      The lazy C++ templates are (syntactically) used very much like
+//      the well known C++ casts:
+//
+//          A *a = static_cast_<A *>(...actor returning a convertible type...);
+//
+//      where the given parameter should be an actor, which eval() function
+//      returns a convertible type.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename A>
+struct static_cast_l {
+
+    template <typename TupleT>
+    struct result { typedef T type; };
+
+    static_cast_l(A const& a_)
+    :   a(a_) {}
+
+    template <typename TupleT>
+    T
+    eval(TupleT const& args) const
+    {
+        return static_cast<T>(a.eval(args));
+    }
+
+    A a;
+};
+
+//////////////////////////////////
+template <typename T, typename BaseAT>
+inline actor<static_cast_l<T, BaseAT> >
+static_cast_(actor<BaseAT> const& a)
+{
+    typedef static_cast_l<T, BaseAT> cast_t;
+    return actor<cast_t>(cast_t(a));
+}
+
+//////////////////////////////////
+template <typename T, typename A>
+struct dynamic_cast_l {
+
+    template <typename TupleT>
+    struct result { typedef T type; };
+
+    dynamic_cast_l(A const& a_)
+    :   a(a_) {}
+
+    template <typename TupleT>
+    T
+    eval(TupleT const& args) const
+    {
+        return dynamic_cast<T>(a.eval(args));
+    }
+
+    A a;
+};
+
+//////////////////////////////////
+template <typename T, typename BaseAT>
+inline actor<dynamic_cast_l<T, BaseAT> >
+dynamic_cast_(actor<BaseAT> const& a)
+{
+    typedef dynamic_cast_l<T, BaseAT> cast_t;
+    return actor<cast_t>(cast_t(a));
+}
+
+//////////////////////////////////
+template <typename T, typename A>
+struct reinterpret_cast_l {
+
+    template <typename TupleT>
+    struct result { typedef T type; };
+
+    reinterpret_cast_l(A const& a_)
+    :   a(a_) {}
+
+    template <typename TupleT>
+    T
+    eval(TupleT const& args) const
+    {
+        return reinterpret_cast<T>(a.eval(args));
+    }
+
+    A a;
+};
+
+//////////////////////////////////
+template <typename T, typename BaseAT>
+inline actor<reinterpret_cast_l<T, BaseAT> >
+reinterpret_cast_(actor<BaseAT> const& a)
+{
+    typedef reinterpret_cast_l<T, BaseAT> cast_t;
+    return actor<cast_t>(cast_t(a));
+}
+
+//////////////////////////////////
+template <typename T, typename A>
+struct const_cast_l {
+
+    template <typename TupleT>
+    struct result { typedef T type; };
+
+    const_cast_l(A const& a_)
+    :   a(a_) {}
+
+    template <typename TupleT>
+    T
+    eval(TupleT const& args) const
+    {
+        return const_cast<T>(a.eval(args));
+    }
+
+    A a;
+};
+
+//////////////////////////////////
+template <typename T, typename BaseAT>
+inline actor<const_cast_l<T, BaseAT> >
+const_cast_(actor<BaseAT> const& a)
+{
+    typedef const_cast_l<T, BaseAT> cast_t;
+    return actor<cast_t>(cast_t(a));
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  construct_
+//
+//      Lazy object construction
+//
+//      The set of construct_<> template classes and functions provide a way
+//      of lazily constructing certain object from a arbitrary set of
+//      actors during parsing.
+//      The construct_ templates are (syntactically) used very much like
+//      the well known C++ casts:
+//
+//          A a = construct_<A>(...arbitrary list of actors...);
+//
+//      where the given parameters are submitted as parameters to the
+//      contructor of the object of type A. (This certainly implies, that
+//      type A has a constructor with a fitting set of parameter types
+//      defined.)
+//
+//      The maximum number of needed parameters is controlled through the
+//      preprocessor constant PHOENIX_CONSTRUCT_LIMIT. Note though, that this
+//      limit should not be greater than PHOENIX_LIMIT.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T>
+struct construct_l_0 {
+    typedef T result_type;
+
+    T operator()() const {
+        return T();
+    }
+};
+
+
+template <typename T>
+struct construct_l {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+
+#if PHOENIX_CONSTRUCT_LIMIT > 3
+        ,   typename D
+        ,   typename E
+        ,   typename F
+
+#if PHOENIX_CONSTRUCT_LIMIT > 6
+        ,   typename G
+        ,   typename H
+        ,   typename I
+
+#if PHOENIX_CONSTRUCT_LIMIT > 9
+        ,   typename J
+        ,   typename K
+        ,   typename L
+
+#if PHOENIX_CONSTRUCT_LIMIT > 12
+        ,   typename M
+        ,   typename N
+        ,   typename O
+#endif
+#endif
+#endif
+#endif
+    >
+    struct result { typedef T type; };
+
+    T operator()() const
+    {
+        return T();
+    }
+
+    template <typename A>
+    T operator()(A const& a) const
+    {
+        T t(a);
+        return t;
+    }
+
+    template <typename A, typename B>
+    T operator()(A const& a, B const& b) const
+    {
+        T t(a, b);
+        return t;
+    }
+
+    template <typename A, typename B, typename C>
+    T operator()(A const& a, B const& b, C const& c) const
+    {
+        T t(a, b, c);
+        return t;
+    }
+
+#if PHOENIX_CONSTRUCT_LIMIT > 3
+    template <
+        typename A, typename B, typename C, typename D
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d) const
+    {
+        T t(a, b, c, d);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e) const
+    {
+        T t(a, b, c, d, e);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f) const
+    {
+        T t(a, b, c, d, e, f);
+        return t;
+    }
+
+#if PHOENIX_CONSTRUCT_LIMIT > 6
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g) const
+    {
+        T t(a, b, c, d, e, f, g);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h) const
+    {
+        T t(a, b, c, d, e, f, g, h);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i) const
+    {
+        T t(a, b, c, d, e, f, g, h, i);
+        return t;
+    }
+
+#if PHOENIX_CONSTRUCT_LIMIT > 9
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k, l);
+        return t;
+    }
+
+#if PHOENIX_CONSTRUCT_LIMIT > 12
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l, M const& m) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k, l, m);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M, typename N
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l, M const& m, N const& n) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
+        return t;
+    }
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M, typename N, typename O
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l, M const& m, N const& n, O const& o) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
+        return t;
+    }
+
+#endif
+#endif
+#endif
+#endif
+};
+
+
+template <typename T>
+struct construct_1 {
+
+    template <
+            typename A
+    >
+    struct result { typedef T type; };
+
+    template <typename A>
+    T operator()(A const& a) const
+    {
+        T t(a);
+        return t;
+    }
+
+};
+
+template <typename T>
+struct construct_2 {
+
+    template <
+            typename A
+        ,   typename B
+    >
+    struct result { typedef T type; };
+
+    template <typename A, typename B>
+    T operator()(A const& a, B const& b) const
+    {
+        T t(a, b);
+        return t;
+    }
+
+};
+
+template <typename T>
+struct construct_3 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+    >
+    struct result { typedef T type; };
+
+    template <typename A, typename B, typename C>
+    T operator()(A const& a, B const& b, C const& c) const
+    {
+        T t(a, b, c);
+        return t;
+    }
+};
+
+#if PHOENIX_CONSTRUCT_LIMIT > 3
+template <typename T>
+struct construct_4 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d) const
+    {
+        T t(a, b, c, d);
+        return t;
+    }
+};
+
+
+template <typename T>
+struct construct_5 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e) const
+    {
+        T t(a, b, c, d, e);
+        return t;
+    }
+};
+
+
+template <typename T>
+struct construct_6 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f) const
+    {
+        T t(a, b, c, d, e, f);
+        return t;
+    }
+};
+#endif
+
+
+#if PHOENIX_CONSTRUCT_LIMIT > 6
+template <typename T>
+struct construct_7 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g) const
+    {
+        T t(a, b, c, d, e, f, g);
+        return t;
+    }
+};
+
+template <typename T>
+struct construct_8 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h) const
+    {
+        T t(a, b, c, d, e, f, g, h);
+        return t;
+    }
+};
+
+template <typename T>
+struct construct_9 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i) const
+    {
+        T t(a, b, c, d, e, f, g, h, i);
+        return t;
+    }
+};
+#endif
+
+
+#if PHOENIX_CONSTRUCT_LIMIT > 9
+template <typename T>
+struct construct_10 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+        ,   typename J
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j);
+        return t;
+    }
+};
+
+template <typename T>
+struct construct_11 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+        ,   typename J
+        ,   typename K
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k);
+        return t;
+    }
+};
+
+template <typename T>
+struct construct_12 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+        ,   typename J
+        ,   typename K
+        ,   typename L
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l) const
+    {
+        T t(a, b, c, d, f, e, g, h, i, j, k, l);
+        return t;
+    }
+};
+#endif
+
+#if PHOENIX_CONSTRUCT_LIMIT > 12
+template <typename T>
+struct construct_13 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+        ,   typename J
+        ,   typename K
+        ,   typename L
+        ,   typename M
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l, M const& m) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k, l, m);
+        return t;
+    }
+};
+
+template <typename T>
+struct construct_14 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+        ,   typename J
+        ,   typename K
+        ,   typename L
+        ,   typename M
+        ,   typename N
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M, typename N
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l, M const& m, N const& n) const
+    {
+        T t(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
+        return t;
+    }
+};
+
+template <typename T>
+struct construct_15 {
+
+    template <
+            typename A
+        ,   typename B
+        ,   typename C
+        ,   typename D
+        ,   typename E
+        ,   typename F
+        ,   typename G
+        ,   typename H
+        ,   typename I
+        ,   typename J
+        ,   typename K
+        ,   typename L
+        ,   typename M
+        ,   typename N
+        ,   typename O
+    >
+    struct result { typedef T type; };
+
+    template <
+        typename A, typename B, typename C, typename D, typename E,
+        typename F, typename G, typename H, typename I, typename J,
+        typename K, typename L, typename M, typename N, typename O
+    >
+    T operator()(
+        A const& a, B const& b, C const& c, D const& d, E const& e,
+        F const& f, G const& g, H const& h, I const& i, J const& j,
+        K const& k, L const& l, M const& m, N const& n, O const& o) const
+    {
+        T t(a, b, c, d, f, e, g, h, i, j, k, l, m, n, o);
+        return t;
+    }
+};
+#endif
+
+
+#if defined(__BORLANDC__) || (defined(__MWERKS__) && (__MWERKS__ <= 0x3002))
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  The following specializations are needed because Borland and CodeWarrior
+//  does not accept default template arguments in nested template classes in
+//  classes (i.e construct_l::result)
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T, typename TupleT>
+struct composite0_result<construct_l_0<T>, TupleT> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A>
+struct composite1_result<construct_l<T>, TupleT, A> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B>
+struct composite2_result<construct_l<T>, TupleT, A, B> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C>
+struct composite3_result<construct_l<T>, TupleT, A, B, C> {
+
+    typedef T type;
+};
+
+#if PHOENIX_LIMIT > 3
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D>
+struct composite4_result<construct_l<T>, TupleT,
+    A, B, C, D> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E>
+struct composite5_result<construct_l<T>, TupleT,
+    A, B, C, D, E> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F>
+struct composite6_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F> {
+
+    typedef T type;
+};
+
+#if PHOENIX_LIMIT > 6
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G>
+struct composite7_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H>
+struct composite8_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I>
+struct composite9_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I> {
+
+    typedef T type;
+};
+
+#if PHOENIX_LIMIT > 9
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J>
+struct composite10_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I, J> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K>
+struct composite11_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I, J, K> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L>
+struct composite12_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I, J, K, L> {
+
+    typedef T type;
+};
+
+#if PHOENIX_LIMIT > 12
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M>
+struct composite13_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I, J, K, L, M> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N>
+struct composite14_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I, J, K, L, M, N> {
+
+    typedef T type;
+};
+
+//////////////////////////////////
+template <typename T, typename TupleT,
+    typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J,
+    typename K, typename L, typename M, typename N, typename O>
+struct composite15_result<construct_l<T>, TupleT,
+    A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> {
+
+    typedef T type;
+};
+
+#endif
+#endif
+#endif
+#endif
+#endif
+
+//////////////////////////////////
+template <typename T>
+inline typename impl::make_composite<construct_l_0<T> >::type
+construct_()
+{
+    typedef impl::make_composite<construct_l_0<T> > make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_l_0<T>()));
+}
+
+//////////////////////////////////
+template <typename T, typename A>
+inline typename impl::make_composite<construct_1<T>, A>::type
+construct_(A const& a)
+{
+    typedef impl::make_composite<construct_1<T>, A> make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_1<T>(),
+        as_actor<A>::convert(a)
+    ));
+}
+
+//////////////////////////////////
+template <typename T, typename A, typename B>
+inline typename impl::make_composite<construct_2<T>, A, B>::type
+construct_(A const& a, B const& b)
+{
+    typedef impl::make_composite<construct_2<T>, A, B> make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_2<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b)
+    ));
+}
+
+//////////////////////////////////
+template <typename T, typename A, typename B, typename C>
+inline typename impl::make_composite<construct_3<T>, A, B, C>::type
+construct_(A const& a, B const& b, C const& c)
+{
+    typedef impl::make_composite<construct_3<T>, A, B, C> make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_3<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c)
+    ));
+}
+
+#if PHOENIX_CONSTRUCT_LIMIT > 3
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D
+>
+inline typename impl::make_composite<construct_4<T>, A, B, C, D>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d)
+{
+    typedef
+        impl::make_composite<construct_4<T>, A, B, C, D>
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_4<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E
+>
+inline typename impl::make_composite<construct_5<T>, A, B, C, D, E>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e)
+{
+    typedef
+        impl::make_composite<construct_5<T>, A, B, C, D, E>
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_5<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F
+>
+inline typename impl::make_composite<construct_6<T>, A, B, C, D, E, F>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f)
+{
+    typedef
+        impl::make_composite<construct_6<T>, A, B, C, D, E, F>
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_6<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f)
+    ));
+}
+
+#if PHOENIX_CONSTRUCT_LIMIT > 6
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G
+>
+inline typename impl::make_composite<construct_7<T>, A, B, C, D, E, F, G>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g)
+{
+    typedef
+        impl::make_composite<construct_7<T>, A, B, C, D, E, F, G>
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_7<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H
+>
+inline typename impl::make_composite<construct_8<T>, A, B, C, D, E, F, G, H>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h)
+{
+    typedef
+        impl::make_composite<construct_8<T>, A, B, C, D, E, F, G, H>
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_8<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I
+>
+inline typename impl::make_composite<construct_9<T>, A, B, C, D, E, F, G, H, I>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i)
+{
+    typedef
+        impl::make_composite<construct_9<T>, A, B, C, D, E, F, G, H, I>
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_9<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i)
+    ));
+}
+
+#if PHOENIX_CONSTRUCT_LIMIT > 9
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J
+>
+inline typename impl::make_composite<
+    construct_10<T>, A, B, C, D, E, F, G, H, I, J>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i, J const& j)
+{
+    typedef
+        impl::make_composite<
+            construct_10<T>, A, B, C, D, E, F, G, H, I, J
+        >
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_10<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i),
+        as_actor<J>::convert(j)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J, typename K
+>
+inline typename impl::make_composite<
+    construct_11<T>, A, B, C, D, E, F, G, H, I, J, K>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i, J const& j,
+    K const& k)
+{
+    typedef
+        impl::make_composite<
+            construct_11<T>, A, B, C, D, E, F, G, H, I, J, K
+        >
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_11<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i),
+        as_actor<J>::convert(j),
+        as_actor<K>::convert(k)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J, typename K,
+    typename L
+>
+inline typename impl::make_composite<
+    construct_12<T>, A, B, C, D, E, F, G, H, I, J, K, L>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i, J const& j,
+    K const& k, L const& l)
+{
+    typedef
+        impl::make_composite<
+            construct_12<T>, A, B, C, D, E, F, G, H, I, J, K, L
+        >
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_12<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i),
+        as_actor<J>::convert(j),
+        as_actor<K>::convert(k),
+        as_actor<L>::convert(l)
+    ));
+}
+
+#if PHOENIX_CONSTRUCT_LIMIT > 12
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J, typename K,
+    typename L, typename M
+>
+inline typename impl::make_composite<
+    construct_13<T>, A, B, C, D, E, F, G, H, I, J, K, L, M>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i, J const& j,
+    K const& k, L const& l, M const& m)
+{
+    typedef
+        impl::make_composite<
+            construct_13<T>, A, B, C, D, E, F, G, H, I, J, K, L, M
+        >
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_13<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i),
+        as_actor<J>::convert(j),
+        as_actor<K>::convert(k),
+        as_actor<L>::convert(l),
+        as_actor<M>::convert(m)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J, typename K,
+    typename L, typename M, typename N
+>
+inline typename impl::make_composite<
+    construct_14<T>, A, B, C, D, E, F, G, H, I, J, K, L, M>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i, J const& j,
+    K const& k, L const& l, M const& m, N const& n)
+{
+    typedef
+        impl::make_composite<
+            construct_14<T>, A, B, C, D, E, F, G, H, I, J, K, L, M, N
+        >
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_14<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i),
+        as_actor<J>::convert(j),
+        as_actor<K>::convert(k),
+        as_actor<L>::convert(l),
+        as_actor<M>::convert(m),
+        as_actor<N>::convert(n)
+    ));
+}
+
+//////////////////////////////////
+template <
+    typename T, typename A, typename B, typename C, typename D, typename E,
+    typename F, typename G, typename H, typename I, typename J, typename K,
+    typename L, typename M, typename N, typename O
+>
+inline typename impl::make_composite<
+    construct_15<T>, A, B, C, D, E, F, G, H, I, J, K, L, M, O>::type
+construct_(
+    A const& a, B const& b, C const& c, D const& d, E const& e,
+    F const& f, G const& g, H const& h, I const& i, J const& j,
+    K const& k, L const& l, M const& m, N const& n, O const& o)
+{
+    typedef
+        impl::make_composite<
+            construct_15<T>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O
+        >
+        make_composite_t;
+    typedef typename make_composite_t::type type_t;
+    typedef typename make_composite_t::composite_type composite_type_t;
+
+    return type_t(composite_type_t(construct_15<T>(),
+        as_actor<A>::convert(a),
+        as_actor<B>::convert(b),
+        as_actor<C>::convert(c),
+        as_actor<D>::convert(d),
+        as_actor<E>::convert(e),
+        as_actor<F>::convert(f),
+        as_actor<G>::convert(g),
+        as_actor<H>::convert(h),
+        as_actor<I>::convert(i),
+        as_actor<J>::convert(j),
+        as_actor<K>::convert(k),
+        as_actor<L>::convert(l),
+        as_actor<M>::convert(m),
+        as_actor<N>::convert(n),
+        as_actor<O>::convert(o)
+    ));
+}
+
+#endif
+#endif
+#endif
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+}   //  namespace phoenix
+
+#endif // PHOENIX_CASTS_HPP
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/operators.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/operators.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/phoenix/operators.hpp	(working copy)
@@ -0,0 +1,2203 @@
+/*=============================================================================
+    Phoenix V1.2.1
+    Copyright (c) 2001-2002 Joel de Guzman
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+==============================================================================*/
+#ifndef PHOENIX_OPERATORS_HPP
+#define PHOENIX_OPERATORS_HPP
+
+///////////////////////////////////////////////////////////////////////////////
+#if !defined(BOOST_NO_CWCTYPE)
+    #include <cwctype>
+#endif
+
+#if defined(__BORLANDC__) || (defined(__ICL) && __ICL >= 700)
+#define CREF const&
+#else
+#define CREF
+#endif
+
+#include <climits>
+#include <boost/spirit/home/classic/phoenix/actor.hpp>
+#include <boost/spirit/home/classic/phoenix/composite.hpp>
+#include <boost/config.hpp>
+#include <boost/mpl/if.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+namespace phoenix {
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Operators
+//
+//      Lazy operators
+//
+//      This class provides a mechanism for lazily evaluating operators.
+//      Syntactically, a lazy operator looks like an ordinary C/C++
+//      infix, prefix or postfix operator. The operator application
+//      looks the same. However, unlike ordinary operators, the actual
+//      operator execution is deferred. (see actor.hpp, primitives.hpp
+//      and composite.hpp for an overview). Samples:
+//
+//          arg1 + arg2
+//          1 + arg1 * arg2
+//          1 / -arg1
+//          arg1 < 150
+//
+//      T1 set of classes implement all the C++ free operators. Like
+//      lazy functions (see functions.hpp), lazy operators are not
+//      immediately executed when invoked. Instead, a composite (see
+//      composite.hpp) object is created and returned to the caller.
+//      Example:
+//
+//          (arg1 + arg2) * arg3
+//
+//      does nothing more than return a composite. T1 second function
+//      call will evaluate the actual operators. Example:
+//
+//          int i = 4, j = 5, k = 6;
+//          cout << ((arg1 + arg2) * arg3)(i, j, k);
+//
+//      will print out "54".
+//
+//      Arbitrarily complex expressions can be lazily evaluated
+//      following three simple rules:
+//
+//          1) Lazy evaluated binary operators apply when at least one
+//          of the operands is an actor object (see actor.hpp and
+//          primitives.hpp). Consequently, if an operand is not an actor
+//          object, it is implicitly converted to an object of type
+//          actor<value<T> > (where T is the original type of the
+//          operand).
+//
+//          2) Lazy evaluated unary operators apply only to operands
+//          which are actor objects.
+//
+//          3) The result of a lazy operator is a composite actor object
+//          that can in turn apply to rule 1.
+//
+//      Example:
+//
+//          arg1 + 3
+//
+//      is a lazy expression involving the operator+. Following rule 1,
+//      lazy evaluation is triggered since arg1 is an instance of an
+//      actor<argument<N> > class (see primitives.hpp). The right
+//      operand <3> is implicitly converted to an actor<value<int> >.
+//      The result of this binary + expression is a composite object,
+//      following rule 3.
+//
+//      Take note that although at least one of the operands must be a
+//      valid actor class in order for lazy evaluation to take effect,
+//      if this is not the case and we still want to lazily evaluate an
+//      expression, we can use var(x), val(x) or cref(x) to transform
+//      the operand into a valid action object (see primitives.hpp).
+//      Example:
+//
+//          val(1) << 3;
+//
+//      Supported operators:
+//
+//          Unary operators:
+//
+//              prefix:   ~, !, -, +, ++, --, & (reference), * (dereference)
+//              postfix:  ++, --
+//
+//          Binary operators:
+//
+//              =, [], +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
+//              +, -, *, /, %, &, |, ^, <<, >>
+//              ==, !=, <, >, <=, >=
+//              &&, ||
+//
+//      Each operator has a special tag type associated with it. For
+//      example the binary + operator has a plus_op tag type associated
+//      with it. This is used to specialize either the unary_operator or
+//      binary_operator template classes (see unary_operator and
+//      binary_operator below). Specializations of these unary_operator
+//      and binary_operator are the actual workhorses that implement the
+//      operations. The behavior of each lazy operator depends on these
+//      unary_operator and binary_operator specializations. 'preset'
+//      specializations conform to the canonical operator rules modeled
+//      by the behavior of integers and pointers:
+//
+//          Prefix -, + and ~ accept constant arguments and return an
+//          object by value.
+//
+//          The ! accept constant arguments and returns a boolean
+//          result.
+//
+//          The & (address-of), * (dereference) both return a reference
+//          to an object.
+//
+//          Prefix ++ returns a reference to its mutable argument after
+//          it is incremented.
+//
+//          Postfix ++ returns the mutable argument by value before it
+//          is incremented.
+//
+//          The += and its family accept mutable right hand side (rhs)
+//          operand and return a reference to the rhs operand.
+//
+//          Infix + and its family accept constant arguments and return
+//          an object by value.
+//
+//          The == and its family accept constant arguments and return a
+//          boolean result.
+//
+//          Operators && and || accept constant arguments and return a
+//          boolean result and are short circuit evaluated as expected.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Operator tags
+//
+//      Each C++ operator has a corresponding tag type. This is
+//      used as a means for specializing the unary_operator and
+//      binary_operator (see below). The tag also serves as the
+//      lazy operator type compatible as a composite operation
+//      see (composite.hpp).
+//
+///////////////////////////////////////////////////////////////////////////////
+
+//  Unary operator tags
+
+struct negative_op;         struct positive_op;
+struct logical_not_op;      struct invert_op;
+struct reference_op;        struct dereference_op;
+struct pre_incr_op;         struct pre_decr_op;
+struct post_incr_op;        struct post_decr_op;
+
+//  Binary operator tags
+
+struct assign_op;           struct index_op;
+struct plus_assign_op;      struct minus_assign_op;
+struct times_assign_op;     struct divide_assign_op;    struct mod_assign_op;
+struct and_assign_op;       struct or_assign_op;        struct xor_assign_op;
+struct shift_l_assign_op;   struct shift_r_assign_op;
+
+struct plus_op;             struct minus_op;
+struct times_op;            struct divide_op;           struct mod_op;
+struct and_op;              struct or_op;               struct xor_op;
+struct shift_l_op;          struct shift_r_op;
+
+struct eq_op;               struct not_eq_op;
+struct lt_op;               struct lt_eq_op;
+struct gt_op;               struct gt_eq_op;
+struct logical_and_op;      struct logical_or_op;
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  unary_operator<TagT, T>
+//
+//      The unary_operator class implements most of the C++ unary
+//      operators. Each specialization is basically a simple static eval
+//      function plus a result_type typedef that determines the return
+//      type of the eval function.
+//
+//      TagT is one of the unary operator tags above and T is the data
+//      type (argument) involved in the operation.
+//
+//      Only the behavior of C/C++ built-in types are taken into account
+//      in the specializations provided below. For user-defined types,
+//      these specializations may still be used provided that the
+//      operator overloads of such types adhere to the standard behavior
+//      of built-in types.
+//
+//      T1 separate special_ops.hpp file implements more stl savvy
+//      specializations. Other more specialized unary_operator
+//      implementations may be defined by the client for specific
+//      unary operator tags/data types.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename TagT, typename T>
+struct unary_operator;
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<negative_op, T> {
+
+    typedef T const result_type;
+    static result_type eval(T const& v)
+    { return -v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<positive_op, T> {
+
+    typedef T const result_type;
+    static result_type eval(T const& v)
+    { return +v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<logical_not_op, T> {
+
+    typedef T const result_type;
+    static result_type eval(T const& v)
+    { return !v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<invert_op, T> {
+
+    typedef T const result_type;
+    static result_type eval(T const& v)
+    { return ~v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<reference_op, T> {
+
+    typedef T* result_type;
+    static result_type eval(T& v)
+    { return &v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<dereference_op, T*> {
+
+    typedef T& result_type;
+    static result_type eval(T* v)
+    { return *v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<dereference_op, T* const> {
+
+    typedef T& result_type;
+    static result_type eval(T* const v)
+    { return *v; }
+};
+
+//////////////////////////////////
+template <>
+struct unary_operator<dereference_op, nil_t> {
+
+    //  G++ eager template instantiation
+    //  somehow requires this.
+    typedef nil_t result_type;
+};
+
+//////////////////////////////////
+#ifndef __BORLANDC__
+template <>
+struct unary_operator<dereference_op, nil_t const> {
+
+    //  G++ eager template instantiation
+    //  somehow requires this.
+    typedef nil_t result_type;
+};
+#endif
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<pre_incr_op, T> {
+
+    typedef T& result_type;
+    static result_type eval(T& v)
+    { return ++v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<pre_decr_op, T> {
+
+    typedef T& result_type;
+    static result_type eval(T& v)
+    { return --v; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<post_incr_op, T> {
+
+    typedef T const result_type;
+    static result_type eval(T& v)
+    { T t(v); ++v; return t; }
+};
+
+//////////////////////////////////
+template <typename T>
+struct unary_operator<post_decr_op, T> {
+
+    typedef T const result_type;
+    static result_type eval(T& v)
+    { T t(v); --v; return t; }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  rank<T>
+//
+//      rank<T> class has a static int constant 'value' that defines the
+//      absolute rank of a type. rank<T> is used to choose the result
+//      type of binary operators such as +. The type with the higher
+//      rank wins and is used as the operator's return type. T1 generic
+//      user defined type has a very high rank and always wins when
+//      compared against a user defined type. If this is not desireable,
+//      one can write a rank specialization for the type.
+//
+//      Take note that ranks 0..9999 are reserved for the framework.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T>
+struct rank { static int const value = INT_MAX; };
+
+template <> struct rank<void>               { static int const value = 0; };
+template <> struct rank<bool>               { static int const value = 10; };
+
+template <> struct rank<char>               { static int const value = 20; };
+template <> struct rank<signed char>        { static int const value = 20; };
+template <> struct rank<unsigned char>      { static int const value = 30; };
+#if !defined(BOOST_NO_INTRINSIC_WCHAR_T)
+template <> struct rank<wchar_t>            { static int const value = 40; };
+#endif // !defined(BOOST_NO_INTRINSIC_WCHAR_T)
+
+template <> struct rank<short>              { static int const value = 50; };
+template <> struct rank<unsigned short>     { static int const value = 60; };
+
+template <> struct rank<int>                { static int const value = 70; };
+template <> struct rank<unsigned int>       { static int const value = 80; };
+
+template <> struct rank<long>               { static int const value = 90; };
+template <> struct rank<unsigned long>      { static int const value = 100; };
+
+#ifdef BOOST_HAS_LONG_LONG
+template <> struct rank< ::boost::long_long_type>          { static int const value = 110; };
+template <> struct rank< ::boost::ulong_long_type> { static int const value = 120; };
+#endif
+
+template <> struct rank<float>              { static int const value = 130; };
+template <> struct rank<double>             { static int const value = 140; };
+template <> struct rank<long double>        { static int const value = 150; };
+
+template <typename T> struct rank<T*>
+{ static int const value = 160; };
+
+template <typename T> struct rank<T* const>
+{ static int const value = 160; };
+
+template <typename T, int N> struct rank<T[N]>
+{ static int const value = 160; };
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  higher_rank<T0, T1>
+//
+//      Chooses the type (T0 or T1) with the higher rank.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename T0, typename T1>
+struct higher_rank {
+    typedef typename boost::mpl::if_c<
+        rank<T0>::value < rank<T1>::value,
+        T1, T0>::type type;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  binary_operator<TagT, T0, T1>
+//
+//      The binary_operator class implements most of the C++ binary
+//      operators. Each specialization is basically a simple static eval
+//      function plus a result_type typedef that determines the return
+//      type of the eval function.
+//
+//      TagT is one of the binary operator tags above T0 and T1 are the
+//      (arguments') data types involved in the operation.
+//
+//      Only the behavior of C/C++ built-in types are taken into account
+//      in the specializations provided below. For user-defined types,
+//      these specializations may still be used provided that the
+//      operator overloads of such types adhere to the standard behavior
+//      of built-in types.
+//
+//      T1 separate special_ops.hpp file implements more stl savvy
+//      specializations. Other more specialized unary_operator
+//      implementations may be defined by the client for specific
+//      unary operator tags/data types.
+//
+//      All binary_operator except the logical_and_op and logical_or_op
+//      have an eval static function that carries out the actual operation.
+//      The logical_and_op and logical_or_op d are special because these
+//      two operators are short-circuit evaluated.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename TagT, typename T0, typename T1>
+struct binary_operator;
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs = rhs; }
+};
+
+//////////////////////////////////
+template <typename T1>
+struct binary_operator<index_op, nil_t, T1> {
+
+    //  G++ eager template instantiation
+    //  somehow requires this.
+    typedef nil_t result_type;
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<index_op, T0*, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0* ptr, T1 const& index)
+    { return ptr[index]; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<index_op, T0* const, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0* const ptr, T1 const& index)
+    { return ptr[index]; }
+};
+
+//////////////////////////////////
+template <typename T0, int N, typename T1>
+struct binary_operator<index_op, T0[N], T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0* ptr, T1 const& index)
+    { return ptr[index]; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<plus_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs += rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<minus_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs -= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<times_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs *= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<divide_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs /= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<mod_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs %= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<and_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs &= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<or_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs |= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<xor_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs ^= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<shift_l_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs <<= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<shift_r_assign_op, T0, T1> {
+
+    typedef T0& result_type;
+    static result_type eval(T0& lhs, T1 const& rhs)
+    { return lhs >>= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<plus_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs + rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<minus_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs - rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<times_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs * rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<divide_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs / rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<mod_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs % rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<and_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs & rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<or_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs | rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<xor_op, T0, T1> {
+
+    typedef typename higher_rank<T0, T1>::type const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs ^ rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<shift_l_op, T0, T1> {
+
+    typedef T0 const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs << rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<shift_r_op, T0, T1> {
+
+    typedef T0 const result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs >> rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<eq_op, T0, T1> {
+
+    typedef bool result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs == rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<not_eq_op, T0, T1> {
+
+    typedef bool result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs != rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<lt_op, T0, T1> {
+
+    typedef bool result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs < rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<lt_eq_op, T0, T1> {
+
+    typedef bool result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs <= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<gt_op, T0, T1> {
+
+    typedef bool result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs > rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<gt_eq_op, T0, T1> {
+
+    typedef bool result_type;
+    static result_type eval(T0 const& lhs, T1 const& rhs)
+    { return lhs >= rhs; }
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<logical_and_op, T0, T1> {
+
+    typedef bool result_type;
+    //  no eval function, see comment above.
+};
+
+//////////////////////////////////
+template <typename T0, typename T1>
+struct binary_operator<logical_or_op, T0, T1> {
+
+    typedef bool result_type;
+    //  no eval function, see comment above.
+};
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  negative lazy operator (prefix -)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct negative_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<negative_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<negative_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<negative_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<negative_op, BaseT>::type
+operator-(actor<BaseT> const& _0)
+{
+    return impl::make_unary<negative_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  positive lazy operator (prefix +)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct positive_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<positive_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<positive_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<positive_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<positive_op, BaseT>::type
+operator+(actor<BaseT> const& _0)
+{
+    return impl::make_unary<positive_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  logical not lazy operator (prefix !)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct logical_not_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<logical_not_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<logical_not_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<logical_not_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<logical_not_op, BaseT>::type
+operator!(actor<BaseT> const& _0)
+{
+    return impl::make_unary<logical_not_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  invert lazy operator (prefix ~)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct invert_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<invert_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<invert_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<invert_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<invert_op, BaseT>::type
+operator~(actor<BaseT> const& _0)
+{
+    return impl::make_unary<invert_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  reference lazy operator (prefix &)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct reference_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<reference_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<reference_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<reference_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<reference_op, BaseT>::type
+operator&(actor<BaseT> const& _0)
+{
+    return impl::make_unary<reference_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  dereference lazy operator (prefix *)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct dereference_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<dereference_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<dereference_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<dereference_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<dereference_op, BaseT>::type
+operator*(actor<BaseT> const& _0)
+{
+    return impl::make_unary<dereference_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  pre increment lazy operator (prefix ++)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct pre_incr_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<pre_incr_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<pre_incr_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<pre_incr_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<pre_incr_op, BaseT>::type
+operator++(actor<BaseT> const& _0)
+{
+    return impl::make_unary<pre_incr_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  pre decrement lazy operator (prefix --)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct pre_decr_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<pre_decr_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<pre_decr_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<pre_decr_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<pre_decr_op, BaseT>::type
+operator--(actor<BaseT> const& _0)
+{
+    return impl::make_unary<pre_decr_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  post increment lazy operator (postfix ++)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct post_incr_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<post_incr_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<post_incr_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<post_incr_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<post_incr_op, BaseT>::type
+operator++(actor<BaseT> const& _0, int)
+{
+    return impl::make_unary<post_incr_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  post decrement lazy operator (postfix --)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct post_decr_op {
+
+    template <typename T0>
+    struct result {
+
+        typedef typename unary_operator<post_decr_op, T0>::result_type type;
+    };
+
+    template <typename T0>
+    typename unary_operator<post_decr_op, T0>::result_type
+    operator()(T0& _0) const
+    { return unary_operator<post_decr_op, T0>::eval(_0); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+inline typename impl::make_unary<post_decr_op, BaseT>::type
+operator--(actor<BaseT> const& _0, int)
+{
+    return impl::make_unary<post_decr_op, BaseT>::construct(_0);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  assignment lazy operator (infix =)
+//  The acual lazy operator is a member of the actor class.
+//
+///////////////////////////////////////////////////////////////////////////////
+struct assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename B>
+inline typename impl::make_binary1<assign_op, BaseT, B>::type
+actor<BaseT>::operator=(B const& _1) const
+{
+    return impl::make_binary1<assign_op, BaseT, B>::construct(*this, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  index lazy operator (array index [])
+//  The acual lazy operator is a member of the actor class.
+//
+///////////////////////////////////////////////////////////////////////////////
+struct index_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<index_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<index_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<index_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT>
+template <typename B>
+inline typename impl::make_binary1<index_op, BaseT, B>::type
+actor<BaseT>::operator[](B const& _1) const
+{
+    return impl::make_binary1<index_op, BaseT, B>::construct(*this, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  plus assign lazy operator (infix +=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct plus_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<plus_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<plus_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<plus_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<plus_assign_op, BaseT, T1>::type
+operator+=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<plus_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  minus assign lazy operator (infix -=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct minus_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<minus_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<minus_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<minus_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<minus_assign_op, BaseT, T1>::type
+operator-=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<minus_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  times assign lazy operator (infix *=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct times_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<times_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<times_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<times_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<times_assign_op, BaseT, T1>::type
+operator*=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<times_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  divide assign lazy operator (infix /=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct divide_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<divide_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<divide_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<divide_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<divide_assign_op, BaseT, T1>::type
+operator/=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<divide_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  mod assign lazy operator (infix %=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct mod_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<mod_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<mod_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<mod_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<mod_assign_op, BaseT, T1>::type
+operator%=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<mod_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  and assign lazy operator (infix &=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct and_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<and_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<and_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<and_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<and_assign_op, BaseT, T1>::type
+operator&=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<and_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  or assign lazy operator (infix |=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct or_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<or_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<or_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<or_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<or_assign_op, BaseT, T1>::type
+operator|=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<or_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  xor assign lazy operator (infix ^=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct xor_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<xor_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<xor_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<xor_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<xor_assign_op, BaseT, T1>::type
+operator^=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<xor_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  shift left assign lazy operator (infix <<=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct shift_l_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<shift_l_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<shift_l_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<shift_l_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<shift_l_assign_op, BaseT, T1>::type
+operator<<=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<shift_l_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  shift right assign lazy operator (infix >>=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct shift_r_assign_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<shift_r_assign_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<shift_r_assign_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<shift_r_assign_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<shift_r_assign_op, BaseT, T1>::type
+operator>>=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<shift_r_assign_op, BaseT, T1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  plus lazy operator (infix +)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct plus_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<plus_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<plus_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<plus_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<plus_op, BaseT, T1>::type
+operator+(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<plus_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<plus_op, T0, BaseT>::type
+operator+(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<plus_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<plus_op, BaseT0, BaseT1>::type
+operator+(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<plus_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  minus lazy operator (infix -)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct minus_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<minus_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<minus_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<minus_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<minus_op, BaseT, T1>::type
+operator-(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<minus_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<minus_op, T0, BaseT>::type
+operator-(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<minus_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<minus_op, BaseT0, BaseT1>::type
+operator-(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<minus_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  times lazy operator (infix *)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct times_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<times_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<times_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<times_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<times_op, BaseT, T1>::type
+operator*(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<times_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<times_op, T0, BaseT>::type
+operator*(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<times_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<times_op, BaseT0, BaseT1>::type
+operator*(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<times_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  divide lazy operator (infix /)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct divide_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<divide_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<divide_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<divide_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<divide_op, BaseT, T1>::type
+operator/(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<divide_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<divide_op, T0, BaseT>::type
+operator/(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<divide_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<divide_op, BaseT0, BaseT1>::type
+operator/(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<divide_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  mod lazy operator (infix %)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct mod_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<mod_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<mod_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<mod_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<mod_op, BaseT, T1>::type
+operator%(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<mod_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<mod_op, T0, BaseT>::type
+operator%(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<mod_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<mod_op, BaseT0, BaseT1>::type
+operator%(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<mod_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  and lazy operator (infix &)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct and_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<and_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<and_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<and_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<and_op, BaseT, T1>::type
+operator&(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<and_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<and_op, T0, BaseT>::type
+operator&(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<and_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<and_op, BaseT0, BaseT1>::type
+operator&(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<and_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  or lazy operator (infix |)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct or_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<or_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<or_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<or_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<or_op, BaseT, T1>::type
+operator|(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<or_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<or_op, T0, BaseT>::type
+operator|(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<or_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<or_op, BaseT0, BaseT1>::type
+operator|(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<or_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  xor lazy operator (infix ^)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct xor_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<xor_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<xor_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<xor_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<xor_op, BaseT, T1>::type
+operator^(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<xor_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<xor_op, T0, BaseT>::type
+operator^(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<xor_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<xor_op, BaseT0, BaseT1>::type
+operator^(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<xor_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  shift left lazy operator (infix <<)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct shift_l_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<shift_l_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<shift_l_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<shift_l_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<shift_l_op, BaseT, T1>::type
+operator<<(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<shift_l_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<shift_l_op, T0, BaseT>::type
+operator<<(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<shift_l_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<shift_l_op, BaseT0, BaseT1>::type
+operator<<(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<shift_l_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  shift right lazy operator (infix >>)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct shift_r_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<shift_r_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<shift_r_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<shift_r_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<shift_r_op, BaseT, T1>::type
+operator>>(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<shift_r_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<shift_r_op, T0, BaseT>::type
+operator>>(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<shift_r_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<shift_r_op, BaseT0, BaseT1>::type
+operator>>(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<shift_r_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  equal lazy operator (infix ==)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct eq_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<eq_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<eq_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<eq_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<eq_op, BaseT, T1>::type
+operator==(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<eq_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<eq_op, T0, BaseT>::type
+operator==(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<eq_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<eq_op, BaseT0, BaseT1>::type
+operator==(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<eq_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  not equal lazy operator (infix !=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct not_eq_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<not_eq_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<not_eq_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<not_eq_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<not_eq_op, BaseT, T1>::type
+operator!=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<not_eq_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<not_eq_op, T0, BaseT>::type
+operator!=(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<not_eq_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<not_eq_op, BaseT0, BaseT1>::type
+operator!=(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<not_eq_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  less than lazy operator (infix <)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct lt_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<lt_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<lt_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<lt_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<lt_op, BaseT, T1>::type
+operator<(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<lt_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<lt_op, T0, BaseT>::type
+operator<(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<lt_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<lt_op, BaseT0, BaseT1>::type
+operator<(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<lt_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  less than equal lazy operator (infix <=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct lt_eq_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<lt_eq_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<lt_eq_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<lt_eq_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<lt_eq_op, BaseT, T1>::type
+operator<=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<lt_eq_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<lt_eq_op, T0, BaseT>::type
+operator<=(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<lt_eq_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<lt_eq_op, BaseT0, BaseT1>::type
+operator<=(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<lt_eq_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  greater than lazy operator (infix >)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct gt_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<gt_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<gt_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<gt_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<gt_op, BaseT, T1>::type
+operator>(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<gt_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<gt_op, T0, BaseT>::type
+operator>(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<gt_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<gt_op, BaseT0, BaseT1>::type
+operator>(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<gt_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  greater than equal lazy operator (infix >=)
+//
+///////////////////////////////////////////////////////////////////////////////
+struct gt_eq_op {
+
+    template <typename T0, typename T1>
+    struct result {
+
+        typedef typename binary_operator<gt_eq_op, T0, T1>
+            ::result_type type;
+    };
+
+    template <typename T0, typename T1>
+    typename binary_operator<gt_eq_op, T0, T1>::result_type
+    operator()(T0& _0, T1& _1) const
+    { return binary_operator<gt_eq_op, T0, T1>::eval(_0, _1); }
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline typename impl::make_binary1<gt_eq_op, BaseT, T1>::type
+operator>=(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return impl::make_binary1<gt_eq_op, BaseT, T1>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline typename impl::make_binary2<gt_eq_op, T0, BaseT>::type
+operator>=(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return impl::make_binary2<gt_eq_op, T0, BaseT>::construct(_0, _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline typename impl::make_binary3<gt_eq_op, BaseT0, BaseT1>::type
+operator>=(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return impl::make_binary3<gt_eq_op, BaseT0, BaseT1>::construct(_0, _1);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  logical and lazy operator (infix &&)
+//
+//  The logical_and_composite class and its corresponding generators are
+//  provided to allow short-circuit evaluation of the operator's
+//  operands.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A0, typename A1>
+struct logical_and_composite {
+
+    typedef logical_and_composite<A0, A1> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename binary_operator<logical_and_op,
+            typename actor_result<A0, TupleT>::plain_type,
+            typename actor_result<A1, TupleT>::plain_type
+        >::result_type type;
+    };
+
+    logical_and_composite(A0 const& _0, A1 const& _1)
+    :   a0(_0), a1(_1) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        return a0.eval(args) && a1.eval(args);
+    }
+
+    A0 a0; A1 a1; //  actors
+};
+
+#if !(defined(__ICL) && __ICL <= 500)
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline actor<logical_and_composite
+<actor<BaseT>, typename as_actor<T1>::type> >
+operator&&(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return logical_and_composite
+        <actor<BaseT>, typename as_actor<T1>::type>
+        (_0, as_actor<T1>::convert(_1));
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline actor<logical_and_composite
+<typename as_actor<T0>::type, actor<BaseT> > >
+operator&&(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return logical_and_composite
+        <typename as_actor<T0>::type, actor<BaseT> >
+        (as_actor<T0>::convert(_0), _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline actor<logical_and_composite
+<actor<BaseT0>, actor<BaseT1> > >
+operator&&(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return logical_and_composite
+        <actor<BaseT0>, actor<BaseT1> >
+        (_0, _1);
+}
+#else
+//////////////////////////////////
+template <typename T0, typename T1>
+inline actor<logical_and_composite
+<typename as_actor<T0>::type, typename as_actor<T1>::type> >
+operator&&(T0 CREF _0, T1 CREF _1)
+{
+    return logical_and_composite
+        <typename as_actor<T0>::type, typename as_actor<T1>::type>
+        (as_actor<T0>::convert(_0), as_actor<T1>::convert(_1));
+}
+#endif // !(__ICL && __ICL <= 500)
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  logical or lazy operator (infix ||)
+//
+//  The logical_or_composite class and its corresponding generators are
+//  provided to allow short-circuit evaluation of the operator's
+//  operands.
+//
+///////////////////////////////////////////////////////////////////////////////
+template <typename A0, typename A1>
+struct logical_or_composite {
+
+    typedef logical_or_composite<A0, A1> self_t;
+
+    template <typename TupleT>
+    struct result {
+
+        typedef typename binary_operator<logical_or_op,
+            typename actor_result<A0, TupleT>::plain_type,
+            typename actor_result<A1, TupleT>::plain_type
+        >::result_type type;
+    };
+
+    logical_or_composite(A0 const& _0, A1 const& _1)
+    :   a0(_0), a1(_1) {}
+
+    template <typename TupleT>
+    typename actor_result<self_t, TupleT>::type
+    eval(TupleT const& args) const
+    {
+        return a0.eval(args) || a1.eval(args);
+    }
+
+    A0 a0; A1 a1; //  actors
+};
+
+//////////////////////////////////
+template <typename BaseT, typename T1>
+inline actor<logical_or_composite
+<actor<BaseT>, typename as_actor<T1>::type> >
+operator||(actor<BaseT> const& _0, T1 CREF _1)
+{
+    return logical_or_composite
+        <actor<BaseT>, typename as_actor<T1>::type>
+        (_0, as_actor<T1>::convert(_1));
+}
+
+//////////////////////////////////
+template <typename T0, typename BaseT>
+inline actor<logical_or_composite
+<typename as_actor<T0>::type, actor<BaseT> > >
+operator||(T0 CREF _0, actor<BaseT> const& _1)
+{
+    return logical_or_composite
+        <typename as_actor<T0>::type, actor<BaseT> >
+        (as_actor<T0>::convert(_0), _1);
+}
+
+//////////////////////////////////
+template <typename BaseT0, typename BaseT1>
+inline actor<logical_or_composite
+<actor<BaseT0>, actor<BaseT1> > >
+operator||(actor<BaseT0> const& _0, actor<BaseT1> const& _1)
+{
+    return logical_or_composite
+        <actor<BaseT0>, actor<BaseT1> >
+        (_0, _1);
+}
+
+}   //  namespace phoenix
+
+#undef CREF
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/debug.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/debug.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/debug.hpp	(working copy)
@@ -0,0 +1,154 @@
+/*=============================================================================
+    Copyright (c) 2001-2003 Joel de Guzman
+    Copyright (c) 2002-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_DEBUG_MAIN_HPP)
+#define BOOST_SPIRIT_DEBUG_MAIN_HPP
+
+///////////////////////////////////////////////////////////////////////////
+#if defined(BOOST_SPIRIT_DEBUG)
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Spirit.Debug includes and defines
+//
+///////////////////////////////////////////////////////////////////////////////
+
+    #include <iostream>
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  The BOOST_SPIRIT_DEBUG_OUT defines the stream object, which should be used
+    //  for debug diagnostics. This defaults to std::cout.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #if !defined(BOOST_SPIRIT_DEBUG_OUT)
+    #define BOOST_SPIRIT_DEBUG_OUT std::cout
+    #endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  The BOOST_SPIRIT_DEBUG_PRINT_SOME constant defines the number of characters
+    //  from the stream to be printed for diagnosis. This defaults to the first
+    //  20 characters.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #if !defined(BOOST_SPIRIT_DEBUG_PRINT_SOME)
+    #define BOOST_SPIRIT_DEBUG_PRINT_SOME 20
+    #endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Additional BOOST_SPIRIT_DEBUG_FLAGS control the level of diagnostics printed
+    //  Basic constants are defined in debug/minimal.hpp.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #define BOOST_SPIRIT_DEBUG_FLAGS_NODES        0x0001  // node diagnostics
+    #define BOOST_SPIRIT_DEBUG_FLAGS_ESCAPE_CHAR  0x0002  // escape_char_parse diagnostics
+    #define BOOST_SPIRIT_DEBUG_FLAGS_TREES        0x0004  // parse tree/ast diagnostics
+    #define BOOST_SPIRIT_DEBUG_FLAGS_CLOSURES     0x0008  // closure diagnostics
+    #define BOOST_SPIRIT_DEBUG_FLAGS_SLEX         0x8000  // slex diagnostics
+
+    #define BOOST_SPIRIT_DEBUG_FLAGS_MAX          0xFFFF  // print maximal diagnostics
+
+    #if !defined(BOOST_SPIRIT_DEBUG_FLAGS)
+    #define BOOST_SPIRIT_DEBUG_FLAGS BOOST_SPIRIT_DEBUG_FLAGS_MAX
+    #endif
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  By default all nodes are traced (even those, not registered with
+    //  BOOST_SPIRIT_DEBUG_RULE et.al. - see below). The following constant may be
+    //  used to redefine this default.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACENODE)
+    #define BOOST_SPIRIT_DEBUG_TRACENODE          (true)
+    #endif // !defined(BOOST_SPIRIT_DEBUG_TRACENODE)
+
+    ///////////////////////////////////////////////////////////////////////////
+    //
+    //  Helper macros for giving rules and subrules a name accessible through
+    //  parser_name() functions (see parser_names.hpp).
+    //
+    //  Additionally, the macros BOOST_SPIRIT_DEBUG_RULE, SPIRIT_DEBUG_NODE and
+    //  BOOST_SPIRIT_DEBUG_GRAMMAR enable/disable the tracing of the
+    //  correspondingnode accordingly to the PP constant
+    //  BOOST_SPIRIT_DEBUG_TRACENODE.
+    //
+    //  The macros BOOST_SPIRIT_DEBUG_TRACE_RULE, BOOST_SPIRIT_DEBUG_TRACE_NODE
+    //  and BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR allow to specify a flag to define,
+    //  whether the corresponding node is to be traced or not.
+    //
+    ///////////////////////////////////////////////////////////////////////////
+    #if !defined(BOOST_SPIRIT_DEBUG_RULE)
+    #define BOOST_SPIRIT_DEBUG_RULE(r)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, #r, BOOST_SPIRIT_DEBUG_TRACENODE)
+    #endif // !defined(BOOST_SPIRIT_DEBUG_RULE)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_NODE)
+    #define BOOST_SPIRIT_DEBUG_NODE(r)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, #r, BOOST_SPIRIT_DEBUG_TRACENODE)
+    #endif // !defined(BOOST_SPIRIT_DEBUG_NODE)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_GRAMMAR)
+    #define BOOST_SPIRIT_DEBUG_GRAMMAR(r)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, #r, BOOST_SPIRIT_DEBUG_TRACENODE)
+    #endif // !defined(BOOST_SPIRIT_DEBUG_GRAMMAR)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE)
+    #define BOOST_SPIRIT_DEBUG_TRACE_RULE(r, t)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, #r, (t))
+    #endif // !defined(BOOST_SPIRIT_TRACE_RULE)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE)
+    #define BOOST_SPIRIT_DEBUG_TRACE_NODE(r, t)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, #r, (t))
+    #endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR)
+    #define BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR(r, t)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, #r, (t))
+    #endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE_NAME)
+    #define BOOST_SPIRIT_DEBUG_TRACE_RULE_NAME(r, n, t)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, (n), (t))
+    #endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_RULE_NAME)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE_NAME)
+    #define BOOST_SPIRIT_DEBUG_TRACE_NODE_NAME(r, n, t)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, (n), (t))
+    #endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_NODE_NAME)
+
+    #if !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR_NAME)
+    #define BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR_NAME(r, n, t)    \
+        ::BOOST_SPIRIT_CLASSIC_NS::impl::get_node_registry(). \
+            register_node(&r, (n), (t))
+    #endif // !defined(BOOST_SPIRIT_DEBUG_TRACE_GRAMMAR_NAME)
+
+    //////////////////////////////////
+    #include <boost/spirit/home/classic/debug/debug_node.hpp>
+
+#else
+    //////////////////////////////////
+    #include <boost/spirit/home/classic/debug/minimal.hpp>
+
+#endif // BOOST_SPIRIT_DEBUG
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/meta.hpp	(working copy)
@@ -0,0 +1,26 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Hartmut Kaiser
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_META_MAIN_HPP)
+#define BOOST_SPIRIT_META_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Master header for Spirit.Meta
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include <boost/spirit/home/classic/meta/fundamental.hpp>
+#include <boost/spirit/home/classic/meta/parser_traits.hpp>
+#include <boost/spirit/home/classic/meta/as_parser.hpp>
+#include <boost/spirit/home/classic/meta/traverse.hpp>
+
+#endif // BOOST_SPIRIT_CORE_MAIN_HPP
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic/core.hpp	(working copy)
@@ -0,0 +1,73 @@
+/*=============================================================================
+    Copyright (c) 1998-2003 Joel de Guzman
+    Copyright (c) 2001-2003 Daniel Nuffer
+    Copyright (c) 2001-2003 Hartmut Kaiser
+    Copyright (c) 2002-2003 Martin Wille
+    Copyright (c) 2002 Raghavendra Satish
+    Copyright (c) 2001 Bruce Florman
+    http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_CORE_MAIN_HPP)
+#define BOOST_SPIRIT_CORE_MAIN_HPP
+
+#include <boost/spirit/home/classic/version.hpp>
+#include <boost/spirit/home/classic/debug.hpp>
+
+///////////////////////////////////////////////////////////////////////////////
+//
+//  Spirit.Core includes
+//
+///////////////////////////////////////////////////////////////////////////////
+
+//  Spirit.Core.Kernel
+#include <boost/spirit/home/classic/core/config.hpp>
+#include <boost/spirit/home/classic/core/nil.hpp>
+#include <boost/spirit/home/classic/core/match.hpp>
+#include <boost/spirit/home/classic/core/parser.hpp>
+
+//  Spirit.Core.Primitives
+#include <boost/spirit/home/classic/core/primitives/primitives.hpp>
+#include <boost/spirit/home/classic/core/primitives/numerics.hpp>
+
+//  Spirit.Core.Scanner
+#include <boost/spirit/home/classic/core/scanner/scanner.hpp>
+#include <boost/spirit/home/classic/core/scanner/skipper.hpp>
+
+//  Spirit.Core.NonTerminal
+#include <boost/spirit/home/classic/core/non_terminal/subrule.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/rule.hpp>
+#include <boost/spirit/home/classic/core/non_terminal/grammar.hpp>
+
+//  Spirit.Core.Composite
+#include <boost/spirit/home/classic/core/composite/actions.hpp>
+#include <boost/spirit/home/classic/core/composite/composite.hpp>
+#include <boost/spirit/home/classic/core/composite/directives.hpp>
+#include <boost/spirit/home/classic/core/composite/epsilon.hpp>
+#include <boost/spirit/home/classic/core/composite/sequence.hpp>
+#include <boost/spirit/home/classic/core/composite/sequential_and.hpp>
+#include <boost/spirit/home/classic/core/composite/sequential_or.hpp>
+#include <boost/spirit/home/classic/core/composite/alternative.hpp>
+#include <boost/spirit/home/classic/core/composite/difference.hpp>
+#include <boost/spirit/home/classic/core/composite/intersection.hpp>
+#include <boost/spirit/home/classic/core/composite/exclusive_or.hpp>
+#include <boost/spirit/home/classic/core/composite/kleene_star.hpp>
+#include <boost/spirit/home/classic/core/composite/positive.hpp>
+#include <boost/spirit/home/classic/core/composite/optional.hpp>
+#include <boost/spirit/home/classic/core/composite/list.hpp>
+#include <boost/spirit/home/classic/core/composite/no_actions.hpp>
+
+//  Deprecated interface includes
+#include <boost/spirit/home/classic/actor/assign_actor.hpp>
+#include <boost/spirit/home/classic/actor/push_back_actor.hpp>
+
+#if defined(BOOST_SPIRIT_DEBUG)
+    //////////////////////////////////
+    #include <boost/spirit/home/classic/debug/parser_names.hpp>
+
+#endif // BOOST_SPIRIT_DEBUG
+
+#endif // BOOST_SPIRIT_CORE_MAIN_HPP
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/home/classic.hpp	(working copy)
@@ -0,0 +1,32 @@
+/*=============================================================================
+    Copyright (c) 1998-2008 Joel de Guzman
+    Copyright (c) 2001-2008 Hartmut Kaiser
+    Copyright (c) 2001-2003 Daniel Nuffer
+    Copyright (c) 2002-2003 Martin Wille
+    Copyright (c) 2002 Juan Carlos Arevalo-Baeza
+    Copyright (c) 2002 Raghavendra Satish
+    Copyright (c) 2002 Jeff Westfahl
+    Copyright (c) 2001 Bruce Florman
+    Copyright (c) 2003 Giovanni Bajo
+    Copyright (c) 2003 Vaclav Vesely
+    Copyright (c) 2003 Jonathan de Halleux
+    http://spirit.sourceforge.net/
+    http://www.boost.org/libs/spirit
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+  See http://www.boost.org/libs/spirit for documentation
+=============================================================================*/
+#if !defined(BOOST_SPIRIT_CLASSIC_APRIL_11_2008_0849AM)
+#define BOOST_SPIRIT_CLASSIC_APRIL_11_2008_0849AM
+
+#include <boost/spirit/home/classic/core.hpp>
+#include <boost/spirit/home/classic/meta.hpp>
+#include <boost/spirit/home/classic/error_handling.hpp>
+#include <boost/spirit/home/classic/iterator.hpp>
+#include <boost/spirit/home/classic/symbols.hpp>
+#include <boost/spirit/home/classic/utility.hpp>
+#include <boost/spirit/home/classic/attribute.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/core.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/core.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/spirit/core.hpp	(working copy)
@@ -0,0 +1,27 @@
+/*=============================================================================
+  Copyright (c) 2001-2008 Joel de Guzman
+  Copyright (c) 2001-2008 Hartmut Kaiser
+  http://spirit.sourceforge.net/
+
+  Distributed under the Boost Software License, Version 1.0. (See accompanying
+  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+=============================================================================*/
+#ifndef BOOST_SPIRIT_DEPRECATED_INCLUDE_CORE
+#define BOOST_SPIRIT_DEPRECATED_INCLUDE_CORE
+
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 103800
+#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__DMC__)
+#  pragma message ("Warning: This header is deprecated. Please use: boost/spirit/include/classic_core.hpp")
+#elif defined(__GNUC__) || defined(__HP_aCC) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
+#  warning "This header is deprecated. Please use: boost/spirit/include/classic_core.hpp"
+#endif
+#endif
+
+#if !defined(BOOST_SPIRIT_USE_OLD_NAMESPACE)
+#define BOOST_SPIRIT_USE_OLD_NAMESPACE
+#endif
+#include <boost/spirit/include/classic_core.hpp>
+
+#endif
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/optional.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/optional.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/optional.hpp	(working copy)
@@ -0,0 +1,18 @@
+// Copyright (C) 2003, Fernando Luis Cacciola Carballal.
+//
+// Use, modification, and distribution is subject to the Boost Software
+// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// See http://www.boost.org/libs/optional for documentation.
+//
+// You are welcome to contact the author at:
+//  fernando_cacciola@hotmail.com
+//
+#ifndef BOOST_OPTIONAL_FLC_19NOV2002_HPP
+#define BOOST_OPTIONAL_FLC_19NOV2002_HPP
+
+#include "boost/optional/optional.hpp"
+
+#endif
+
Index: plugins/contrib/NassiShneiderman/boost_1_48/boost/concept_check.hpp
===================================================================
--- plugins/contrib/NassiShneiderman/boost_1_48/boost/concept_check.hpp	(revision 0)
+++ plugins/contrib/NassiShneiderman/boost_1_48/boost/concept_check.hpp	(working copy)
@@ -0,0 +1,1083 @@
+//
+// (C) Copyright Jeremy Siek 2000.
+// Copyright 2002 The Trustees of Indiana University.
+//
+// Distributed under the Boost Software License, Version 1.0. (See
+// accompanying file LICENSE_1_0.txt or copy at
+// http://www.boost.org/LICENSE_1_0.txt)
+//
+// Revision History:
+//   05 May   2001: Workarounds for HP aCC from Thomas Matelich. (Jeremy Siek)
+//   02 April 2001: Removed limits header altogether. (Jeremy Siek)
+//   01 April 2001: Modified to use new <boost/limits.hpp> header. (JMaddock)
+//
+
+// See http://www.boost.org/libs/concept_check for documentation.
+
+#ifndef BOOST_CONCEPT_CHECKS_HPP
+# define BOOST_CONCEPT_CHECKS_HPP
+
+# include <boost/concept/assert.hpp>
+
+# include <boost/iterator.hpp>
+# include <boost/type_traits/conversion_traits.hpp>
+# include <utility>
+# include <boost/type_traits/is_same.hpp>
+# include <boost/type_traits/is_void.hpp>
+# include <boost/mpl/assert.hpp>
+# include <boost/mpl/bool.hpp>
+# include <boost/detail/workaround.hpp>
+# include <boost/detail/iterator.hpp>
+
+# include <boost/concept/usage.hpp>
+# include <boost/concept/detail/concept_def.hpp>
+
+namespace boost
+{
+
+  //
+  // Backward compatibility
+  //
+
+  template <class Model>
+  inline void function_requires(Model* = 0)
+  {
+      BOOST_CONCEPT_ASSERT((Model));
+  }
+  template <class T> inline void ignore_unused_variable_warning(T const&) {}
+
+#  define BOOST_CLASS_REQUIRE(type_var, ns, concept)    \
+    BOOST_CONCEPT_ASSERT((ns::concept<type_var>))
+
+#  define BOOST_CLASS_REQUIRE2(type_var1, type_var2, ns, concept)   \
+    BOOST_CONCEPT_ASSERT((ns::concept<type_var1,type_var2>))
+
+#  define BOOST_CLASS_REQUIRE3(tv1, tv2, tv3, ns, concept)  \
+    BOOST_CONCEPT_ASSERT((ns::concept<tv1,tv2,tv3>))
+
+#  define BOOST_CLASS_REQUIRE4(tv1, tv2, tv3, tv4, ns, concept) \
+    BOOST_CONCEPT_ASSERT((ns::concept<tv1,tv2,tv3,tv4>))
+
+
+  //
+  // Begin concept definitions
+  //
+  BOOST_concept(Integer, (T))
+  {
+      BOOST_CONCEPT_USAGE(Integer)
+        {
+            x.error_type_must_be_an_integer_type();
+        }
+   private:
+      T x;
+  };
+
+  template <> struct Integer<char> {};
+  template <> struct Integer<signed char> {};
+  template <> struct Integer<unsigned char> {};
+  template <> struct Integer<short> {};
+  template <> struct Integer<unsigned short> {};
+  template <> struct Integer<int> {};
+  template <> struct Integer<unsigned int> {};
+  template <> struct Integer<long> {};
+  template <> struct Integer<unsigned long> {};
+# if defined(BOOST_HAS_LONG_LONG)
+  template <> struct Integer< ::boost::long_long_type> {};
+  template <> struct Integer< ::boost::ulong_long_type> {};
+# elif defined(BOOST_HAS_MS_INT64)
+  template <> struct Integer<__int64> {};
+  template <> struct Integer<unsigned __int64> {};
+# endif
+
+  BOOST_concept(SignedInteger,(T)) {
+    BOOST_CONCEPT_USAGE(SignedInteger) {
+      x.error_type_must_be_a_signed_integer_type();
+    }
+   private:
+    T x;
+  };
+  template <> struct SignedInteger<signed char> { };
+  template <> struct SignedInteger<short> {};
+  template <> struct SignedInteger<int> {};
+  template <> struct SignedInteger<long> {};
+# if defined(BOOST_HAS_LONG_LONG)
+  template <> struct SignedInteger< ::boost::long_long_type> {};
+# elif defined(BOOST_HAS_MS_INT64)
+  template <> struct SignedInteger<__int64> {};
+# endif
+
+  BOOST_concept(UnsignedInteger,(T)) {
+    BOOST_CONCEPT_USAGE(UnsignedInteger) {
+      x.error_type_must_be_an_unsigned_integer_type();
+    }
+   private:
+    T x;
+  };
+
+  template <> struct UnsignedInteger<unsigned char> {};
+  template <> struct UnsignedInteger<unsigned short> {};
+  template <> struct UnsignedInteger<unsigned int> {};
+  template <> struct UnsignedInteger<unsigned long> {};
+# if defined(BOOST_HAS_LONG_LONG)
+  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};
+# elif defined(BOOST_HAS_MS_INT64)
+  template <> struct UnsignedInteger<unsigned __int64> {};
+# endif
+
+  //===========================================================================
+  // Basic Concepts
+
+  BOOST_concept(DefaultConstructible,(TT))
+  {
+    BOOST_CONCEPT_USAGE(DefaultConstructible) {
+      TT a;               // require default constructor
+      ignore_unused_variable_warning(a);
+    }
+  };
+
+  BOOST_concept(Assignable,(TT))
+  {
+    BOOST_CONCEPT_USAGE(Assignable) {
+#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL
+      a = b;             // require assignment operator
+#endif
+      const_constraints(b);
+    }
+   private:
+    void const_constraints(const TT& x) {
+#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL
+      a = x;              // const required for argument to assignment
+#else
+      ignore_unused_variable_warning(x);
+#endif
+    }
+   private:
+    TT a;
+    TT b;
+  };
+
+
+  BOOST_concept(CopyConstructible,(TT))
+  {
+    BOOST_CONCEPT_USAGE(CopyConstructible) {
+      TT a(b);            // require copy constructor
+      TT* ptr = &a;       // require address of operator
+      const_constraints(a);
+      ignore_unused_variable_warning(ptr);
+    }
+   private:
+    void const_constraints(const TT& a) {
+      TT c(a);            // require const copy constructor
+      const TT* ptr = &a; // require const address of operator
+      ignore_unused_variable_warning(c);
+      ignore_unused_variable_warning(ptr);
+    }
+    TT b;
+  };
+
+#if (defined _MSC_VER)
+# pragma warning( push )
+# pragma warning( disable : 4510 ) // default constructor could not be generated
+# pragma warning( disable : 4610 ) // object 'class' can never be instantiated - user-defined constructor required
+#endif
+  // The SGI STL version of Assignable requires copy constructor and operator=
+  BOOST_concept(SGIAssignable,(TT))
+  {
+    BOOST_CONCEPT_USAGE(SGIAssignable) {
+      TT c(a);
+#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL
+      a = b;              // require assignment operator
+#endif
+      const_constraints(b);
+      ignore_unused_variable_warning(c);
+    }
+   private:
+    void const_constraints(const TT& x) {
+      TT c(x);
+#if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL
+      a = x;              // const required for argument to assignment
+#endif
+      ignore_unused_variable_warning(c);
+    }
+    TT a;
+    TT b;
+  };
+#if (defined _MSC_VER)
+# pragma warning( pop )
+#endif
+
+  BOOST_concept(Convertible,(X)(Y))
+  {
+    BOOST_CONCEPT_USAGE(Convertible) {
+      Y y = x;
+      ignore_unused_variable_warning(y);
+    }
+   private:
+    X x;
+  };
+
+  // The C++ standard requirements for many concepts talk about return
+  // types that must be "convertible to bool".  The problem with this
+  // requirement is that it leaves the door open for evil proxies that
+  // define things like operator|| with strange return types.  Two
+  // possible solutions are:
+  // 1) require the return type to be exactly bool
+  // 2) stay with convertible to bool, and also
+  //    specify stuff about all the logical operators.
+  // For now we just test for convertible to bool.
+  template <class TT>
+  void require_boolean_expr(const TT& t) {
+    bool x = t;
+    ignore_unused_variable_warning(x);
+  }
+
+  BOOST_concept(EqualityComparable,(TT))
+  {
+    BOOST_CONCEPT_USAGE(EqualityComparable) {
+      require_boolean_expr(a == b);
+      require_boolean_expr(a != b);
+    }
+   private:
+    TT a, b;
+  };
+
+  BOOST_concept(LessThanComparable,(TT))
+  {
+    BOOST_CONCEPT_USAGE(LessThanComparable) {
+      require_boolean_expr(a < b);
+    }
+   private:
+    TT a, b;
+  };
+
+  // This is equivalent to SGI STL's LessThanComparable.
+  BOOST_concept(Comparable,(TT))
+  {
+    BOOST_CONCEPT_USAGE(Comparable) {
+      require_boolean_expr(a < b);
+      require_boolean_expr(a > b);
+      require_boolean_expr(a <= b);
+      require_boolean_expr(a >= b);
+    }
+   private:
+    TT a, b;
+  };
+
+#define BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(OP,NAME)    \
+  BOOST_concept(NAME, (First)(Second))                          \
+  {                                                             \
+      BOOST_CONCEPT_USAGE(NAME) { (void)constraints_(); }                         \
+     private:                                                   \
+        bool constraints_() { return a OP b; }                  \
+        First a;                                                \
+        Second b;                                               \
+  }
+
+#define BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(OP,NAME)    \
+  BOOST_concept(NAME, (Ret)(First)(Second))                 \
+  {                                                         \
+      BOOST_CONCEPT_USAGE(NAME) { (void)constraints_(); }                     \
+  private:                                                  \
+      Ret constraints_() { return a OP b; }                 \
+      First a;                                              \
+      Second b;                                             \
+  }
+
+  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(==, EqualOp);
+  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(!=, NotEqualOp);
+  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(<, LessThanOp);
+  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(<=, LessEqualOp);
+  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(>, GreaterThanOp);
+  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(>=, GreaterEqualOp);
+
+  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(+, PlusOp);
+  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(*, TimesOp);
+  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(/, DivideOp);
+  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(-, SubtractOp);
+  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(%, ModOp);
+
+  //===========================================================================
+  // Function Object Concepts
+
+  BOOST_concept(Generator,(Func)(Return))
+  {
+      BOOST_CONCEPT_USAGE(Generator) { test(is_void<Return>()); }
+
+   private:
+      void test(boost::mpl::false_)
+      {
+          // Do we really want a reference here?
+          const Return& r = f();
+          ignore_unused_variable_warning(r);
+      }
+
+      void test(boost::mpl::true_)
+      {
+          f();
+      }
+
+      Func f;
+  };
+
+  BOOST_concept(UnaryFunction,(Func)(Return)(Arg))
+  {
+      BOOST_CONCEPT_USAGE(UnaryFunction) { test(is_void<Return>()); }
+
+   private:
+      void test(boost::mpl::false_)
+      {
+          f(arg);               // "priming the pump" this way keeps msvc6 happy (ICE)
+          Return r = f(arg);
+          ignore_unused_variable_warning(r);
+      }
+
+      void test(boost::mpl::true_)
+      {
+          f(arg);
+      }
+
+#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \
+                      && BOOST_WORKAROUND(__GNUC__, > 3)))
+      // Declare a dummy construktor to make gcc happy.
+      // It seems the compiler can not generate a sensible constructor when this is instantiated with a refence type.
+      // (warning: non-static reference "const double& boost::UnaryFunction<YourClassHere>::arg"
+      // in class without a constructor [-Wuninitialized])
+      UnaryFunction();
+#endif
+
+      Func f;
+      Arg arg;
+  };
+
+  BOOST_concept(BinaryFunction,(Func)(Return)(First)(Second))
+  {
+      BOOST_CONCEPT_USAGE(BinaryFunction) { test(is_void<Return>()); }
+   private:
+      void test(boost::mpl::false_)
+      {
+          f(first,second);
+          Return r = f(first, second); // require operator()
+          (void)r;
+      }
+
+      void test(boost::mpl::true_)
+      {
+          f(first,second);
+      }
+
+#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \
+                      && BOOST_WORKAROUND(__GNUC__, > 3)))
+      // Declare a dummy constructor to make gcc happy.
+      // It seems the compiler can not generate a sensible constructor when this is instantiated with a refence type.
+      // (warning: non-static reference "const double& boost::BinaryFunction<YourClassHere>::arg"
+      // in class without a constructor [-Wuninitialized])
+      BinaryFunction();
+#endif
+
+      Func f;
+      First first;
+      Second second;
+  };
+
+  BOOST_concept(UnaryPredicate,(Func)(Arg))
+  {
+    BOOST_CONCEPT_USAGE(UnaryPredicate) {
+      require_boolean_expr(f(arg)); // require operator() returning bool
+    }
+   private:
+#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \
+                      && BOOST_WORKAROUND(__GNUC__, > 3)))
+      // Declare a dummy constructor to make gcc happy.
+      // It seems the compiler can not generate a sensible constructor when this is instantiated with a refence type.
+      // (warning: non-static reference "const double& boost::UnaryPredicate<YourClassHere>::arg"
+      // in class without a constructor [-Wuninitialized])
+      UnaryPredicate();
+#endif
+
+    Func f;
+    Arg arg;
+  };
+
+  BOOST_concept(BinaryPredicate,(Func)(First)(Second))
+  {
+    BOOST_CONCEPT_USAGE(BinaryPredicate) {
+      require_boolean_expr(f(a, b)); // require operator() returning bool
+    }
+   private:
+#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \
+                      && BOOST_WORKAROUND(__GNUC__, > 3)))
+      // Declare a dummy constructor to make gcc happy.
+      // It seems the compiler can not generate a sensible constructor when this is instantiated with a refence type.
+      // (warning: non-static reference "const double& boost::BinaryPredicate<YourClassHere>::arg"
+      // in class without a constructor [-Wuninitialized])
+      BinaryPredicate();
+#endif
+    Func f;
+    First a;
+    Second b;
+  };
+
+  // use this when functor is used inside a container class like std::set
+  BOOST_concept(Const_BinaryPredicate,(Func)(First)(Second))
+    : BinaryPredicate<Func, First, Second>
+  {
+    BOOST_CONCEPT_USAGE(Const_BinaryPredicate) {
+      const_constraints(f);
+    }
+   private:
+    void const_constraints(const Func& fun) {
+      // operator() must be a const member function
+      require_boolean_expr(fun(a, b));
+    }
+#if (BOOST_WORKAROUND(__GNUC__, BOOST_TESTED_AT(4) \
+                      && BOOST_WORKAROUND(__GNUC__, > 3)))
+      // Declare a dummy constructor to make gcc happy.
+      // It seems the compiler can not generate a sensible constructor when this is instantiated with a refence type.
+      // (warning: non-static reference "const double& boost::Const_BinaryPredicate<YourClassHere>::arg"
+      // in class without a constructor [-Wuninitialized])
+      Const_BinaryPredicate();
+#endif
+
+    Func f;
+    First a;
+    Second b;
+  };
+
+  BOOST_concept(AdaptableGenerator,(Func)(Return))
+    : Generator<Func, typename Func::result_type>
+  {
+      typedef typename Func::result_type result_type;
+
+      BOOST_CONCEPT_USAGE(AdaptableGenerator)
+      {
+          BOOST_CONCEPT_ASSERT((Convertible<result_type, Return>));
+      }
+  };
+
+  BOOST_concept(AdaptableUnaryFunction,(Func)(Return)(Arg))
+    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
+  {
+      typedef typename Func::argument_type argument_type;
+      typedef typename Func::result_type result_type;
+
+      ~AdaptableUnaryFunction()
+      {
+          BOOST_CONCEPT_ASSERT((Convertible<result_type, Return>));
+          BOOST_CONCEPT_ASSERT((Convertible<Arg, argument_type>));
+      }
+  };
+
+  BOOST_concept(AdaptableBinaryFunction,(Func)(Return)(First)(Second))
+    : BinaryFunction<
+          Func
+        , typename Func::result_type
+        , typename Func::first_argument_type
+        , typename Func::second_argument_type
+      >
+  {
+      typedef typename Func::first_argument_type first_argument_type;
+      typedef typename Func::second_argument_type second_argument_type;
+      typedef typename Func::result_type result_type;
+
+      ~AdaptableBinaryFunction()
+      {
+          BOOST_CONCEPT_ASSERT((Convertible<result_type, Return>));
+          BOOST_CONCEPT_ASSERT((Convertible<First, first_argument_type>));
+          BOOST_CONCEPT_ASSERT((Convertible<Second, second_argument_type>));
+      }
+  };
+
+  BOOST_concept(AdaptablePredicate,(Func)(Arg))
+    : UnaryPredicate<Func, Arg>
+    , AdaptableUnaryFunction<Func, bool, Arg>
+  {
+  };
+
+  BOOST_concept(AdaptableBinaryPredicate,(Func)(First)(Second))
+    : BinaryPredicate<Func, First, Second>
+    , AdaptableBinaryFunction<Func, bool, First, Second>
+  {
+  };
+
+  //===========================================================================
+  // Iterator Concepts
+
+  BOOST_concept(InputIterator,(TT))
+    : Assignable<TT>
+    , EqualityComparable<TT>
+  {
+      typedef typename boost::detail::iterator_traits<TT>::value_type value_type;
+      typedef typename boost::detail::iterator_traits<TT>::difference_type difference_type;
+      typedef typename boost::detail::iterator_traits<TT>::reference reference;
+      typedef typename boost::detail::iterator_traits<TT>::pointer pointer;
+      typedef typename boost::detail::iterator_traits<TT>::iterator_category iterator_category;
+
+      BOOST_CONCEPT_USAGE(InputIterator)
+      {
+        BOOST_CONCEPT_ASSERT((SignedInteger<difference_type>));
+        BOOST_CONCEPT_ASSERT((Convertible<iterator_category, std::input_iterator_tag>));
+
+        TT j(i);
+        (void)*i;           // require dereference operator
+        ++j;                // require preincrement operator
+        i++;                // require postincrement operator
+      }
+   private:
+    TT i;
+  };
+
+  BOOST_concept(OutputIterator,(TT)(ValueT))
+    : Assignable<TT>
+  {
+    BOOST_CONCEPT_USAGE(OutputIterator) {
+
+      ++i;                // require preincrement operator
+      i++;                // require postincrement operator
+      *i++ = t;           // require postincrement and assignment
+    }
+   private:
+    TT i, j;
+    ValueT t;
+  };
+
+  BOOST_concept(ForwardIterator,(TT))
+    : InputIterator<TT>
+  {
+      BOOST_CONCEPT_USAGE(ForwardIterator)
+      {
+          BOOST_CONCEPT_ASSERT((Convertible<
+              BOOST_DEDUCED_TYPENAME ForwardIterator::iterator_category
+            , std::forward_iterator_tag
+          >));
+
+          typename InputIterator<TT>::reference r = *i;
+          ignore_unused_variable_warning(r);
+      }
+
+   private:
+      TT i;
+  };
+
+  BOOST_concept(Mutable_ForwardIterator,(TT))
+    : ForwardIterator<TT>
+  {
+      BOOST_CONCEPT_USAGE(Mutable_ForwardIterator) {
+        *i++ = *i;         // require postincrement and assignment
+      }
+   private:
+      TT i;
+  };
+
+  BOOST_concept(BidirectionalIterator,(TT))
+    : ForwardIterator<TT>
+  {
+      BOOST_CONCEPT_USAGE(BidirectionalIterator)
+      {
+          BOOST_CONCEPT_ASSERT((Convertible<
+              BOOST_DEDUCED_TYPENAME BidirectionalIterator::iterator_category
+            , std::bidirectional_iterator_tag
+          >));
+
+          --i;                // require predecrement operator
+          i--;                // require postdecrement operator
+      }
+   private:
+      TT i;
+  };
+
+  BOOST_concept(Mutable_BidirectionalIterator,(TT))
+    : BidirectionalIterator<TT>
+    , Mutable_ForwardIterator<TT>
+  {
+      BOOST_CONCEPT_USAGE(Mutable_BidirectionalIterator)
+      {
+          *i-- = *i;                  // require postdecrement and assignment
+      }
+   private:
+      TT i;
+  };
+
+  BOOST_concept(RandomAccessIterator,(TT))
+    : BidirectionalIterator<TT>
+    , Comparable<TT>
+  {
+      BOOST_CONCEPT_USAGE(RandomAccessIterator)
+      {
+          BOOST_CONCEPT_ASSERT((Convertible<
+              BOOST_DEDUCED_TYPENAME BidirectionalIterator<TT>::iterator_category
+            , std::random_access_iterator_tag
+          >));
+
+          i += n;             // require assignment addition operator
+          i = i + n; i = n + i; // require addition with difference type
+          i -= n;             // require assignment subtraction operator
+          i = i - n;                  // require subtraction with difference type
+          n = i - j;                  // require difference operator
+          (void)i[n];                 // require element access operator
+      }
+
+   private:
+    TT a, b;
+    TT i, j;
+      typename boost::detail::iterator_traits<TT>::difference_type n;
+  };
+
+  BOOST_concept(Mutable_RandomAccessIterator,(TT))
+    : RandomAccessIterator<TT>
+    , Mutable_BidirectionalIterator<TT>
+  {
+      BOOST_CONCEPT_USAGE(Mutable_RandomAccessIterator)
+      {
+          i[n] = *i;                  // require element access and assignment
+      }
+   private:
+    TT i;
+    typename boost::detail::iterator_traits<TT>::difference_type n;
+  };
+
+  //===========================================================================
+  // Container s
+
+  BOOST_concept(Container,(C))
+    : Assignable<C>
+  {
+    typedef typename C::value_type value_type;
+    typedef typename C::difference_type difference_type;
+    typedef typename C::size_type size_type;
+    typedef typename C::const_reference const_reference;
+    typedef typename C::const_pointer const_pointer;
+    typedef typename C::const_iterator const_iterator;
+
+      BOOST_CONCEPT_USAGE(Container)
+      {
+          BOOST_CONCEPT_ASSERT((InputIterator<const_iterator>));
+          const_constraints(c);
+      }
+
+   private:
+      void const_constraints(const C& cc) {
+          i = cc.begin();
+          i = cc.end();
+          n = cc.size();
+          n = cc.max_size();
+          b = cc.empty();
+      }
+      C c;
+      bool b;
+      const_iterator i;
+      size_type n;
+  };
+
+  BOOST_concept(Mutable_Container,(C))
+    : Container<C>
+  {
+      typedef typename C::reference reference;
+      typedef typename C::iterator iterator;
+      typedef typename C::pointer pointer;
+
+      BOOST_CONCEPT_USAGE(Mutable_Container)
+      {
+          BOOST_CONCEPT_ASSERT((
+               Assignable<typename Mutable_Container::value_type>));
+
+          BOOST_CONCEPT_ASSERT((InputIterator<iterator>));
+
+          i = c.begin();
+          i = c.end();
+          c.swap(c2);
+      }
+
+   private:
+      iterator i;
+      C c, c2;
+  };
+
+  BOOST_concept(ForwardContainer,(C))
+    : Container<C>
+  {
+      BOOST_CONCEPT_USAGE(ForwardContainer)
+      {
+          BOOST_CONCEPT_ASSERT((
+               ForwardIterator<
+                    typename ForwardContainer::const_iterator
+               >));
+      }
+  };
+
+  BOOST_concept(Mutable_ForwardContainer,(C))
+    : ForwardContainer<C>
+    , Mutable_Container<C>
+  {
+      BOOST_CONCEPT_USAGE(Mutable_ForwardContainer)
+      {
+          BOOST_CONCEPT_ASSERT((
+               Mutable_ForwardIterator<
+                   typename Mutable_ForwardContainer::iterator
+               >));
+      }
+  };
+
+  BOOST_concept(ReversibleContainer,(C))
+    : ForwardContainer<C>
+  {
+      typedef typename
+        C::const_reverse_iterator
+      const_reverse_iterator;
+
+      BOOST_CONCEPT_USAGE(ReversibleContainer)
+      {
+          BOOST_CONCEPT_ASSERT((
+              BidirectionalIterator<
+                  typename ReversibleContainer::const_iterator>));
+
+          BOOST_CONCEPT_ASSERT((BidirectionalIterator<const_reverse_iterator>));
+
+          const_constraints(c);
+      }
+   private:
+      void const_constraints(const C& cc)
+      {
+          const_reverse_iterator i = cc.rbegin();
+          i = cc.rend();
+      }
+      C c;
+  };
+
+  BOOST_concept(Mutable_ReversibleContainer,(C))
+    : Mutable_ForwardContainer<C>
+    , ReversibleContainer<C>
+  {
+      typedef typename C::reverse_iterator reverse_iterator;
+
+      BOOST_CONCEPT_USAGE(Mutable_ReversibleContainer)
+      {
+          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
+          BOOST_CONCEPT_ASSERT((Mutable_BidirectionalIterator<iterator>));
+          BOOST_CONCEPT_ASSERT((Mutable_BidirectionalIterator<reverse_iterator>));
+
+          reverse_iterator i = c.rbegin();
+          i = c.rend();
+      }
+   private:
+      C c;
+  };
+
+  BOOST_concept(RandomAccessContainer,(C))
+    : ReversibleContainer<C>
+  {
+      typedef typename C::size_type size_type;
+      typedef typename C::const_reference const_reference;
+
+      BOOST_CONCEPT_USAGE(RandomAccessContainer)
+      {
+          BOOST_CONCEPT_ASSERT((
+              RandomAccessIterator<
+                  typename RandomAccessContainer::const_iterator
+              >));
+
+          const_constraints(c);
+      }
+   private:
+      void const_constraints(const C& cc)
+      {
+          const_reference r = cc[n];
+          ignore_unused_variable_warning(r);
+      }
+
+      C c;
+      size_type n;
+  };
+
+  BOOST_concept(Mutable_RandomAccessContainer,(C))
+    : Mutable_ReversibleContainer<C>
+    , RandomAccessContainer<C>
+  {
+   private:
+      typedef Mutable_RandomAccessContainer self;
+   public:
+      BOOST_CONCEPT_USAGE(Mutable_RandomAccessContainer)
+      {
+          BOOST_CONCEPT_ASSERT((Mutable_RandomAccessIterator<typename self::iterator>));
+          BOOST_CONCEPT_ASSERT((Mutable_RandomAccessIterator<typename self::reverse_iterator>));
+
+          typename self::reference r = c[i];
+          ignore_unused_variable_warning(r);
+      }
+
+   private:
+      typename Mutable_ReversibleContainer<C>::size_type i;
+      C c;
+  };
+
+  // A Sequence is inherently mutable
+  BOOST_concept(Sequence,(S))
+    : Mutable_ForwardContainer<S>
+      // Matt Austern's book puts DefaultConstructible here, the C++
+      // standard places it in Container --JGS
+      // ... so why aren't we following the standard?  --DWA
+    , DefaultConstructible<S>
+  {
+      BOOST_CONCEPT_USAGE(Sequence)
+      {
+          S
+              c(n),
+              c2(n, t),
+              c3(first, last);
+
+          c.insert(p, t);
+          c.insert(p, n, t);
+          c.insert(p, first, last);
+
+          c.erase(p);
+          c.erase(p, q);
+
+          typename Sequence::reference r = c.front();
+
+          ignore_unused_variable_warning(c);
+          ignore_unused_variable_warning(c2);
+          ignore_unused_variable_warning(c3);
+          ignore_unused_variable_warning(r);
+          const_constraints(c);
+      }
+   private:
+      void const_constraints(const S& c) {
+          typename Sequence::const_reference r = c.front();
+          ignore_unused_variable_warning(r);
+      }
+
+      typename S::value_type t;
+      typename S::size_type n;
+      typename S::value_type* first, *last;
+      typename S::iterator p, q;
+  };
+
+  BOOST_concept(FrontInsertionSequence,(S))
+    : Sequence<S>
+  {
+      BOOST_CONCEPT_USAGE(FrontInsertionSequence)
+      {
+          c.push_front(t);
+          c.pop_front();
+      }
+   private:
+      S c;
+      typename S::value_type t;
+  };
+
+  BOOST_concept(BackInsertionSequence,(S))
+    : Sequence<S>
+  {
+      BOOST_CONCEPT_USAGE(BackInsertionSequence)
+      {
+          c.push_back(t);
+          c.pop_back();
+          typename BackInsertionSequence::reference r = c.back();
+          ignore_unused_variable_warning(r);
+          const_constraints(c);
+      }
+   private:
+      void const_constraints(const S& cc) {
+          typename BackInsertionSequence::const_reference
+              r = cc.back();
+          ignore_unused_variable_warning(r);
+      };
+      S c;
+      typename S::value_type t;
+  };
+
+  BOOST_concept(AssociativeContainer,(C))
+    : ForwardContainer<C>
+    , DefaultConstructible<C>
+  {
+      typedef typename C::key_type key_type;
+      typedef typename C::key_compare key_compare;
+      typedef typename C::value_compare value_compare;
+      typedef typename C::iterator iterator;
+
+      BOOST_CONCEPT_USAGE(AssociativeContainer)
+      {
+          i = c.find(k);
+          r = c.equal_range(k);
+          c.erase(k);
+          c.erase(i);
+          c.erase(r.first, r.second);
+          const_constraints(c);
+          BOOST_CONCEPT_ASSERT((BinaryPredicate<key_compare,key_type,key_type>));
+
+          typedef typename AssociativeContainer::value_type value_type_;
+          BOOST_CONCEPT_ASSERT((BinaryPredicate<value_compare,value_type_,value_type_>));
+      }
+
+      // Redundant with the base concept, but it helps below.
+      typedef typename C::const_iterator const_iterator;
+   private:
+      void const_constraints(const C& cc)
+      {
+          ci = cc.find(k);
+          n = cc.count(k);
+          cr = cc.equal_range(k);
+      }
+
+      C c;
+      iterator i;
+      std::pair<iterator,iterator> r;
+      const_iterator ci;
+      std::pair<const_iterator,const_iterator> cr;
+      typename C::key_type k;
+      typename C::size_type n;
+  };
+
+  BOOST_concept(UniqueAssociativeContainer,(C))
+    : AssociativeContainer<C>
+  {
+      BOOST_CONCEPT_USAGE(UniqueAssociativeContainer)
+      {
+          C c(first, last);
+
+          pos_flag = c.insert(t);
+          c.insert(first, last);
+
+          ignore_unused_variable_warning(c);
+      }
+   private:
+      std::pair<typename C::iterator, bool> pos_flag;
+      typename C::value_type t;
+      typename C::value_type* first, *last;
+  };
+
+  BOOST_concept(MultipleAssociativeContainer,(C))
+    : AssociativeContainer<C>
+  {
+      BOOST_CONCEPT_USAGE(MultipleAssociativeContainer)
+      {
+          C c(first, last);
+
+          pos = c.insert(t);
+          c.insert(first, last);
+
+          ignore_unused_variable_warning(c);
+          ignore_unused_variable_warning(pos);
+      }
+   private:
+      typename C::iterator pos;
+      typename C::value_type t;
+      typename C::value_type* first, *last;
+  };
+
+  BOOST_concept(SimpleAssociativeContainer,(C))
+    : AssociativeContainer<C>
+  {
+      BOOST_CONCEPT_USAGE(SimpleAssociativeContainer)
+      {
+          typedef typename C::key_type key_type;
+          typedef typename C::value_type value_type;
+          BOOST_MPL_ASSERT((boost::is_same<key_type,value_type>));
+      }
+  };
+
+  BOOST_concept(PairAssociativeContainer,(C))
+    : AssociativeContainer<C>
+  {
+      BOOST_CONCEPT_USAGE(PairAssociativeContainer)
+      {
+          typedef typename C::key_type key_type;
+          typedef typename C::value_type value_type;
+          typedef typename C::mapped_type mapped_type;
+          typedef std::pair<const key_type, mapped_type> required_value_type;
+          BOOST_MPL_ASSERT((boost::is_same<value_type,required_value_type>));
+      }
+  };
+
+  BOOST_concept(SortedAssociativeContainer,(C))
+    : AssociativeContainer<C>
+    , ReversibleContainer<C>
+  {
+      BOOST_CONCEPT_USAGE(SortedAssociativeContainer)
+      {
+          C
+              c(kc),
+              c2(first, last),
+              c3(first, last, kc);
+
+          p = c.upper_bound(k);
+          p = c.lower_bound(k);
+          r = c.equal_range(k);
+
+          c.insert(p, t);
+
+          ignore_unused_variable_warning(c);
+          ignore_unused_variable_warning(c2);
+          ignore_unused_variable_warning(c3);
+          const_constraints(c);
+      }
+
+      void const_constraints(const C& c)
+      {
+          kc = c.key_comp();
+          vc = c.value_comp();
+
+          cp = c.upper_bound(k);
+          cp = c.lower_bound(k);
+          cr = c.equal_range(k);
+      }
+
+   private:
+      typename C::key_compare kc;
+      typename C::value_compare vc;
+      typename C::value_type t;
+      typename C::key_type k;
+      typedef typename C::iterator iterator;
+      typedef typename C::const_iterator const_iterator;
+
+      typedef SortedAssociativeContainer self;
+      iterator p;
+      const_iterator cp;
+      std::pair<typename self::iterator,typename self::iterator> r;
+      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
+      typename C::value_type* first, *last;
+  };
+
+  // HashedAssociativeContainer
+
+  BOOST_concept(Collection,(C))
+  {
+      BOOST_CONCEPT_USAGE(Collection)
+      {
+        boost::function_requires<boost::InputIteratorConcept<iterator> >();
+        boost::function_requires<boost::InputIteratorConcept<const_iterator> >();
+        boost::function_requires<boost::CopyConstructibleConcept<value_type> >();
+        const_constraints(c);
+        i = c.begin();
+        i = c.end();
+        c.swap(c);
+      }
+
+      void const_constraints(const C& c) {
+        ci = c.begin();
+        ci = c.end();
+        n = c.size();
+        b = c.empty();
+      }
+
+    private:
+      typedef typename C::value_type value_type;
+      typedef typename C::iterator iterator;
+      typedef typename C::const_iterator const_iterator;
+      typedef typename C::reference reference;
+      typedef typename C::const_reference const_reference;
+      // typedef typename C::pointer pointer;
+      typedef typename C::difference_type difference_type;
+      typedef typename C::size_type size_type;
+
+      C c;
+      bool b;
+      iterator i;
+      const_iterator ci;
+      size_type n;
+  };
+} // namespace boost
+
+# include <boost/concept/detail/concept_undef.hpp>
+
+#endif // BOOST_CONCEPT_CHECKS_HPP
+
Index: plugins/contrib/NassiShneiderman/NassiShneiderman.cbp
===================================================================
--- plugins/contrib/NassiShneiderman/NassiShneiderman.cbp	(revision 7810)
+++ plugins/contrib/NassiShneiderman/NassiShneiderman.cbp	(working copy)
@@ -34,7 +35,7 @@
 					<Add directory="$(#wx.include)" />
 					<Add directory="$(#wx.lib)\gcc_dll$(WX_CFG)\msw$(WX_SUFFIX)" />
 					<Add directory="$(#wx)\contrib\include" />
-					<Add directory="$(#boost)" />
+					<Add directory="boost_1_48" />
 				</Compiler>
 				<Linker>
 					<Add option="-Wl,-enable-auto-import" />
