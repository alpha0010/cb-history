Index: src/sdk/cbeditor.cpp
===================================================================
--- src/sdk/cbeditor.cpp	(revision 5311)
+++ src/sdk/cbeditor.cpp	(working copy)
@@ -43,20 +43,27 @@
 
 const wxString g_EditorModified = _T("*");
 
-#define ERROR_MARKER        1
-#define ERROR_STYLE            wxSCI_MARK_SMALLRECT
+#define ERROR_MARKER            1
+#define ERROR_STYLE             wxSCI_MARK_SMALLRECT
 
-#define BOOKMARK_MARKER        2
-#define BOOKMARK_STYLE         wxSCI_MARK_ARROW
+#define BOOKMARK_MARKER         2
+#define BOOKMARK_STYLE          wxSCI_MARK_ARROW
 
-#define BREAKPOINT_MARKER    3
-#define BREAKPOINT_STYLE     wxSCI_MARK_CIRCLE
+#define BREAKPOINT_MARKER       3
+#define BREAKPOINT_STYLE        wxSCI_MARK_CIRCLE
 
-#define DEBUG_MARKER        4
-#define DEBUG_STYLE         wxSCI_MARK_ARROW
+#define DEBUG_MARKER            4
+#define DEBUG_STYLE             wxSCI_MARK_ARROW
 
+#define CHANGEUNSAVED_MARKER    23
+#define CHANGEUNSAVED_STYLE     wxSCI_MARK_LEFTRECT
 
+#define CHANGESAVED_MARKER      24
+#define CHANGESAVED_STYLE       wxSCI_MARK_LEFTRECT
 
+static const int foldingMargin   = 2;
+static const int changebarMargin = 3;
+
 /* This struct holds private data for the cbEditor class.
  * It's a paradigm to avoid rebuilding the entire project (as cbEditor is a basic dependency)
  * for just adding a private var or method.
@@ -1044,7 +1051,7 @@
     control->SetMarginMask(1, (1 << BOOKMARK_MARKER) |
                                  (1 << BREAKPOINT_MARKER) |
                                  (1 << DEBUG_MARKER) |
-                                 (1 << ERROR_MARKER));
+                                 (1 << ERROR_MARKER) );
     control->MarkerDefine(BOOKMARK_MARKER, BOOKMARK_STYLE);
     control->MarkerSetBackground(BOOKMARK_MARKER, wxColour(0xA0, 0xA0, 0xFF));
     control->MarkerDefine(BREAKPOINT_MARKER, BREAKPOINT_STYLE);
@@ -1059,6 +1066,15 @@
 
     control->SetEOLMode(mgr->ReadInt(_T("/eol/eolmode"), default_eol));
 
+    control->SetMarginType(changebarMargin,  wxSCI_MARGIN_SYMBOL);
+    control->SetMarginWidth(changebarMargin, 4);
+    control->SetMarginMask(changebarMargin, (1 << CHANGEUNSAVED_MARKER) | (1 << CHANGESAVED_MARKER) );
+
+    control->MarkerDefine(CHANGEUNSAVED_MARKER, CHANGEUNSAVED_STYLE);
+    control->MarkerSetBackground(CHANGEUNSAVED_MARKER, wxColour(0xFF, 0xE6, 0x04));
+    control->MarkerDefine(CHANGESAVED_MARKER, CHANGESAVED_STYLE);
+    control->MarkerSetBackground(CHANGESAVED_MARKER, wxColour(0x04, 0xFF, 0x50));
+
     // folding margin
     control->SetProperty(_T("fold"), mgr->ReadBool(_T("/folding/show_folds"), true) ? _T("1") : _T("0"));
     control->SetProperty(_T("fold.html"), mgr->ReadBool(_T("/folding/fold_xml"), true) ? _T("1") : _T("0"));
@@ -1068,10 +1084,10 @@
     if (mgr->ReadBool(_T("/folding/show_folds"), true))
     {
         control->SetFoldFlags(16);
-        control->SetMarginType(2, wxSCI_MARGIN_SYMBOL);
-        control->SetMarginWidth(2, 16);
-        control->SetMarginMask(2, wxSCI_MASK_FOLDERS);
-        control->SetMarginSensitive(2, 1);
+        control->SetMarginType(foldingMargin, wxSCI_MARGIN_SYMBOL);
+        control->SetMarginWidth(foldingMargin, 16);
+        control->SetMarginMask(foldingMargin, wxSCI_MASK_FOLDERS);
+        control->SetMarginSensitive(foldingMargin, 1);
 
         /*Default behaviour
         control->MarkerDefine(wxSCI_MARKNUM_FOLDEROPEN, wxSCI_MARK_BOXMINUS);
@@ -1098,7 +1114,7 @@
         */
     }
     else
-        control->SetMarginWidth(2, 0);
+        control->SetMarginWidth(foldingMargin, 0);
 }
 
 // static
@@ -2264,7 +2280,8 @@
         wxPoint clientpos(ScreenToClient(position));
         const int margin = m_pControl->GetMarginWidth(0) + // numbers, if present
                            m_pControl->GetMarginWidth(1) + // breakpoints, bookmarks... if present
-                           m_pControl->GetMarginWidth(2);  // folding, if present
+                           m_pControl->GetMarginWidth(changebarMargin) +
+                           m_pControl->GetMarginWidth(foldingMargin);  // folding, if present
         wxRect r = m_pControl->GetRect();
 
         bool inside1 = r.Contains(clientpos);
@@ -2490,7 +2507,7 @@
             ToggleBreakpoint(line);
             break;
         }
-        case 2: // folding margin
+        case foldingMargin: // folding margin
         {
             int lineYpix = event.GetPosition();
             int line = GetControl()->LineFromPosition(lineYpix);
Index: src/sdk/wxscintilla/src/PlatWX.cpp
===================================================================
--- src/sdk/wxscintilla/src/PlatWX.cpp	(revision 5311)
+++ src/sdk/wxscintilla/src/PlatWX.cpp	(working copy)
@@ -44,6 +44,7 @@
                     (unsigned char)cd.GetBlue());
 }
 
+
 //----------------------------------------------------------------------
 
 Palette::Palette() {
@@ -735,6 +736,10 @@
 }
 
 
+PRectangle Window::GetMonitorRect(Point pt) {
+    return PRectangle(pt.x, pt.y, pt.x+1, pt.y+1);
+}
+
 //----------------------------------------------------------------------
 // Helper classes for ListBox
 
@@ -1499,10 +1504,10 @@
     if (!len)
         return wxEmptyString;
 
-    size_t wclen = UCS2Length(str, len);
+    size_t wclen = UTF16Length(str, len);
     wxWCharBuffer buffer(wclen+1);
 
-    size_t actualLen = UCS2FromUTF8(str, len, buffer.data(), wclen+1);
+    size_t actualLen = UTF16FromUTF8(str, len, buffer.data(), wclen+1);
     return wxString(buffer.data(), actualLen);
 }
 
@@ -1513,7 +1518,7 @@
     size_t len           = UTF8Length(wcstr, wclen);
 
     wxCharBuffer buffer(len+1);
-    UTF8FromUCS2(wcstr, wclen, buffer.data(), len);
+    UTF8FromUTF16(wcstr, wclen, buffer.data(), len);
 
     // TODO check NULL termination!!
 
Index: src/sdk/wxscintilla/src/scintilla/include/HFacer.py
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/HFacer.py	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/HFacer.py	(working copy)
@@ -71,6 +71,6 @@
 	f.ReadFromFile("Scintilla.iface")
 	Regenerate("Scintilla.h", printHFile, f)
 	Regenerate("SciLexer.h", printLexHFile, f)
-	print "Maximum ID is", max(x for x in f.values if int(x) < 3000)
+	print "Maximum ID is", max([x for x in f.values if int(x) < 3000])
 except:
 	raise
Index: src/sdk/wxscintilla/src/scintilla/include/SString.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/SString.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/SString.h	(working copy)
@@ -8,11 +8,16 @@
 #ifndef SSTRING_H
 #define SSTRING_H
 
+
 // These functions are implemented because each platform calls them something different.
 int CompareCaseInsensitive(const char *a, const char *b);
 int CompareNCaseInsensitive(const char *a, const char *b, size_t len);
 bool EqualCaseInsensitive(const char *a, const char *b);
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 // Define another string class.
 // While it would be 'better' to use std::string, that doubles the executable size.
 // An SString may contain embedded nul characters.
@@ -277,4 +282,8 @@
 	return SContainer::StringAllocate(s, len);
 }
 
+#ifdef SCI_NAMESPACE
+}
 #endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/include/WindowAccessor.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/WindowAccessor.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/WindowAccessor.h	(working copy)
@@ -6,6 +6,10 @@
 // Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 /**
  */
 class WindowAccessor : public Accessor {
@@ -54,4 +58,9 @@
 	void ColourTo(unsigned int pos, int chAttr);
 	void SetLevel(int line, int level);
 	int IndentAmount(int line, int *flags, PFNIsCommentLeader pfnIsCommentLeader = 0);
+	void IndicatorFill(int start, int end, int indicator, int value);
 };
+
+#ifdef SCI_NAMESPACE
+}
+#endif
Index: src/sdk/wxscintilla/src/scintilla/include/PropSet.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/PropSet.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/PropSet.h	(working copy)
@@ -13,6 +13,10 @@
 
 bool isprefix(const char *target, const char *prefix);
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 struct Property {
 	unsigned int hash;
 	char *key;
@@ -29,7 +33,6 @@
 	Property *props[hashRoots];
 	Property *enumnext;
 	int enumhash;
-	static bool caseSensitiveFilenames;
 	static unsigned int HashString(const char *s, size_t len) {
 		unsigned int ret = 0;
 		while (len--) {
@@ -39,7 +42,6 @@
 		}
 		return ret;
 	}
-	static bool IncludesVar(const char *value, const char *key);
 
 public:
 	PropSet *superPS;
@@ -49,19 +51,12 @@
 	void Set(const char *keyVal);
 	void Unset(const char *key, int lenKey=-1);
 	void SetMultiple(const char *s);
-	SString Get(const char *key);
-	SString GetExpanded(const char *key);
-	SString Expand(const char *withVars, int maxExpands=100);
-	int GetInt(const char *key, int defaultValue=0);
-	SString GetWild(const char *keybase, const char *filename);
-	SString GetNewExpand(const char *keybase, const char *filename="");
+	SString Get(const char *key) const;
+	SString GetExpanded(const char *key) const;
+	SString Expand(const char *withVars, int maxExpands=100) const;
+	int GetInt(const char *key, int defaultValue=0) const;
 	void Clear();
-	char *ToString();	// Caller must delete[] the return value
-	bool GetFirst(char **key, char **val);
-	bool GetNext(char **key, char **val);
-	static void SetCaseSensitiveFilenames(bool caseSensitiveFilenames_) {
-		caseSensitiveFilenames = caseSensitiveFilenames_;
-	}
+	char *ToString() const;	// Caller must delete[] the return value
 
 private:
 	// copy-value semantics not implemented
@@ -75,35 +70,30 @@
 public:
 	// Each word contains at least one character - a empty word acts as sentinel at the end.
 	char **words;
-	char **wordsNoCase;
 	char *list;
 	int len;
 	bool onlyLineEnds;	///< Delimited by any white space or only line ends
 	bool sorted;
-	bool sortedNoCase;
 	int starts[256];
 	WordList(bool onlyLineEnds_ = false) :
-		words(0), wordsNoCase(0), list(0), len(0), onlyLineEnds(onlyLineEnds_),
-		sorted(false), sortedNoCase(false) {}
+		words(0), list(0), len(0), onlyLineEnds(onlyLineEnds_),
+		sorted(false)
+		{}
 	~WordList() { Clear(); }
 	operator bool() { return len ? true : false; }
-	char *operator[](int ind) { return words[ind]; }
 	void Clear();
 	void Set(const char *s);
-	char *Allocate(int size);
-	void SetFromAllocated();
 	bool InList(const char *s);
 	bool InListAbbreviated(const char *s, const char marker);
-	const char *GetNearestWord(const char *wordStart, int searchLen,
-		bool ignoreCase = false, SString wordCharacters="", int wordIndex = -1);
-	char *GetNearestWords(const char *wordStart, int searchLen,
-		bool ignoreCase=false, char otherSeparator='\0', bool exactLen=false);
 };
 
 inline bool IsAlphabetic(unsigned int ch) {
 	return ((ch >= 'A') && (ch <= 'Z')) || ((ch >= 'a') && (ch <= 'z'));
 }
 
+#ifdef SCI_NAMESPACE
+}
+#endif
 
 #ifdef _MSC_VER
 // Visual C++ doesn't like the private copy idiom for disabling
Index: src/sdk/wxscintilla/src/scintilla/include/SciLexer.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/SciLexer.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/SciLexer.h	(working copy)
@@ -91,6 +91,14 @@
 #define SCLEX_INNOSETUP 76
 #define SCLEX_OPAL 77
 #define SCLEX_SPICE 78
+#define SCLEX_D 79
+#define SCLEX_CMAKE 80
+#define SCLEX_GAP 81
+#define SCLEX_PLM 82
+#define SCLEX_PROGRESS 83
+#define SCLEX_ABAQUS 84
+#define SCLEX_ASYMPTOTE 85
+#define SCLEX_R 86
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
@@ -128,7 +136,24 @@
 #define SCE_C_COMMENTDOCKEYWORD 17
 #define SCE_C_COMMENTDOCKEYWORDERROR 18
 #define SCE_C_GLOBALCLASS 19
-#define SCE_C_WXSMITH 20
+#define SCE_D_DEFAULT 0
+#define SCE_D_COMMENT 1
+#define SCE_D_COMMENTLINE 2
+#define SCE_D_COMMENTDOC 3
+#define SCE_D_COMMENTNESTED 4
+#define SCE_D_NUMBER 5
+#define SCE_D_WORD 6
+#define SCE_D_WORD2 7
+#define SCE_D_WORD3 8
+#define SCE_D_TYPEDEF 9
+#define SCE_D_STRING 10
+#define SCE_D_STRINGEOL 11
+#define SCE_D_CHARACTER 12
+#define SCE_D_OPERATOR 13
+#define SCE_D_IDENTIFIER 14
+#define SCE_D_COMMENTLINEDOC 15
+#define SCE_D_COMMENTDOCKEYWORD 16
+#define SCE_D_COMMENTDOCKEYWORDERROR 17
 #define SCE_TCL_DEFAULT 0
 #define SCE_TCL_COMMENT 1
 #define SCE_TCL_COMMENTLINE 2
@@ -294,6 +319,9 @@
 #define SCE_PL_STRING_QR 29
 #define SCE_PL_STRING_QW 30
 #define SCE_PL_POD_VERB 31
+#define SCE_PL_SUB_PROTOTYPE 40
+#define SCE_PL_FORMAT_IDENT 41
+#define SCE_PL_FORMAT 42
 #define SCE_RB_DEFAULT 0
 #define SCE_RB_ERROR 1
 #define SCE_RB_COMMENTLINE 2
@@ -399,6 +427,7 @@
 #define SCE_ERR_ABSF 18
 #define SCE_ERR_TIDY 19
 #define SCE_ERR_JAVA_STACK 20
+#define SCE_ERR_VALUE 21
 #define SCE_BAT_DEFAULT 0
 #define SCE_BAT_COMMENT 1
 #define SCE_BAT_WORD 2
@@ -711,6 +740,7 @@
 #define SCE_YAML_DOCUMENT 6
 #define SCE_YAML_TEXT 7
 #define SCE_YAML_ERROR 8
+#define SCE_YAML_OPERATOR 9
 #define SCE_TEX_DEFAULT 0
 #define SCE_TEX_SPECIAL 1
 #define SCE_TEX_GROUP 2
@@ -928,6 +958,7 @@
 #define SCE_T3_USER1 17
 #define SCE_T3_USER2 18
 #define SCE_T3_USER3 19
+#define SCE_T3_BRACE 20
 #define SCE_REBOL_DEFAULT 0
 #define SCE_REBOL_COMMENTLINE 1
 #define SCE_REBOL_COMMENTBLOCK 2
@@ -1068,6 +1099,110 @@
 #define SCE_SPICE_DELIMITER 6
 #define SCE_SPICE_VALUE 7
 #define SCE_SPICE_COMMENTLINE 8
+#define SCE_CMAKE_DEFAULT 0
+#define SCE_CMAKE_COMMENT 1
+#define SCE_CMAKE_STRINGDQ 2
+#define SCE_CMAKE_STRINGLQ 3
+#define SCE_CMAKE_STRINGRQ 4
+#define SCE_CMAKE_COMMANDS 5
+#define SCE_CMAKE_PARAMETERS 6
+#define SCE_CMAKE_VARIABLE 7
+#define SCE_CMAKE_USERDEFINED 8
+#define SCE_CMAKE_WHILEDEF 9
+#define SCE_CMAKE_FOREACHDEF 10
+#define SCE_CMAKE_IFDEFINEDEF 11
+#define SCE_CMAKE_MACRODEF 12
+#define SCE_CMAKE_STRINGVAR 13
+#define SCE_CMAKE_NUMBER 14
+#define SCE_GAP_DEFAULT 0
+#define SCE_GAP_IDENTIFIER 1
+#define SCE_GAP_KEYWORD 2
+#define SCE_GAP_KEYWORD2 3
+#define SCE_GAP_KEYWORD3 4
+#define SCE_GAP_KEYWORD4 5
+#define SCE_GAP_STRING 6
+#define SCE_GAP_CHAR 7
+#define SCE_GAP_OPERATOR 8
+#define SCE_GAP_COMMENT 9
+#define SCE_GAP_NUMBER 10
+#define SCE_GAP_STRINGEOL 11
+#define SCE_PLM_DEFAULT 0
+#define SCE_PLM_COMMENT 1
+#define SCE_PLM_STRING 2
+#define SCE_PLM_NUMBER 3
+#define SCE_PLM_IDENTIFIER 4
+#define SCE_PLM_OPERATOR 5
+#define SCE_PLM_CONTROL 6
+#define SCE_PLM_KEYWORD 7
+#define SCE_4GL_DEFAULT 0
+#define SCE_4GL_NUMBER 1
+#define SCE_4GL_WORD 2
+#define SCE_4GL_STRING 3
+#define SCE_4GL_CHARACTER 4
+#define SCE_4GL_PREPROCESSOR 5
+#define SCE_4GL_OPERATOR 6
+#define SCE_4GL_IDENTIFIER 7
+#define SCE_4GL_BLOCK 8
+#define SCE_4GL_END 9
+#define SCE_4GL_COMMENT1 10
+#define SCE_4GL_COMMENT2 11
+#define SCE_4GL_COMMENT3 12
+#define SCE_4GL_COMMENT4 13
+#define SCE_4GL_COMMENT5 14
+#define SCE_4GL_COMMENT6 15
+#define SCE_4GL_DEFAULT_ 16
+#define SCE_4GL_NUMBER_ 17
+#define SCE_4GL_WORD_ 18
+#define SCE_4GL_STRING_ 19
+#define SCE_4GL_CHARACTER_ 20
+#define SCE_4GL_PREPROCESSOR_ 21
+#define SCE_4GL_OPERATOR_ 22
+#define SCE_4GL_IDENTIFIER_ 23
+#define SCE_4GL_BLOCK_ 24
+#define SCE_4GL_END_ 25
+#define SCE_4GL_COMMENT1_ 26
+#define SCE_4GL_COMMENT2_ 27
+#define SCE_4GL_COMMENT3_ 28
+#define SCE_4GL_COMMENT4_ 29
+#define SCE_4GL_COMMENT5_ 30
+#define SCE_4GL_COMMENT6_ 31
+#define SCE_ABAQUS_DEFAULT 0
+#define SCE_ABAQUS_COMMENT 1
+#define SCE_ABAQUS_COMMENTBLOCK 2
+#define SCE_ABAQUS_NUMBER 3
+#define SCE_ABAQUS_STRING 4
+#define SCE_ABAQUS_OPERATOR 5
+#define SCE_ABAQUS_WORD 6
+#define SCE_ABAQUS_PROCESSOR 7
+#define SCE_ABAQUS_COMMAND 8
+#define SCE_ABAQUS_SLASHCOMMAND 9
+#define SCE_ABAQUS_STARCOMMAND 10
+#define SCE_ABAQUS_ARGUMENT 11
+#define SCE_ABAQUS_FUNCTION 12
+#define SCE_ASY_DEFAULT 0
+#define SCE_ASY_COMMENT 1
+#define SCE_ASY_COMMENTLINE 2
+#define SCE_ASY_NUMBER 3
+#define SCE_ASY_WORD 4
+#define SCE_ASY_STRING 5
+#define SCE_ASY_CHARACTER 6
+#define SCE_ASY_OPERATOR 7
+#define SCE_ASY_IDENTIFIER 8
+#define SCE_ASY_STRINGEOL 9
+#define SCE_ASY_COMMENTLINEDOC 10
+#define SCE_ASY_WORD2 11
+#define SCE_R_DEFAULT 0
+#define SCE_R_COMMENT 1
+#define SCE_R_KWORD 2
+#define SCE_R_BASEKWORD 3
+#define SCE_R_OTHERKWORD 4
+#define SCE_R_NUMBER 5
+#define SCE_R_STRING 6
+#define SCE_R_STRING2 7
+#define SCE_R_OPERATOR 8
+#define SCE_R_IDENTIFIER 9
+#define SCE_R_INFIX 10
+#define SCE_R_INFIXEOL 11
 #define SCLEX_ASP 29
 #define SCLEX_PHP 30
 //--Autogenerated -- end of section automatically generated from Scintilla.iface
Index: src/sdk/wxscintilla/src/scintilla/include/Accessor.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/Accessor.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/Accessor.h	(working copy)
@@ -75,4 +75,5 @@
 	virtual void ColourTo(unsigned int pos, int chAttr)=0;
 	virtual void SetLevel(int line, int level)=0;
 	virtual int IndentAmount(int line, int *flags, PFNIsCommentLeader pfnIsCommentLeader = 0)=0;
+	virtual void IndicatorFill(int start, int end, int indicator, int value)=0;
 };
Index: src/sdk/wxscintilla/src/scintilla/include/Scintilla.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/Scintilla.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/Scintilla.h	(working copy)
@@ -118,7 +118,10 @@
 #define SC_MARK_ARROWS 24
 #define SC_MARK_PIXMAP 25
 #define SC_MARK_FULLRECT 26
+#define SC_MARK_LEFTRECT 27
 #define SC_MARK_CHARACTER 10000
+#define SC_MARKNUM_CHANGEUNSAVED 23
+#define SC_MARKNUM_CHANGESAVED 24
 #define SC_MARKNUM_FOLDEREND 25
 #define SC_MARKNUM_FOLDEROPENMID 26
 #define SC_MARKNUM_FOLDERMIDTAIL 27
@@ -126,7 +129,7 @@
 #define SC_MARKNUM_FOLDERSUB 29
 #define SC_MARKNUM_FOLDER 30
 #define SC_MARKNUM_FOLDEROPEN 31
-#define SC_MASK_FOLDERS 0xFE000000
+#define SC_MASK_FOLDERS 0xFF800000
 #define SCI_MARKERDEFINE 2040
 #define SCI_MARKERSETFORE 2041
 #define SCI_MARKERSETBACK 2042
@@ -143,6 +146,7 @@
 #define SC_MARGIN_NUMBER 1
 #define SC_MARGIN_BACK 2
 #define SC_MARGIN_FORE 3
+#define SC_MARGIN_CHANGED 4
 #define SCI_SETMARGINTYPEN 2240
 #define SCI_GETMARGINTYPEN 2241
 #define SCI_SETMARGINWIDTHN 2242
@@ -159,7 +163,7 @@
 #define STYLE_INDENTGUIDE 37
 #define STYLE_CALLTIP 38
 #define STYLE_LASTPREDEFINED 39
-#define STYLE_MAX 127
+#define STYLE_MAX 255
 #define SC_CHARSET_ANSI 0
 #define SC_CHARSET_DEFAULT 1
 #define SC_CHARSET_BALTIC 186
@@ -194,6 +198,19 @@
 #define SC_CASE_MIXED 0
 #define SC_CASE_UPPER 1
 #define SC_CASE_LOWER 2
+#define SCI_STYLEGETFORE 2481
+#define SCI_STYLEGETBACK 2482
+#define SCI_STYLEGETBOLD 2483
+#define SCI_STYLEGETITALIC 2484
+#define SCI_STYLEGETSIZE 2485
+#define SCI_STYLEGETFONT 2486
+#define SCI_STYLEGETEOLFILLED 2487
+#define SCI_STYLEGETUNDERLINE 2488
+#define SCI_STYLEGETCASE 2489
+#define SCI_STYLEGETCHARACTERSET 2490
+#define SCI_STYLEGETVISIBLE 2491
+#define SCI_STYLEGETCHANGEABLE 2492
+#define SCI_STYLEGETHOTSPOT 2493
 #define SCI_STYLESETCASE 2060
 #define SCI_STYLESETCHARACTERSET 2066
 #define SCI_STYLESETHOTSPOT 2409
@@ -201,6 +218,8 @@
 #define SCI_SETSELBACK 2068
 #define SCI_GETSELALPHA 2477
 #define SCI_SETSELALPHA 2478
+#define SCI_GETSELEOLFILLED 2479
+#define SCI_SETSELEOLFILLED 2480
 #define SCI_SETCARETFORE 2069
 #define SCI_ASSIGNCMDKEY 2070
 #define SCI_CLEARCMDKEY 2071
@@ -222,7 +241,6 @@
 #define INDIC_ROUNDBOX 7
 #define INDIC_MAX 31
 #define INDIC_CONTAINER 8
-#define INDIC_HIGHLIGHT 31 // please change also in wxscintilla.h !! I use INDIC_MAX here, to avoid conflicts with future versions of Scintilla
 #define INDIC0_MASK 0x20
 #define INDIC1_MASK 0x40
 #define INDIC2_MASK 0x80
@@ -231,6 +249,8 @@
 #define SCI_INDICGETSTYLE 2081
 #define SCI_INDICSETFORE 2082
 #define SCI_INDICGETFORE 2083
+#define SCI_INDICSETUNDER 2510
+#define SCI_INDICGETUNDER 2511
 #define SCI_SETWHITESPACEFORE 2084
 #define SCI_SETWHITESPACEBACK 2085
 #define SCI_SETSTYLEBITS 2090
@@ -282,6 +302,10 @@
 #define SCI_GETCOLUMN 2129
 #define SCI_SETHSCROLLBAR 2130
 #define SCI_GETHSCROLLBAR 2131
+#define SC_IV_NONE 0
+#define SC_IV_REAL 1
+#define SC_IV_LOOKFORWARD 2
+#define SC_IV_LOOKBOTH 3
 #define SCI_SETINDENTATIONGUIDES 2132
 #define SCI_GETINDENTATIONGUIDES 2133
 #define SCI_SETHIGHLIGHTGUIDE 2134
@@ -432,6 +456,8 @@
 #define SCI_GETLAYOUTCACHE 2273
 #define SCI_SETSCROLLWIDTH 2274
 #define SCI_GETSCROLLWIDTH 2275
+#define SCI_SETSCROLLWIDTHTRACKING 2516
+#define SCI_GETSCROLLWIDTHTRACKING 2517
 #define SCI_TEXTWIDTH 2276
 #define SCI_SETENDATLASTLINE 2277
 #define SCI_GETENDATLASTLINE 2278
@@ -483,6 +509,7 @@
 #define SCI_ZOOMOUT 2334
 #define SCI_DELWORDLEFT 2335
 #define SCI_DELWORDRIGHT 2336
+#define SCI_DELWORDRIGHTEND 2518
 #define SCI_LINECUT 2337
 #define SCI_LINEDELETE 2338
 #define SCI_LINETRANSPOSE 2339
@@ -568,9 +595,13 @@
 #define SCI_SETPRINTWRAPMODE 2406
 #define SCI_GETPRINTWRAPMODE 2407
 #define SCI_SETHOTSPOTACTIVEFORE 2410
+#define SCI_GETHOTSPOTACTIVEFORE 2494
 #define SCI_SETHOTSPOTACTIVEBACK 2411
+#define SCI_GETHOTSPOTACTIVEBACK 2495
 #define SCI_SETHOTSPOTACTIVEUNDERLINE 2412
+#define SCI_GETHOTSPOTACTIVEUNDERLINE 2496
 #define SCI_SETHOTSPOTSINGLELINE 2421
+#define SCI_GETHOTSPOTSINGLELINE 2497
 #define SCI_PARADOWN 2413
 #define SCI_PARADOWNEXTEND 2414
 #define SCI_PARAUP 2415
@@ -622,6 +653,23 @@
 #define SC_ALPHA_NOALPHA 256
 #define SCI_SETCARETLINEBACKALPHA 2470
 #define SCI_GETCARETLINEBACKALPHA 2471
+#define CARETSTYLE_INVISIBLE 0
+#define CARETSTYLE_LINE 1
+#define CARETSTYLE_BLOCK 2
+#define SCI_SETCARETSTYLE 2512
+#define SCI_GETCARETSTYLE 2513
+#define SCI_SETINDICATORCURRENT 2500
+#define SCI_GETINDICATORCURRENT 2501
+#define SCI_SETINDICATORVALUE 2502
+#define SCI_GETINDICATORVALUE 2503
+#define SCI_INDICATORFILLRANGE 2504
+#define SCI_INDICATORCLEARRANGE 2505
+#define SCI_INDICATORALLONFOR 2506
+#define SCI_INDICATORVALUEAT 2507
+#define SCI_INDICATORSTART 2508
+#define SCI_INDICATOREND 2509
+#define SCI_SETPOSITIONCACHE 2514
+#define SCI_GETPOSITIONCACHE 2515
 #define SCI_STARTRECORD 3001
 #define SCI_STOPRECORD 3002
 #define SCI_SETLEXER 4001
@@ -649,7 +697,10 @@
 #define SC_MOD_BEFOREINSERT 0x400
 #define SC_MOD_BEFOREDELETE 0x800
 #define SC_MULTILINEUNDOREDO 0x1000
-#define SC_MODEVENTMASKALL 0x1FFF
+#define SC_STARTACTION 0x2000
+#define SC_MOD_CHANGEINDICATOR 0x4000
+#define SC_MOD_CHANGELINESTATE 0x8000
+#define SC_MODEVENTMASKALL 0xFFFF
 #define SCEN_CHANGE 768
 #define SCEN_SETFOCUS 512
 #define SCEN_KILLFOCUS 256
@@ -670,6 +721,9 @@
 #define SCK_ADD 310
 #define SCK_SUBTRACT 311
 #define SCK_DIVIDE 312
+#define SCK_WIN 313
+#define SCK_RWIN 314
+#define SCK_MENU 315
 #define SCMOD_NORM 0
 #define SCMOD_SHIFT 1
 #define SCMOD_CTRL 2
@@ -696,12 +750,18 @@
 #define SCN_HOTSPOTDOUBLECLICK 2020
 #define SCN_CALLTIPCLICK 2021
 #define SCN_AUTOCSELECTION 2022
+#define SCN_INDICATORCLICK 2023
+#define SCN_INDICATORRELEASE 2024
 //--Autogenerated -- end of section automatically generated from Scintilla.iface
 
 // These structures are defined to be exactly the same shape as the Win32
 // CHARRANGE, TEXTRANGE, FINDTEXTEX, FORMATRANGE, and NMHDR structs.
 // So older code that treats Scintilla as a RichEdit will work.
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 struct CharacterRange {
 	long cpMin;
 	long cpMax;
@@ -763,6 +823,10 @@
 	int y;		// SCN_DWELLSTART, SCN_DWELLEND
 };
 
+#ifdef SCI_NAMESPACE
+}
+#endif
+
 // Deprecation section listing all API features that are deprecated and will
 // will be removed completely in a future version.
 // To enable these features define INCLUDE_DEPRECATED_FEATURES
Index: src/sdk/wxscintilla/src/scintilla/include/Scintilla.iface
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/Scintilla.iface	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/Scintilla.iface	(working copy)
@@ -268,11 +268,14 @@
 val SC_MARK_ARROWS=24
 val SC_MARK_PIXMAP=25
 val SC_MARK_FULLRECT=26
+val SC_MARK_LEFTRECT=27
 
 val SC_MARK_CHARACTER=10000
 
 enu MarkerOutline=SC_MARKNUM_
-# Markers used for outlining column.
+# Markers used for outlining and changed column.
+val SC_MARKNUM_CHANGEUNSAVED=23
+val SC_MARKNUM_CHANGESAVED=24
 val SC_MARKNUM_FOLDEREND=25
 val SC_MARKNUM_FOLDEROPENMID=26
 val SC_MARKNUM_FOLDERMIDTAIL=27
@@ -281,7 +284,7 @@
 val SC_MARKNUM_FOLDER=30
 val SC_MARKNUM_FOLDEROPEN=31
 
-val SC_MASK_FOLDERS=0xFE000000
+val SC_MASK_FOLDERS=0xFF800000
 
 # Set the symbol used for a particular marker number.
 fun void MarkerDefine=2040(int markerNumber, int markerSymbol)
@@ -324,6 +327,7 @@
 val SC_MARGIN_NUMBER=1
 val SC_MARGIN_BACK=2
 val SC_MARGIN_FORE=3
+val SC_MARGIN_CHANGED=4
 
 # Set a margin to be either numeric or symbolic.
 set void SetMarginTypeN=2240(int margin, int marginType)
@@ -360,7 +364,7 @@
 val STYLE_INDENTGUIDE=37
 val STYLE_CALLTIP=38
 val STYLE_LASTPREDEFINED=39
-val STYLE_MAX=127
+val STYLE_MAX=255
 
 # Character set identifiers are used in StyleSetCharacterSet.
 # The values are the same as the Windows *_CHARSET values.
@@ -421,6 +425,48 @@
 val SC_CASE_MIXED=0
 val SC_CASE_UPPER=1
 val SC_CASE_LOWER=2
+
+# Get the foreground colour of a style.
+get colour StyleGetFore=2481(int style,)
+
+# Get the background colour of a style.
+get colour StyleGetBack=2482(int style,)
+
+# Get is a style bold or not.
+get bool StyleGetBold=2483(int style,)
+
+# Get is a style italic or not.
+get bool StyleGetItalic=2484(int style,)
+
+# Get the size of characters of a style.
+get int StyleGetSize=2485(int style,)
+
+# Get the font of a style.
+# Returns the length of the fontName
+fun int StyleGetFont=2486(int style, stringresult fontName)
+
+# Get is a style to have its end of line filled or not.
+get bool StyleGetEOLFilled=2487(int style,)
+
+# Get is a style underlined or not.
+get bool StyleGetUnderline=2488(int style,)
+
+# Get is a style mixed case, or to force upper or lower case.
+get int StyleGetCase=2489(int style,)
+
+# Get the character get of the font in a style.
+get int StyleGetCharacterSet=2490(int style,)
+
+# Get is a style visible or not.
+get bool StyleGetVisible=2491(int style,)
+
+# Get is a style changeable or not (read only).
+# Experimental feature, currently buggy.
+get bool StyleGetChangeable=2492(int style,)
+
+# Get is a style a hotspot or not.
+get bool StyleGetHotSpot=2493(int style,)
+
 # Set a style to be mixed case, or to force upper or lower case.
 set void StyleSetCase=2060(int style, int caseForce)
 
@@ -442,6 +488,12 @@
 # Set the alpha of the selection.
 set void SetSelAlpha=2478(int alpha,)
 
+# Is the selection end of line filled?
+get bool GetSelEOLFilled=2479(,)
+
+# Set the selection to have its end of line filled or not.
+set void SetSelEOLFilled=2480(bool filled,)
+
 # Set the foreground colour of the caret.
 set void SetCaretFore=2069(colour fore,)
 
@@ -477,8 +529,8 @@
 # End a sequence of actions that is undone and redone as a unit.
 fun void EndUndoAction=2079(,)
 
+# Indicator style enumeration and some constants
 enu IndicatorStyle=INDIC_
-val INDIC_MAX=7
 val INDIC_PLAIN=0
 val INDIC_SQUIGGLE=1
 val INDIC_TT=2
@@ -487,6 +539,8 @@
 val INDIC_HIDDEN=5
 val INDIC_BOX=6
 val INDIC_ROUNDBOX=7
+val INDIC_MAX=31
+val INDIC_CONTAINER=8
 val INDIC0_MASK=0x20
 val INDIC1_MASK=0x40
 val INDIC2_MASK=0x80
@@ -504,6 +558,12 @@
 # Retrieve the foreground colour of an indicator.
 get colour IndicGetFore=2083(int indic,)
 
+# Set an indicator to draw under text or over(default).
+set void IndicSetUnder=2510(int indic, bool under)
+
+# Retrieve whether indicator drawn under or over text.
+get bool IndicGetUnder=2511(int indic,)
+
 # Set the foreground colour of all whitespace and whether to use this setting.
 fun void SetWhitespaceFore=2084(bool useSetting, colour fore)
 
@@ -671,11 +731,17 @@
 # Is the horizontal scroll bar visible?
 get bool GetHScrollBar=2131(,)
 
+enu IndentView=SC_IV_
+val SC_IV_NONE=0
+val SC_IV_REAL=1
+val SC_IV_LOOKFORWARD=2
+val SC_IV_LOOKBOTH=3
+
 # Show or hide indentation guides.
-set void SetIndentationGuides=2132(bool show,)
+set void SetIndentationGuides=2132(int indentView,)
 
 # Are the indentation guides visible?
-get bool GetIndentationGuides=2133(,)
+get int GetIndentationGuides=2133(,)
 
 # Set the highlighted indentation guide column.
 # 0 = no highlighted guide.
@@ -1087,6 +1153,12 @@
 # Retrieve the document width assumed for scrolling.
 get int GetScrollWidth=2275(,)
 
+# Sets whether the maximum width line displayed is used to set scroll width.
+set void SetScrollWidthTracking=2516(bool tracking,)
+
+# Retrieve whether the scroll width tracks wide lines.
+get bool GetScrollWidthTracking=2517(,)
+
 # Measure the pixel width of some text in a particular style.
 # NUL terminated text argument.
 # Does not handle tab or control characters.
@@ -1250,6 +1322,9 @@
 # Delete the word to the right of the caret.
 fun void DelWordRight=2336(,)
 
+# Delete the word to the right of the caret, but not the trailing non-word characters.
+fun void DelWordRightEnd=2518(,)
+
 # Cut the line containing the caret.
 fun void LineCut=2337(,)
 
@@ -1311,7 +1386,7 @@
 # Move the caret inside current view if it's not there already.
 fun void MoveCaretInsideView=2401(,)
 
-# How many characters are on a line, not including end of line characters?
+# How many characters are on a line, including end of line characters?
 fun int LineLength=2350(int line,)
 
 # Highlight the characters at two positions.
@@ -1505,15 +1580,27 @@
 # Set a fore colour for active hotspots.
 set void SetHotspotActiveFore=2410(bool useSetting, colour fore)
 
+# Get the fore colour for active hotspots.
+get colour GetHotspotActiveFore=2494(,)
+
 # Set a back colour for active hotspots.
 set void SetHotspotActiveBack=2411(bool useSetting, colour back)
 
+# Get the back colour for active hotspots.
+get colour GetHotspotActiveBack=2495(,)
+
 # Enable / Disable underlining active hotspots.
 set void SetHotspotActiveUnderline=2412(bool underline,)
 
+# Get whether underlining for active hotspots.
+get bool GetHotspotActiveUnderline=2496(,)
+
 # Limit hotspots to single line so hotspots on two lines don't merge.
 set void SetHotspotSingleLine=2421(bool singleLine,)
 
+# Get the HotspotSingleLine property
+get bool GetHotspotSingleLine=2497(,)
+
 # Move caret between paragraphs (delimited by empty lines).
 fun void ParaDown=2413(,)
 fun void ParaDownExtend=2414(,)
@@ -1666,6 +1753,53 @@
 # Get the background alpha of the caret line.
 get int GetCaretLineBackAlpha=2471(,)
 
+enu CaretStyle=CARETSTYLE_
+val CARETSTYLE_INVISIBLE=0
+val CARETSTYLE_LINE=1
+val CARETSTYLE_BLOCK=2
+
+# Set the style of the caret to be drawn.
+set void SetCaretStyle=2512(int caretStyle,)
+
+# Returns the current style of the caret.
+get int GetCaretStyle=2513(,)
+
+# Set the indicator used for IndicatorFillRange and IndicatorClearRange
+set void SetIndicatorCurrent=2500(int indicator,)
+
+# Get the current indicator
+get int GetIndicatorCurrent=2501(,)
+
+# Set the value used for IndicatorFillRange
+set void SetIndicatorValue=2502(int value,)
+
+# Get the current indicator vaue
+get int GetIndicatorValue=2503(,)
+
+# Turn a indicator on over a range.
+fun void IndicatorFillRange=2504(int position, int fillLength)
+
+# Turn a indicator off over a range.
+fun void IndicatorClearRange=2505(int position, int clearLength)
+
+# Are any indicators present at position?
+fun int IndicatorAllOnFor=2506(int position,)
+
+# What value does a particular indicator have at at a position?
+fun int IndicatorValueAt=2507(int indicator, int position)
+
+# Where does a particular indicator start?
+fun int IndicatorStart=2508(int indicator, int position)
+
+# Where does a particular indicator end?
+fun int IndicatorEnd=2509(int indicator, int position)
+
+# Set number of entries in position cache
+set void SetPositionCache=2514(int size,)
+
+# How many entries are allocated to the position cache?
+get int GetPositionCache=2515(,)
+
 # Start notifying the container of all key presses and commands.
 fun void StartRecord=3001(,)
 
@@ -1728,7 +1862,10 @@
 val SC_MOD_BEFOREINSERT=0x400
 val SC_MOD_BEFOREDELETE=0x800
 val SC_MULTILINEUNDOREDO=0x1000
-val SC_MODEVENTMASKALL=0x1FFF
+val SC_STARTACTION=0x2000
+val SC_MOD_CHANGEINDICATOR=0x4000
+val SC_MOD_CHANGELINESTATE=0x8000
+val SC_MODEVENTMASKALL=0xFFFF
 
 # For compatibility, these go through the COMMAND notification rather than NOTIFY
 # and should have had exactly the same values as the EN_* constants.
@@ -1760,6 +1897,9 @@
 val SCK_ADD=310
 val SCK_SUBTRACT=311
 val SCK_DIVIDE=312
+val SCK_WIN=313
+val SCK_RWIN=314
+val SCK_MENU=315
 
 enu KeyMod=SCMOD_
 val SCMOD_NORM=0
@@ -1847,6 +1987,14 @@
 val SCLEX_INNOSETUP=76
 val SCLEX_OPAL=77
 val SCLEX_SPICE=78
+val SCLEX_D=79
+val SCLEX_CMAKE=80
+val SCLEX_GAP=81
+val SCLEX_PLM=82
+val SCLEX_PROGRESS=83
+val SCLEX_ABAQUS=84
+val SCLEX_ASYMPTOTE=85
+val SCLEX_R=86
 
 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
 # value assigned in sequence from SCLEX_AUTOMATIC+1.
@@ -1893,6 +2041,26 @@
 val SCE_C_COMMENTDOCKEYWORD=17
 val SCE_C_COMMENTDOCKEYWORDERROR=18
 val SCE_C_GLOBALCLASS=19
+# Lexical states for SCLEX_D
+lex D=SCLEX_D SCE_D_
+val SCE_D_DEFAULT=0
+val SCE_D_COMMENT=1
+val SCE_D_COMMENTLINE=2
+val SCE_D_COMMENTDOC=3
+val SCE_D_COMMENTNESTED=4
+val SCE_D_NUMBER=5
+val SCE_D_WORD=6
+val SCE_D_WORD2=7
+val SCE_D_WORD3=8
+val SCE_D_TYPEDEF=9
+val SCE_D_STRING=10
+val SCE_D_STRINGEOL=11
+val SCE_D_CHARACTER=12
+val SCE_D_OPERATOR=13
+val SCE_D_IDENTIFIER=14
+val SCE_D_COMMENTLINEDOC=15
+val SCE_D_COMMENTDOCKEYWORD=16
+val SCE_D_COMMENTDOCKEYWORDERROR=17
 # Lexical states for SCLEX_TCL
 lex TCL=SCLEX_TCL SCE_TCL_
 val SCE_TCL_DEFAULT=0
@@ -2079,6 +2247,9 @@
 val SCE_PL_STRING_QR=29
 val SCE_PL_STRING_QW=30
 val SCE_PL_POD_VERB=31
+val SCE_PL_SUB_PROTOTYPE=40
+val SCE_PL_FORMAT_IDENT=41
+val SCE_PL_FORMAT=42
 # Lexical states for SCLEX_RUBY
 lex Ruby=SCLEX_RUBY SCE_RB_
 val SCE_RB_DEFAULT=0
@@ -2198,6 +2369,7 @@
 val SCE_ERR_ABSF=18
 val SCE_ERR_TIDY=19
 val SCE_ERR_JAVA_STACK=20
+val SCE_ERR_VALUE=21
 # Lexical states for SCLEX_BATCH
 lex Batch=SCLEX_BATCH SCE_BAT_
 val SCE_BAT_DEFAULT=0
@@ -2563,6 +2735,7 @@
 val SCE_YAML_DOCUMENT=6
 val SCE_YAML_TEXT=7
 val SCE_YAML_ERROR=8
+val SCE_YAML_OPERATOR=9
 # Lexical states for SCLEX_TEX
 lex TeX=SCLEX_TEX SCE_TEX_
 val SCE_TEX_DEFAULT=0
@@ -2812,6 +2985,7 @@
 val SCE_T3_USER1=17
 val SCE_T3_USER2=18
 val SCE_T3_USER3=19
+val SCE_T3_BRACE=20
 # Lexical states for SCLEX_REBOL
 lex Rebol=SCLEX_REBOL SCE_REBOL_
 val SCE_REBOL_DEFAULT=0
@@ -2968,6 +3142,124 @@
 val SCE_SPICE_DELIMITER=6
 val SCE_SPICE_VALUE=7
 val SCE_SPICE_COMMENTLINE=8
+# Lexical states for SCLEX_CMAKE
+lex CMAKE=SCLEX_CMAKE SCE_CMAKE_
+val SCE_CMAKE_DEFAULT=0
+val SCE_CMAKE_COMMENT=1
+val SCE_CMAKE_STRINGDQ=2
+val SCE_CMAKE_STRINGLQ=3
+val SCE_CMAKE_STRINGRQ=4
+val SCE_CMAKE_COMMANDS=5
+val SCE_CMAKE_PARAMETERS=6
+val SCE_CMAKE_VARIABLE=7
+val SCE_CMAKE_USERDEFINED=8
+val SCE_CMAKE_WHILEDEF=9
+val SCE_CMAKE_FOREACHDEF=10
+val SCE_CMAKE_IFDEFINEDEF=11
+val SCE_CMAKE_MACRODEF=12
+val SCE_CMAKE_STRINGVAR=13
+val SCE_CMAKE_NUMBER=14
+# Lexical states for SCLEX_GAP
+lex Gap=SCLEX_GAP SCE_GAP_
+val SCE_GAP_DEFAULT=0
+val SCE_GAP_IDENTIFIER=1
+val SCE_GAP_KEYWORD=2
+val SCE_GAP_KEYWORD2=3
+val SCE_GAP_KEYWORD3=4
+val SCE_GAP_KEYWORD4=5
+val SCE_GAP_STRING=6
+val SCE_GAP_CHAR=7
+val SCE_GAP_OPERATOR=8
+val SCE_GAP_COMMENT=9
+val SCE_GAP_NUMBER=10
+val SCE_GAP_STRINGEOL=11
+# Lexical state for SCLEX_PLM
+lex PLM=SCLEX_PLM SCE_PLM_
+val SCE_PLM_DEFAULT=0
+val SCE_PLM_COMMENT=1
+val SCE_PLM_STRING=2
+val SCE_PLM_NUMBER=3
+val SCE_PLM_IDENTIFIER=4
+val SCE_PLM_OPERATOR=5
+val SCE_PLM_CONTROL=6
+val SCE_PLM_KEYWORD=7
+# Lexical state for SCLEX_PROGRESS
+lex Progress=SCLEX_PROGRESS SCE_4GL_
+val SCE_4GL_DEFAULT=0
+val SCE_4GL_NUMBER=1
+val SCE_4GL_WORD=2
+val SCE_4GL_STRING=3
+val SCE_4GL_CHARACTER=4
+val SCE_4GL_PREPROCESSOR=5
+val SCE_4GL_OPERATOR=6
+val SCE_4GL_IDENTIFIER=7
+val SCE_4GL_BLOCK=8
+val SCE_4GL_END=9
+val SCE_4GL_COMMENT1=10
+val SCE_4GL_COMMENT2=11
+val SCE_4GL_COMMENT3=12
+val SCE_4GL_COMMENT4=13
+val SCE_4GL_COMMENT5=14
+val SCE_4GL_COMMENT6=15
+val SCE_4GL_DEFAULT_=16
+val SCE_4GL_NUMBER_=17
+val SCE_4GL_WORD_=18
+val SCE_4GL_STRING_=19
+val SCE_4GL_CHARACTER_=20
+val SCE_4GL_PREPROCESSOR_=21
+val SCE_4GL_OPERATOR_=22
+val SCE_4GL_IDENTIFIER_=23
+val SCE_4GL_BLOCK_=24
+val SCE_4GL_END_=25
+val SCE_4GL_COMMENT1_=26
+val SCE_4GL_COMMENT2_=27
+val SCE_4GL_COMMENT3_=28
+val SCE_4GL_COMMENT4_=29
+val SCE_4GL_COMMENT5_=30
+val SCE_4GL_COMMENT6_=31
+# Lexical states for SCLEX_ABAQUS
+lex ABAQUS=SCLEX_ABAQUS SCE_ABAQUS_
+val SCE_ABAQUS_DEFAULT=0
+val SCE_ABAQUS_COMMENT=1
+val SCE_ABAQUS_COMMENTBLOCK=2
+val SCE_ABAQUS_NUMBER=3
+val SCE_ABAQUS_STRING=4
+val SCE_ABAQUS_OPERATOR=5
+val SCE_ABAQUS_WORD=6
+val SCE_ABAQUS_PROCESSOR=7
+val SCE_ABAQUS_COMMAND=8
+val SCE_ABAQUS_SLASHCOMMAND=9
+val SCE_ABAQUS_STARCOMMAND=10
+val SCE_ABAQUS_ARGUMENT=11
+val SCE_ABAQUS_FUNCTION=12
+# Lexical states for SCLEX_ASYMPTOTE
+lex Asymptote=SCLEX_ASYMPTOTE SCE_ASY_
+val SCE_ASY_DEFAULT=0
+val SCE_ASY_COMMENT=1
+val SCE_ASY_COMMENTLINE=2
+val SCE_ASY_NUMBER=3
+val SCE_ASY_WORD=4
+val SCE_ASY_STRING=5
+val SCE_ASY_CHARACTER=6
+val SCE_ASY_OPERATOR=7
+val SCE_ASY_IDENTIFIER=8
+val SCE_ASY_STRINGEOL=9
+val SCE_ASY_COMMENTLINEDOC=10
+val SCE_ASY_WORD2=11
+# Lexical states for SCLEX_R
+lex R=SCLEX_R SCE_R_
+val SCE_R_DEFAULT=0
+val SCE_R_COMMENT=1
+val SCE_R_KWORD=2
+val SCE_R_BASEKWORD=3
+val SCE_R_OTHERKWORD=4
+val SCE_R_NUMBER=5
+val SCE_R_STRING=6
+val SCE_R_STRING2=7
+val SCE_R_OPERATOR=8
+val SCE_R_IDENTIFIER=9
+val SCE_R_INFIX=10
+val SCE_R_INFIXEOL=11
 
 # Events
 
@@ -2994,6 +3286,8 @@
 evt void HotSpotDoubleClick=2020(int modifiers, int position)
 evt void CallTipClick=2021(int position)
 evt void AutoCSelection=2022(string text)
+evt void IndicatorClick=2023(int modifiers, int position)
+evt void IndicatorRelease=2024(int modifiers, int position)
 
 cat Deprecated
 
Index: src/sdk/wxscintilla/src/scintilla/include/Platform.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/Platform.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/Platform.h	(working copy)
@@ -16,6 +16,7 @@
 
 #define PLAT_GTK 0
 #define PLAT_GTK_WIN32 0
+#define PLAT_MACOSX 0
 #define PLAT_WIN 0
 #define PLAT_WX  0
 #define PLAT_FOX 0
@@ -27,26 +28,29 @@
 #elif defined(__WX__)
 #undef PLAT_WX
 #define PLAT_WX  1
-#undef PLAT_WIN
-#define PLAT_WIN 1
 
 #elif defined(GTK)
 #undef PLAT_GTK
 #define PLAT_GTK 1
-#undef PLAT_WX
-#define PLAT_WX  1
 
 #ifdef _MSC_VER
 #undef PLAT_GTK_WIN32
 #define PLAT_GTK_WIN32 1
 #endif
 
+#elif defined(MACOSX)
+#undef PLAT_MACOSX
+#define PLAT_MACOSX 1
+
 #else
 #undef PLAT_WIN
 #define PLAT_WIN 1
 
 #endif
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
 
 // Underlying the implementation of the platform classes are platform specific types.
 // Sometimes these need to be passed around by client code so they are defined here
@@ -118,6 +122,9 @@
 	}
 	int Width() { return right - left; }
 	int Height() { return bottom - top; }
+	bool Empty() { 
+		return (Height() <= 0) || (Width() <= 0);
+	}
 };
 
 /**
@@ -364,9 +371,23 @@
 class Window {
 protected:
 	WindowID id;
+#if PLAT_MACOSX
+	void *windowRef;
+	void *control;
+#endif
 public:
-	Window() : id(0), cursorLast(cursorInvalid) {}
-	Window(const Window &source) : id(source.id), cursorLast(cursorInvalid) {}
+	Window() : id(0), cursorLast(cursorInvalid) {
+#if PLAT_MACOSX
+	  windowRef = 0;
+	  control = 0;
+#endif
+	}
+	Window(const Window &source) : id(source.id), cursorLast(cursorInvalid) {
+#if PLAT_MACOSX
+	  windowRef = 0;
+	  control = 0;
+#endif
+	}
 	virtual ~Window();
 	Window &operator=(WindowID id_) {
 		id = id_;
@@ -387,6 +408,11 @@
 	enum Cursor { cursorInvalid, cursorText, cursorArrow, cursorUp, cursorWait, cursorHoriz, cursorVert, cursorReverseArrow, cursorHand };
 	void SetCursor(Cursor curs);
 	void SetTitle(const char *s);
+	PRectangle GetMonitorRect(Point pt);
+#if PLAT_MACOSX
+	void SetWindow(void *ref) { windowRef = ref; };
+	void SetControl(void *_control) { control = _control; };
+#endif
 private:
 	Cursor cursorLast;
 };
@@ -510,9 +536,17 @@
 #ifdef  NDEBUG
 #define PLATFORM_ASSERT(c) ((void)0)
 #else
+#ifdef SCI_NAMESPACE
+#define PLATFORM_ASSERT(c) ((c) ? (void)(0) : Scintilla::Platform::Assert(#c, __FILE__, __LINE__))
+#else
 #define PLATFORM_ASSERT(c) ((c) ? (void)(0) : Platform::Assert(#c, __FILE__, __LINE__))
 #endif
+#endif
 
+#ifdef SCI_NAMESPACE
+}
+#endif
+
 // Shut up annoying Visual C++ warnings:
 #ifdef _MSC_VER
 #pragma warning(disable: 4244 4309 4514 4710)
Index: src/sdk/wxscintilla/src/scintilla/include/KeyWords.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/include/KeyWords.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/include/KeyWords.h	(working copy)
@@ -5,6 +5,10 @@
 // Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 typedef void (*LexerFunction)(unsigned int startPos, int lengthDoc, int initStyle,
                   WordList *keywordlists[], Accessor &styler);
                   
@@ -51,6 +55,10 @@
 	static const LexerModule *Find(const char *languageName);
 };
 
+#ifdef SCI_NAMESPACE
+}
+#endif
+
 /**
  * Check if a character is a space.
  * This is ASCII specific but is safe with chars >= 0x80.
Index: src/sdk/wxscintilla/src/scintilla/version.txt
===================================================================
--- src/sdk/wxscintilla/src/scintilla/version.txt	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/version.txt	(revision 0)
@@ -0,0 +1 @@
+175
Index: src/sdk/wxscintilla/src/scintilla/src/LineMarker.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LineMarker.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LineMarker.h	(working copy)
@@ -8,6 +8,10 @@
 #ifndef LINEMARKER_H
 #define LINEMARKER_H
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 /**
  */
 class LineMarker {
@@ -51,4 +55,8 @@
 	void Draw(Surface *surface, PRectangle &rc, Font &fontForCharacter);
 };
 
+#ifdef SCI_NAMESPACE
+}
 #endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/LexLisp.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexLisp.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexLisp.cxx	(working copy)
@@ -21,6 +21,10 @@
 #include "SciLexer.h"
 #include "StyleContext.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 #define SCE_LISP_CHARACTER 29
 #define SCE_LISP_MACRO 30
 #define SCE_LISP_MACRO_DISPATCH 31
Index: src/sdk/wxscintilla/src/scintilla/src/LexErlang.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexErlang.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexErlang.cxx	(working copy)
@@ -21,6 +21,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 /*
    TODO:
    o  _Param should be a new lexical type
Index: src/sdk/wxscintilla/src/scintilla/src/LexEScript.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexEScript.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexEScript.cxx	(working copy)
@@ -19,6 +19,9 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
 
 
 static inline bool IsAWordChar(const int ch) {
Index: src/sdk/wxscintilla/src/scintilla/src/LexAVE.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexAVE.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexAVE.cxx	(working copy)
@@ -22,6 +22,9 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
 
 
 static inline bool IsAWordChar(const int ch) {
Index: src/sdk/wxscintilla/src/scintilla/src/LexFortran.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexFortran.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexFortran.cxx	(working copy)
@@ -19,6 +19,11 @@
 #include "KeyWords.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 /***********************************************/
 static inline bool IsAWordChar(const int ch) {
 	return (ch < 0x80) && (isalnum(ch) || ch == '_' || ch == '%');
Index: src/sdk/wxscintilla/src/scintilla/src/LexNsis.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexNsis.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexNsis.cxx	(working copy)
@@ -19,6 +19,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 /*
 // located in SciLexer.h
 #define SCLEX_NSIS 43
@@ -94,7 +98,7 @@
   return false;
 }
 
-static int NsisCmp( const char *s1, const char *s2, bool bIgnoreCase )
+static int NsisCmp( char *s1, char *s2, bool bIgnoreCase )
 {
   if( bIgnoreCase )
      return CompareCaseInsensitive( s1, s2);
@@ -141,7 +145,7 @@
 
   if( s[0] == '!' )
   {
-    if( NsisCmp(s, "!ifndef", bIgnoreCase) == 0 || NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 || NsisCmp(s, "!macro", bIgnoreCase ) == 0 )
+    if( NsisCmp(s, "!ifndef", bIgnoreCase) == 0 || NsisCmp(s, "!ifdef", bIgnoreCase ) == 0 || NsisCmp(s, "!if", bIgnoreCase ) == 0 || NsisCmp(s, "!macro", bIgnoreCase ) == 0 )
       newFoldlevel++;
     else if( NsisCmp(s, "!endif", bIgnoreCase) == 0 || NsisCmp(s, "!macroend", bIgnoreCase ) == 0 )
       newFoldlevel--;
@@ -195,6 +199,9 @@
   if( NsisCmp(s, "!else", bIgnoreCase ) == 0 ) // ||  NsisCmp(s, "!ifndef", bIgnoreCase) == 0 ||  NsisCmp(s, "!endif", bIgnoreCase) == 0 )
 		return SCE_NSIS_IFDEFINEDEF;
 
+  if( NsisCmp(s, "!if", bIgnoreCase ) == 0 )
+		return SCE_NSIS_IFDEFINEDEF;
+
   if( NsisCmp(s, "SectionGroup", bIgnoreCase) == 0 || NsisCmp(s, "SectionGroupEnd", bIgnoreCase) == 0 ) // Covers SectionGroup and SectionGroupEnd
     return SCE_NSIS_SECTIONGROUP;
 
Index: src/sdk/wxscintilla/src/scintilla/src/AutoComplete.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/AutoComplete.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/AutoComplete.h	(working copy)
@@ -8,6 +8,10 @@
 #ifndef AUTOCOMPLETE_H
 #define AUTOCOMPLETE_H
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 /**
  */
 class AutoComplete {
@@ -67,4 +71,8 @@
 	void Select(const char *word);
 };
 
+#ifdef SCI_NAMESPACE
+}
 #endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/DocumentAccessor.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/DocumentAccessor.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/DocumentAccessor.h	(working copy)
@@ -6,6 +6,10 @@
 // Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 class Document;
 
 /**
@@ -64,4 +68,9 @@
 	void ColourTo(unsigned int pos, int chAttr);
 	void SetLevel(int line, int level);
 	int IndentAmount(int line, int *flags, PFNIsCommentLeader pfnIsCommentLeader = 0);
+	void IndicatorFill(int start, int end, int indicator, int value);
 };
+
+#ifdef SCI_NAMESPACE
+}
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/LexTADS3.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexTADS3.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexTADS3.cxx	(working copy)
@@ -2,12 +2,8 @@
 /** @file LexTADS3.cxx
  ** Lexer for TADS3.
  **/
-/* Copyright 2005 by Michael Cartmell
- * Parts copyright 1998-2002 by Neil Hodgson <neilh@scintilla.org>
- * In particular FoldTADS3Doc is derived from FoldCppDoc
- * The License.txt file describes the conditions under which this software may
- * be distributed.
- */
+// Copyright 1998-2006 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
 
 /*
  * TADS3 is a language designed by Michael J. Roberts for the writing of text
@@ -50,516 +46,583 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static const int T3_SINGLE_QUOTE = 1;
 static const int T3_INT_EXPRESSION = 2;
+static const int T3_INT_EXPRESSION_IN_TAG = 4;
+static const int T3_HTML_SQUOTE = 8;
 
 static inline bool IsEOL(const int ch, const int chNext) {
-	return (ch == '\r' && chNext != '\n') || (ch == '\n');
+        return (ch == '\r' && chNext != '\n') || (ch == '\n');
 }
 
+/*
+ *   Test the current character to see if it's the START of an EOL sequence;
+ *   if so, skip ahead to the last character of the sequence and return true,
+ *   and if not just return false.  There are a few places where we want to
+ *   check to see if a newline sequence occurs at a particular point, but
+ *   where a caller expects a subroutine to stop only upon reaching the END
+ *   of a newline sequence (in particular, CR-LF on Windows).  That's why
+ *   IsEOL() above only returns true on CR if the CR isn't followed by an LF
+ *   - it doesn't want to admit that there's a newline until reaching the END
+ *   of the sequence.  We meet both needs by saying that there's a newline
+ *   when we see the CR in a CR-LF, but skipping the CR before returning so
+ *   that the caller's caller will see that we've stopped at the LF.  
+ */
+static inline bool IsEOLSkip(StyleContext &sc)
+{
+    /* test for CR-LF */
+    if (sc.ch == '\r' && sc.chNext == '\n')
+    {
+        /* got CR-LF - skip the CR and indicate that we're at a newline */
+        sc.Forward();
+        return true;
+    }
+
+    /* 
+     *   in other cases, we have at most a 1-character newline, so do the
+     *   normal IsEOL test 
+     */
+    return IsEOL(sc.ch, sc.chNext);
+}
+
 static inline bool IsASpaceOrTab(const int ch) {
-	return ch == ' ' || ch == '\t';
+        return ch == ' ' || ch == '\t';
 }
 
 static inline bool IsATADS3Operator(const int ch) {
-	return ch == '=' || ch == '{' || ch == '}' || ch == '(' || ch == ')'
-		|| ch == '[' || ch == ']' || ch == ',' || ch == ':' || ch == ';'
-		|| ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%'
-		|| ch == '?' || ch == '!' || ch == '<' || ch == '>' || ch == '|'
-		|| ch == '@' || ch == '&' || ch == '~';
+        return ch == '=' || ch == '{' || ch == '}' || ch == '(' || ch == ')'
+                || ch == '[' || ch == ']' || ch == ',' || ch == ':' || ch == ';'
+                || ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%'
+                || ch == '?' || ch == '!' || ch == '<' || ch == '>' || ch == '|'
+                || ch == '@' || ch == '&' || ch == '~';
 }
 
 static inline bool IsAWordChar(const int ch) {
-	return isalnum(ch) || ch == '_' || ch == '.';
+        return isalnum(ch) || ch == '_';
 }
 
 static inline bool IsAWordStart(const int ch) {
-	return isalpha(ch) || ch == '_';
+        return isalpha(ch) || ch == '_';
 }
 
 static inline bool IsAHexDigit(const int ch) {
-	int lch = tolower(ch);
-	return isdigit(lch) || lch == 'a' || lch == 'b' || lch == 'c'
-		|| lch == 'd' || lch == 'e' || lch == 'f';
+        int lch = tolower(ch);
+        return isdigit(lch) || lch == 'a' || lch == 'b' || lch == 'c'
+                || lch == 'd' || lch == 'e' || lch == 'f';
 }
 
 static inline bool IsAnHTMLChar(int ch) {
-	return isalnum(ch) || ch == '-' || ch == '_' || ch == '.';
+        return isalnum(ch) || ch == '-' || ch == '_' || ch == '.';
 }
 
 static inline bool IsADirectiveChar(int ch) {
-	return isalnum(ch) || isspace(ch) || ch == '-' || ch == '/';
+        return isalnum(ch) || isspace(ch) || ch == '-' || ch == '/';
 }
 
 static inline bool IsANumberStart(StyleContext &sc) {
-	return isdigit(sc.ch)
-		|| (!isdigit(sc.chPrev) && sc.ch == '.' && isdigit(sc.chNext));
+        return isdigit(sc.ch)
+                || (!isdigit(sc.chPrev) && sc.ch == '.' && isdigit(sc.chNext));
 }
 
 inline static void ColouriseTADS3Operator(StyleContext &sc) {
-	int initState = sc.state;
-	sc.SetState(SCE_T3_OPERATOR);
-	sc.ForwardSetState(initState);
+        int initState = sc.state;
+        int c = sc.ch;
+        sc.SetState(c == '{' || c == '}' ? SCE_T3_BRACE : SCE_T3_OPERATOR);
+        sc.ForwardSetState(initState);
 }
 
 static void ColouriseTADSHTMLString(StyleContext &sc, int &lineState) {
-	int endState = sc.state;
-	int chQuote = sc.ch;
-	if (endState == SCE_T3_HTML_STRING) {
-		if (lineState&T3_SINGLE_QUOTE) {
-			endState = SCE_T3_S_STRING;
-			chQuote = '"';
-		} else if (lineState&T3_INT_EXPRESSION) {
-			endState = SCE_T3_X_STRING;
-			chQuote = '\'';
-		} else {
-			endState = SCE_T3_D_STRING;
-			chQuote = '\'';
-		}
-	} else {
-		sc.SetState(SCE_T3_HTML_STRING);
-		sc.Forward();
-	}
-	int chString = chQuote == '"'? '\'': '"';
+        int endState = sc.state;
+        int chQuote = sc.ch;
+        int chString = (lineState & T3_SINGLE_QUOTE) ? '\'' : '"';
+        if (endState == SCE_T3_HTML_STRING) {
+                if (lineState&T3_SINGLE_QUOTE) {
+                        endState = SCE_T3_S_STRING;
+                        chString = '\'';
+                } else if (lineState&T3_INT_EXPRESSION) {
+                        endState = SCE_T3_X_STRING;
+                        chString = '"';
+                } else {
+                        endState = SCE_T3_HTML_DEFAULT;
+                        chString = '"';
+                }
+                chQuote = (lineState & T3_HTML_SQUOTE) ? '\'' : '"';
+        } else {
+                sc.SetState(SCE_T3_HTML_STRING);
+                sc.Forward();
+        }
+        if (chQuote == '"')
+                lineState &= ~T3_HTML_SQUOTE; 
+        else
+                lineState |= T3_HTML_SQUOTE;
 
-	while (sc.More()) {
-		if (IsEOL(sc.ch, sc.chNext)) {
-			return;
-		}
-		if (sc.ch == chQuote) {
-			sc.ForwardSetState(endState);
-			return;
-		}
-		if (sc.ch == chString) {
-			sc.SetState(endState);
-			return;
-		}
-		if (sc.Match('\\', static_cast<char>(chQuote))
-			|| sc.Match('\\', static_cast<char>(chString))) {
-			sc.Forward(2);
-		} else {
-			sc.Forward();
-		}
-	}
+        while (sc.More()) {
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        return;
+                }
+                if (sc.ch == chQuote) {
+                        sc.ForwardSetState(endState);
+                        return;
+                }
+                if (sc.Match('\\', static_cast<char>(chQuote))) {
+                        sc.Forward(2);
+                        sc.SetState(endState);
+                        return;
+                }
+                if (sc.ch == chString) {
+                        sc.SetState(SCE_T3_DEFAULT);
+                        return;
+                }
+
+                if (sc.Match('<', '<')) {
+                        lineState |= T3_INT_EXPRESSION | T3_INT_EXPRESSION_IN_TAG;
+                        sc.SetState(SCE_T3_X_DEFAULT);
+                        sc.Forward(2);
+                        return;
+                }
+
+                if (sc.Match('\\', static_cast<char>(chQuote))
+                        || sc.Match('\\', static_cast<char>(chString))
+                        || sc.Match('\\', '\\')) {
+                        sc.Forward(2);
+                } else {
+                        sc.Forward();
+                }
+        }
 }
 
 static void ColouriseTADS3HTMLTagStart(StyleContext &sc) {
-	sc.SetState(SCE_T3_HTML_TAG);
-	sc.Forward();
-	if (sc.ch == '/') {
-		sc.Forward();
-	}
-	while (IsAnHTMLChar(sc.ch)) {
-		sc.Forward();
-	}
+        sc.SetState(SCE_T3_HTML_TAG);
+        sc.Forward();
+        if (sc.ch == '/') {
+                sc.Forward();
+        }
+        while (IsAnHTMLChar(sc.ch)) {
+                sc.Forward();
+        }
 }
 
 static void ColouriseTADS3HTMLTag(StyleContext &sc, int &lineState) {
-	int endState = sc.state;
-	int chQuote = '"';
-	int chString = '\'';
-	switch (endState) {
-		case SCE_T3_S_STRING:
-			ColouriseTADS3HTMLTagStart(sc);
-			sc.SetState(SCE_T3_HTML_DEFAULT);
-			chQuote = '\'';
-			chString = '"';
-			break;
-		case SCE_T3_D_STRING:
-		case SCE_T3_X_STRING:
-			ColouriseTADS3HTMLTagStart(sc);
-			sc.SetState(SCE_T3_HTML_DEFAULT);
-			break;
-		case SCE_T3_HTML_DEFAULT:
-			if (lineState&T3_SINGLE_QUOTE) {
-				endState = SCE_T3_S_STRING;
-				chQuote = '\'';
-				chString = '"';
-			} else if (lineState&T3_INT_EXPRESSION) {
-				endState = SCE_T3_X_STRING;
-			} else {
-				endState = SCE_T3_D_STRING;
-			}
-			break;
-	}
+        int endState = sc.state;
+        int chQuote = '"';
+        int chString = '\'';
+        switch (endState) {
+                case SCE_T3_S_STRING:
+                        ColouriseTADS3HTMLTagStart(sc);
+                        sc.SetState(SCE_T3_HTML_DEFAULT);
+                        chQuote = '\'';
+                        chString = '"';
+                        break;
+                case SCE_T3_D_STRING:
+                case SCE_T3_X_STRING:
+                        ColouriseTADS3HTMLTagStart(sc);
+                        sc.SetState(SCE_T3_HTML_DEFAULT);
+                        break;
+                case SCE_T3_HTML_DEFAULT:
+                        if (lineState&T3_SINGLE_QUOTE) {
+                                endState = SCE_T3_S_STRING;
+                                chQuote = '\'';
+                                chString = '"';
+                        } else if (lineState&T3_INT_EXPRESSION) {
+                                endState = SCE_T3_X_STRING;
+                        } else {
+                                endState = SCE_T3_D_STRING;
+                        }
+                        break;
+        }
 
-	while (sc.More()) {
-		if (IsEOL(sc.ch, sc.chNext)) {
-			return;
-		}
-		if (sc.Match('/', '>')) {
-			sc.SetState(SCE_T3_HTML_TAG);
-			sc.Forward(2);
-			sc.SetState(endState);
-			return;
-		}
-		if (sc.ch == '>') {
-			sc.SetState(SCE_T3_HTML_TAG);
-			sc.ForwardSetState(endState);
-			return;
-		}
-		if (sc.ch == chQuote) {
-			sc.SetState(endState);
-			return;
-		}
-		if (sc.ch == chString) {
-			ColouriseTADSHTMLString(sc, lineState);
-		} else if (sc.ch == '=') {
-			ColouriseTADS3Operator(sc);
-		} else {
-			sc.Forward();
-		}
-	}
+        while (sc.More()) {
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        return;
+                }
+                if (sc.Match('/', '>')) {
+                        sc.SetState(SCE_T3_HTML_TAG);
+                        sc.Forward(2);
+                        sc.SetState(endState);
+                        return;
+                }
+                if (sc.ch == '>') {
+                        sc.SetState(SCE_T3_HTML_TAG);
+                        sc.ForwardSetState(endState);
+                        return;
+                }
+                if (sc.ch == chQuote) {
+                        sc.SetState(endState);
+                        return;
+                }
+                if (sc.Match('\\', static_cast<char>(chQuote))) {
+                        sc.Forward();
+                        ColouriseTADSHTMLString(sc, lineState);
+                        if (sc.state == SCE_T3_X_DEFAULT)
+                            break;
+                } else if (sc.ch == chString) {
+                        ColouriseTADSHTMLString(sc, lineState);
+                } else if (sc.ch == '=') {
+                        ColouriseTADS3Operator(sc);
+                } else {
+                        sc.Forward();
+                }
+        }
 }
 
 static void ColouriseTADS3Keyword(StyleContext &sc,
-							WordList *keywordlists[], 	unsigned int endPos) {
-	char s[250];
-	WordList &keywords = *keywordlists[0];
-	WordList &userwords1 = *keywordlists[1];
-	WordList &userwords2 = *keywordlists[2];
-	WordList &userwords3 = *keywordlists[3];
-	int initState = sc.state;
-	sc.SetState(SCE_T3_IDENTIFIER);
-	while (sc.More() && (IsAWordChar(sc.ch))) {
-		sc.Forward();
-	}
-	sc.GetCurrent(s, sizeof(s));
-	if ( strcmp(s, "is") == 0 || strcmp(s, "not") == 0) {
-		// have to find if "in" is next
-		int n = 1;
-		while (n + sc.currentPos < endPos && IsASpaceOrTab(sc.GetRelative(n)))
-			n++;
-		if (sc.GetRelative(n) == 'i' && sc.GetRelative(n+1) == 'n') {
-			sc.Forward(n+2);
-			sc.ChangeState(SCE_T3_KEYWORD);
-		}
-	} else if (keywords.InList(s)) {
-		sc.ChangeState(SCE_T3_KEYWORD);
-	} else if (userwords3.InList(s)) {
-		sc.ChangeState(SCE_T3_USER3);
-	} else if (userwords2.InList(s)) {
-		sc.ChangeState(SCE_T3_USER2);
-	} else if (userwords1.InList(s)) {
-		sc.ChangeState(SCE_T3_USER1);
-	}
-	sc.SetState(initState);
+                                                        WordList *keywordlists[],       unsigned int endPos) {
+        char s[250];
+        WordList &keywords = *keywordlists[0];
+        WordList &userwords1 = *keywordlists[1];
+        WordList &userwords2 = *keywordlists[2];
+        WordList &userwords3 = *keywordlists[3];
+        int initState = sc.state;
+        sc.SetState(SCE_T3_IDENTIFIER);
+        while (sc.More() && (IsAWordChar(sc.ch))) {
+                sc.Forward();
+        }
+        sc.GetCurrent(s, sizeof(s));
+        if ( strcmp(s, "is") == 0 || strcmp(s, "not") == 0) {
+                // have to find if "in" is next
+                int n = 1;
+                while (n + sc.currentPos < endPos && IsASpaceOrTab(sc.GetRelative(n)))
+                        n++;
+                if (sc.GetRelative(n) == 'i' && sc.GetRelative(n+1) == 'n') {
+                        sc.Forward(n+2);
+                        sc.ChangeState(SCE_T3_KEYWORD);
+                }
+        } else if (keywords.InList(s)) {
+                sc.ChangeState(SCE_T3_KEYWORD);
+        } else if (userwords3.InList(s)) {
+                sc.ChangeState(SCE_T3_USER3);
+        } else if (userwords2.InList(s)) {
+                sc.ChangeState(SCE_T3_USER2);
+        } else if (userwords1.InList(s)) {
+                sc.ChangeState(SCE_T3_USER1);
+        }
+        sc.SetState(initState);
 }
 
 static void ColouriseTADS3MsgParam(StyleContext &sc, int &lineState) {
-	int endState = sc.state;
-	int chQuote = '"';
-	switch (endState) {
-		case SCE_T3_S_STRING:
-			sc.SetState(SCE_T3_MSG_PARAM);
-			sc.Forward();
-			chQuote = '\'';
-			break;
-		case SCE_T3_D_STRING:
-		case SCE_T3_X_STRING:
-			sc.SetState(SCE_T3_MSG_PARAM);
-			sc.Forward();
-			break;
-		case SCE_T3_MSG_PARAM:
-			if (lineState&T3_SINGLE_QUOTE) {
-				endState = SCE_T3_S_STRING;
-				chQuote = '\'';
-			} else if (lineState&T3_INT_EXPRESSION) {
-				endState = SCE_T3_X_STRING;
-			} else {
-				endState = SCE_T3_D_STRING;
-			}
-			break;
-	}
-	while (sc.More() && sc.ch != '}' && sc.ch != chQuote) {
-		if (IsEOL(sc.ch, sc.chNext)) {
-			return;
-		}
-		if (sc.ch == '\\') {
-			sc.Forward();
-		}
-		sc.Forward();
-	}
-	if (sc.ch == chQuote) {
-		sc.SetState(endState);
-	} else {
-		sc.ForwardSetState(endState);
-	}
+        int endState = sc.state;
+        int chQuote = '"';
+        switch (endState) {
+                case SCE_T3_S_STRING:
+                        sc.SetState(SCE_T3_MSG_PARAM);
+                        sc.Forward();
+                        chQuote = '\'';
+                        break;
+                case SCE_T3_D_STRING:
+                case SCE_T3_X_STRING:
+                        sc.SetState(SCE_T3_MSG_PARAM);
+                        sc.Forward();
+                        break;
+                case SCE_T3_MSG_PARAM:
+                        if (lineState&T3_SINGLE_QUOTE) {
+                                endState = SCE_T3_S_STRING;
+                                chQuote = '\'';
+                        } else if (lineState&T3_INT_EXPRESSION) {
+                                endState = SCE_T3_X_STRING;
+                        } else {
+                                endState = SCE_T3_D_STRING;
+                        }
+                        break;
+        }
+        while (sc.More() && sc.ch != '}' && sc.ch != chQuote) {
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        return;
+                }
+                if (sc.ch == '\\') {
+                        sc.Forward();
+                }
+                sc.Forward();
+        }
+        if (sc.ch == chQuote) {
+                sc.SetState(endState);
+        } else {
+                sc.ForwardSetState(endState);
+        }
 }
 
 static void ColouriseTADS3LibDirective(StyleContext &sc, int &lineState) {
-	int initState = sc.state;
-	int chQuote = '"';
-	switch (initState) {
-		case SCE_T3_S_STRING:
-			sc.SetState(SCE_T3_LIB_DIRECTIVE);
-			sc.Forward(2);
-			chQuote = '\'';
-			break;
-		case SCE_T3_D_STRING:
-			sc.SetState(SCE_T3_LIB_DIRECTIVE);
-			sc.Forward(2);
-			break;
-		case SCE_T3_LIB_DIRECTIVE:
-			if (lineState&T3_SINGLE_QUOTE) {
-				initState = SCE_T3_S_STRING;
-				chQuote = '\'';
-			} else {
-				initState = SCE_T3_D_STRING;
-			}
-			break;
-	}
-	while (sc.More() && IsADirectiveChar(sc.ch)) {
-		if (IsEOL(sc.ch, sc.chNext)) {
-			return;
-		}
-		sc.Forward();
-	};
-	if (sc.ch == '>' || !sc.More()) {
-		sc.ForwardSetState(initState);
-	} else if (sc.ch == chQuote) {
-		sc.SetState(initState);
-	} else {
-		sc.ChangeState(initState);
-		sc.Forward();
-	}
+        int initState = sc.state;
+        int chQuote = '"';
+        switch (initState) {
+                case SCE_T3_S_STRING:
+                        sc.SetState(SCE_T3_LIB_DIRECTIVE);
+                        sc.Forward(2);
+                        chQuote = '\'';
+                        break;
+                case SCE_T3_D_STRING:
+                        sc.SetState(SCE_T3_LIB_DIRECTIVE);
+                        sc.Forward(2);
+                        break;
+                case SCE_T3_LIB_DIRECTIVE:
+                        if (lineState&T3_SINGLE_QUOTE) {
+                                initState = SCE_T3_S_STRING;
+                                chQuote = '\'';
+                        } else {
+                                initState = SCE_T3_D_STRING;
+                        }
+                        break;
+        }
+        while (sc.More() && IsADirectiveChar(sc.ch)) {
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        return;
+                }
+                sc.Forward();
+        };
+        if (sc.ch == '>' || !sc.More()) {
+                sc.ForwardSetState(initState);
+        } else if (sc.ch == chQuote) {
+                sc.SetState(initState);
+        } else {
+                sc.ChangeState(initState);
+                sc.Forward();
+        }
 }
 
 static void ColouriseTADS3String(StyleContext &sc, int &lineState) {
-	int chQuote = sc.ch;
-	int endState = sc.state;
-	switch (sc.state) {
-		case SCE_T3_DEFAULT:
-		case SCE_T3_X_DEFAULT:
-			if (chQuote == '"') {
-				if (sc.state == SCE_T3_DEFAULT) {
-					sc.SetState(SCE_T3_D_STRING);
-				} else {
-					sc.SetState(SCE_T3_X_STRING);
-				}
-				lineState &= ~T3_SINGLE_QUOTE;
-			} else {
-				sc.SetState(SCE_T3_S_STRING);
-				lineState |= T3_SINGLE_QUOTE;
-			}
-			sc.Forward();
-			break;
-		case SCE_T3_S_STRING:
-			chQuote = '\'';
-			endState = lineState&T3_INT_EXPRESSION ?
-				SCE_T3_X_DEFAULT : SCE_T3_DEFAULT;
-			break;
-		case SCE_T3_D_STRING:
-			chQuote = '"';
-			endState = SCE_T3_DEFAULT;
-			break;
-		case SCE_T3_X_STRING:
-			chQuote = '"';
-			endState = SCE_T3_X_DEFAULT;
-			break;
-	}
-	while (sc.More()) {
-		if (IsEOL(sc.ch, sc.chNext)) {
-			return;
-		}
-		if (sc.ch == chQuote) {
-			sc.ForwardSetState(endState);
-			return;
-		}
-		if (sc.state == SCE_T3_D_STRING && sc.Match('<', '<')) {
-			lineState |= T3_INT_EXPRESSION;
-			sc.SetState(SCE_T3_X_DEFAULT);
-			sc.Forward(2);
-			return;
-		}
-		if (sc.Match('\\', static_cast<char>(chQuote))) {
-			sc.Forward(2);
-		} else if (sc.ch == '{') {
-			ColouriseTADS3MsgParam(sc, lineState);
-		} else if (sc.Match('<', '.')) {
-			ColouriseTADS3LibDirective(sc, lineState);
-		} else if (sc.ch == '<') {
-			ColouriseTADS3HTMLTag(sc, lineState);
-		} else {
-			sc.Forward();
-		}
-	}
+        int chQuote = sc.ch;
+        int endState = sc.state;
+        switch (sc.state) {
+                case SCE_T3_DEFAULT:
+                case SCE_T3_X_DEFAULT:
+                        if (chQuote == '"') {
+                                if (sc.state == SCE_T3_DEFAULT) {
+                                        sc.SetState(SCE_T3_D_STRING);
+                                } else {
+                                        sc.SetState(SCE_T3_X_STRING);
+                                }
+                                lineState &= ~T3_SINGLE_QUOTE;
+                        } else {
+                                sc.SetState(SCE_T3_S_STRING);
+                                lineState |= T3_SINGLE_QUOTE;
+                        }
+                        sc.Forward();
+                        break;
+                case SCE_T3_S_STRING:
+                        chQuote = '\'';
+                        endState = lineState&T3_INT_EXPRESSION ?
+                                SCE_T3_X_DEFAULT : SCE_T3_DEFAULT;
+                        break;
+                case SCE_T3_D_STRING:
+                        chQuote = '"';
+                        endState = SCE_T3_DEFAULT;
+                        break;
+                case SCE_T3_X_STRING:
+                        chQuote = '"';
+                        endState = SCE_T3_X_DEFAULT;
+                        break;
+        }
+        while (sc.More()) {
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        return;
+                }
+                if (sc.ch == chQuote) {
+                        sc.ForwardSetState(endState);
+                        return;
+                }
+                if (sc.state == SCE_T3_D_STRING && sc.Match('<', '<')) {
+                        lineState |= T3_INT_EXPRESSION;
+                        sc.SetState(SCE_T3_X_DEFAULT);
+                        sc.Forward(2);
+                        return;
+                }
+                if (sc.Match('\\', static_cast<char>(chQuote))
+                    || sc.Match('\\', '\\')) {
+                        sc.Forward(2);
+                } else if (sc.ch == '{') {
+                        ColouriseTADS3MsgParam(sc, lineState);
+                } else if (sc.Match('<', '.')) {
+                        ColouriseTADS3LibDirective(sc, lineState);
+                } else if (sc.ch == '<') {
+                        ColouriseTADS3HTMLTag(sc, lineState);
+                        if (sc.state == SCE_T3_X_DEFAULT)
+                                return;
+                } else {
+                        sc.Forward();
+                }
+        }
 }
 
 static void ColouriseTADS3Comment(StyleContext &sc, int endState) {
-	sc.SetState(SCE_T3_BLOCK_COMMENT);
-	while (sc.More()) {
-		if (IsEOL(sc.ch, sc.chNext)) {
-			return;
-		}
-		if (sc.Match('*', '/')) {
-			sc.Forward(2);
-			sc.SetState(endState);
-			return;
-		}
-		sc.Forward();
-	}
+        sc.SetState(SCE_T3_BLOCK_COMMENT);
+        while (sc.More()) {
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        return;
+                }
+                if (sc.Match('*', '/')) {
+                        sc.Forward(2);
+                        sc.SetState(endState);
+                        return;
+                }
+                sc.Forward();
+        }
 }
 
 static void ColouriseToEndOfLine(StyleContext &sc, int initState, int endState) {
-	sc.SetState(initState);
-	while (sc.More()) {
-		if (sc.ch == '\\') {
-			sc.Forward();
-			if (IsEOL(sc.ch, sc.chNext)) {
-					return;
-			}
-		}
-		if (IsEOL(sc.ch, sc.chNext)) {
-			sc.SetState(endState);
-			return;
-		}
-		sc.Forward();
-	}
+        sc.SetState(initState);
+        while (sc.More()) {
+                if (sc.ch == '\\') {
+                        sc.Forward();
+                        if (IsEOLSkip(sc)) {
+                                        return;
+                        }
+                }
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        sc.SetState(endState);
+                        return;
+                }
+                sc.Forward();
+        }
 }
 
 static void ColouriseTADS3Number(StyleContext &sc) {
-	int endState = sc.state;
-	bool inHexNumber = false;
-	bool seenE = false;
-	bool seenDot = sc.ch == '.';
-	sc.SetState(SCE_T3_NUMBER);
-	if (sc.More()) {
-		sc.Forward();
-	}
-	if (sc.chPrev == '0' && tolower(sc.ch) == 'x') {
-		inHexNumber = true;
-		sc.Forward();
-	}
-	while (sc.More()) {
-		if (inHexNumber) {
-			if (!IsAHexDigit(sc.ch)) {
-				break;
-			}
-		} else if (!isdigit(sc.ch)) {
-			if (!seenE && tolower(sc.ch) == 'e') {
-				seenE = true;
-				seenDot = true;
-				if (sc.chNext == '+' || sc.chNext == '-') {
-					sc.Forward();
-				}
-			} else if (!seenDot && sc.ch == '.') {
-				seenDot = true;
-			} else {
-				break;
-			}
-		}
-		sc.Forward();
-	}
-	sc.SetState(endState);
+        int endState = sc.state;
+        bool inHexNumber = false;
+        bool seenE = false;
+        bool seenDot = sc.ch == '.';
+        sc.SetState(SCE_T3_NUMBER);
+        if (sc.More()) {
+                sc.Forward();
+        }
+        if (sc.chPrev == '0' && tolower(sc.ch) == 'x') {
+                inHexNumber = true;
+                sc.Forward();
+        }
+        while (sc.More()) {
+                if (inHexNumber) {
+                        if (!IsAHexDigit(sc.ch)) {
+                                break;
+                        }
+                } else if (!isdigit(sc.ch)) {
+                        if (!seenE && tolower(sc.ch) == 'e') {
+                                seenE = true;
+                                seenDot = true;
+                                if (sc.chNext == '+' || sc.chNext == '-') {
+                                        sc.Forward();
+                                }
+                        } else if (!seenDot && sc.ch == '.') {
+                                seenDot = true;
+                        } else {
+                                break;
+                        }
+                }
+                sc.Forward();
+        }
+        sc.SetState(endState);
 }
 
 static void ColouriseTADS3Doc(unsigned int startPos, int length, int initStyle,
-							   WordList *keywordlists[], Accessor &styler) {
-	int visibleChars = 0;
-	int bracketLevel = 0;
-	int lineState = 0;
-	unsigned int endPos = startPos + length;
-	int lineCurrent = styler.GetLine(startPos);
-	if (lineCurrent > 0) {
-		lineState = styler.GetLineState(lineCurrent-1);
-	}
-	StyleContext sc(startPos, length, initStyle, styler);
+                                                           WordList *keywordlists[], Accessor &styler) {
+        int visibleChars = 0;
+        int bracketLevel = 0;
+        int lineState = 0;
+        unsigned int endPos = startPos + length;
+        int lineCurrent = styler.GetLine(startPos);
+        if (lineCurrent > 0) {
+                lineState = styler.GetLineState(lineCurrent-1);
+        }
+        StyleContext sc(startPos, length, initStyle, styler);
 
-	while (sc.More()) {
+        while (sc.More()) {
 
-		if (IsEOL(sc.ch, sc.chNext)) {
-			styler.SetLineState(lineCurrent, lineState);
-			lineCurrent++;
-			visibleChars = 0;
-			sc.Forward();
-			if (sc.ch == '\n') {
-				sc.Forward();
-			}
-		}
+                if (IsEOL(sc.ch, sc.chNext)) {
+                        styler.SetLineState(lineCurrent, lineState);
+                        lineCurrent++;
+                        visibleChars = 0;
+                        sc.Forward();
+                        if (sc.ch == '\n') {
+                                sc.Forward();
+                        }
+                }
 
-		switch(sc.state) {
-			case SCE_T3_PREPROCESSOR:
-			case SCE_T3_LINE_COMMENT:
-				ColouriseToEndOfLine(sc, sc.state, lineState&T3_INT_EXPRESSION ?
-					SCE_T3_X_DEFAULT : SCE_T3_DEFAULT);
-				break;
-			case SCE_T3_S_STRING:
-			case SCE_T3_D_STRING:
-			case SCE_T3_X_STRING:
-				ColouriseTADS3String(sc, lineState);
-				visibleChars++;
-				break;
-			case SCE_T3_MSG_PARAM:
-				ColouriseTADS3MsgParam(sc, lineState);
-				break;
-			case SCE_T3_LIB_DIRECTIVE:
-				ColouriseTADS3LibDirective(sc, lineState);
-				break;
-			case SCE_T3_HTML_DEFAULT:
-				ColouriseTADS3HTMLTag(sc, lineState);
-				break;
-			case SCE_T3_HTML_STRING:
-				ColouriseTADSHTMLString(sc, lineState);
-				break;
-			case SCE_T3_BLOCK_COMMENT:
-				ColouriseTADS3Comment(sc, lineState&T3_INT_EXPRESSION ?
-					SCE_T3_X_DEFAULT : SCE_T3_DEFAULT);
-				break;
-			case SCE_T3_DEFAULT:
-			case SCE_T3_X_DEFAULT:
-				if (IsASpaceOrTab(sc.ch)) {
-					sc.Forward();
-				} else if (sc.ch == '#' && visibleChars == 0) {
-					ColouriseToEndOfLine(sc, SCE_T3_PREPROCESSOR, sc.state);
-				} else if (sc.Match('/', '*')) {
-					ColouriseTADS3Comment(sc, sc.state);
-					visibleChars++;
-				} else if (sc.Match('/', '/')) {
-					ColouriseToEndOfLine(sc, SCE_T3_LINE_COMMENT, sc.state);
-				} else if (sc.ch == '"') {
-					bracketLevel = 0;
-					ColouriseTADS3String(sc, lineState);
-					visibleChars++;
-				} else if (sc.ch == '\'') {
-					ColouriseTADS3String(sc, lineState);
-					visibleChars++;
-				} else if (sc.state == SCE_T3_X_DEFAULT && bracketLevel == 0
-						   && sc.Match('>', '>')) {
-					sc.Forward(2);
-					sc.SetState(SCE_T3_D_STRING);
-					lineState &= ~(T3_SINGLE_QUOTE|T3_INT_EXPRESSION);
-				} else if (IsATADS3Operator(sc.ch)) {
-					if (sc.state == SCE_T3_X_DEFAULT) {
-						if (sc.ch == '(') {
-							bracketLevel++;
-						} else if (sc.ch == ')') {
-							bracketLevel--;
-						}
-					}
-					ColouriseTADS3Operator(sc);
-					visibleChars++;
-				} else if (IsANumberStart(sc)) {
-					ColouriseTADS3Number(sc);
-					visibleChars++;
-				} else if (IsAWordStart(sc.ch)) {
-					ColouriseTADS3Keyword(sc, keywordlists, endPos);
-					visibleChars++;
-				} else if (sc.Match("...")) {
-					sc.SetState(SCE_T3_IDENTIFIER);
-					sc.Forward(3);
-					sc.SetState(SCE_T3_DEFAULT);
-				} else {
-					sc.Forward();
-					visibleChars++;
-				}
-				break;
-			default:
-				sc.SetState(SCE_T3_DEFAULT);
-				sc.Forward();
-		}
-	}
-	sc.Complete();
+                switch(sc.state) {
+                        case SCE_T3_PREPROCESSOR:
+                        case SCE_T3_LINE_COMMENT:
+                                ColouriseToEndOfLine(sc, sc.state, lineState&T3_INT_EXPRESSION ?
+                                        SCE_T3_X_DEFAULT : SCE_T3_DEFAULT);
+                                break;
+                        case SCE_T3_S_STRING:
+                        case SCE_T3_D_STRING:
+                        case SCE_T3_X_STRING:
+                                ColouriseTADS3String(sc, lineState);
+                                visibleChars++;
+                                break;
+                        case SCE_T3_MSG_PARAM:
+                                ColouriseTADS3MsgParam(sc, lineState);
+                                break;
+                        case SCE_T3_LIB_DIRECTIVE:
+                                ColouriseTADS3LibDirective(sc, lineState);
+                                break;
+                        case SCE_T3_HTML_DEFAULT:
+                                ColouriseTADS3HTMLTag(sc, lineState);
+                                break;
+                        case SCE_T3_HTML_STRING:
+                                ColouriseTADSHTMLString(sc, lineState);
+                                break;
+                        case SCE_T3_BLOCK_COMMENT:
+                                ColouriseTADS3Comment(sc, lineState&T3_INT_EXPRESSION ?
+                                        SCE_T3_X_DEFAULT : SCE_T3_DEFAULT);
+                                break;
+                        case SCE_T3_DEFAULT:
+                        case SCE_T3_X_DEFAULT:
+                                if (IsASpaceOrTab(sc.ch)) {
+                                        sc.Forward();
+                                } else if (sc.ch == '#' && visibleChars == 0) {
+                                        ColouriseToEndOfLine(sc, SCE_T3_PREPROCESSOR, sc.state);
+                                } else if (sc.Match('/', '*')) {
+                                        ColouriseTADS3Comment(sc, sc.state);
+                                        visibleChars++;
+                                } else if (sc.Match('/', '/')) {
+                                        ColouriseToEndOfLine(sc, SCE_T3_LINE_COMMENT, sc.state);
+                                } else if (sc.ch == '"') {
+                                        bracketLevel = 0;
+                                        ColouriseTADS3String(sc, lineState);
+                                        visibleChars++;
+                                } else if (sc.ch == '\'') {
+                                        ColouriseTADS3String(sc, lineState);
+                                        visibleChars++;
+                                } else if (sc.state == SCE_T3_X_DEFAULT && bracketLevel == 0
+                                                   && sc.Match('>', '>')) {
+                                        sc.Forward(2);
+                                        sc.SetState(SCE_T3_D_STRING);
+                                        if (lineState & T3_INT_EXPRESSION_IN_TAG)
+                                                sc.SetState(SCE_T3_HTML_STRING);
+                                        lineState &= ~(T3_SINGLE_QUOTE|T3_INT_EXPRESSION
+                                                       |T3_INT_EXPRESSION_IN_TAG);
+                                } else if (IsATADS3Operator(sc.ch)) {
+                                        if (sc.state == SCE_T3_X_DEFAULT) {
+                                                if (sc.ch == '(') {
+                                                        bracketLevel++;
+                                                } else if (sc.ch == ')' && bracketLevel > 0) {
+                                                        bracketLevel--;
+                                                }
+                                        }
+                                        ColouriseTADS3Operator(sc);
+                                        visibleChars++;
+                                } else if (IsANumberStart(sc)) {
+                                        ColouriseTADS3Number(sc);
+                                        visibleChars++;
+                                } else if (IsAWordStart(sc.ch)) {
+                                        ColouriseTADS3Keyword(sc, keywordlists, endPos);
+                                        visibleChars++;
+                                } else if (sc.Match("...")) {
+                                        sc.SetState(SCE_T3_IDENTIFIER);
+                                        sc.Forward(3);
+                                        sc.SetState(SCE_T3_DEFAULT);
+                                } else {
+                                        sc.Forward();
+                                        visibleChars++;
+                                }
+                                break;
+                        default:
+                                sc.SetState(SCE_T3_DEFAULT);
+                                sc.Forward();
+                }
+        }
+        sc.Complete();
 }
 
 /*
@@ -567,15 +630,15 @@
 
  // default style
  silverKey : Key 'small silver key' 'small silver key'
-	"A small key glints in the sunlight. "
+        "A small key glints in the sunlight. "
  ;
 
  and
 
  silverKey : Key {
-	'small silver key'
-	'small silver key'
-	"A small key glints in the sunlight. "
+        'small silver key'
+        'small silver key'
+        "A small key glints in the sunlight. "
  }
 
  Some constructs mandate one or the other, but usually the author has may choose
@@ -614,224 +677,228 @@
 static const int T3_EXPECTINGPUNCTUATION = 1 << 14;
 
 static inline bool IsStringTransition(int s1, int s2) {
-	return s1 != s2
-		&& (s1 == SCE_T3_S_STRING || s1 == SCE_T3_X_STRING
-			|| s1 == SCE_T3_D_STRING && s2 != SCE_T3_X_DEFAULT)
-		&& s2 != SCE_T3_LIB_DIRECTIVE
-		&& s2 != SCE_T3_MSG_PARAM
-		&& s2 != SCE_T3_HTML_TAG
-		&& s2 != SCE_T3_HTML_STRING;
+        return s1 != s2
+                && (s1 == SCE_T3_S_STRING || s1 == SCE_T3_X_STRING
+                        || s1 == SCE_T3_D_STRING && s2 != SCE_T3_X_DEFAULT)
+                && s2 != SCE_T3_LIB_DIRECTIVE
+                && s2 != SCE_T3_MSG_PARAM
+                && s2 != SCE_T3_HTML_TAG
+                && s2 != SCE_T3_HTML_STRING;
 }
 
 static inline bool IsATADS3Punctuation(const int ch) {
-	return ch == ':' || ch == ',' || ch == '(' || ch == ')';
+        return ch == ':' || ch == ',' || ch == '(' || ch == ')';
 }
 
 static inline bool IsAnIdentifier(const int style) {
-	return style == SCE_T3_IDENTIFIER
-		|| style == SCE_T3_USER1
-		|| style == SCE_T3_USER2
-		|| style == SCE_T3_USER3;
+        return style == SCE_T3_IDENTIFIER
+                || style == SCE_T3_USER1
+                || style == SCE_T3_USER2
+                || style == SCE_T3_USER3;
 }
 
+static inline bool IsAnOperator(const int style) {
+    return style == SCE_T3_OPERATOR || SCE_T3_BRACE;
+}
+
 static inline bool IsSpaceEquivalent(const int ch, const int style) {
-	return isspace(ch)
-		|| style == SCE_T3_BLOCK_COMMENT
-		|| style == SCE_T3_LINE_COMMENT
-		|| style == SCE_T3_PREPROCESSOR;
+        return isspace(ch)
+                || style == SCE_T3_BLOCK_COMMENT
+                || style == SCE_T3_LINE_COMMENT
+                || style == SCE_T3_PREPROCESSOR;
 }
 
 static char peekAhead(unsigned int startPos, unsigned int endPos,
-					  Accessor &styler) {
-	for (unsigned int i = startPos; i < endPos; i++) {
-		int style = styler.StyleAt(i);
-		char ch = styler[i];
-		if (!IsSpaceEquivalent(ch, style)) {
-			if (IsAnIdentifier(style)) {
-				return 'a';
-			}
-			if (IsATADS3Punctuation(ch)) {
-				return ':';
-			}
-			if (ch == '{') {
-				return '{';
-			}
-			return '*';
-		}
-	}
-	return ' ';
+                                          Accessor &styler) {
+        for (unsigned int i = startPos; i < endPos; i++) {
+                int style = styler.StyleAt(i);
+                char ch = styler[i];
+                if (!IsSpaceEquivalent(ch, style)) {
+                        if (IsAnIdentifier(style)) {
+                                return 'a';
+                        }
+                        if (IsATADS3Punctuation(ch)) {
+                                return ':';
+                        }
+                        if (ch == '{') {
+                                return '{';
+                        }
+                        return '*';
+                }
+        }
+        return ' ';
 }
 
 static void FoldTADS3Doc(unsigned int startPos, int length, int initStyle,
                             WordList *[], Accessor &styler) {
-	unsigned int endPos = startPos + length;
-	int lineCurrent = styler.GetLine(startPos);
-	int levelCurrent = SC_FOLDLEVELBASE;
-	if (lineCurrent > 0)
-		levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
-	int seenStart = levelCurrent & T3_SEENSTART;
-	int expectingIdentifier = levelCurrent & T3_EXPECTINGIDENTIFIER;
-	int expectingPunctuation = levelCurrent & T3_EXPECTINGPUNCTUATION;
-	levelCurrent &= SC_FOLDLEVELNUMBERMASK;
-	int levelMinCurrent = levelCurrent;
-	int levelNext = levelCurrent;
-	char chNext = styler[startPos];
-	int styleNext = styler.StyleAt(startPos);
-	int style = initStyle;
-	char ch = chNext;
-	int stylePrev = style;
-	bool redo = false;
-	for (unsigned int i = startPos; i < endPos; i++) {
-		if (redo) {
-			redo = false;
-			i--;
-		} else {
-			ch = chNext;
-			chNext = styler.SafeGetCharAt(i + 1);
-			stylePrev = style;
-			style = styleNext;
-			styleNext = styler.StyleAt(i + 1);
-		}
-		bool atEOL = IsEOL(ch, chNext);
+        unsigned int endPos = startPos + length;
+        int lineCurrent = styler.GetLine(startPos);
+        int levelCurrent = SC_FOLDLEVELBASE;
+        if (lineCurrent > 0)
+                levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
+        int seenStart = levelCurrent & T3_SEENSTART;
+        int expectingIdentifier = levelCurrent & T3_EXPECTINGIDENTIFIER;
+        int expectingPunctuation = levelCurrent & T3_EXPECTINGPUNCTUATION;
+        levelCurrent &= SC_FOLDLEVELNUMBERMASK;
+        int levelMinCurrent = levelCurrent;
+        int levelNext = levelCurrent;
+        char chNext = styler[startPos];
+        int styleNext = styler.StyleAt(startPos);
+        int style = initStyle;
+        char ch = chNext;
+        int stylePrev = style;
+        bool redo = false;
+        for (unsigned int i = startPos; i < endPos; i++) {
+                if (redo) {
+                        redo = false;
+                        i--;
+                } else {
+                        ch = chNext;
+                        chNext = styler.SafeGetCharAt(i + 1);
+                        stylePrev = style;
+                        style = styleNext;
+                        styleNext = styler.StyleAt(i + 1);
+                }
+                bool atEOL = IsEOL(ch, chNext);
 
-		if (levelNext == SC_FOLDLEVELBASE) {
-			if (IsSpaceEquivalent(ch, style)) {
-				if (expectingPunctuation) {
-					expectingIdentifier = 0;
-				}
-				if (style == SCE_T3_BLOCK_COMMENT) {
-					levelNext++;
-				}
-			} else if (ch == '{') {
-				levelNext++;
-				seenStart = 0;
-			} else if (ch == '\'' || ch == '"' || ch == '[') {
-				levelNext++;
-				if (seenStart) {
-					redo = true;
-				}
-			} else if (ch == ';') {
-				seenStart = 0;
-				expectingIdentifier = 0;
-				expectingPunctuation = 0;
-			} else if (expectingIdentifier && expectingPunctuation) {
-				if (IsATADS3Punctuation(ch)) {
-					if (ch == ')' && peekAhead(i+1, endPos, styler) != '{') {
-						levelNext++;
-					} else {
-						expectingPunctuation = 0;
-					}
-				} else if (!IsAnIdentifier(style)) {
-					levelNext++;
-				}
-			} else if (expectingIdentifier && !expectingPunctuation) {
-				if (!IsAnIdentifier(style)) {
-					levelNext++;
-				} else {
-					expectingPunctuation = T3_EXPECTINGPUNCTUATION;
-				}
-			} else if (!expectingIdentifier && expectingPunctuation) {
-				if (!IsATADS3Punctuation(ch)) {
-					levelNext++;
-				} else {
-					if (ch == ')' && peekAhead(i+1, endPos, styler) != '{') {
-						levelNext++;
-					} else {
-						expectingIdentifier = T3_EXPECTINGIDENTIFIER;
-						expectingPunctuation = 0;
-					}
-				}
-			} else if (!expectingIdentifier && !expectingPunctuation) {
-				if (IsAnIdentifier(style)) {
-					seenStart = T3_SEENSTART;
-					expectingIdentifier = T3_EXPECTINGIDENTIFIER;
-					expectingPunctuation = T3_EXPECTINGPUNCTUATION;
-				}
-			}
+                if (levelNext == SC_FOLDLEVELBASE) {
+                        if (IsSpaceEquivalent(ch, style)) {
+                                if (expectingPunctuation) {
+                                        expectingIdentifier = 0;
+                                }
+                                if (style == SCE_T3_BLOCK_COMMENT) {
+                                        levelNext++;
+                                }
+                        } else if (ch == '{') {
+                                levelNext++;
+                                seenStart = 0;
+                        } else if (ch == '\'' || ch == '"' || ch == '[') {
+                                levelNext++;
+                                if (seenStart) {
+                                        redo = true;
+                                }
+                        } else if (ch == ';') {
+                                seenStart = 0;
+                                expectingIdentifier = 0;
+                                expectingPunctuation = 0;
+                        } else if (expectingIdentifier && expectingPunctuation) {
+                                if (IsATADS3Punctuation(ch)) {
+                                        if (ch == ')' && peekAhead(i+1, endPos, styler) != '{') {
+                                                levelNext++;
+                                        } else {
+                                                expectingPunctuation = 0;
+                                        }
+                                } else if (!IsAnIdentifier(style)) {
+                                        levelNext++;
+                                }
+                        } else if (expectingIdentifier && !expectingPunctuation) {
+                                if (!IsAnIdentifier(style)) {
+                                        levelNext++;
+                                } else {
+                                        expectingPunctuation = T3_EXPECTINGPUNCTUATION;
+                                }
+                        } else if (!expectingIdentifier && expectingPunctuation) {
+                                if (!IsATADS3Punctuation(ch)) {
+                                        levelNext++;
+                                } else {
+                                        if (ch == ')' && peekAhead(i+1, endPos, styler) != '{') {
+                                                levelNext++;
+                                        } else {
+                                                expectingIdentifier = T3_EXPECTINGIDENTIFIER;
+                                                expectingPunctuation = 0;
+                                        }
+                                }
+                        } else if (!expectingIdentifier && !expectingPunctuation) {
+                                if (IsAnIdentifier(style)) {
+                                        seenStart = T3_SEENSTART;
+                                        expectingIdentifier = T3_EXPECTINGIDENTIFIER;
+                                        expectingPunctuation = T3_EXPECTINGPUNCTUATION;
+                                }
+                        }
 
-			if (levelNext != SC_FOLDLEVELBASE && style != SCE_T3_BLOCK_COMMENT) {
-				expectingIdentifier = 0;
-				expectingPunctuation = 0;
-			}
+                        if (levelNext != SC_FOLDLEVELBASE && style != SCE_T3_BLOCK_COMMENT) {
+                                expectingIdentifier = 0;
+                                expectingPunctuation = 0;
+                        }
 
-		} else if (levelNext == SC_FOLDLEVELBASE+1 && seenStart
-				   && ch == ';' && style == SCE_T3_OPERATOR ) {
-			levelNext--;
-			seenStart = 0;
-		} else if (style == SCE_T3_BLOCK_COMMENT) {
-			if (stylePrev != SCE_T3_BLOCK_COMMENT) {
-				levelNext++;
-			} else if (styleNext != SCE_T3_BLOCK_COMMENT && !atEOL) {
-				// Comments don't end at end of line and the next character may be unstyled.
-				levelNext--;
-			}
-		} else if (ch == '\'' || ch == '"') {
-			if (IsStringTransition(style, stylePrev)) {
-				if (levelMinCurrent > levelNext) {
-					levelMinCurrent = levelNext;
-				}
-				levelNext++;
-			} else if (IsStringTransition(style, styleNext)) {
-				levelNext--;
-			}
-		} else if (style == SCE_T3_OPERATOR) {
-			if (ch == '{' || ch == '[') {
-				// Measure the minimum before a '{' to allow
-				// folding on "} else {"
-				if (levelMinCurrent > levelNext) {
-					levelMinCurrent = levelNext;
-				}
-				levelNext++;
-			} else if (ch == '}' || ch == ']') {
-				levelNext--;
-			}
-		}
+                } else if (levelNext == SC_FOLDLEVELBASE+1 && seenStart
+                                   && ch == ';' && IsAnOperator(style)) {
+                        levelNext--;
+                        seenStart = 0;
+                } else if (style == SCE_T3_BLOCK_COMMENT) {
+                        if (stylePrev != SCE_T3_BLOCK_COMMENT) {
+                                levelNext++;
+                        } else if (styleNext != SCE_T3_BLOCK_COMMENT && !atEOL) {
+                                // Comments don't end at end of line and the next character may be unstyled.
+                                levelNext--;
+                        }
+                } else if (ch == '\'' || ch == '"') {
+                        if (IsStringTransition(style, stylePrev)) {
+                                if (levelMinCurrent > levelNext) {
+                                        levelMinCurrent = levelNext;
+                                }
+                                levelNext++;
+                        } else if (IsStringTransition(style, styleNext)) {
+                                levelNext--;
+                        }
+                } else if (IsAnOperator(style)) {
+                        if (ch == '{' || ch == '[') {
+                                // Measure the minimum before a '{' to allow
+                                // folding on "} else {"
+                                if (levelMinCurrent > levelNext) {
+                                        levelMinCurrent = levelNext;
+                                }
+                                levelNext++;
+                        } else if (ch == '}' || ch == ']') {
+                                levelNext--;
+                        }
+                }
 
-		if (atEOL) {
-			if (seenStart && levelNext == SC_FOLDLEVELBASE) {
-				switch (peekAhead(i+1, endPos, styler)) {
-					case ' ':
-					case '{':
-						break;
-					case '*':
-						levelNext++;
-						break;
-					case 'a':
-						if (expectingPunctuation) {
-							levelNext++;
-						}
-						break;
-					case ':':
-						if (expectingIdentifier) {
-							levelNext++;
-						}
-						break;
-				}
-				if (levelNext != SC_FOLDLEVELBASE) {
-					expectingIdentifier = 0;
-					expectingPunctuation = 0;
-				}
-			}
-			int lev = levelMinCurrent | (levelNext | expectingIdentifier
-				| expectingPunctuation | seenStart) << 16;
-			if (levelMinCurrent < levelNext)
-				lev |= SC_FOLDLEVELHEADERFLAG;
-			if (lev != styler.LevelAt(lineCurrent)) {
-				styler.SetLevel(lineCurrent, lev);
-			}
-			lineCurrent++;
-			levelCurrent = levelNext;
-			levelMinCurrent = levelCurrent;
-		}
-	}
+                if (atEOL) {
+                        if (seenStart && levelNext == SC_FOLDLEVELBASE) {
+                                switch (peekAhead(i+1, endPos, styler)) {
+                                        case ' ':
+                                        case '{':
+                                                break;
+                                        case '*':
+                                                levelNext++;
+                                                break;
+                                        case 'a':
+                                                if (expectingPunctuation) {
+                                                        levelNext++;
+                                                }
+                                                break;
+                                        case ':':
+                                                if (expectingIdentifier) {
+                                                        levelNext++;
+                                                }
+                                                break;
+                                }
+                                if (levelNext != SC_FOLDLEVELBASE) {
+                                        expectingIdentifier = 0;
+                                        expectingPunctuation = 0;
+                                }
+                        }
+                        int lev = levelMinCurrent | (levelNext | expectingIdentifier
+                                | expectingPunctuation | seenStart) << 16;
+                        if (levelMinCurrent < levelNext)
+                                lev |= SC_FOLDLEVELHEADERFLAG;
+                        if (lev != styler.LevelAt(lineCurrent)) {
+                                styler.SetLevel(lineCurrent, lev);
+                        }
+                        lineCurrent++;
+                        levelCurrent = levelNext;
+                        levelMinCurrent = levelCurrent;
+                }
+        }
 }
 
 static const char * const tads3WordList[] = {
-	"TADS3 Keywords",
-	"User defined 1",
-	"User defined 2",
-	"User defined 3",
-	0
+        "TADS3 Keywords",
+        "User defined 1",
+        "User defined 2",
+        "User defined 3",
+        0
 };
 
 LexerModule lmTADS3(SCLEX_TADS3, ColouriseTADS3Doc, "tads3", FoldTADS3Doc, tads3WordList);
Index: src/sdk/wxscintilla/src/scintilla/src/XPM.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/XPM.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/XPM.h	(working copy)
@@ -8,6 +8,10 @@
 #ifndef XPM_H
 #define XPM_H
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 /**
  * Hold a pixmap in XPM format.
  */
@@ -69,4 +73,8 @@
 	int GetWidth();
 };
 
+#ifdef SCI_NAMESPACE
+}
 #endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/LexBasic.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexBasic.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexBasic.cxx	(working copy)
@@ -31,6 +31,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 /* Bits:
  * 1  - whitespace
  * 2  - operator
Index: src/sdk/wxscintilla/src/scintilla/src/LexForth.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexForth.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexForth.cxx	(working copy)
@@ -21,6 +21,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 bool is_whitespace(int ch){
     return ch == '\n' || ch == '\r' || ch == '\t' || ch == ' ';
 }
Index: src/sdk/wxscintilla/src/scintilla/src/RESearch.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/RESearch.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/RESearch.cxx	(working copy)
@@ -16,6 +16,7 @@
  * Converted to modern function prototypes.
  * Put all global/static variables into an object so this code can be
  * used from multiple threads, etc.
+ * Some extensions by Philippe Lhoste PhiLho(a)GMX.net
  *
  * These routines are the PUBLIC DOMAIN equivalents of regex
  * routines as found in 4.nBSD UN*X, with minor extensions.
@@ -58,31 +59,38 @@
  *      [2]     .       matches any character.
  *
  *      [3]     \       matches the character following it, except:
- *                      - \a, \b, \f, \n, \t, \v match the
- *                      corresponding C escape char;
+ *                      - \a, \b, \f, \n, \r, \t, \v match the corresponding C
+ *                      escape char, respectively BEL, BS, FF, LF, CR, TAB and VT;
+ *                      Note that \r and \n are never matched because Scintilla
+ *                      regex searches are made line per line
+ *                      (stripped of end-of-line chars).
  *                      - if not in posix mode, when followed by a
  *                      left or right round bracket (see [7]);
  *                      - when followed by a digit 1 to 9 (see [8]);
  *                      - when followed by a left or right angle bracket
- *                      (see [9]).
- *                      It is used as an escape character for all
- *                      other meta-characters, and itself. When used
- *                      in a set ([4]), it is treated as an ordinary
- *                      character (except for escape chars).
+ *                      (see [9]);
+ *                      - when followed by d, D, s, S, w or W (see [10]);
+ *                      - when followed by x and two hexa digits (see [11].
+ *                      Backslash is used as an escape character for all
+ *                      other meta-characters, and itself.
  *
  *      [4]     [set]   matches one of the characters in the set.
  *                      If the first character in the set is "^",
- *                      it matches a character NOT in the set, i.e.
- *                      complements the set. A shorthand S-E (start-end)
- *                      is used to specify a set of characters S upto
- *                      E, inclusive. The special characters "]" and
- *                      "-" have no special meaning if they appear
- *                      as the first chars in the set. To include both,
- *                      put - first: [-]A-Z]:
- *                      [-]|] matches these 2 chars,
- *                      []-|] matches from ] to | chars.
+ *                      it matches the characters NOT in the set, i.e.
+ *                      complements the set. A shorthand S-E (start dash end)
+ *                      is used to specify a set of characters S up to
+ *                      E, inclusive. S and E must be characters, otherwise
+ *                      the dash is taken literally (eg. in expression [\d-a]).
+ *                      The special characters "]" and "-" have no special
+ *                      meaning if they appear as the first chars in the set.
+ *                      To include both, put - first: [-]A-Z]
+ *                      (or just backslash them).
  *                      examples:        match:
  *
+ *                              [-]|]    matches these 3 chars,
+ *
+ *                              []-|]    matches from ] to | chars
+ *
  *                              [a-z]    any lowercase alpha
  *
  *                              [^-]]    any char except - and ]
@@ -92,13 +100,15 @@
  *
  *                              [a-zA-Z] any alpha
  *
- *      [5]     *       any regular expression form [1] to [4], followed by
- *                      closure char (*) matches zero or more matches of
- *                      that form.
+ *      [5]     *       any regular expression form [1] to [4]
+ *                      (except [7], [8] and [9] forms of [3]),
+ *                      followed by closure char (*)
+ *                      matches zero or more matches of that form.
  *
  *      [6]     +       same as [5], except it matches one or more.
+ *                      Both [5] and [6] are greedy (they match as much as possible).
  *
- *      [7]             a regular expression in the form [1] to [10], enclosed
+ *      [7]             a regular expression in the form [1] to [12], enclosed
  *                      as \(form\) (or (form) with posix flag) matches what
  *                      form matches. The enclosure creates a set of tags,
  *                      used for [8] and for pattern substitution.
@@ -112,14 +122,30 @@
  *                      pattern matching to the beginning of a word, and/or
  *                      the end of a word. A word is defined to be a character
  *                      string beginning and/or ending with the characters
- *                      A-Z a-z 0-9 and _. It must also be preceded and/or
+ *                      A-Z a-z 0-9 and _. Scintilla extends this definition
+ *                      by user setting. The word must also be preceded and/or
  *                      followed by any character outside those mentioned.
  *
- *      [10]            a composite regular expression xy where x and y
- *                      are in the form [1] to [10] matches the longest
+ *      [10]    \l      a backslash followed by d, D, s, S, w or W,
+ *                      becomes a character class (both inside and
+ *                      outside sets []).
+ *                        d: decimal digits
+ *                        D: any char except decimal digits
+ *                        s: whitespace (space, \t \n \r \f \v)
+ *                        S: any char except whitespace (see above)
+ *                        w: alphanumeric & underscore (changed by user setting)
+ *                        W: any char except alphanumeric & underscore (see above)
+ *
+ *      [11]    \xHH    a backslash followed by x and two hexa digits,
+ *                      becomes the character whose Ascii code is equal
+ *                      to these digits. If not followed by two digits,
+ *                      it is 'x' char itself.
+ *
+ *      [12]            a composite regular expression xy where x and y
+ *                      are in the form [1] to [11] matches the longest
  *                      match of x followed by a match for y.
  *
- *      [11]    ^       a regular expression starting with a ^ character
+ *      [13]    ^       a regular expression starting with a ^ character
  *              $       and/or ending with a $ character, restricts the
  *                      pattern matching to the beginning of the line,
  *                      or the end of line. [anchors] Elsewhere in the
@@ -143,11 +169,11 @@
  *
  * Notes:
  *
- *	This implementation uses a bit-set representation for character
- *	classes for speed and compactness. Each character is represented
- *	by one bit in a 256-bit block. Thus, CCL always takes a
+ *  This implementation uses a bit-set representation for character
+ *  classes for speed and compactness. Each character is represented
+ *  by one bit in a 256-bit block. Thus, CCL always takes a
  *	constant 32 bytes in the internal nfa, and RESearch::Execute does a single
- *	bit comparison to locate the character in the set.
+ *  bit comparison to locate the character in the set.
  *
  * Examples:
  *
@@ -180,6 +206,10 @@
 #pragma warning(disable: 4514)
 #endif
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 #define OKP     1
 #define NOP     0
 
@@ -204,7 +234,7 @@
 #define BLKIND  0370
 #define BITIND  07
 
-const char bitarr[] = {1,2,4,8,16,32,64,'\200'};
+const char bitarr[] = { 1, 2, 4, 8, 16, 32, 64, '\200' };
 
 #define badpat(x)	(*nfa = END, x)
 
@@ -212,7 +242,7 @@
  * Character classification table for word boundary operators BOW
  * and EOW is passed in by the creator of this object (Scintilla
  * Document). The Document default state is that word chars are:
- * 0-9,a-z, A-Z and _
+ * 0-9, a-z, A-Z and _
  */
 
 RESearch::RESearch(CharClassify *charClassTable) {
@@ -227,14 +257,14 @@
 void RESearch::Init() {
 	sta = NOP;                  /* status of lastpat */
 	bol = 0;
-	for (int i=0; i<MAXTAG; i++)
+	for (int i = 0; i < MAXTAG; i++)
 		pat[i] = 0;
-	for (int j=0; j<BITBLK; j++)
+	for (int j = 0; j < BITBLK; j++)
 		bittab[j] = 0;
 }
 
 void RESearch::Clear() {
-	for (int i=0; i<MAXTAG; i++) {
+	for (int i = 0; i < MAXTAG; i++) {
 		delete []pat[i];
 		pat[i] = 0;
 		bopat[i] = NOTFOUND;
@@ -244,12 +274,12 @@
 
 bool RESearch::GrabMatches(CharacterIndexer &ci) {
 	bool success = true;
-	for (unsigned int i=0; i<MAXTAG; i++) {
+	for (unsigned int i = 0; i < MAXTAG; i++) {
 		if ((bopat[i] != NOTFOUND) && (eopat[i] != NOTFOUND)) {
 			unsigned int len = eopat[i] - bopat[i];
 			pat[i] = new char[len + 1];
 			if (pat[i]) {
-				for (unsigned int j=0; j<len; j++)
+				for (unsigned int j = 0; j < len; j++)
 					pat[i][j] = ci.CharAt(bopat[i] + j);
 				pat[i][len] = '\0';
 			} else {
@@ -260,27 +290,27 @@
 	return success;
 }
 
-void RESearch::ChSet(char c) {
+void RESearch::ChSet(unsigned char c) {
 	bittab[((c) & BLKIND) >> 3] |= bitarr[(c) & BITIND];
 }
 
-void RESearch::ChSetWithCase(char c, bool caseSensitive) {
+void RESearch::ChSetWithCase(unsigned char c, bool caseSensitive) {
 	if (caseSensitive) {
 		ChSet(c);
 	} else {
 		if ((c >= 'a') && (c <= 'z')) {
 			ChSet(c);
-			ChSet(static_cast<char>(c - 'a' + 'A'));
+			ChSet(static_cast<unsigned char>(c - 'a' + 'A'));
 		} else if ((c >= 'A') && (c <= 'Z')) {
 			ChSet(c);
-			ChSet(static_cast<char>(c - 'A' + 'a'));
+			ChSet(static_cast<unsigned char>(c - 'A' + 'a'));
 		} else {
 			ChSet(c);
 		}
 	}
 }
 
-const char escapeValue(char ch) {
+const unsigned char escapeValue(unsigned char ch) {
 	switch (ch) {
 	case 'a':	return '\a';
 	case 'b':	return '\b';
@@ -293,6 +323,119 @@
 	return 0;
 }
 
+static int GetHexaChar(unsigned char hd1, unsigned char hd2) {
+	int hexValue = 0;
+	if (hd1 >= '0' && hd1 <= '9') {
+		hexValue += 16 * (hd1 - '0');
+	} else if (hd1 >= 'A' && hd1 <= 'F') {
+		hexValue += 16 * (hd1 - 'A' + 10);
+	} else if (hd1 >= 'a' && hd1 <= 'f') {
+		hexValue += 16 * (hd1 - 'a' + 10);
+	} else
+		return -1;
+	if (hd2 >= '0' && hd2 <= '9') {
+		hexValue += hd2 - '0';
+	} else if (hd2 >= 'A' && hd2 <= 'F') {
+		hexValue += hd2 - 'A' + 10;
+	} else if (hd2 >= 'a' && hd2 <= 'f') {
+		hexValue += hd2 - 'a' + 10;
+	} else
+		return -1;
+	return hexValue;
+}
+
+/**
+ * Called when the parser finds a backslash not followed
+ * by a valid expression (like \( in non-Posix mode).
+ * @param pat: pointer on the char after the backslash.
+ * @param incr: (out) number of chars to skip after expression evaluation.
+ * @return the char if it resolves to a simple char,
+ * or -1 for a char class. In this case, bittab is changed.
+ */
+int RESearch::GetBackslashExpression(
+		const char *pat,
+		int &incr) {
+	// Since error reporting is primitive and messages are not used anyway,
+	// I choose to interpret unexpected syntax in a logical way instead
+	// of reporting errors. Otherwise, we can stick on, eg., PCRE behavior.
+	incr = 0;	// Most of the time, will skip the char "naturally".
+	int c;
+	int result = -1;
+	unsigned char bsc = *pat;
+	if (!bsc) {
+		// Avoid overrun
+		result = '\\';	// \ at end of pattern, take it literally
+		return result;
+	}
+
+	switch (bsc) {
+	case 'a':
+	case 'b':
+	case 'n':
+	case 'f':
+	case 'r':
+	case 't':
+	case 'v':
+		result = escapeValue(bsc);
+		break;
+	case 'x': {
+			unsigned char hd1 = *(pat + 1);
+			unsigned char hd2 = *(pat + 2);
+			int hexValue = GetHexaChar(hd1, hd2);
+			if (hexValue >= 0) {
+				result = hexValue;
+				incr = 2;	// Must skip the digits
+			} else {
+				result = 'x';	// \x without 2 digits: see it as 'x'
+			}
+		}
+		break;
+	case 'd':
+		for (c = '0'; c <= '9'; c++) {
+			ChSet(static_cast<unsigned char>(c));
+		}
+		break;
+	case 'D':
+		for (c = 0; c < MAXCHR; c++) {
+			if (c < '0' || c > '9') {
+				ChSet(static_cast<unsigned char>(c));
+			}
+		}
+		break;
+	case 's':
+		ChSet(' ');
+		ChSet('\t');
+		ChSet('\n');
+		ChSet('\r');
+		ChSet('\f');
+		ChSet('\v');
+		break;
+	case 'S':
+		for (c = 0; c < MAXCHR; c++) {
+			if (c != ' ' && !(c >= 0x09 && c <= 0x0D)) {
+				ChSet(static_cast<unsigned char>(c));
+			}
+		}
+	case 'w':
+		for (c = 0; c < MAXCHR; c++) {
+			if (iswordc(static_cast<unsigned char>(c))) {
+				ChSet(static_cast<unsigned char>(c));
+			}
+		}
+		break;
+	case 'W':
+		for (c = 0; c < MAXCHR; c++) {
+			if (!iswordc(static_cast<unsigned char>(c))) {
+				ChSet(static_cast<unsigned char>(c));
+			}
+		}
+		break;
+	default:
+		result = bsc;
+	}
+	return result;
+}
+
 const char *RESearch::Compile(const char *pat, int length, bool caseSensitive, bool posix) {
 	char *mp=nfa;          /* nfa pointer       */
 	char *lp;              /* saved pointer     */
@@ -304,7 +447,7 @@
 
 	int n;
 	char mask;             /* xor mask -CCL/NCL */
-	int c1, c2;
+	int c1, c2, prevChar;
 
 	if (!pat || !length)
 		if (sta)
@@ -318,7 +461,7 @@
 		if (mp > mpMax)
 			return badpat("Pattern too long");
 		lp = mp;
-		switch(*p) {
+		switch (*p) {
 
 		case '.':               /* match any char  */
 			*mp++ = ANY;
@@ -344,6 +487,7 @@
 
 		case '[':               /* match char class */
 			*mp++ = CCL;
+			prevChar = 0;
 
 			i++;
 			if (*++p == '^') {
@@ -355,41 +499,89 @@
 
 			if (*p == '-') {	/* real dash */
 				i++;
+				prevChar = *p;
 				ChSet(*p++);
 			}
 			if (*p == ']') {	/* real brace */
 				i++;
+				prevChar = *p;
 				ChSet(*p++);
 			}
 			while (*p && *p != ']') {
-				if (*p == '-' && *(p+1) && *(p+1) != ']') {
-					i++;
-					p++;
-					c1 = *(p-2) + 1;
-					i++;
-					c2 = *p++;
-					while (c1 <= c2) {
-						ChSetWithCase(static_cast<char>(c1++), caseSensitive);
+				if (*p == '-') {
+					if (prevChar < 0) {
+						// Previous def. was a char class like \d, take dash literally
+						prevChar = *p;
+						ChSet(*p);
+					} else if (*(p+1)) {
+						if (*(p+1) != ']') {
+							c1 = prevChar + 1;
+							i++;
+							c2 = *++p;
+							if (c2 == '\\') {
+								if (!*(p+1))	// End of RE
+									return badpat("Missing ]");
+								else {
+									i++;
+									p++;
+									int incr;
+									c2 = GetBackslashExpression(p, incr);
+									i += incr;
+									p += incr;
+									if (c2 >= 0) {
+										// Convention: \c (c is any char) is case sensitive, whatever the option
+										ChSet(static_cast<unsigned char>(c2));
+										prevChar = c2;
+									} else {
+										// bittab is already changed
+										prevChar = -1;
+									}
+								}
+							}
+							if (prevChar < 0) {
+								// Char after dash is char class like \d, take dash literally
+								prevChar = '-';
+								ChSet('-');
+							} else {
+								// Put all chars between c1 and c2 included in the char set
+								while (c1 <= c2) {
+									ChSetWithCase(static_cast<unsigned char>(c1++), caseSensitive);
+								}
+							}
+						} else {
+							// Dash before the ], take it literally
+							prevChar = *p;
+							ChSet(*p);
+						}
+					} else {
+						return badpat("Missing ]");
 					}
 				} else if (*p == '\\' && *(p+1)) {
 					i++;
 					p++;
-					char escape = escapeValue(*p);
-					if (escape)
-						ChSetWithCase(escape, caseSensitive);
-					else
-						ChSetWithCase(*p, caseSensitive);
-					i++;
-					p++;
+					int incr;
+					int c = GetBackslashExpression(p, incr);
+					i += incr;
+					p += incr;
+					if (c >= 0) {
+						// Convention: \c (c is any char) is case sensitive, whatever the option
+						ChSet(static_cast<unsigned char>(c));
+						prevChar = c;
+					} else {
+						// bittab is already changed
+						prevChar = -1;
+					}
 				} else {
-					i++;
-					ChSetWithCase(*p++, caseSensitive);
+					prevChar = *p;
+					ChSetWithCase(*p, caseSensitive);
 				}
+				i++;
+				p++;
 			}
 			if (!*p)
 				return badpat("Missing ]");
 
-			for (n = 0; n < BITBLK; bittab[n++] = (char) 0)
+			for (n = 0; n < BITBLK; bittab[n++] = 0)
 				*mp++ = static_cast<char>(mask ^ bittab[n]);
 
 			break;
@@ -401,7 +593,7 @@
 			lp = sp;		/* previous opcode */
 			if (*lp == CLO)		/* equivalence... */
 				break;
-			switch(*lp) {
+			switch (*lp) {
 
 			case BOL:
 			case BOT:
@@ -429,8 +621,7 @@
 
 		case '\\':              /* tags, backrefs... */
 			i++;
-			switch(*++p) {
-
+			switch (*++p) {
 			case '<':
 				*mp++ = BOW;
 				break;
@@ -454,28 +645,16 @@
 				if (tagc > n) {
 					*mp++ = static_cast<char>(REF);
 					*mp++ = static_cast<char>(n);
-				}
-				else
+				} else
 					return badpat("Undetermined reference");
 				break;
-			case 'a':
-			case 'b':
-			case 'n':
-			case 'f':
-			case 'r':
-			case 't':
-			case 'v':
-				*mp++ = CHR;
-				*mp++ = escapeValue(*p);
-				break;
 			default:
 				if (!posix && *p == '(') {
 					if (tagc < MAXTAG) {
 						tagstk[++tagi] = tagc;
 						*mp++ = BOT;
 						*mp++ = static_cast<char>(tagc++);
-					}
-					else
+					} else
 						return badpat("Too many \\(\\) pairs");
 				} else if (!posix && *p == ')') {
 					if (*sp == BOT)
@@ -483,12 +662,22 @@
 					if (tagi > 0) {
 						*mp++ = static_cast<char>(EOT);
 						*mp++ = static_cast<char>(tagstk[tagi--]);
-					}
-					else
+					} else
 						return badpat("Unmatched \\)");
 				} else {
-					*mp++ = CHR;
-					*mp++ = *p;
+					int incr;
+					int c = GetBackslashExpression(p, incr);
+					i += incr;
+					p += incr;
+					if (c >= 0) {
+						*mp++ = CHR;
+						*mp++ = static_cast<unsigned char>(c);
+					} else {
+						*mp++ = CCL;
+						mask = 0;
+						for (n = 0; n < BITBLK; bittab[n++] = 0)
+							*mp++ = static_cast<char>(mask ^ bittab[n]);
+					}
 				}
 			}
 			break;
@@ -499,8 +688,7 @@
 					tagstk[++tagi] = tagc;
 					*mp++ = BOT;
 					*mp++ = static_cast<char>(tagc++);
-				}
-				else
+				} else
 					return badpat("Too many () pairs");
 			} else if (posix && *p == ')') {
 				if (*sp == BOT)
@@ -508,18 +696,22 @@
 				if (tagi > 0) {
 					*mp++ = static_cast<char>(EOT);
 					*mp++ = static_cast<char>(tagstk[tagi--]);
-				}
-				else
+				} else
 					return badpat("Unmatched )");
-			} else if (caseSensitive) {
-				*mp++ = CHR;
-				*mp++ = *p;
 			} else {
-				*mp++ = CCL;
-				mask = 0;
-				ChSetWithCase(*p, false);
-				for (n = 0; n < BITBLK; bittab[n++] = (char) 0)
-					*mp++ = static_cast<char>(mask ^ bittab[n]);
+				unsigned char c = *p;
+				if (!c)	// End of RE
+					c = '\\';	// We take it as raw backslash
+				if (caseSensitive || !iswordc(c)) {
+					*mp++ = CHR;
+					*mp++ = c;
+				} else {
+					*mp++ = CCL;
+					mask = 0;
+					ChSetWithCase(c, false);
+					for (n = 0; n < BITBLK; bittab[n++] = 0)
+						*mp++ = static_cast<char>(mask ^ bittab[n]);
+				}
 			}
 			break;
 		}
@@ -553,9 +745,8 @@
  *  respectively.
  *
  */
-
 int RESearch::Execute(CharacterIndexer &ci, int lp, int endp) {
-	char c;
+	unsigned char c;
 	int ep = NOTFOUND;
 	char *ap = nfa;
 
@@ -564,7 +755,7 @@
 
 	Clear();
 
-	switch(*ap) {
+	switch (*ap) {
 
 	case BOL:			/* anchored: match from BOL only */
 		ep = PMatch(ci, lp, endp, ap);
@@ -651,7 +842,7 @@
 	int are;	/* to save the line ptr.  */
 
 	while ((op = *ap++) != END)
-		switch(op) {
+		switch (op) {
 
 		case CHR:
 			if (ci.CharAt(lp++) != *ap++)
@@ -699,7 +890,7 @@
 			break;
 		case CLO:
 			are = lp;
-			switch(*ap) {
+			switch (*ap) {
 
 			case ANY:
 				while (lp < endp)
@@ -749,7 +940,7 @@
  *      tagged subpattern does not exist, null is substituted.
  */
 int RESearch::Substitute(CharacterIndexer &ci, char *src, char *dst) {
-	char c;
+	unsigned char c;
 	int  pin;
 	int bp;
 	int ep;
@@ -758,7 +949,7 @@
 		return 0;
 
 	while ((c = *src++) != 0) {
-		switch(c) {
+		switch (c) {
 
 		case '&':
 			pin = 0;
@@ -783,6 +974,7 @@
 				return 0;
 		}
 	}
-	*dst = (char) 0;
+	*dst = '\0';
 	return 1;
 }
+
Index: src/sdk/wxscintilla/src/scintilla/src/Partitioning.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/Partitioning.h	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/src/Partitioning.h	(revision 0)
@@ -0,0 +1,186 @@
+// Scintilla source code edit control
+/** @file Partitioning.h
+ ** Data structure used to partition an interval. Used for holding line start/end positions.
+ **/
+// Copyright 1998-2007 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#ifndef PARTITIONING_H
+#define PARTITIONING_H
+
+#include "SplitVector.h"
+
+/// A split vector of integers with a method for adding a value to all elements
+/// in a range.
+/// Used by the Partitioning class.
+
+class SplitVectorWithRangeAdd : public SplitVector<int> {
+public:
+	SplitVectorWithRangeAdd(int growSize_) {
+		SetGrowSize(growSize_);
+		ReAllocate(growSize_);
+	}
+	~SplitVectorWithRangeAdd() {
+	}
+	void RangeAddDelta(int start, int end, int delta) {
+		// end is 1 past end, so end-start is number of elements to change
+		int i = 0;
+		int rangeLength = end - start;
+		int range1Length = rangeLength;
+		int part1Left = part1Length - start;
+		if (range1Length > part1Left)
+			range1Length = part1Left;
+		while (i < range1Length) {
+			body[start++] += delta;
+			i++;
+		}
+		start += gapLength;
+		while (i < rangeLength) {
+			body[start++] += delta;
+			i++;
+		}
+	}
+};
+
+/// Divide an interval into multiple partitions.
+/// Useful for breaking a document down into sections such as lines.
+
+class Partitioning {
+private:
+	// To avoid calculating all the partition positions whenever any text is inserted
+	// there may be a step somewhere in the list.
+	int stepPartition;
+	int stepLength;
+	SplitVectorWithRangeAdd *body;
+
+	// Move step forward
+	void ApplyStep(int partitionUpTo) {
+		if (stepLength != 0) {
+			body->RangeAddDelta(stepPartition+1, partitionUpTo + 1, stepLength);
+		}
+		stepPartition = partitionUpTo;
+		if (stepPartition >= body->Length()-1) {
+			stepPartition = body->Length()-1;
+			stepLength = 0;
+		}
+	}
+
+	// Move step backward
+	void BackStep(int partitionDownTo) {
+		if (stepLength != 0) {
+			body->RangeAddDelta(partitionDownTo+1, stepPartition+1, -stepLength);
+		}
+		stepPartition = partitionDownTo;
+	}
+
+	void Allocate(int growSize) {
+		body = new SplitVectorWithRangeAdd(growSize);
+		stepPartition = 0;
+		stepLength = 0;
+		body->Insert(0, 0);	// This value stays 0 for ever
+		body->Insert(1, 0);	// This is the end of the first partition and will be the start of the second
+	}
+
+public:
+	Partitioning(int growSize) {
+		Allocate(growSize);
+	}
+
+	~Partitioning() {
+		delete body;
+		body = 0;
+	}
+
+	int Partitions() const {
+		return body->Length()-1;
+	}
+
+	void InsertPartition(int partition, int pos) {
+		if (stepPartition < partition) {
+			ApplyStep(partition);
+		}
+		body->Insert(partition, pos);
+		stepPartition++;
+	}
+
+	void SetPartitionStartPosition(int partition, int pos) {
+		ApplyStep(partition+1);
+		if ((partition < 0) || (partition > body->Length())) {
+			return;
+		}
+		body->SetValueAt(partition, pos);
+	}
+
+	void InsertText(int partitionInsert, int delta) {
+		// Point all the partitions after the insertion point further along in the buffer
+		if (stepLength != 0) {
+			if (partitionInsert >= stepPartition) {
+				// Fill in up to the new insertion point
+				ApplyStep(partitionInsert);
+				stepLength += delta;
+			} else if (partitionInsert >= (stepPartition - body->Length() / 10)) {
+				// Close to step but before so move step back
+				BackStep(partitionInsert);
+				stepLength += delta;
+			} else {
+				ApplyStep(body->Length()-1);
+				stepPartition = partitionInsert;
+				stepLength = delta;
+			}
+		} else {
+			stepPartition = partitionInsert;
+			stepLength = delta;
+		}
+	}
+
+	void RemovePartition(int partition) {
+		if (partition > stepPartition) {
+			ApplyStep(partition);
+			stepPartition--;
+		} else {
+			stepPartition--;
+		}
+		body->Delete(partition);
+	}
+
+	int PositionFromPartition(int partition) const {
+		PLATFORM_ASSERT(partition >= 0);
+		PLATFORM_ASSERT(partition < body->Length());
+		if ((partition < 0) || (partition >= body->Length())) {
+			return 0;
+		}
+		int pos = body->ValueAt(partition);
+		if (partition > stepPartition)
+			pos += stepLength;
+		return pos;
+	}
+
+	int PartitionFromPosition(int pos) {
+		if (body->Length() <= 1)
+			return 0;
+		if (pos >= (PositionFromPartition(body->Length()-1)))
+			return body->Length() - 1 - 1;
+		int lower = 0;
+		int upper = body->Length()-1;
+		do {
+			int middle = (upper + lower + 1) / 2; 	// Round high
+			int posMiddle = body->ValueAt(middle);
+			if (middle > stepPartition)
+				posMiddle += stepLength;
+			if (pos < posMiddle) {
+				upper = middle - 1;
+			} else {
+				lower = middle;
+			}
+		} while (lower < upper);
+		return lower;
+	}
+
+	void DeleteAll() {
+		int growSize = body->GetGrowSize();
+		delete body;
+		Allocate(growSize);
+	}
+};
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/RunStyles.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/RunStyles.h	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/src/RunStyles.h	(revision 0)
@@ -0,0 +1,53 @@
+/** @file RunStyles.h
+ ** Data structure used to store sparse styles.
+ **/
+// Copyright 1998-2007 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#ifndef RUNSTYLES_H
+#define RUNSTYLES_H
+
+/// Styling buffer using one element for each run rather than using
+/// a filled buffer.
+
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
+class Partitioning;
+template<class T> class SplitVector;
+
+class RunStyles {
+public:
+	Partitioning *starts;
+	SplitVector<int> *styles;
+	int RunFromPosition(int position);
+	int SplitRun(int position);
+	void RemoveRun(int run);
+	void RemoveRunIfEmpty(int run);
+	void RemoveRunIfSameAsPrevious(int run);
+public:
+	RunStyles();
+	~RunStyles();
+	int Length() const;
+	int ValueAt(int position) const;
+	int FindNextChange(int position, int end);
+	int StartRun(int position);
+	int EndRun(int position);
+	// Returns true if some values may have changed
+	bool FillRange(int &position, int value, int &fillLength);
+	void SetValueAt(int position, int value);
+	void InsertSpace(int position, int insertLength);
+	void DeleteAll();
+	void DeleteRange(int position, int deleteLength);
+
+	char *PersistantForm() const;
+	void FromPersistant(const char *form);
+	static bool PersistantSame(const char *form1, const char *form2);
+};
+
+#ifdef SCI_NAMESPACE
+}
+#endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/LexPLM.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexPLM.cxx	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/src/LexPLM.cxx	(revision 0)
@@ -0,0 +1,198 @@
+// Copyright (c) 1990-2007, Scientific Toolworks, Inc.
+// Author: Jason Haslam
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Platform.h"
+
+#include "PropSet.h"
+#include "Accessor.h"
+#include "KeyWords.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+#include "StyleContext.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+static void GetRange(unsigned int start,
+                     unsigned int end,
+                     Accessor &styler,
+                     char *s,
+                     unsigned int len) {
+	unsigned int i = 0;
+	while ((i < end - start + 1) && (i < len-1)) {
+		s[i] = static_cast<char>(tolower(styler[start + i]));
+		i++;
+	}
+	s[i] = '\0';
+}
+
+static void ColourisePlmDoc(unsigned int startPos,
+                            int length,
+                            int initStyle,
+                            WordList *keywordlists[],
+                            Accessor &styler)
+{
+	unsigned int endPos = startPos + length;
+	int state = initStyle;
+
+	styler.StartAt(startPos);
+	styler.StartSegment(startPos);
+
+	for (unsigned int i = startPos; i < endPos; i++) {
+		char ch = styler.SafeGetCharAt(i);
+		char chNext = styler.SafeGetCharAt(i + 1);
+
+		if (state == SCE_PLM_DEFAULT) {
+			if (ch == '/' && chNext == '*') {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_COMMENT;
+			} else if (ch == '\'') {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_STRING;
+			} else if (isdigit(ch)) {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_NUMBER;
+			} else if (isalpha(ch)) {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_IDENTIFIER;
+			} else if (ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
+			           ch == '=' || ch == '<' || ch == '>' || ch == ':') {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_OPERATOR;
+			} else if (ch == '$') {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_CONTROL;
+			}
+		} else if (state == SCE_PLM_COMMENT) {
+			if (ch == '*' && chNext == '/') {
+				i++;
+				styler.ColourTo(i, state);
+				state = SCE_PLM_DEFAULT;
+			}
+		} else if (state == SCE_PLM_STRING) {
+			if (ch == '\'') {
+				if (chNext == '\'') {
+					i++;
+				} else {
+					styler.ColourTo(i, state);
+					state = SCE_PLM_DEFAULT;
+				}
+			}
+		} else if (state == SCE_PLM_NUMBER) {
+			if (!isdigit(ch) && !isalpha(ch) && ch != '$') {
+				i--;
+				styler.ColourTo(i, state);
+				state = SCE_PLM_DEFAULT;
+			}
+		} else if (state == SCE_PLM_IDENTIFIER) {
+			if (!isdigit(ch) && !isalpha(ch) && ch != '$') {
+				// Get the entire identifier.
+				char word[1024];
+				int segmentStart = styler.GetStartSegment();
+				GetRange(segmentStart, i - 1, styler, word, sizeof(word));
+
+				i--;
+				if (keywordlists[0]->InList(word))
+					styler.ColourTo(i, SCE_PLM_KEYWORD);
+				else
+					styler.ColourTo(i, state);
+				state = SCE_PLM_DEFAULT;
+			}
+		} else if (state == SCE_PLM_OPERATOR) {
+			if (ch != '=' && ch != '>') {
+				i--;
+				styler.ColourTo(i, state);
+				state = SCE_PLM_DEFAULT;
+			}
+		} else if (state == SCE_PLM_CONTROL) {
+			if (ch == '\r' || ch == '\n') {
+				styler.ColourTo(i - 1, state);
+				state = SCE_PLM_DEFAULT;
+			}
+		}
+	}
+	styler.ColourTo(endPos - 1, state);
+}
+
+static void FoldPlmDoc(unsigned int startPos,
+                       int length,
+                       int initStyle,
+                       WordList *[],
+                       Accessor &styler)
+{
+	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+	unsigned int endPos = startPos + length;
+	int visibleChars = 0;
+	int lineCurrent = styler.GetLine(startPos);
+	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
+	int levelCurrent = levelPrev;
+	char chNext = styler[startPos];
+	int styleNext = styler.StyleAt(startPos);
+	int style = initStyle;
+	int startKeyword = 0;
+
+	for (unsigned int i = startPos; i < endPos; i++) {
+		char ch = chNext;
+		chNext = styler.SafeGetCharAt(i + 1);
+		int stylePrev = style;
+		style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+
+		if (stylePrev != SCE_PLM_KEYWORD && style == SCE_PLM_KEYWORD)
+			startKeyword = i;
+
+		if (style == SCE_PLM_KEYWORD && styleNext != SCE_PLM_KEYWORD) {
+			char word[1024];
+			GetRange(startKeyword, i, styler, word, sizeof(word));
+
+			if (strcmp(word, "procedure") == 0 || strcmp(word, "do") == 0)
+				levelCurrent++;
+			else if (strcmp(word, "end") == 0)
+				levelCurrent--;
+		}
+
+		if (foldComment) {
+			if (stylePrev != SCE_PLM_COMMENT && style == SCE_PLM_COMMENT)
+				levelCurrent++;
+			else if (stylePrev == SCE_PLM_COMMENT && style != SCE_PLM_COMMENT)
+				levelCurrent--;
+		}
+
+		if (atEOL) {
+			int lev = levelPrev;
+			if (visibleChars == 0 && foldCompact)
+				lev |= SC_FOLDLEVELWHITEFLAG;
+			if ((levelCurrent > levelPrev) && (visibleChars > 0))
+				lev |= SC_FOLDLEVELHEADERFLAG;
+			if (lev != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, lev);
+			}
+			lineCurrent++;
+			levelPrev = levelCurrent;
+			visibleChars = 0;
+		}
+
+		if (!isspacechar(ch))
+			visibleChars++;
+	}
+
+	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
+	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
+}
+
+static const char *const plmWordListDesc[] = {
+	"Keywords",
+	0
+};
+
+LexerModule lmPLM(SCLEX_PLM, ColourisePlmDoc, "PL/M", FoldPlmDoc, plmWordListDesc);
Index: src/sdk/wxscintilla/src/scintilla/src/LexOpal.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexOpal.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexOpal.cxx	(working copy)
@@ -19,6 +19,10 @@
 #include "SciLexer.h"
 #include "StyleContext.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 inline static void getRange( unsigned int start, unsigned int end, Accessor & styler, char * s, unsigned int len )
 {
 	unsigned int i = 0;
Index: src/sdk/wxscintilla/src/scintilla/src/LexFlagship.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexFlagship.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexFlagship.cxx	(working copy)
@@ -22,6 +22,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static bool IsFlagShipComment(Accessor &styler, int pos, int len) {
 	return len>0 && styler[pos]=='\'';
 }
Index: src/sdk/wxscintilla/src/scintilla/src/LexScriptol.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexScriptol.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexScriptol.cxx	(working copy)
@@ -17,6 +17,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static void ClassifyWordSol(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler, char *prevWord)
 {
     char s[100];
Index: src/sdk/wxscintilla/src/scintilla/src/LexMatlab.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexMatlab.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexMatlab.cxx	(working copy)
@@ -25,6 +25,9 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
 
 static bool IsMatlabCommentChar(int c) {
 	return (c == '%') ;
@@ -100,11 +103,19 @@
 				transpose = true;
 			}
 		} else if (sc.state == SCE_MATLAB_STRING) {
-			if (sc.ch == '\'' && sc.chPrev != '\\') {
+			if (sc.ch == '\\') {
+				if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
+					sc.Forward();
+				}
+			} else if (sc.ch == '\'') {
 				sc.ForwardSetState(SCE_MATLAB_DEFAULT);
 			}
 		} else if (sc.state == SCE_MATLAB_DOUBLEQUOTESTRING) {
-			if (sc.ch == '"' && sc.chPrev != '\\') {
+			if (sc.ch == '\\') {
+				if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
+					sc.Forward();
+				}
+			} else if (sc.ch == '\"') {
 				sc.ForwardSetState(SCE_MATLAB_DEFAULT);
 			}
 		} else if (sc.state == SCE_MATLAB_COMMENT || sc.state == SCE_MATLAB_COMMAND) {
@@ -126,7 +137,7 @@
 					sc.SetState(SCE_MATLAB_STRING);
 				}
 			} else if (sc.ch == '"') {
-              sc.SetState(SCE_MATLAB_DOUBLEQUOTESTRING);
+				sc.SetState(SCE_MATLAB_DOUBLEQUOTESTRING);
 			} else if (isdigit(sc.ch) || (sc.ch == '.' && isdigit(sc.chNext))) {
 				sc.SetState(SCE_MATLAB_NUMBER);
 			} else if (isalpha(sc.ch)) {
@@ -148,17 +159,17 @@
 
 static void ColouriseMatlabDoc(unsigned int startPos, int length, int initStyle,
                                WordList *keywordlists[], Accessor &styler) {
-  ColouriseMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsMatlabCommentChar);
+	ColouriseMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsMatlabCommentChar);
 }
 
 static void ColouriseOctaveDoc(unsigned int startPos, int length, int initStyle,
                                WordList *keywordlists[], Accessor &styler) {
-  ColouriseMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveCommentChar);
+	ColouriseMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveCommentChar);
 }
 
 static void FoldMatlabOctaveDoc(unsigned int startPos, int length, int,
-                          WordList *[], Accessor &styler,
-                          bool (*IsComment)(Accessor&,int,int)) {
+                                WordList *[], Accessor &styler,
+                                bool (*IsComment)(Accessor&, int, int)) {
 
 	int endPos = startPos + length;
 
@@ -202,12 +213,12 @@
 
 static void FoldMatlabDoc(unsigned int startPos, int length, int initStyle,
                           WordList *keywordlists[], Accessor &styler) {
-  FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsMatlabComment);
+	FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsMatlabComment);
 }
 
 static void FoldOctaveDoc(unsigned int startPos, int length, int initStyle,
                           WordList *keywordlists[], Accessor &styler) {
-  FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveComment);
+	FoldMatlabOctaveDoc(startPos, length, initStyle, keywordlists, styler, IsOctaveComment);
 }
 
 static const char * const matlabWordListDesc[] = {
Index: src/sdk/wxscintilla/src/scintilla/src/LexPB.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexPB.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexPB.cxx	(working copy)
@@ -48,6 +48,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static inline bool IsTypeCharacter(const int ch)
 {
     return ch == '%' || ch == '&' || ch == '@' || ch == '!' || ch == '#' || ch == '$' || ch == '?';
Index: src/sdk/wxscintilla/src/scintilla/src/LexBullant.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexBullant.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexBullant.cxx	(working copy)
@@ -15,6 +15,9 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
 
 static int classifyWordBullant(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler) {
 	char s[100];
Index: src/sdk/wxscintilla/src/scintilla/src/SVector.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/SVector.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/SVector.h	(working copy)
@@ -8,6 +8,10 @@
 #ifndef SVECTOR_H
 #define SVECTOR_H
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 /**
  * A simple expandable integer vector.
  * Storage not allocated for elements until an element is used.
@@ -124,4 +128,8 @@
 	}
 };
 
+#ifdef SCI_NAMESPACE
+}
 #endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/LexRebol.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexRebol.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexRebol.cxx	(working copy)
@@ -26,6 +26,9 @@
 #include "SciLexer.h"
 #include "StyleContext.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
 
 static inline bool IsAWordChar(const int ch) {
 	return (isalnum(ch) || ch == '?' || ch == '!' || ch == '.' || ch == '\'' || ch == '+' || ch == '-' || ch == '*' || ch == '&' || ch == '|' || ch == '=' || ch == '_' || ch == '~');
Index: src/sdk/wxscintilla/src/scintilla/src/Decoration.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/Decoration.h	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/src/Decoration.h	(revision 0)
@@ -0,0 +1,64 @@
+/** @file Decoration.h
+ ** Visual elements added over text.
+ **/
+// Copyright 1998-2007 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#ifndef DECORATION_H
+#define DECORATION_H
+
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
+class Decoration {
+public:
+	Decoration *next;
+	RunStyles rs;
+	int indicator;
+
+	Decoration(int indicator_);
+	~Decoration();
+
+	bool Empty();
+};
+
+class DecorationList {
+	int currentIndicator;
+	int currentValue;
+	Decoration *current;
+	int lengthDocument;
+	Decoration *DecorationFromIndicator(int indicator);
+	Decoration *Create(int indicator, int length);
+	void Delete(int indicator);
+	void DeleteAnyEmpty();
+public:
+	Decoration *root;
+	bool clickNotified;
+
+	DecorationList();
+	~DecorationList();
+
+	void SetCurrentIndicator(int indicator);
+	int GetCurrentIndicator() { return currentIndicator; }
+
+	void SetCurrentValue(int value);
+	int GetCurrentValue() { return currentValue; }
+
+	// Returns true if some values may have changed
+	bool FillRange(int &position, int value, int &fillLength);
+
+	void InsertSpace(int position, int insertLength);
+	void DeleteRange(int position, int deleteLength);
+
+	int AllOnFor(int position);
+	int ValueAt(int indicator, int position);
+	int Start(int indicator, int position);
+	int End(int indicator, int position);
+};
+
+#ifdef SCI_NAMESPACE
+}
+#endif
+
+#endif
Index: src/sdk/wxscintilla/src/scintilla/src/LexHTML.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexHTML.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexHTML.cxx	(working copy)
@@ -19,7 +19,12 @@
 #include "KeyWords.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
+#include "CharacterSet.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 #define SCE_HA_JS (SCE_HJA_START - SCE_HJ_START)
 #define SCE_HA_VBS (SCE_HBA_START - SCE_HB_START)
 #define SCE_HA_PYTHON (SCE_HPA_START - SCE_HP_START)
@@ -35,6 +40,20 @@
 	return (ch < 0x80) && (isalnum(ch) || ch == '_');
 }
 
+inline bool IsOperator(int ch) {
+	if (isascii(ch) && isalnum(ch))
+		return false;
+	// '.' left out as it is used to make up numbers
+	if (ch == '%' || ch == '^' || ch == '&' || ch == '*' ||
+	        ch == '(' || ch == ')' || ch == '-' || ch == '+' ||
+	        ch == '=' || ch == '|' || ch == '{' || ch == '}' ||
+	        ch == '[' || ch == ']' || ch == ':' || ch == ';' ||
+	        ch == '<' || ch == '>' || ch == ',' || ch == '/' ||
+	        ch == '?' || ch == '!' || ch == '.' || ch == '~')
+		return true;
+	return false;
+}
+
 static inline int MakeLowerCase(int ch) {
 	if (ch < 'A' || ch > 'Z')
 		return ch;
@@ -66,8 +85,15 @@
 		return eScriptJS;
 	if (strstr(s, "php"))
 		return eScriptPHP;
-	if (strstr(s, "xml"))
+	if (strstr(s, "xml")) {
+		const char *xml = strstr(s, "xml");
+		for (const char *t=s; t<xml; t++) {
+			if (!IsASpace(*t)) {
+				return prevValue;
+			}
+		}
 		return eScriptXML;
+	}
 
 	return prevValue;
 }
@@ -102,16 +128,16 @@
 }
 
 static int statePrintForState(int state, script_mode inScriptType) {
-	int StateToPrint;
+	int StateToPrint = state;
 
-	if ((state >= SCE_HP_START) && (state <= SCE_HP_IDENTIFIER)) {
-		StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_PYTHON);
-	} else if ((state >= SCE_HB_START) && (state <= SCE_HB_STRINGEOL)) {
-		StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_VBS);
-	} else if ((state >= SCE_HJ_START) && (state <= SCE_HJ_REGEX)) {
-		StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_JS);
-	} else {
-		StateToPrint = state;
+	if (state >= SCE_HJ_START) {
+		if ((state >= SCE_HP_START) && (state <= SCE_HP_IDENTIFIER)) {
+			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_PYTHON);
+		} else if ((state >= SCE_HB_START) && (state <= SCE_HB_STRINGEOL)) {
+			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_VBS);
+		} else if ((state >= SCE_HJ_START) && (state <= SCE_HJ_REGEX)) {
+			StateToPrint = state + ((inScriptType == eNonHtmlScript) ? 0 : SCE_HA_JS);
+		}
 	}
 
 	return StateToPrint;
@@ -173,6 +199,7 @@
 	bool allowTermination = !isStringState(state);
 	if (allowTermination) {
 		switch (state) {
+		case SCE_HB_COMMENTLINE:
 		case SCE_HPHP_COMMENT:
 		case SCE_HP_COMMENTLINE:
 		case SCE_HPA_COMMENTLINE:
@@ -222,7 +249,7 @@
 
 static int classifyTagHTML(unsigned int start, unsigned int end,
                            WordList &keywords, Accessor &styler, bool &tagDontFold,
-			   bool caseSensitive) {
+			   bool caseSensitive, bool isXml) {
 	char s[30 + 2];
 	// Copy after the '<'
 	unsigned int i = 0;
@@ -238,9 +265,10 @@
 	s[i] = ' ';
 	s[i+1] = '\0';
 
+	// if the current language is XML, I can fold any tag
+	// if the current language is HTML, I don't want to fold certain tags (input, meta, etc.)
 	//...to find it in the list of no-container-tags
-	// (There are many more. We will need a keywordlist in the property file for this)
-	tagDontFold = (NULL != strstr("meta link img area br hr input ",s));
+	tagDontFold = (!isXml) && (NULL != strstr("meta link img area br hr input ",s));
 
 	//now we can remove the trailing space
 	s[i] = '\0';
@@ -390,21 +418,21 @@
 	return Result;
 }
 
-static inline bool ishtmlwordchar(char ch) {
+static inline bool ishtmlwordchar(int ch) {
 	return !isascii(ch) ||
 		(isalnum(ch) || ch == '.' || ch == '-' || ch == '_' || ch == ':' || ch == '!' || ch == '#');
 }
 
-static inline bool issgmlwordchar(char ch) {
+static inline bool issgmlwordchar(int ch) {
 	return !isascii(ch) ||
 		(isalnum(ch) || ch == '.' || ch == '_' || ch == ':' || ch == '!' || ch == '#' || ch == '[');
 }
 
-static inline bool IsPhpWordStart(const unsigned char ch) {
+static inline bool IsPhpWordStart(int ch) {
 	return (isascii(ch) && (isalpha(ch) || (ch == '_'))) || (ch >= 0x7f);
 }
 
-static inline bool IsPhpWordChar(char ch) {
+static inline bool IsPhpWordChar(int ch) {
 	return IsADigit(ch) || IsPhpWordStart(ch);
 }
 
@@ -425,11 +453,11 @@
 		   state == SCE_HJA_COMMENTLINE || state == SCE_HB_COMMENTLINE || state == SCE_HBA_COMMENTLINE;
 }
 
-static bool isLineEnd(char ch) {
+static bool isLineEnd(int ch) {
 	return ch == '\r' || ch == '\n';
 }
 
-static bool isOKBeforeRE(char ch) {
+static bool isOKBeforeRE(int ch) {
 	return (ch == '(') || (ch == '=') || (ch == ',');
 }
 
@@ -457,7 +485,7 @@
 }
 
 static void ColouriseHyperTextDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
-                                  Accessor &styler) {
+                                  Accessor &styler, bool isXml) {
 	WordList &keywords = *keywordlists[0];
 	WordList &keywords2 = *keywordlists[1];
 	WordList &keywords3 = *keywordlists[2];
@@ -465,8 +493,8 @@
 	WordList &keywords5 = *keywordlists[4];
 	WordList &keywords6 = *keywordlists[5]; // SGML (DTD) keywords
 
-	// Lexer for HTML requires more lexical states (7 bits worth) than most lexers
-	styler.StartAt(startPos, STYLE_MAX);
+	// Lexer for HTML requires more lexical states (8 bits worth) than most lexers
+	styler.StartAt(startPos, static_cast<char>(STYLE_MAX));
 	char prevWord[200];
 	prevWord[0] = '\0';
 	char phpStringDelimiter[200]; // PHP is not limited in length, we are
@@ -488,7 +516,7 @@
 		length++;
 		state = styler.StyleAt(startPos);
 	}
-	styler.StartAt(startPos, STYLE_MAX);
+	styler.StartAt(startPos, static_cast<char>(STYLE_MAX));
 
 	int lineCurrent = styler.GetLine(startPos);
 	int lineState;
@@ -515,13 +543,17 @@
 	const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
 	const bool caseSensitive = styler.GetPropertyInt("html.tags.case.sensitive", 0) != 0;
 
+	const CharacterSet setHTMLWord(CharacterSet::setAlphaNum, ".-_:!#", 0x80, true);
+	const CharacterSet setTagContinue(CharacterSet::setAlphaNum, ".-_:!#[", 0x80, true);
+	const CharacterSet setAttributeContinue(CharacterSet::setAlphaNum, ".-_:!#/", 0x80, true);
+
 	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
 	int levelCurrent = levelPrev;
 	int visibleChars = 0;
 
-	char chPrev = ' ';
-	char ch = ' ';
-	char chPrevNonWhite = ' ';
+	int chPrev = ' ';
+	int ch = ' ';
+	int chPrevNonWhite = ' ';
 	// look back to set chPrevNonWhite properly for better regex colouring
 	if (scriptLanguage == eScriptJS && startPos > 0) {
 		int back = startPos;
@@ -533,30 +565,30 @@
 				break;
 		}
 		if (style == SCE_HJ_SYMBOLS) {
-			chPrevNonWhite = styler.SafeGetCharAt(back);
+			chPrevNonWhite = static_cast<unsigned char>(styler.SafeGetCharAt(back));
 		}
 	}
 
 	styler.StartSegment(startPos);
 	const int lengthDoc = startPos + length;
 	for (int i = startPos; i < lengthDoc; i++) {
-		const char chPrev2 = chPrev;
+		const int chPrev2 = chPrev;
 		chPrev = ch;
-		if (!isspacechar(ch) && state != SCE_HJ_COMMENT &&
+		if (!IsASpace(ch) && state != SCE_HJ_COMMENT &&
 			state != SCE_HJ_COMMENTLINE && state != SCE_HJ_COMMENTDOC)
 			chPrevNonWhite = ch;
-		ch = styler[i];
-		char chNext = styler.SafeGetCharAt(i + 1);
-		const char chNext2 = styler.SafeGetCharAt(i + 2);
+		ch = static_cast<unsigned char>(styler[i]);
+		int chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
+		const int chNext2 = static_cast<unsigned char>(styler.SafeGetCharAt(i + 2));
 
 		// Handle DBCS codepages
-		if (styler.IsLeadByte(ch)) {
+		if (styler.IsLeadByte(static_cast<char>(ch))) {
 			chPrev = ' ';
 			i += 1;
 			continue;
 		}
 
-		if ((!isspacechar(ch) || !foldCompact) && fold)
+		if ((!IsASpace(ch) || !foldCompact) && fold)
 			visibleChars++;
 
 		// decide what is the current state to print (depending of the script tag)
@@ -644,22 +676,24 @@
 			case SCE_HJ_COMMENTDOC:
 			//case SCE_HJ_COMMENTLINE: // removed as this is a common thing done to hide
 			// the end of script marker from some JS interpreters.
+			case SCE_HB_COMMENTLINE:
+			case SCE_HBA_COMMENTLINE:
 			case SCE_HJ_DOUBLESTRING:
 			case SCE_HJ_SINGLESTRING:
 			case SCE_HJ_REGEX:
 			case SCE_HB_STRING:
+			case SCE_HBA_STRING:
 			case SCE_HP_STRING:
 			case SCE_HP_TRIPLE:
 			case SCE_HP_TRIPLEDOUBLE:
 				break;
 			default :
 				// check if the closing tag is a script tag
-				if (state == SCE_HJ_COMMENTLINE) {
+				if (state == SCE_HJ_COMMENTLINE || isXml) {
 					char tag[7]; // room for the <script> tag
-					char chr;	// current char
-					int j=0;
-					chr = styler.SafeGetCharAt(i+2);
-					while (j < 6 && !isspacechar(chr)) {
+					int j = 0;
+					char chr = styler.SafeGetCharAt(i+2);
+					while (j < 6 && !IsASpace(chr)) {
 						tag[j++] = static_cast<char>(MakeLowerCase(chr));
 						chr = styler.SafeGetCharAt(i+2+j);
 					}
@@ -708,7 +742,7 @@
 				levelCurrent++;
 			}
 			// should be better
-			ch = styler.SafeGetCharAt(i);
+			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
 			continue;
 		}
 
@@ -747,7 +781,7 @@
 			if (foldHTMLPreprocessor)
 				levelCurrent++;
 			// should be better
-			ch = styler.SafeGetCharAt(i);
+			ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
 			continue;
 		}
 
@@ -862,7 +896,9 @@
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_H_SGML_SIMPLESTRING;
 			} else if ((ch == '-') && (chPrev == '-')) {
-				styler.ColourTo(i - 2, StateToPrint);
+				if (static_cast<int>(styler.GetStartSegment()) <= (i - 2)) {
+					styler.ColourTo(i - 2, StateToPrint);
+				}
 				state = SCE_H_SGML_COMMENT;
 			} else if (isascii(ch) && isalpha(ch) && (chPrev == '%')) {
 				styler.ColourTo(i - 2, StateToPrint);
@@ -924,12 +960,12 @@
 				}
 				// find the length of the word
 				int size = 1;
-				while (ishtmlwordchar(styler.SafeGetCharAt(i + size)))
+				while (setHTMLWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(i + size))))
 					size++;
 				styler.ColourTo(i + size - 1, StateToPrint);
 				i += size - 1;
 				visibleChars += size - 1;
-				ch = styler.SafeGetCharAt(i);
+				ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
 				if (scriptLanguage == eScriptSGMLblock) {
 					state = SCE_H_SGML_BLOCK_DEFAULT;
 				} else {
@@ -1012,9 +1048,9 @@
 			}
 			break;
 		case SCE_H_TAGUNKNOWN:
-			if (!ishtmlwordchar(ch) && !((ch == '/') && (chPrev == '<')) && ch != '[') {
+			if (!setTagContinue.Contains(ch) && !((ch == '/') && (chPrev == '<'))) {
 				int eClass = classifyTagHTML(styler.GetStartSegment(),
-					i - 1, keywords, styler, tagDontFold, caseSensitive);
+					i - 1, keywords, styler, tagDontFold, caseSensitive, isXml);
 				if (eClass == SCE_H_SCRIPT) {
 					if (!tagClosing) {
 						inScriptType = eNonHtmlScript;
@@ -1064,7 +1100,7 @@
 			}
 			break;
 		case SCE_H_ATTRIBUTE:
-			if (!ishtmlwordchar(ch) && ch != '/' && ch != '-') {
+			if (!setAttributeContinue.Contains(ch)) {
 				if (inScriptType == eNonHtmlScript) {
 					int scriptLanguagePrev = scriptLanguage;
 					clientScript = segIsScriptingIndicator(styler, styler.GetStartSegment(), i - 1, scriptLanguage);
@@ -1137,7 +1173,7 @@
 				i++;
 				ch = chNext;
 				state = SCE_H_DEFAULT;
-			} else if (ishtmlwordchar(ch)) {
+			} else if (setHTMLWord.Contains(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_H_ATTRIBUTE;
 			}
@@ -1161,7 +1197,7 @@
 			}
 			break;
 		case SCE_H_VALUE:
-			if (!ishtmlwordchar(ch)) {
+			if (!setHTMLWord.Contains(ch)) {
 				if (ch == '\"' && chPrev == '=') {
 					// Should really test for being first character
 					state = SCE_H_DOUBLESTRING;
@@ -1198,7 +1234,7 @@
 		case SCE_HJ_DEFAULT:
 		case SCE_HJ_START:
 		case SCE_HJ_SYMBOLS:
-			if (iswordstart(ch)) {
+			if (IsAWordStart(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_HJ_WORD;
 			} else if (ch == '/' && chNext == '*') {
@@ -1227,7 +1263,7 @@
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_HJ_COMMENTLINE;
 				i += 2;
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
 				state = SCE_HJ_DEFAULT;
@@ -1239,7 +1275,7 @@
 			}
 			break;
 		case SCE_HJ_WORD:
-			if (!iswordchar(ch)) {
+			if (!IsAWordChar(ch)) {
 				classifyWordHTJS(styler.GetStartSegment(), i - 1, keywords2, styler, inScriptType);
 				//styler.ColourTo(i - 1, eHTJSKeyword);
 				state = SCE_HJ_DEFAULT;
@@ -1258,7 +1294,7 @@
 					styler.ColourTo(i - 1, StateToPrint);
 					state = SCE_HJ_COMMENTLINE;
 					i += 2;
-				} else if (isoperator(ch)) {
+				} else if (IsOperator(ch)) {
 					styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
 					state = SCE_HJ_DEFAULT;
 				}
@@ -1328,7 +1364,7 @@
 					while (isascii(chNext) && islower(chNext)) {   // gobble regex flags
 						i++;
 						ch = chNext;
-						chNext = styler.SafeGetCharAt(i + 1);
+						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 					}
 				}
 				styler.ColourTo(i, StateToPrint);
@@ -1338,13 +1374,13 @@
 				if (chNext == '\\' || chNext == '/') {
 					i++;
 					ch = chNext;
-					chNext = styler.SafeGetCharAt(i + 1);
+					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 				}
 			}
 			break;
 		case SCE_HB_DEFAULT:
 		case SCE_HB_START:
-			if (iswordstart(ch)) {
+			if (IsAWordStart(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_HB_WORD;
 			} else if (ch == '\'') {
@@ -1357,7 +1393,7 @@
 			           styler.SafeGetCharAt(i + 3) == '-') {
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_HB_COMMENTLINE;
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				styler.ColourTo(i, statePrintForState(SCE_HB_DEFAULT, inScriptType));
 				state = SCE_HB_DEFAULT;
@@ -1369,14 +1405,14 @@
 			}
 			break;
 		case SCE_HB_WORD:
-			if (!iswordchar(ch)) {
+			if (!IsAWordChar(ch)) {
 				state = classifyWordHTVB(styler.GetStartSegment(), i - 1, keywords3, styler, inScriptType);
 				if (state == SCE_HB_DEFAULT) {
 					if (ch == '\"') {
 						state = SCE_HB_STRING;
 					} else if (ch == '\'') {
 						state = SCE_HB_COMMENTLINE;
-					} else if (isoperator(ch)) {
+					} else if (IsOperator(ch)) {
 						styler.ColourTo(i, statePrintForState(SCE_HB_DEFAULT, inScriptType));
 						state = SCE_HB_DEFAULT;
 					}
@@ -1409,7 +1445,7 @@
 			break;
 		case SCE_HP_DEFAULT:
 		case SCE_HP_START:
-			if (iswordstart(ch)) {
+			if (IsAWordStart(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_HP_WORD;
 			} else if ((ch == '<') && (chNext == '!') && (chNext2 == '-') &&
@@ -1426,7 +1462,7 @@
 					state = SCE_HP_TRIPLEDOUBLE;
 					ch = ' ';
 					chPrev = ' ';
-					chNext = styler.SafeGetCharAt(i + 1);
+					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 				} else {
 					//					state = statePrintForState(SCE_HP_STRING,inScriptType);
 					state = SCE_HP_STRING;
@@ -1438,11 +1474,11 @@
 					state = SCE_HP_TRIPLE;
 					ch = ' ';
 					chPrev = ' ';
-					chNext = styler.SafeGetCharAt(i + 1);
+					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 				} else {
 					state = SCE_HP_CHARACTER;
 				}
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				styler.ColourTo(i - 1, StateToPrint);
 				styler.ColourTo(i, statePrintForState(SCE_HP_OPERATOR, inScriptType));
 			} else if ((ch == ' ') || (ch == '\t')) {
@@ -1453,7 +1489,7 @@
 			}
 			break;
 		case SCE_HP_WORD:
-			if (!iswordchar(ch)) {
+			if (!IsAWordChar(ch)) {
 				classifyWordHTPy(styler.GetStartSegment(), i - 1, keywords4, styler, prevWord, inScriptType);
 				state = SCE_HP_DEFAULT;
 				if (ch == '#') {
@@ -1464,7 +1500,7 @@
 						state = SCE_HP_TRIPLEDOUBLE;
 						ch = ' ';
 						chPrev = ' ';
-						chNext = styler.SafeGetCharAt(i + 1);
+						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 					} else {
 						state = SCE_HP_STRING;
 					}
@@ -1474,11 +1510,11 @@
 						state = SCE_HP_TRIPLE;
 						ch = ' ';
 						chPrev = ' ';
-						chNext = styler.SafeGetCharAt(i + 1);
+						chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 					} else {
 						state = SCE_HP_CHARACTER;
 					}
-				} else if (isoperator(ch)) {
+				} else if (IsOperator(ch)) {
 					styler.ColourTo(i, statePrintForState(SCE_HP_OPERATOR, inScriptType));
 				}
 			}
@@ -1494,7 +1530,7 @@
 				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
 					i++;
 					ch = chNext;
-					chNext = styler.SafeGetCharAt(i + 1);
+					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 				}
 			} else if (ch == '\"') {
 				styler.ColourTo(i, StateToPrint);
@@ -1506,7 +1542,7 @@
 				if (chNext == '\"' || chNext == '\'' || chNext == '\\') {
 					i++;
 					ch = chNext;
-					chNext = styler.SafeGetCharAt(i + 1);
+					chNext = static_cast<unsigned char>(styler.SafeGetCharAt(i + 1));
 				}
 			} else if (ch == '\'') {
 				styler.ColourTo(i, StateToPrint);
@@ -1527,7 +1563,7 @@
 			break;
 			///////////// start - PHP state handling
 		case SCE_HPHP_WORD:
-			if (!iswordchar(ch)) {
+			if (!IsAWordChar(ch)) {
 				classifyWordHTPHP(styler.GetStartSegment(), i - 1, keywords5, styler);
 				if (ch == '/' && chNext == '*') {
 					i++;
@@ -1547,7 +1583,7 @@
 					state = SCE_HPHP_SIMPLESTRING;
 				} else if (ch == '$' && IsPhpWordStart(chNext)) {
 					state = SCE_HPHP_VARIABLE;
-				} else if (isoperator(ch)) {
+				} else if (IsOperator(ch)) {
 					state = SCE_HPHP_OPERATOR;
 				} else {
 					state = SCE_HPHP_DEFAULT;
@@ -1560,7 +1596,7 @@
 				&& strchr(".xXabcdefABCDEF", ch) == NULL
 				&& ((ch != '-' && ch != '+') || (chPrev != 'e' && chPrev != 'E'))) {
 				styler.ColourTo(i - 1, SCE_HPHP_NUMBER);
-				if (isoperator(ch))
+				if (IsOperator(ch))
 					state = SCE_HPHP_OPERATOR;
 				else
 					state = SCE_HPHP_DEFAULT;
@@ -1569,7 +1605,7 @@
 		case SCE_HPHP_VARIABLE:
 			if (!IsPhpWordChar(ch)) {
 				styler.ColourTo(i - 1, SCE_HPHP_VARIABLE);
-				if (isoperator(ch))
+				if (IsOperator(ch))
 					state = SCE_HPHP_OPERATOR;
 				else
 					state = SCE_HPHP_DEFAULT;
@@ -1599,8 +1635,9 @@
 				styler.ColourTo(i - 1, StateToPrint);
 				state = SCE_HPHP_HSTRING_VARIABLE;
 			} else if (styler.Match(i, phpStringDelimiter)) {
-				if (strlen(phpStringDelimiter) > 1)
-					i += strlen(phpStringDelimiter) - 1;
+				const int psdLength = strlen(phpStringDelimiter);
+				if ((psdLength > 1) && ((i + psdLength) < lengthDoc))
+					i += psdLength - 1;
 				styler.ColourTo(i, StateToPrint);
 				state = SCE_HPHP_DEFAULT;
 			}
@@ -1632,7 +1669,7 @@
 			styler.ColourTo(i - 1, StateToPrint);
 			if (IsADigit(ch) || (ch == '.' && IsADigit(chNext))) {
 				state = SCE_HPHP_NUMBER;
-			} else if (iswordstart(ch)) {
+			} else if (IsAWordStart(ch)) {
 				state = SCE_HPHP_WORD;
 			} else if (ch == '/' && chNext == '*') {
 				i++;
@@ -1652,9 +1689,9 @@
 				state = SCE_HPHP_SIMPLESTRING;
 			} else if (ch == '$' && IsPhpWordStart(chNext)) {
 				state = SCE_HPHP_VARIABLE;
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				state = SCE_HPHP_OPERATOR;
-			} else if ((state == SCE_HPHP_OPERATOR) && (isspacechar(ch))) {
+			} else if ((state == SCE_HPHP_OPERATOR) && (IsASpace(ch))) {
 				state = SCE_HPHP_DEFAULT;
 			}
 			break;
@@ -1670,9 +1707,9 @@
 				state = SCE_HB_STRING;
 			} else if (ch == '\'') {
 				state = SCE_HB_COMMENTLINE;
-			} else if (iswordstart(ch)) {
+			} else if (IsAWordStart(ch)) {
 				state = SCE_HB_WORD;
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				styler.ColourTo(i, SCE_HB_DEFAULT);
 			}
 		} else if (state == SCE_HBA_DEFAULT) {    // One of the above succeeded
@@ -1680,9 +1717,9 @@
 				state = SCE_HBA_STRING;
 			} else if (ch == '\'') {
 				state = SCE_HBA_COMMENTLINE;
-			} else if (iswordstart(ch)) {
+			} else if (IsAWordStart(ch)) {
 				state = SCE_HBA_WORD;
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				styler.ColourTo(i, SCE_HBA_DEFAULT);
 			}
 		} else if (state == SCE_HJ_DEFAULT) {    // One of the above succeeded
@@ -1697,9 +1734,9 @@
 				state = SCE_HJ_DOUBLESTRING;
 			} else if ((ch == '\'') && (nonEmptySegment)) {
 				state = SCE_HJ_SINGLESTRING;
-			} else if (iswordstart(ch)) {
+			} else if (IsAWordStart(ch)) {
 				state = SCE_HJ_WORD;
-			} else if (isoperator(ch)) {
+			} else if (IsOperator(ch)) {
 				styler.ColourTo(i, statePrintForState(SCE_HJ_SYMBOLS, inScriptType));
 			}
 		}
@@ -1715,6 +1752,18 @@
 	}
 }
 
+static void ColouriseXMLDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
+                                  Accessor &styler) {
+	// Passing in true because we're lexing XML
+	ColouriseHyperTextDoc(startPos, length, initStyle, keywordlists,styler, true);
+}
+
+static void ColouriseHTMLDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
+                                  Accessor &styler) {
+	// Passing in false because we're notlexing XML
+	ColouriseHyperTextDoc(startPos, length, initStyle, keywordlists,styler, false);
+}
+
 static bool isASPScript(int state) {
 	return
 		(state >= SCE_HJA_START && state <= SCE_HJA_REGEX) ||
@@ -1789,7 +1838,7 @@
 			sc.SetState(SCE_H_DEFAULT);
 		}
 	} else if (sc.state == SCE_H_TAGUNKNOWN) {
-		if (!ishtmlwordchar(static_cast<char>(sc.ch)) && !((sc.ch == '/') && (sc.chPrev == '<')) && sc.ch != '[') {
+		if (!ishtmlwordchar(sc.ch) && !((sc.ch == '/') && (sc.chPrev == '<')) && sc.ch != '[') {
 			char s[100];
 			sc.GetCurrentLowered(s, sizeof(s));
 			if (s[1] == '/') {
@@ -1812,7 +1861,7 @@
 			}
 		}
 	} else if (sc.state == SCE_H_ATTRIBUTE) {
-		if (!ishtmlwordchar(static_cast<char>(sc.ch))) {
+		if (!ishtmlwordchar(sc.ch)) {
 			char s[100];
 			sc.GetCurrentLowered(s, sizeof(s));
 			if (!keywordsTags.InList(s)) {
@@ -1864,7 +1913,7 @@
 		} else if (sc.ch == '>') {
 			sc.SetState(SCE_H_TAG);
 			sc.ForwardSetState(SCE_H_DEFAULT);
-		} else if (ishtmlwordchar(static_cast<char>(sc.ch))) {
+		} else if (ishtmlwordchar(sc.ch)) {
 			sc.SetState(SCE_H_ATTRIBUTE);
 		}
 	}
@@ -1908,8 +1957,8 @@
 
 static void ColouriseASPDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
                                   Accessor &styler) {
-	// Lexer for HTML requires more lexical states (7 bits worth) than most lexers
-	StyleContext sc(startPos, length, initStyle, styler, 0x7f);
+	// Lexer for HTML requires more lexical states (8 bits worth) than most lexers
+	StyleContext sc(startPos, length, initStyle, styler, static_cast<char>(STYLE_MAX));
 	for (; sc.More(); sc.Forward()) {
 		ColouriseASPPiece(sc, keywordlists);
 	}
@@ -1992,7 +2041,7 @@
 			sc.SetState(SCE_HPHP_SIMPLESTRING);
 		} else if (sc.ch == '$' && IsPhpWordStart(static_cast<char>(sc.chNext))) {
 			sc.SetState(SCE_HPHP_VARIABLE);
-		} else if (isoperator(static_cast<char>(sc.ch))) {
+		} else if (IsOperator(static_cast<char>(sc.ch))) {
 			sc.SetState(SCE_HPHP_OPERATOR);
 		}
 	}
@@ -2000,8 +2049,8 @@
 
 static void ColourisePHPDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
                                   Accessor &styler) {
-	// Lexer for HTML requires more lexical states (7 bits worth) than most lexers
-	StyleContext sc(startPos, length, initStyle, styler, 0x7f);
+	// Lexer for HTML requires more lexical states (8 bits worth) than most lexers
+	StyleContext sc(startPos, length, initStyle, styler, static_cast<char>(STYLE_MAX));
 	for (; sc.More(); sc.Forward()) {
 		ColourisePHPPiece(sc, keywordlists);
 	}
@@ -2011,7 +2060,7 @@
 static void ColourisePHPScriptDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
                                                Accessor &styler) {
 	if(startPos == 0) initStyle = SCE_HPHP_DEFAULT;
-		ColouriseHyperTextDoc(startPos,length,initStyle,keywordlists,styler);
+		ColouriseHTMLDoc(startPos,length,initStyle,keywordlists,styler);
 }
 
 static const char * const htmlWordListDesc[] = {
@@ -2034,9 +2083,9 @@
 	0,
 };
 
-LexerModule lmHTML(SCLEX_HTML, ColouriseHyperTextDoc, "hypertext", 0, htmlWordListDesc, 7);
-LexerModule lmXML(SCLEX_XML, ColouriseHyperTextDoc, "xml", 0, htmlWordListDesc, 7);
+LexerModule lmHTML(SCLEX_HTML, ColouriseHTMLDoc, "hypertext", 0, htmlWordListDesc, 8);
+LexerModule lmXML(SCLEX_XML, ColouriseXMLDoc, "xml", 0, htmlWordListDesc, 8);
 // SCLEX_ASP and SCLEX_PHP should not be used in new code: use SCLEX_HTML instead.
-LexerModule lmASP(SCLEX_ASP, ColouriseASPDoc, "asp", 0, htmlWordListDesc, 7);
-LexerModule lmPHP(SCLEX_PHP, ColourisePHPDoc, "php", 0, htmlWordListDesc, 7);
-LexerModule lmPHPSCRIPT(SCLEX_PHPSCRIPT, ColourisePHPScriptDoc, "phpscript", 0, phpscriptWordListDesc, 7);
+LexerModule lmASP(SCLEX_ASP, ColouriseASPDoc, "asp", 0, htmlWordListDesc, 8);
+LexerModule lmPHP(SCLEX_PHP, ColourisePHPDoc, "php", 0, htmlWordListDesc, 8);
+LexerModule lmPHPSCRIPT(SCLEX_PHPSCRIPT, ColourisePHPScriptDoc, "phpscript", 0, phpscriptWordListDesc, 8);
Index: src/sdk/wxscintilla/src/scintilla/src/RESearch.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/RESearch.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/RESearch.h	(working copy)
@@ -9,6 +9,10 @@
 #ifndef RESEARCH_H
 #define RESEARCH_H
 
+#ifdef SCI_NAMESPACE
+namespace Scintilla {
+#endif
+
 /*
  * The following defines are not meant to be changeable.
  * They are for readability only.
@@ -34,9 +38,9 @@
 	int Execute(CharacterIndexer &ci, int lp, int endp);
 	int Substitute(CharacterIndexer &ci, char *src, char *dst);
 
-	enum {MAXTAG=10};
-	enum {MAXNFA=2048};
-	enum {NOTFOUND=-1};
+	enum { MAXTAG=10 };
+	enum { MAXNFA=2048 };
+	enum { NOTFOUND=-1 };
 
 	int bopat[MAXTAG];
 	int eopat[MAXTAG];
@@ -45,16 +49,17 @@
 private:
 	void Init();
 	void Clear();
-	void ChSet(char c);
-	void ChSetWithCase(char c, bool caseSensitive);
+	void ChSet(unsigned char c);
+	void ChSetWithCase(unsigned char c, bool caseSensitive);
+	int GetBackslashExpression(const char *pat, int &incr);
 
 	int PMatch(CharacterIndexer &ci, int lp, int endp, char *ap);
 
 	int bol;
-	int  tagstk[MAXTAG]; /* subpat tag stack */
+	int tagstk[MAXTAG];  /* subpat tag stack */
 	char nfa[MAXNFA];    /* automaton */
 	int sta;
-	char bittab[BITBLK]; /* bit table for CCL pre-set bits */
+	unsigned char bittab[BITBLK]; /* bit table for CCL pre-set bits */
 	int failure;
 	CharClassify *charClass;
 	bool iswordc(unsigned char x) {
@@ -62,4 +67,9 @@
 	}
 };
 
+#ifdef SCI_NAMESPACE
+}
 #endif
+
+#endif
+
Index: src/sdk/wxscintilla/src/scintilla/src/ContractionState.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/ContractionState.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/ContractionState.cxx	(working copy)
@@ -1,289 +1,251 @@
 // Scintilla source code edit control
 /** @file ContractionState.cxx
- ** Manages visibility of lines for folding.
+ ** Manages visibility of lines for folding and wrapping.
  **/
-// Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
+// Copyright 1998-2007 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+#include <string.h>
+
 #include "Platform.h"
 
+#include "SplitVector.h"
+#include "Partitioning.h"
+#include "RunStyles.h"
 #include "ContractionState.h"
 
-OneLine::OneLine() {
-	displayLine = 0;
-	//docLine = 0;
-	visible = true;
-	height = 1;
-	expanded = true;
-}
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
 
-ContractionState::ContractionState() {
-	lines = 0;
-	size = 0;
-	linesInDoc = 1;
-	linesInDisplay = 1;
-	valid = false;
-	docLines = 0;
-	sizeDocLines = 0;
+ContractionState::ContractionState() : visible(0), expanded(0), heights(0), displayLines(0), linesInDocument(1) {
+	//InsertLine(0);
 }
 
 ContractionState::~ContractionState() {
 	Clear();
 }
 
-void ContractionState::MakeValid() const {
-	if (!valid) {
-		// Could be cleverer by keeping the index of the last still valid entry
-		// rather than invalidating all.
-		linesInDisplay = 0;
-		for (int lineInDoc=0; lineInDoc<linesInDoc; lineInDoc++) {
-			lines[lineInDoc].displayLine = linesInDisplay;
-			if (lines[lineInDoc].visible) {
-				linesInDisplay += lines[lineInDoc].height;
-			}
-		}
-		if (sizeDocLines < linesInDisplay) {
-			delete []docLines;
-			int *docLinesNew = new int[linesInDisplay + growSize];
-			if (!docLinesNew) {
-				docLines = 0;
-				sizeDocLines = 0;
-				return;
-			}
-			docLines = docLinesNew;
-			sizeDocLines = linesInDisplay + growSize;
-		}
-
-		int lineInDisplay=0;
-		for (int line=0; line<linesInDoc; line++) {
-			if (lines[line].visible) {
-				for (int linePiece=0; linePiece<lines[line].height; linePiece++) {
-					docLines[lineInDisplay] = line;
-					lineInDisplay++;
-				}
-			}
-		}
-		valid = true;
+void ContractionState::EnsureData() {
+	if (OneToOne()) {
+		visible = new RunStyles();
+		expanded = new RunStyles();
+		heights = new RunStyles();
+		displayLines = new Partitioning(4);
+		InsertLines(0, linesInDocument);
 	}
 }
 
 void ContractionState::Clear() {
-	delete []lines;
-	lines = 0;
-	size = 0;
-	linesInDoc = 1;
-	linesInDisplay = 1;
-	delete []docLines;
-	docLines = 0;
-	sizeDocLines = 0;
+	delete visible;
+	visible = 0;
+	delete expanded;
+	expanded = 0;
+	delete heights;
+	heights = 0;
+	delete displayLines;
+	displayLines = 0;
+	linesInDocument = 1;
 }
 
 int ContractionState::LinesInDoc() const {
-	return linesInDoc;
+	if (OneToOne()) {
+		return linesInDocument;
+	} else {
+		return displayLines->Partitions() - 1;
+	}
 }
 
 int ContractionState::LinesDisplayed() const {
-	if (size != 0) {
-		MakeValid();
+	if (OneToOne()) {
+		return linesInDocument;
+	} else {
+		return displayLines->PositionFromPartition(LinesInDoc());
 	}
-	return linesInDisplay;
 }
 
 int ContractionState::DisplayFromDoc(int lineDoc) const {
-	if (size == 0) {
+	if (OneToOne()) {
 		return lineDoc;
+	} else {
+		if (lineDoc > displayLines->Partitions())
+			lineDoc = displayLines->Partitions();
+		return displayLines->PositionFromPartition(lineDoc);
 	}
-	MakeValid();
-	if ((lineDoc >= 0) && (lineDoc < linesInDoc)) {
-		return lines[lineDoc].displayLine;
-	}
-	return -1;
 }
 
 int ContractionState::DocFromDisplay(int lineDisplay) const {
-	if (lineDisplay <= 0)
-		return 0;
-	if (lineDisplay >= linesInDisplay)
-		return linesInDoc;
-	if (size == 0)
+	if (OneToOne()) {
 		return lineDisplay;
-	MakeValid();
-	if (docLines) {	// Valid allocation
-		return docLines[lineDisplay];
 	} else {
-		return 0;
+		if (lineDisplay <= 0) {
+			return 0;
+		}
+		if (lineDisplay > LinesDisplayed()) {
+			return displayLines->PartitionFromPosition(LinesDisplayed());
+		}
+		int lineDoc = displayLines->PartitionFromPosition(lineDisplay);
+		PLATFORM_ASSERT(GetVisible(lineDoc));
+		return lineDoc;
 	}
 }
 
-void ContractionState::Grow(int sizeNew) {
-	OneLine *linesNew = new OneLine[sizeNew];
-	if (linesNew) {
-		int i = 0;
-		for (; i < size; i++) {
-			linesNew[i] = lines[i];
-		}
-		for (; i < sizeNew; i++) {
-			linesNew[i].displayLine = i;
-		}
-		delete []lines;
-		lines = linesNew;
-		size = sizeNew;
-		valid = false;
+void ContractionState::InsertLine(int lineDoc) {
+	if (OneToOne()) {
+		linesInDocument++;
 	} else {
-		Platform::DebugPrintf("No memory available\n");
-		// TODO: Blow up
+		visible->InsertSpace(lineDoc, 1);
+		visible->SetValueAt(lineDoc, 1);
+		expanded->InsertSpace(lineDoc, 1);
+		expanded->SetValueAt(lineDoc, 1);
+		heights->InsertSpace(lineDoc, 1);
+		heights->SetValueAt(lineDoc, 1);
+		int lineDisplay = DisplayFromDoc(lineDoc);
+		displayLines->InsertPartition(lineDoc, lineDisplay);
+		displayLines->InsertText(lineDoc, 1);
 	}
 }
 
 void ContractionState::InsertLines(int lineDoc, int lineCount) {
-	if (size == 0) {
-		linesInDoc += lineCount;
-		linesInDisplay += lineCount;
-		return;
+	for (int l = 0; l < lineCount; l++) {
+		InsertLine(lineDoc + l);
 	}
-	//Platform::DebugPrintf("InsertLine[%d] = %d\n", lineDoc);
-	if ((linesInDoc + lineCount + 2) >= size) {
-		Grow(linesInDoc + lineCount + growSize);
+	Check();
+}
+
+void ContractionState::DeleteLine(int lineDoc) {
+	if (OneToOne()) {
+		linesInDocument--;
+	} else {
+		if (GetVisible(lineDoc)) {
+			displayLines->InsertText(lineDoc, -heights->ValueAt(lineDoc));
+		}
+		displayLines->RemovePartition(lineDoc);
+		visible->DeleteRange(lineDoc, 1);
+		expanded->DeleteRange(lineDoc, 1);
+		heights->DeleteRange(lineDoc, 1);
 	}
-	linesInDoc += lineCount;
-	for (int i = linesInDoc; i >= lineDoc + lineCount; i--) {
-		lines[i].visible = lines[i - lineCount].visible;
-		lines[i].height = lines[i - lineCount].height;
-		linesInDisplay += lines[i].height;
-		lines[i].expanded = lines[i - lineCount].expanded;
-	}
-	for (int d=0;d<lineCount;d++) {
-		lines[lineDoc+d].visible = true;	// Should inherit visibility from context ?
-		lines[lineDoc+d].height = 1;
-		lines[lineDoc+d].expanded = true;
-	}
-	valid = false;
 }
 
 void ContractionState::DeleteLines(int lineDoc, int lineCount) {
-	if (size == 0) {
-		linesInDoc -= lineCount;
-		linesInDisplay -= lineCount;
-		return;
+	for (int l = 0; l < lineCount; l++) {
+		DeleteLine(lineDoc);
 	}
-	int deltaDisplayed = 0;
-	for (int d=0;d<lineCount;d++) {
-		if (lines[lineDoc+d].visible)
-			deltaDisplayed -= lines[lineDoc+d].height;
-	}
-	for (int i = lineDoc; i < linesInDoc-lineCount; i++) {
-		if (i != 0) // Line zero is always visible
-			lines[i].visible = lines[i + lineCount].visible;
-		lines[i].expanded = lines[i + lineCount].expanded;
-		lines[i].height = lines[i + lineCount].height;
-	}
-	linesInDoc -= lineCount;
-	linesInDisplay += deltaDisplayed;
-	valid = false;
+	Check();
 }
 
 bool ContractionState::GetVisible(int lineDoc) const {
-	if (size == 0)
+	if (OneToOne()) {
 		return true;
-	if ((lineDoc >= 0) && (lineDoc < linesInDoc)) {
-		return lines[lineDoc].visible;
 	} else {
-		return false;
+		if (lineDoc >= visible->Length())
+			return true;
+		return visible->ValueAt(lineDoc) == 1;
 	}
 }
 
-bool ContractionState::SetVisible(int lineDocStart, int lineDocEnd, bool visible) {
-	if (lineDocStart == 0)
-		lineDocStart++;
-	if (lineDocStart > lineDocEnd)
+bool ContractionState::SetVisible(int lineDocStart, int lineDocEnd, bool visible_) {
+	if (OneToOne() && visible_) {
 		return false;
-	if (size == 0) {
-		Grow(linesInDoc + growSize);
-	}
-	// TODO: modify docLine members to mirror displayLine
-	int delta = 0;
-	// Change lineDocs
-	if ((lineDocStart <= lineDocEnd) && (lineDocStart >= 0) && (lineDocEnd < linesInDoc)) {
-		for (int line=lineDocStart; line <= lineDocEnd; line++) {
-			if (lines[line].visible != visible) {
-				delta += visible ? lines[line].height : -lines[line].height;
-				lines[line].visible = visible;
+	} else {
+		EnsureData();
+		int delta = 0;
+		Check();
+		if ((lineDocStart <= lineDocEnd) && (lineDocStart >= 0) && (lineDocEnd < LinesInDoc())) {
+			for (int line = lineDocStart; line <= lineDocEnd; line++) {
+				if (GetVisible(line) != visible_) {
+					int difference = visible_ ? heights->ValueAt(line) : -heights->ValueAt(line);
+					visible->SetValueAt(line, visible_ ? 1 : 0);
+					displayLines->InsertText(line, difference);
+					delta += difference;
+				}
 			}
+		} else {
+			return false;
 		}
+		Check();
+		return delta != 0;
 	}
-	linesInDisplay += delta;
-	valid = false;
-	return delta != 0;
 }
 
 bool ContractionState::GetExpanded(int lineDoc) const {
-	if (size == 0)
+	if (OneToOne()) {
 		return true;
-	if ((lineDoc >= 0) && (lineDoc < linesInDoc)) {
-		return lines[lineDoc].expanded;
 	} else {
-		return false;
+		Check();
+		return expanded->ValueAt(lineDoc) == 1;
 	}
 }
 
-bool ContractionState::SetExpanded(int lineDoc, bool expanded) {
-	if (size == 0) {
-		if (expanded) {
-			// If in completely expanded state then setting
-			// one line to expanded has no effect.
+bool ContractionState::SetExpanded(int lineDoc, bool expanded_) {
+	if (OneToOne() && expanded_) {
+		return false;
+	} else {
+		EnsureData();
+		if (expanded_ != (expanded->ValueAt(lineDoc) == 1)) {
+			expanded->SetValueAt(lineDoc, expanded_ ? 1 : 0);
+			Check();
+			return true;
+		} else {
+			Check();
 			return false;
 		}
-		Grow(linesInDoc + growSize);
 	}
-	if ((lineDoc >= 0) && (lineDoc < linesInDoc)) {
-		if (lines[lineDoc].expanded != expanded) {
-			lines[lineDoc].expanded = expanded;
-			return true;
-		}
-	}
-	return false;
 }
 
 int ContractionState::GetHeight(int lineDoc) const {
-	if (size == 0)
+	if (OneToOne()) {
 		return 1;
-	if ((lineDoc >= 0) && (lineDoc < linesInDoc)) {
-		return lines[lineDoc].height;
 	} else {
-		return 1;
+		return heights->ValueAt(lineDoc);
 	}
 }
 
 // Set the number of display lines needed for this line.
 // Return true if this is a change.
 bool ContractionState::SetHeight(int lineDoc, int height) {
-	if (lineDoc > linesInDoc)
+	if (OneToOne() && (height == 1)) {
 		return false;
-	if (size == 0) {
-		if (height == 1) {
-			// If in completely expanded state then all lines
-			// assumed to have height of one so no effect here.
+	} else {
+		EnsureData();
+		if (GetHeight(lineDoc) != height) {
+			if (GetVisible(lineDoc)) {
+				displayLines->InsertText(lineDoc, height - GetHeight(lineDoc));
+			}
+			heights->SetValueAt(lineDoc, height);
+			Check();
+			return true;
+		} else {
+			Check();
 			return false;
 		}
-		Grow(linesInDoc + growSize);
 	}
-	if (lines[lineDoc].height != height) {
-		lines[lineDoc].height = height;
-		valid = false;
-		return true;
-	} else {
-		return false;
-	}
 }
 
 void ContractionState::ShowAll() {
-	delete []lines;
-	lines = 0;
-	size = 0;
+	int lines = LinesInDoc();
+	Clear();
+	linesInDocument = lines;
+}
 
-	delete []docLines;
-	docLines = 0;
-	sizeDocLines = 0;
+// Debugging checks
 
-	linesInDisplay = linesInDoc;
+void ContractionState::Check() const {
+#ifdef CHECK_CORRECTNESS
+	for (int vline = 0;vline < LinesDisplayed(); vline++) {
+		const int lineDoc = DocFromDisplay(vline);
+		PLATFORM_ASSERT(GetVisible(lineDoc));
+	}
+	for (int lineDoc = 0;lineDoc < LinesInDoc(); lineDoc++) {
+		const int displayThis = DisplayFromDoc(lineDoc);
+		const int displayNext = DisplayFromDoc(lineDoc + 1);
+		const int height = displayNext - displayThis;
+		PLATFORM_ASSERT(height >= 0);
+		if (GetVisible(lineDoc)) {
+			PLATFORM_ASSERT(GetHeight(lineDoc) == height);
+		} else {
+			PLATFORM_ASSERT(0 == height);
+		}
+	}
+#endif
 }
Index: src/sdk/wxscintilla/src/scintilla/src/LexBash.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexBash.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexBash.cxx	(working copy)
@@ -2,7 +2,7 @@
 /** @file LexBash.cxx
  ** Lexer for Bash.
  **/
-// Copyright 2004-2005 by Neil Hodgson <neilh@scintilla.org>
+// Copyright 2004-2007 by Neil Hodgson <neilh@scintilla.org>
 // Adapted from LexPerl by Kein-Hong Man <mkh@pl.jaring.my> 2004
 // The License.txt file describes the conditions under which this software may be distributed.
 
@@ -20,14 +20,24 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+// define this if you want 'invalid octals' to be marked as errors
+// usually, this is not a good idea, permissive lexing is better
+#undef PEDANTIC_OCTAL
+
 #define BASH_BASE_ERROR		65
 #define BASH_BASE_DECIMAL	66
 #define BASH_BASE_HEX		67
+#ifdef PEDANTIC_OCTAL
 #define BASH_BASE_OCTAL		68
 #define BASH_BASE_OCTAL_ERROR	69
+#endif
 
 #define HERE_DELIM_MAX 256
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static inline int translateBashDigit(char ch) {
 	if (ch >= '0' && ch <= '9') {
 		return ch - '0';
@@ -273,7 +283,11 @@
 						ch = chNext;
 						chNext = chNext2;
 					} else if (isdigit(chNext)) {
+#ifdef PEDANTIC_OCTAL
 						numBase = BASH_BASE_OCTAL;
+#else
+						numBase = BASH_BASE_HEX;
+#endif
 					}
 				}
 			} else if (iswordstart(ch)) {
@@ -338,7 +352,8 @@
 				HereDoc.Indent = false;
 			} else if (ch == '-'	// file test operators
 			           && isSingleCharOp(chNext)
-			           && !isalnum((chNext2 = styler.SafeGetCharAt(i+2)))) {
+			           && !isalnum((chNext2 = styler.SafeGetCharAt(i+2)))
+			           && isspace(chPrev)) {
 				styler.ColourTo(i + 1, SCE_SH_WORD);
 				state = SCE_SH_DEFAULT;
 				i++;
@@ -364,14 +379,16 @@
 					// hex digit 0-9a-fA-F
 				} else
 					goto numAtEnd;
+#ifdef PEDANTIC_OCTAL
 			} else if (numBase == BASH_BASE_OCTAL ||
 				   numBase == BASH_BASE_OCTAL_ERROR) {
 				if (digit > 7) {
 					if (digit <= 9) {
-						numBase = BASH_BASE_OCTAL_ERROR;
+                                                numBase = BASH_BASE_OCTAL_ERROR;
 					} else
 						goto numAtEnd;
 				}
+#endif
 			} else if (numBase == BASH_BASE_ERROR) {
 				if (digit > 9)
 					goto numAtEnd;
@@ -389,8 +406,11 @@
 					}
 				} else {
 			numAtEnd:
-					if (numBase == BASH_BASE_ERROR ||
-					    numBase == BASH_BASE_OCTAL_ERROR)
+					if (numBase == BASH_BASE_ERROR
+#ifdef PEDANTIC_OCTAL
+					    || numBase == BASH_BASE_OCTAL_ERROR
+#endif
+                                           )
 						state = SCE_SH_ERROR;
 					styler.ColourTo(i - 1, state);
 					state = SCE_SH_DEFAULT;
Index: src/sdk/wxscintilla/src/scintilla/src/UniConversion.h
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/UniConversion.h	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/UniConversion.h	(working copy)
@@ -6,7 +6,7 @@
 // The License.txt file describes the conditions under which this software may be distributed.
 
 unsigned int UTF8Length(const wchar_t *uptr, unsigned int tlen);
-void UTF8FromUCS2(const wchar_t *uptr, unsigned int tlen, char *putf, unsigned int len);
-unsigned int UCS2Length(const char *s, unsigned int len);
-unsigned int UCS2FromUTF8(const char *s, unsigned int len, wchar_t *tbuf, unsigned int tlen);
+void UTF8FromUTF16(const wchar_t *uptr, unsigned int tlen, char *putf, unsigned int len);
+unsigned int UTF16Length(const char *s, unsigned int len);
+unsigned int UTF16FromUTF8(const char *s, unsigned int len, wchar_t *tbuf, unsigned int tlen);
 
Index: src/sdk/wxscintilla/src/scintilla/src/PositionCache.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/PositionCache.cxx	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/src/PositionCache.cxx	(revision 0)
@@ -0,0 +1,635 @@
+// Scintilla source code edit control
+/** @file PositionCache.cxx
+ ** Classes for caching layout information.
+ **/
+// Copyright 1998-2007 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+
+#include "Platform.h"
+
+#include "Scintilla.h"
+
+#include "SplitVector.h"
+#include "Partitioning.h"
+#include "RunStyles.h"
+#include "ContractionState.h"
+#include "CellBuffer.h"
+#include "KeyMap.h"
+#include "Indicator.h"
+#include "XPM.h"
+#include "LineMarker.h"
+#include "Style.h"
+#include "ViewStyle.h"
+#include "CharClassify.h"
+#include "Decoration.h"
+#include "Document.h"
+#include "PositionCache.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+static inline bool IsControlCharacter(int ch) {
+	// iscntrl returns true for lots of chars > 127 which are displayable
+	return ch >= 0 && ch < ' ';
+}
+
+LineLayout::LineLayout(int maxLineLength_) :
+	lineStarts(0),
+	lenLineStarts(0),
+	lineNumber(-1),
+	inCache(false),
+	maxLineLength(-1),
+	numCharsInLine(0),
+	validity(llInvalid),
+	xHighlightGuide(0),
+	highlightColumn(0),
+	selStart(0),
+	selEnd(0),
+	containsCaret(false),
+	edgeColumn(0),
+	chars(0),
+	styles(0),
+	styleBitsSet(0),
+	indicators(0),
+	positions(0),
+	hsStart(0),
+	hsEnd(0),
+	widthLine(wrapWidthInfinite),
+	lines(1) {
+	Resize(maxLineLength_);
+}
+
+LineLayout::~LineLayout() {
+	Free();
+}
+
+void LineLayout::Resize(int maxLineLength_) {
+	if (maxLineLength_ > maxLineLength) {
+		Free();
+		chars = new char[maxLineLength_ + 1];
+		styles = new unsigned char[maxLineLength_ + 1];
+		indicators = new char[maxLineLength_ + 1];
+		// Extra position allocated as sometimes the Windows
+		// GetTextExtentExPoint API writes an extra element.
+		positions = new int[maxLineLength_ + 1 + 1];
+		maxLineLength = maxLineLength_;
+	}
+}
+
+void LineLayout::Free() {
+	delete []chars;
+	chars = 0;
+	delete []styles;
+	styles = 0;
+	delete []indicators;
+	indicators = 0;
+	delete []positions;
+	positions = 0;
+	delete []lineStarts;
+	lineStarts = 0;
+}
+
+void LineLayout::Invalidate(validLevel validity_) {
+	if (validity > validity_)
+		validity = validity_;
+}
+
+int LineLayout::LineStart(int line) const {
+	if (line <= 0) {
+		return 0;
+	} else if ((line >= lines) || !lineStarts) {
+		return numCharsInLine;
+	} else {
+		return lineStarts[line];
+	}
+}
+
+int LineLayout::LineLastVisible(int line) const {
+	if (line < 0) {
+		return 0;
+	} else if ((line >= lines-1) || !lineStarts) {
+		int startLine = LineStart(line);
+		int endLine = numCharsInLine;
+		while ((endLine > startLine) && IsEOLChar(chars[endLine-1])) {
+			endLine--;
+		}
+		return endLine;
+	} else {
+		return lineStarts[line+1];
+	}
+}
+
+bool LineLayout::InLine(int offset, int line) const {
+	return ((offset >= LineStart(line)) && (offset < LineStart(line + 1)) ||
+		((offset == numCharsInLine) && (line == (lines-1))));
+}
+
+void LineLayout::SetLineStart(int line, int start) {
+	if ((line >= lenLineStarts) && (line != 0)) {
+		int newMaxLines = line + 20;
+		int *newLineStarts = new int[newMaxLines];
+		if (!newLineStarts)
+			return;
+		for (int i = 0; i < newMaxLines; i++) {
+			if (i < lenLineStarts)
+				newLineStarts[i] = lineStarts[i];
+			else
+				newLineStarts[i] = 0;
+		}
+		delete []lineStarts;
+		lineStarts = newLineStarts;
+		lenLineStarts = newMaxLines;
+	}
+	lineStarts[line] = start;
+}
+
+void LineLayout::SetBracesHighlight(Range rangeLine, Position braces[],
+                                    char bracesMatchStyle, int xHighlight) {
+	if (rangeLine.ContainsCharacter(braces[0])) {
+		int braceOffset = braces[0] - rangeLine.start;
+		if (braceOffset < numCharsInLine) {
+			bracePreviousStyles[0] = styles[braceOffset];
+			styles[braceOffset] = bracesMatchStyle;
+		}
+	}
+	if (rangeLine.ContainsCharacter(braces[1])) {
+		int braceOffset = braces[1] - rangeLine.start;
+		if (braceOffset < numCharsInLine) {
+			bracePreviousStyles[1] = styles[braceOffset];
+			styles[braceOffset] = bracesMatchStyle;
+		}
+	}
+	if ((braces[0] >= rangeLine.start && braces[1] <= rangeLine.end) ||
+	        (braces[1] >= rangeLine.start && braces[0] <= rangeLine.end)) {
+		xHighlightGuide = xHighlight;
+	}
+}
+
+void LineLayout::RestoreBracesHighlight(Range rangeLine, Position braces[]) {
+	if (rangeLine.ContainsCharacter(braces[0])) {
+		int braceOffset = braces[0] - rangeLine.start;
+		if (braceOffset < numCharsInLine) {
+			styles[braceOffset] = bracePreviousStyles[0];
+		}
+	}
+	if (rangeLine.ContainsCharacter(braces[1])) {
+		int braceOffset = braces[1] - rangeLine.start;
+		if (braceOffset < numCharsInLine) {
+			styles[braceOffset] = bracePreviousStyles[1];
+		}
+	}
+	xHighlightGuide = 0;
+}
+
+int LineLayout::FindBefore(int x, int lower, int upper) const {
+	do {
+		int middle = (upper + lower + 1) / 2; 	// Round high
+		int posMiddle = positions[middle];
+		if (x < posMiddle) {
+			upper = middle - 1;
+		} else {
+			lower = middle;
+		}
+	} while (lower < upper);
+	return lower;
+}
+
+LineLayoutCache::LineLayoutCache() :
+	level(0), length(0), size(0), cache(0),
+	allInvalidated(false), styleClock(-1), useCount(0) {
+	Allocate(0);
+}
+
+LineLayoutCache::~LineLayoutCache() {
+	Deallocate();
+}
+
+void LineLayoutCache::Allocate(int length_) {
+	PLATFORM_ASSERT(cache == NULL);
+	allInvalidated = false;
+	length = length_;
+	size = length;
+	if (size > 1) {
+		size = (size / 16 + 1) * 16;
+	}
+	if (size > 0) {
+		cache = new LineLayout * [size];
+	}
+	for (int i = 0; i < size; i++)
+		cache[i] = 0;
+}
+
+void LineLayoutCache::AllocateForLevel(int linesOnScreen, int linesInDoc) {
+	PLATFORM_ASSERT(useCount == 0);
+	int lengthForLevel = 0;
+	if (level == llcCaret) {
+		lengthForLevel = 1;
+	} else if (level == llcPage) {
+		lengthForLevel = linesOnScreen + 1;
+	} else if (level == llcDocument) {
+		lengthForLevel = linesInDoc;
+	}
+	if (lengthForLevel > size) {
+		Deallocate();
+		Allocate(lengthForLevel);
+	} else {
+		if (lengthForLevel < length) {
+			for (int i = lengthForLevel; i < length; i++) {
+				delete cache[i];
+				cache[i] = 0;
+			}
+		}
+		length = lengthForLevel;
+	}
+	PLATFORM_ASSERT(length == lengthForLevel);
+	PLATFORM_ASSERT(cache != NULL || length == 0);
+}
+
+void LineLayoutCache::Deallocate() {
+	PLATFORM_ASSERT(useCount == 0);
+	for (int i = 0; i < length; i++)
+		delete cache[i];
+	delete []cache;
+	cache = 0;
+	length = 0;
+	size = 0;
+}
+
+void LineLayoutCache::Invalidate(LineLayout::validLevel validity_) {
+	if (cache && !allInvalidated) {
+		for (int i = 0; i < length; i++) {
+			if (cache[i]) {
+				cache[i]->Invalidate(validity_);
+			}
+		}
+		if (validity_ == LineLayout::llInvalid) {
+			allInvalidated = true;
+		}
+	}
+}
+
+void LineLayoutCache::SetLevel(int level_) {
+	allInvalidated = false;
+	if ((level_ != -1) && (level != level_)) {
+		level = level_;
+		Deallocate();
+	}
+}
+
+LineLayout *LineLayoutCache::Retrieve(int lineNumber, int lineCaret, int maxChars, int styleClock_,
+                                      int linesOnScreen, int linesInDoc) {
+	AllocateForLevel(linesOnScreen, linesInDoc);
+	if (styleClock != styleClock_) {
+		Invalidate(LineLayout::llCheckTextAndStyle);
+		styleClock = styleClock_;
+	}
+	allInvalidated = false;
+	int pos = -1;
+	LineLayout *ret = 0;
+	if (level == llcCaret) {
+		pos = 0;
+	} else if (level == llcPage) {
+		if (lineNumber == lineCaret) {
+			pos = 0;
+		} else if (length > 1) {
+			pos = 1 + (lineNumber % (length - 1));
+		}
+	} else if (level == llcDocument) {
+		pos = lineNumber;
+	}
+	if (pos >= 0) {
+		PLATFORM_ASSERT(useCount == 0);
+		if (cache && (pos < length)) {
+			if (cache[pos]) {
+				if ((cache[pos]->lineNumber != lineNumber) ||
+				        (cache[pos]->maxLineLength < maxChars)) {
+					delete cache[pos];
+					cache[pos] = 0;
+				}
+			}
+			if (!cache[pos]) {
+				cache[pos] = new LineLayout(maxChars);
+			}
+			if (cache[pos]) {
+				cache[pos]->lineNumber = lineNumber;
+				cache[pos]->inCache = true;
+				ret = cache[pos];
+				useCount++;
+			}
+		}
+	}
+
+	if (!ret) {
+		ret = new LineLayout(maxChars);
+		ret->lineNumber = lineNumber;
+	}
+
+	return ret;
+}
+
+void LineLayoutCache::Dispose(LineLayout *ll) {
+	allInvalidated = false;
+	if (ll) {
+		if (!ll->inCache) {
+			delete ll;
+		} else {
+			useCount--;
+		}
+	}
+}
+
+void BreakFinder::Insert(int val) {
+	// Expand if needed
+	if (saeLen >= saeSize) {
+		saeSize *= 2;
+		int *selAndEdgeNew = new int[saeSize];
+		for (unsigned int j = 0; j<saeLen; j++) {
+			selAndEdgeNew[j] = selAndEdge[j];
+		}
+		delete []selAndEdge;
+		selAndEdge = selAndEdgeNew;
+	}
+
+	if (val >= nextBreak) {
+		for (unsigned int j = 0; j<saeLen; j++) {
+			if (val == selAndEdge[j]) {
+				return;
+			} if (val < selAndEdge[j]) {
+				for (unsigned int k = saeLen; k>j; k--) {
+					selAndEdge[k] = selAndEdge[k-1];
+				}
+				saeLen++;
+				selAndEdge[j] = val;
+				return;
+			}
+		}
+		// Not less than any so append
+		selAndEdge[saeLen++] = val;
+	}
+}
+
+extern bool BadUTF(const char *s, int len, int &trailBytes);
+
+static int NextBadU(const char *s, int p, int len, int &trailBytes) {
+	while (p < len) {
+		p++;
+		if (BadUTF(s + p, len - p, trailBytes))
+			return p;
+	}
+	return -1;
+}
+
+BreakFinder::BreakFinder(LineLayout *ll_, int lineStart_, int lineEnd_, int posLineStart_, bool utf8_, int xStart) :
+	ll(ll_),
+	lineStart(lineStart_),
+	lineEnd(lineEnd_),
+	posLineStart(posLineStart_),
+	utf8(utf8_),
+	nextBreak(lineStart_),
+	saeSize(0),
+	saeLen(0),
+	saeCurrentPos(0),
+	saeNext(0),
+	subBreak(-1) {
+	saeSize = 8;
+	selAndEdge = new int[saeSize];
+	for (unsigned int j=0; j < saeSize; j++) {
+		selAndEdge[j] = 0;
+	}
+
+	// Search for first visible break
+	// First find the first visible character
+	nextBreak = ll->FindBefore(xStart, lineStart, lineEnd);
+	// Now back to a style break
+	while ((nextBreak > lineStart) && (ll->styles[nextBreak] == ll->styles[nextBreak - 1])) {
+		nextBreak--;
+	}
+
+	if (ll->selStart != ll->selEnd) {
+		Insert(ll->selStart - posLineStart - 1);
+		Insert(ll->selEnd - posLineStart - 1);
+	}
+
+	Insert(ll->edgeColumn - 1);
+	Insert(lineEnd - 1);
+
+	if (utf8) {
+		int trailBytes=0;
+		for (int pos = -1;;) {
+			pos = NextBadU(ll->chars, pos, lineEnd, trailBytes);
+			if (pos < 0)
+				break;
+			Insert(pos-1);
+			Insert(pos);
+		}
+	}
+	saeNext = (saeLen > 0) ? selAndEdge[0] : -1;
+}
+
+BreakFinder::~BreakFinder() {
+	delete []selAndEdge;
+}
+
+int BreakFinder::First() {
+	return nextBreak;
+}
+
+int BreakFinder::Next() {
+	if (subBreak == -1) {
+		int prev = nextBreak;
+		while (nextBreak < lineEnd) {
+			if ((ll->styles[nextBreak] != ll->styles[nextBreak + 1]) ||
+					(nextBreak == saeNext) ||
+					IsControlCharacter(ll->chars[nextBreak]) || IsControlCharacter(ll->chars[nextBreak + 1])) {
+				if (nextBreak == saeNext) {
+					saeCurrentPos++;
+					saeNext = (saeLen > saeCurrentPos) ? selAndEdge[saeCurrentPos] : -1;
+				}
+				nextBreak++;
+				if ((nextBreak - prev) < lengthStartSubdivision) {
+					return nextBreak;
+				}
+				break;
+			}
+			nextBreak++;
+		}
+		if ((nextBreak - prev) < lengthStartSubdivision) {
+			return nextBreak;
+		}
+		subBreak = prev;
+	}
+	// Splitting up a long run from prev to nextBreak in lots of approximately lengthEachSubdivision.
+	// For very long runs add extra breaks after spaces or if no spaces before low punctuation.
+	if ((nextBreak - subBreak) <= lengthEachSubdivision) {
+		subBreak = -1;
+		return nextBreak;
+	} else {
+		int lastGoodBreak = -1;
+		int lastOKBreak = -1;
+		int j;
+		for (j = subBreak + 1; j <= nextBreak; j++) {
+			if (IsSpaceOrTab(ll->chars[j - 1]) && !IsSpaceOrTab(ll->chars[j])) {
+				lastGoodBreak = j;
+			}
+			if (ll->chars[j] < 'A') {
+				lastOKBreak = j;
+			}
+			if (((j - subBreak) >= lengthEachSubdivision) && ((lastGoodBreak >= 0) || (lastOKBreak >= 0))) {
+				break;
+			}
+		}
+		if (lastGoodBreak >= 0) {
+			subBreak = lastGoodBreak;
+		} else if (lastOKBreak >= 0) {
+			subBreak = lastOKBreak;
+		} else {
+			subBreak = nextBreak;
+		}
+		if (subBreak >= nextBreak) {
+			subBreak = -1;
+			return nextBreak;
+		} else {
+			return subBreak;
+		}
+	}
+}
+
+PositionCacheEntry::PositionCacheEntry() :
+	styleNumber(0), len(0), clock(0), positions(0) {
+}
+
+void PositionCacheEntry::Set(unsigned int styleNumber_, const char *s_,
+	unsigned int len_, int *positions_, unsigned int clock_) {
+	Clear();
+	styleNumber = styleNumber_;
+	len = len_;
+	clock = clock_;
+	if (s_ && positions_) {
+		positions = new short[len + (len + 1) / 2];
+		for (unsigned int i=0;i<len;i++) {
+			positions[i] = static_cast<short>(positions_[i]);
+		}
+		memcpy(reinterpret_cast<char *>(positions + len), s_, len);
+	}
+}
+
+PositionCacheEntry::~PositionCacheEntry() {
+	Clear();
+}
+
+void PositionCacheEntry::Clear() {
+	delete []positions;
+	positions = 0;
+	styleNumber = 0;
+	len = 0;
+	clock = 0;
+}
+
+bool PositionCacheEntry::Retrieve(unsigned int styleNumber_, const char *s_,
+	unsigned int len_, int *positions_) const {
+	if ((styleNumber == styleNumber_) && (len == len_) &&
+		(memcmp(reinterpret_cast<char *>(positions + len), s_, len)== 0)) {
+		for (unsigned int i=0;i<len;i++) {
+			positions_[i] = positions[i];
+		}
+		return true;
+	} else {
+		return false;
+	}
+}
+
+int PositionCacheEntry::Hash(unsigned int styleNumber, const char *s, unsigned int len) {
+	unsigned int ret = s[0] << 7;
+	for (unsigned int i=0; i<len; i++) {
+		ret *= 1000003;
+		ret ^= s[i];
+	}
+	ret *= 1000003;
+	ret ^= len;
+	ret *= 1000003;
+	ret ^= styleNumber;
+	return ret;
+}
+
+bool PositionCacheEntry::NewerThan(const PositionCacheEntry &other) {
+	return clock > other.clock;
+}
+
+void PositionCacheEntry::ResetClock() {
+	if (clock > 0) {
+		clock = 1;
+	}
+}
+
+PositionCache::PositionCache() {
+	size = 0x400;
+	clock = 1;
+	pces = new PositionCacheEntry[size];
+	allClear = true;
+}
+
+PositionCache::~PositionCache() {
+	Clear();
+	delete []pces;
+}
+
+void PositionCache::Clear() {
+	if (!allClear) {
+		for (size_t i=0;i<size;i++) {
+			pces[i].Clear();
+		}
+	}
+	clock = 1;
+	allClear = true;
+}
+
+void PositionCache::SetSize(size_t size_) {
+	Clear();
+	delete []pces;
+	size = size_;
+	pces = new PositionCacheEntry[size];
+}
+
+void PositionCache::MeasureWidths(Surface *surface, ViewStyle &vstyle, unsigned int styleNumber,
+	const char *s, unsigned int len, int *positions) {
+	allClear = false;
+	int probe = -1;
+	if ((size > 0) && (len < 30)) {
+		// Only store short strings in the cache so it doesn't churn with
+		// long comments with only a single comment.
+
+		// Two way associative: try two probe positions.
+		int hashValue = PositionCacheEntry::Hash(styleNumber, s, len);
+		probe = hashValue % size;
+		if (pces[probe].Retrieve(styleNumber, s, len, positions)) {
+			return;
+		}
+		int probe2 = (hashValue * 37) % size;
+		if (pces[probe2].Retrieve(styleNumber, s, len, positions)) {
+			return;
+		}
+		// Not found. Choose the oldest of the two slots to replace
+		if (pces[probe].NewerThan(pces[probe2])) {
+			probe = probe2;
+		}
+	}
+	surface->MeasureWidths(vstyle.styles[styleNumber].font, s, len, positions);
+	if (probe >= 0) {
+		clock++;
+		if (clock > 60000) {
+			// Since there are only 16 bits for the clock, wrap it round and
+			// reset all cache entries so none get stuck with a high clock.
+			for (size_t i=0;i<size;i++) {
+				pces[i].ResetClock();
+			}
+			clock = 2;
+		}
+		pces[probe].Set(styleNumber, s, len, positions, clock);
+	}
+}
Index: src/sdk/wxscintilla/src/scintilla/src/CallTip.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/CallTip.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/CallTip.cxx	(working copy)
@@ -12,7 +12,12 @@
 
 #include "Scintilla.h"
 #include "CallTip.h"
+#include <stdio.h>
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static const int insetX = 5;    // text inset in x from calltip border
 static const int widthArrow = 14;
 
@@ -29,8 +34,14 @@
 	tabSize = 0;
 	useStyleCallTip = false;    // for backwards compatibility
 
+#ifdef __APPLE__
+	// proper apple colours for the default
+	colourBG.desired = ColourDesired(0xff, 0xff, 0xc6);
+	colourUnSel.desired = ColourDesired(0, 0, 0);
+#else
 	colourBG.desired = ColourDesired(0xff, 0xff, 0xff);
 	colourUnSel.desired = ColourDesired(0x80, 0x80, 0x80);
+#endif
 	colourSel.desired = ColourDesired(0, 0, 0x80);
 	colourShade.desired = ColourDesired(0, 0, 0);
 	colourLight.desired = ColourDesired(0xc0, 0xc0, 0xc0);
@@ -170,6 +181,7 @@
 	char *chunkVal = val;
 	bool moreChunks = true;
 	int maxWidth = 0;
+
 	while (moreChunks) {
 		char *chunkEnd = strchr(chunkVal, '\n');
 		if (chunkEnd == NULL) {
@@ -217,6 +229,8 @@
 	offsetMain = insetX;    // initial alignment assuming no arrows
 	PaintContents(surfaceWindow, true);
 
+#ifndef __APPLE__
+	// OSX doesn't put borders on "help tags"
 	// Draw a raised border around the edges of the window
 	surfaceWindow->MoveTo(0, rcClientSize.bottom - 1);
 	surfaceWindow->PenColour(colourShade.allocated);
@@ -225,6 +239,7 @@
 	surfaceWindow->PenColour(colourLight.allocated);
 	surfaceWindow->LineTo(0, 0);
 	surfaceWindow->LineTo(0, rcClientSize.bottom - 1);
+#endif
 }
 
 void CallTip::MouseClick(Point pt) {
Index: src/sdk/wxscintilla/src/scintilla/src/LineMarker.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LineMarker.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LineMarker.cxx	(working copy)
@@ -13,6 +13,10 @@
 #include "XPM.h"
 #include "LineMarker.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 void LineMarker::RefreshColourPalette(Palette &pal, bool want) {
 	pal.WantFind(fore, want);
 	pal.WantFind(back, want);
@@ -295,6 +299,10 @@
 		};
 		surface->Polygon(pts, sizeof(pts) / sizeof(pts[0]),
 				fore.allocated, back.allocated);
+	} else if (markType == SC_MARK_LEFTRECT) {
+		PRectangle rcLeft = rcWhole;
+		rcLeft.right = rcLeft.left + 4;
+		surface->FillRectangle(rcLeft, back.allocated);
 	} else { // SC_MARK_FULLRECT
 		surface->FillRectangle(rcWhole, back.allocated);
 	}
Index: src/sdk/wxscintilla/src/scintilla/src/LexRuby.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexRuby.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexRuby.cxx	(working copy)
@@ -49,7 +49,10 @@
 }
 
 static inline bool isSafeWordcharOrHigh(char ch) {
-    return isHighBitChar(ch) || iswordchar(ch);
+    // Error: scintilla's KeyWords.h includes '.' as a word-char
+    // we want to separate things that can take methods from the
+    // methods.
+    return isHighBitChar(ch) || isalnum(ch) || ch == '_';
 }
 
 static bool inline iswhitespace(char ch) {
@@ -95,7 +98,7 @@
                               Accessor &styler);
 
 static int ClassifyWordRb(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler, char *prevWord) {
-	char s[100];
+	char s[MAX_KEYWORD_LENGTH];
     unsigned int i, j;
 	unsigned int lim = end - start + 1; // num chars to copy
 	if (lim >= MAX_KEYWORD_LENGTH) {
@@ -238,7 +241,75 @@
     return true;
 }
 
+// This class is used by the enter and exit methods, so it needs
+// to be hoisted out of the function.
 
+class QuoteCls {
+    public:
+    int  Count;
+    char Up;
+    char Down;
+    QuoteCls() {
+        this->New();
+    }
+    void New() {
+        Count = 0;
+        Up    = '\0';
+        Down  = '\0';
+    }
+    void Open(char u) {
+        Count++;
+        Up    = u;
+        Down  = opposite(Up);
+    }
+    QuoteCls(const QuoteCls& q) {
+        // copy constructor -- use this for copying in
+        Count = q.Count;
+        Up    = q.Up;
+        Down  = q.Down;
+    }
+    QuoteCls& operator=(const QuoteCls& q) { // assignment constructor
+        if (this != &q) {
+            Count = q.Count;
+            Up    = q.Up;
+            Down  = q.Down;
+        }
+		return *this;
+    }
+            
+};
+
+
+static void enterInnerExpression(int  *p_inner_string_types,
+                                 int  *p_inner_expn_brace_counts,
+                                 QuoteCls *p_inner_quotes,
+                                 int&  inner_string_count,
+                                 int&  state,
+                                 int&  brace_counts,
+                                 QuoteCls curr_quote
+                                 ) {
+    p_inner_string_types[inner_string_count] = state;
+    state = SCE_RB_DEFAULT;
+    p_inner_expn_brace_counts[inner_string_count] = brace_counts;
+    brace_counts = 0;
+    p_inner_quotes[inner_string_count] = curr_quote;
+    ++inner_string_count;
+}
+
+static void exitInnerExpression(int *p_inner_string_types,
+                                 int *p_inner_expn_brace_counts,
+                                 QuoteCls *p_inner_quotes,
+                                 int& inner_string_count,
+                                 int& state,
+                                 int&  brace_counts,
+                                 QuoteCls& curr_quote
+                                ) {
+    --inner_string_count;
+    state = p_inner_string_types[inner_string_count];
+    brace_counts = p_inner_expn_brace_counts[inner_string_count];
+    curr_quote = p_inner_quotes[inner_string_count];
+}
+
 static bool isEmptyLine(int pos,
                         Accessor &styler) {
 	int spaceFlags = 0;
@@ -288,7 +359,7 @@
 //
 // iPrev points to the start of <<
 
-static bool sureThisIsHeredoc(int iPrev, 
+static bool sureThisIsHeredoc(int iPrev,
                               Accessor &styler,
                               char *prevWord) {
                     
@@ -605,25 +676,6 @@
 	};
 	HereDocCls HereDoc;	
 
-	class QuoteCls {
-		public:
-		int  Count;
-		char Up;
-		char Down;
-		QuoteCls() {
-			this->New();
-		}
-		void New() {
-			Count = 0;
-			Up    = '\0';
-			Down  = '\0';
-		}
-		void Open(char u) {
-			Count++;
-			Up    = u;
-			Down  = opposite(Up);
-		}
-	};
 	QuoteCls Quote;
 
     int numDots = 0;  // For numbers --
@@ -643,6 +695,7 @@
 
 	char chPrev = styler.SafeGetCharAt(startPos - 1);
 	char chNext = styler.SafeGetCharAt(startPos);
+	bool is_real_number = true;   // Differentiate between constants and ?-sequences.
 	// Ruby uses a different mask because bad indentation is marked by oring with 32
 	styler.StartAt(startPos, 127);
 	styler.StartSegment(startPos);
@@ -654,8 +707,39 @@
                              SCE_RB_STRING_QW,
                              SCE_RB_STRING_QX};
     static const char* q_chars = "qQrwWx";
-    
-	for (int i = startPos; i < lengthDoc; i++) {
+
+    // In most cases a value of 2 should be ample for the code in the
+    // Ruby library, and the code the user is likely to enter.
+    // For example,
+    // fu_output_message "mkdir #{options[:mode] ? ('-m %03o ' % options[:mode]) : ''}#{list.join ' '}"
+    //     if options[:verbose]
+    // from fileutils.rb nests to a level of 2
+    // If the user actually hits a 6th occurrence of '#{' in a double-quoted
+    // string (including regex'es, %Q, %<sym>, %w, and other strings
+    // that interpolate), it will stay as a string.  The problem with this
+    // is that quotes might flip, a 7th '#{' will look like a comment,
+    // and code-folding might be wrong.
+
+    // If anyone runs into this problem, I recommend raising this
+    // value slightly higher to replacing the fixed array with a linked
+    // list.  Keep in mind this code will be called everytime the lexer
+    // is invoked.
+
+#define INNER_STRINGS_MAX_COUNT 5
+    // These vars track our instances of "...#{,,,%Q<..#{,,,}...>,,,}..."
+    int inner_string_types[INNER_STRINGS_MAX_COUNT];
+    // Track # braces when we push a new #{ thing
+    int inner_expn_brace_counts[INNER_STRINGS_MAX_COUNT];
+    QuoteCls inner_quotes[INNER_STRINGS_MAX_COUNT];
+    int inner_string_count = 0;
+    int brace_counts = 0;   // Number of #{ ... } things within an expression
+
+    int i;
+	for (i = 0; i < INNER_STRINGS_MAX_COUNT; i++) {
+        inner_string_types[i] = 0;
+        inner_expn_brace_counts[i] = 0;
+    }
+	for (i = startPos; i < lengthDoc; i++) {
 		char ch = chNext;
 		chNext = styler.SafeGetCharAt(i + 1);
 		char chNext2 = styler.SafeGetCharAt(i + 2);
@@ -690,6 +774,7 @@
             if (isSafeDigit(ch)) {
             	styler.ColourTo(i - 1, state);
 				state = SCE_RB_NUMBER;
+                is_real_number = true;
                 numDots = 0;
             } else if (isHighBitChar(ch) || iswordstart(ch)) {
             	styler.ColourTo(i - 1, state);
@@ -885,7 +970,7 @@
 						chNext = styler.SafeGetCharAt(i + 1);
                         have_string = true;
                     }
-                } else if (!isSafeWordcharOrHigh(chNext)) {
+                } else if (preferRE && !isSafeWordcharOrHigh(chNext)) {
                     // Ruby doesn't allow high bit chars here,
                     // but the editor host might
                     state = SCE_RB_STRING_QQ;
@@ -898,6 +983,16 @@
                     // stay in default
                     preferRE = true;
                 }
+            } else if (ch == '?') {
+                styler.ColourTo(i - 1, state);
+                if (iswhitespace(chNext) || chNext == '\n' || chNext == '\r') {
+                    styler.ColourTo(i, SCE_RB_OPERATOR);
+                } else {
+                    // It's the start of a character code escape sequence
+                    // Color it as a number.
+                    state = SCE_RB_NUMBER;
+                    is_real_number = false;
+                }
             } else if (isoperator(ch) || ch == '.') {
 				styler.ColourTo(i - 1, state);
 				styler.ColourTo(i, SCE_RB_OPERATOR);
@@ -909,7 +1004,20 @@
                 // we aren't ending an object exp'n, and ops
                 // like : << / are unary operators.
                 
-                preferRE = (strchr(")}].", ch) == NULL);
+                if (ch == '{') {
+                    ++brace_counts;
+                    preferRE = true;
+                } else if (ch == '}' && --brace_counts < 0
+                           && inner_string_count > 0) {
+                    styler.ColourTo(i, SCE_RB_OPERATOR);
+                    exitInnerExpression(inner_string_types,
+                                        inner_expn_brace_counts,
+                                        inner_quotes,
+                                        inner_string_count,
+                                        state, brace_counts, Quote);
+                } else {
+                    preferRE = (strchr(")}].", ch) == NULL);
+                }
                 // Stay in default state
             } else if (isEOLChar(ch)) {
                 // Make sure it's a true line-end, with no backslash
@@ -984,7 +1092,37 @@
                 }
             }
         } else if (state == SCE_RB_NUMBER) {
-            if (isSafeAlnumOrHigh(ch) || ch == '_') {
+            if (!is_real_number) {
+                if (ch != '\\') {
+                    styler.ColourTo(i, state);
+                    state = SCE_RB_DEFAULT;
+                    preferRE = false;
+                } else if (strchr("\\ntrfvaebs", chNext)) {
+                    // Terminal escape sequence -- handle it next time
+                    // Nothing more to do this time through the loop
+                } else if (chNext == 'C' || chNext == 'M') {
+                    if (chNext2 != '-') {
+                        // \C or \M ends the sequence -- handle it next time
+                    } else {
+                        // Move from abc?\C-x
+                        //               ^
+                        // to
+                        //                 ^
+                        i += 2;
+                        ch = chNext2;
+                        chNext = styler.SafeGetCharAt(i + 1);
+                    }
+                } else if (chNext == 'c') {
+                    // Stay here, \c is a combining sequence
+                    advance_char(i, ch, chNext, chNext2); // pass by ref
+                } else {
+                    // ?\x, including ?\\ is final.
+                    styler.ColourTo(i + 1, state);
+                    state = SCE_RB_DEFAULT;
+                    preferRE = false;
+                    advance_char(i, ch, chNext, chNext2);
+                }
+            } else if (isSafeAlnumOrHigh(ch) || ch == '_') {
                 // Keep going
             } else if (ch == '.' && ++numDots == 1) {
                 // Keep going
@@ -1155,30 +1293,47 @@
                 Quote.Count++;
                 
             } else if (ch == '#' ) {
-                //todo: distinguish comments from pound chars
-                // for now, handle as comment
-                styler.ColourTo(i - 1, state);
-                bool inEscape = false;
-                while (++i < lengthDoc) {
-                    ch = styler.SafeGetCharAt(i);
-                    if (ch == '\\') {
-                        inEscape = true;
-                    } else if (isEOLChar(ch)) {
-                        // Comment inside a regex
-                        styler.ColourTo(i - 1, SCE_RB_COMMENTLINE);
-                        break;
-                    } else if (inEscape) {
-                        inEscape = false;  // don't look at char
-                    } else if (ch == Quote.Down) {
-                        // Have the regular handler deal with this
-                        // to get trailing modifiers.
-                        i--;
-                        ch = styler[i];
-						break;
+                if (chNext == '{'
+                    && inner_string_count < INNER_STRINGS_MAX_COUNT) {
+                    // process #{ ... }
+                    styler.ColourTo(i - 1, state);
+                    styler.ColourTo(i + 1, SCE_RB_OPERATOR);
+                    enterInnerExpression(inner_string_types,
+                                         inner_expn_brace_counts,
+                                         inner_quotes,
+                                         inner_string_count,
+                                         state,
+                                         brace_counts,
+                                         Quote);
+                    preferRE = true;
+                    // Skip one
+                    advance_char(i, ch, chNext, chNext2);
+                } else {
+                    //todo: distinguish comments from pound chars
+                    // for now, handle as comment
+                    styler.ColourTo(i - 1, state);
+                    bool inEscape = false;
+                    while (++i < lengthDoc) {
+                        ch = styler.SafeGetCharAt(i);
+                        if (ch == '\\') {
+                            inEscape = true;
+                        } else if (isEOLChar(ch)) {
+                            // Comment inside a regex
+                            styler.ColourTo(i - 1, SCE_RB_COMMENTLINE);
+                            break;
+                        } else if (inEscape) {
+                            inEscape = false;  // don't look at char
+                        } else if (ch == Quote.Down) {
+                            // Have the regular handler deal with this
+                            // to get trailing modifiers.
+                            i--;
+                            ch = styler[i];
+                            break;
+                        }
                     }
+                    chNext = styler.SafeGetCharAt(i + 1);
+                    chNext2 = styler.SafeGetCharAt(i + 2);
                 }
-                chNext = styler.SafeGetCharAt(i + 1);
-                chNext2 = styler.SafeGetCharAt(i + 2);
             }
         // Quotes of all kinds...
         } else if (state == SCE_RB_STRING_Q || state == SCE_RB_STRING_QQ || 
@@ -1199,6 +1354,23 @@
                 }
             } else if (ch == Quote.Up) {
                 Quote.Count++;
+            } else if (ch == '#' && chNext == '{'
+                       && inner_string_count < INNER_STRINGS_MAX_COUNT
+                       && state != SCE_RB_CHARACTER
+                       && state != SCE_RB_STRING_Q) {
+                // process #{ ... }
+                styler.ColourTo(i - 1, state);
+                styler.ColourTo(i + 1, SCE_RB_OPERATOR);
+                enterInnerExpression(inner_string_types,
+                                     inner_expn_brace_counts,
+                                     inner_quotes,
+                                     inner_string_count,
+                                     state,
+                                     brace_counts,
+                                     Quote);
+                preferRE = true;
+                // Skip one
+                advance_char(i, ch, chNext, chNext2);
             }
         }
             
Index: src/sdk/wxscintilla/src/scintilla/src/LexPS.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexPS.cxx	(revision 5311)
+++ src/sdk/wxscintilla/src/scintilla/src/LexPS.cxx	(working copy)
@@ -21,6 +21,10 @@
 #include "Scintilla.h"
 #include "SciLexer.h"
 
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
 static inline bool IsASelfDelimitingChar(const int ch) {
     return (ch == '[' || ch == ']' || ch == '{' || ch == '}' ||
             ch == '/' || ch == '<' || ch == '>' ||
@@ -103,7 +107,7 @@
                     sc.SetState(SCE_C_DEFAULT);
             } else if (sc.atLineEnd) {
                 sc.SetState(SCE_C_DEFAULT);
-            } else if (IsAWhitespaceChar(sc.ch)) {
+            } else if (IsAWhitespaceChar(sc.ch) && sc.ch != '\r') {
                 sc.ChangeState(SCE_PS_COMMENT);
             }
         } else if (sc.state == SCE_PS_NUMBER) {
Index: src/sdk/wxscintilla/src/scintilla/src/LexD.cxx
===================================================================
--- src/sdk/wxscintilla/src/scintilla/src/LexD.cxx	(revision 0)
+++ src/sdk/wxscintilla/src/scintilla/src/LexD.cxx	(revision 0)
@@ -0,0 +1,358 @@
+/** @file LexD.cxx
+ ** Lexer for D.
+ **
+ ** Copyright (c) 2006 by Waldemar Augustyn <waldemar@wdmsys.com>
+ **/
+// Copyright 1998-2005 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Platform.h"
+
+#include "PropSet.h"
+#include "Accessor.h"
+#include "StyleContext.h"
+#include "KeyWords.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+/*/ Nested comments require keeping the value of the nesting level for every
+    position in the document.  But since scintilla always styles line by line,
+    we only need to store one value per line. The non-negative number indicates
+    nesting level at the end of the line.
+/*/
+
+// We use custom qualifiers since it is not clear what D allows.
+
+static bool IsWordStart(int ch) {
+	return isascii(ch) && (isalpha(ch) || ch == '_');
+}
+
+static bool IsWord(int ch) {
+	return isascii(ch) && (isalnum(ch) || ch == '_');
+}
+
+static bool IsDoxygen(int ch) {
+	if (isascii(ch) && islower(ch))
+		return true;
+	if (ch == '$' || ch == '@' || ch == '\\' ||
+		ch == '&' || ch == '#' || ch == '<' || ch == '>' ||
+		ch == '{' || ch == '}' || ch == '[' || ch == ']')
+		return true;
+	return false;
+}
+
+
+static void ColouriseDoc(unsigned int startPos, int length, int initStyle, 
+    WordList *keywordlists[], Accessor &styler, bool caseSensitive) {
+
+    WordList &keywords = *keywordlists[0];
+    WordList &keywords2 = *keywordlists[1];
+    WordList &keywords3 = *keywordlists[2];
+    WordList &keywords4 = *keywordlists[3];
+
+    int styleBeforeDCKeyword = SCE_D_DEFAULT;
+
+    StyleContext sc(startPos, length, initStyle, styler);
+
+    int curLine = styler.GetLine(startPos);
+    int curNcLevel = curLine > 0? styler.GetLineState(curLine-1): 0;
+
+    for (; sc.More(); sc.Forward()) {
+
+        if (sc.atLineStart) {
+            if (sc.state == SCE_D_STRING) {
+                // Prevent SCE_D_STRINGEOL from leaking back to previous line which
+                // ends with a line continuation by locking in the state upto this position.
+                sc.SetState(SCE_D_STRING);
+            }
+            curLine = styler.GetLine(sc.currentPos);
+            styler.SetLineState(curLine, curNcLevel);
+        }
+
+        // Handle line continuation generically.
+        if (sc.ch == '\\') {
+            if (sc.chNext == '\n' || sc.chNext == '\r') {
+                sc.Forward();
+                if (sc.ch == '\r' && sc.chNext == '\n') {
+                    sc.Forward();
+                }
+                continue;
+            }
+        }
+
+        // Determine if the current state should terminate.
+        switch (sc.state) {
+            case SCE_D_OPERATOR:
+                sc.SetState(SCE_D_DEFAULT);
+                break;
+            case SCE_D_NUMBER:
+                // We accept almost anything because of hex. and number suffixes
+                if (!IsWord(sc.ch) && sc.ch != '.') {
+                    sc.SetState(SCE_D_DEFAULT);
+                }
+                break;
+            case SCE_D_IDENTIFIER:
+                if (!IsWord(sc.ch)) {
+                    char s[1000];
+                    if (caseSensitive) {
+                        sc.GetCurrent(s, sizeof(s));
+                    } else {
+                        sc.GetCurrentLowered(s, sizeof(s));
+                    }
+                    if (keywords.InList(s)) {
+                        sc.ChangeState(SCE_D_WORD);
+                    } else if (keywords2.InList(s)) {
+                        sc.ChangeState(SCE_D_WORD2);
+                    } else if (keywords4.InList(s)) {
+                        sc.ChangeState(SCE_D_TYPEDEF);
+                    }
+                    sc.SetState(SCE_D_DEFAULT);
+                }
+                break;
+            case SCE_D_COMMENT:
+                if (sc.Match('*', '/')) {
+                    sc.Forward();
+                    sc.ForwardSetState(SCE_D_DEFAULT);
+                }
+                break;
+            case SCE_D_COMMENTDOC:
+                if (sc.Match('*', '/')) {
+                    sc.Forward();
+                    sc.ForwardSetState(SCE_D_DEFAULT);
+                } else if (sc.ch == '@' || sc.ch == '\\') { // JavaDoc and Doxygen support
+                    // Verify that we have the conditions to mark a comment-doc-keyword
+                    if ((IsASpace(sc.chPrev) || sc.chPrev == '*') && (!IsASpace(sc.chNext))) {
+                        styleBeforeDCKeyword = SCE_D_COMMENTDOC;
+                        sc.SetState(SCE_D_COMMENTDOCKEYWORD);
+                    }
+                }
+                break;
+            case SCE_D_COMMENTLINE:
+                if (sc.atLineStart) {
+                    sc.SetState(SCE_D_DEFAULT);
+                }
+                break;
+            case SCE_D_COMMENTLINEDOC:
+                if (sc.atLineStart) {
+                    sc.SetState(SCE_D_DEFAULT);
+                } else if (sc.ch == '@' || sc.ch == '\\') { // JavaDoc and Doxygen support
+                    // Verify that we have the conditions to mark a comment-doc-keyword
+                    if ((IsASpace(sc.chPrev) || sc.chPrev == '/' || sc.chPrev == '!') && (!IsASpace(sc.chNext))) {
+                        styleBeforeDCKeyword = SCE_D_COMMENTLINEDOC;
+                        sc.SetState(SCE_D_COMMENTDOCKEYWORD);
+                    }
+                }
+                break;
+            case SCE_D_COMMENTDOCKEYWORD:
+                if ((styleBeforeDCKeyword == SCE_D_COMMENTDOC) && sc.Match('*', '/')) {
+                    sc.ChangeState(SCE_D_COMMENTDOCKEYWORDERROR);
+                    sc.Forward();
+                    sc.ForwardSetState(SCE_D_DEFAULT);
+                } else if (!IsDoxygen(sc.ch)) {
+                    char s[100];
+                    if (caseSensitive) {
+                        sc.GetCurrent(s, sizeof(s));
+                    } else {
+                        sc.GetCurrentLowered(s, sizeof(s));
+                    }
+                    if (!IsASpace(sc.ch) || !keywords3.InList(s + 1)) {
+                        sc.ChangeState(SCE_D_COMMENTDOCKEYWORDERROR);
+                    }
+                    sc.SetState(styleBeforeDCKeyword);
+                }
+                break;
+            case SCE_D_COMMENTNESTED:
+                if (sc.Match('+', '/')) {
+                    if (curNcLevel > 0)
+                        curNcLevel -= 1;
+                    curLine = styler.GetLine(sc.currentPos);
+                    styler.SetLineState(curLine, curNcLevel);
+                    sc.Forward();
+                    if (curNcLevel == 0) {
+                        sc.ForwardSetState(SCE_D_DEFAULT);
+		    }
+                }
+                else if (sc.Match('/','+')) {
+                    curNcLevel += 1;
+                    curLine = styler.GetLine(sc.currentPos);
+                    styler.SetLineState(curLine, curNcLevel);
+                    sc.Forward();
+                }
+                break;
+            case SCE_D_STRING:
+                if (sc.atLineEnd) {
+                    sc.ChangeState(SCE_D_STRINGEOL);
+                } else if (sc.ch == '\\') {
+                    if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
+                        sc.Forward();
+                    }
+                } else if (sc.ch == '\"') {
+                    sc.ForwardSetState(SCE_D_DEFAULT);
+                }
+                break;
+            case SCE_D_CHARACTER:
+                if (sc.atLineEnd) {
+                    sc.ChangeState(SCE_D_STRINGEOL);
+                } else if (sc.ch == '\\') {
+                    if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
+                        sc.Forward();
+                    }
+                } else if (sc.ch == '\'') {
+                    sc.ForwardSetState(SCE_D_DEFAULT);
+                }
+                break;
+            case SCE_D_STRINGEOL:
+                if (sc.atLineStart) {
+                    sc.SetState(SCE_D_DEFAULT);
+                }
+                break;
+        }
+
+        // Determine if a new state should be entered.
+        if (sc.state == SCE_D_DEFAULT) {
+            if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
+                    sc.SetState(SCE_D_NUMBER);
+            } else if (IsWordStart(sc.ch)) {
+                    sc.SetState(SCE_D_IDENTIFIER);
+            } else if (sc.Match('/','+')) {
+                curNcLevel += 1;
+		curLine = styler.GetLine(sc.currentPos);
+                styler.SetLineState(curLine, curNcLevel);
+                sc.SetState(SCE_D_COMMENTNESTED);
+                sc.Forward();
+            } else if (sc.Match('/', '*')) {
+                if (sc.Match("/**") || sc.Match("/*!")) {   // Support of Qt/Doxygen doc. style
+                    sc.SetState(SCE_D_COMMENTDOC);
+                } else {
+                    sc.SetState(SCE_D_COMMENT);
+                }
+                sc.Forward();   // Eat the * so it isn't used for the end of the comment
+            } else if (sc.Match('/', '/')) {
+                if ((sc.Match("///") && !sc.Match("////")) || sc.Match("//!"))
+                    // Support of Qt/Doxygen doc. style
+                    sc.SetState(SCE_D_COMMENTLINEDOC);
+                else
+                    sc.SetState(SCE_D_COMMENTLINE);
+            } else if (sc.ch == '\"') {
+                sc.SetState(SCE_D_STRING);
+            } else if (sc.ch == '\'') {
+                sc.SetState(SCE_D_CHARACTER);
+            } else if (isoperator(static_cast<char>(sc.ch))) {
+                sc.SetState(SCE_D_OPERATOR);
+            }
+        }
+    }
+    sc.Complete();
+}
+
+static bool IsStreamCommentStyle(int style) {
+    return style == SCE_D_COMMENT ||
+        style == SCE_D_COMMENTDOC ||
+        style == SCE_D_COMMENTDOCKEYWORD ||
+        style == SCE_D_COMMENTDOCKEYWORDERROR;
+}
+
+// Store both the current line's fold level and the next lines in the
+// level store to make it easy to pick up with each increment
+// and to make it possible to fiddle the current level for "} else {".
+static void FoldDoc(unsigned int startPos, int length, int initStyle, Accessor &styler) {
+    bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+    bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+    bool foldAtElse = styler.GetPropertyInt("lexer.d.fold.at.else",
+		styler.GetPropertyInt("fold.at.else", 0)) != 0;
+    unsigned int endPos = startPos + length;
+    int visibleChars = 0;
+    int lineCurrent = styler.GetLine(startPos);
+    int levelCurrent = SC_FOLDLEVELBASE;
+    if (lineCurrent > 0)
+        levelCurrent = styler.LevelAt(lineCurrent-1) >> 16;
+    int levelMinCurrent = levelCurrent;
+    int levelNext = levelCurrent;
+    char chNext = styler[startPos];
+    int styleNext = styler.StyleAt(startPos);
+    int style = initStyle;
+    for (unsigned int i = startPos; i < endPos; i++) {
+        char ch = chNext;
+        chNext = styler.SafeGetCharAt(i + 1);
+        int stylePrev = style;
+        style = styleNext;
+        styleNext = styler.StyleAt(i + 1);
+        bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+        if (foldComment && IsStreamCommentStyle(style)) {
+            if (!IsStreamCommentStyle(stylePrev)) {
+                levelNext++;
+            } else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
+                // Comments don't end at end of line and the next character may be unstyled.
+                levelNext--;
+            }
+        }
+        if (style == SCE_D_OPERATOR) {
+            if (ch == '{') {
+                // Measure the minimum before a '{' to allow
+                // folding on "} else {"
+                if (levelMinCurrent > levelNext) {
+                    levelMinCurrent = levelNext;
+                }
+                levelNext++;
+            } else if (ch == '}') {
+                levelNext--;
+            }
+        }
+        if (atEOL) {
+            if (foldComment) {	// Handle nested comments
+		int nc;
+                nc =  styler.GetLineState(lineCurrent);
+                nc -= lineCurrent>0? styler.GetLineState(lineCurrent-1): 0;
+                levelNext += nc;
+	    }
+            int levelUse = levelCurrent;
+            if (foldAtElse) {
+                levelUse = levelMinCurrent;
+            }
+            int lev = levelUse | levelNext << 16;
+            if (visibleChars == 0 && foldCompact)
+                lev |= SC_FOLDLEVELWHITEFLAG;
+            if (levelUse < levelNext)
+                lev |= SC_FOLDLEVELHEADERFLAG;
+            if (lev != styler.LevelAt(lineCurrent)) {
+                styler.SetLevel(lineCurrent, lev);
+            }
+            lineCurrent++;
+            levelCurrent = levelNext;
+            levelMinCurrent = levelCurrent;
+            visibleChars = 0;
+        }
+        if (!IsASpace(ch))
+            visibleChars++;
+    }
+}
+
+static void FoldDDoc(unsigned int startPos, int length, int initStyle,
+    WordList *[], Accessor &styler) {
+        FoldDoc(startPos, length, initStyle, styler);
+}
+
+static const char * const dWordLists[] = {
+            "Primary keywords and identifiers",
+            "Secondary keywords and identifiers",
+            "Documentation comment keywords",
+            "Type definitions and aliases",
+            0,
+        };
+
+static void ColouriseDDoc(unsigned int startPos, int length, 
+    int initStyle, WordList *keywordlists[], Accessor &styler) {
+        ColouriseDoc(startPos, length, initStyle, keywordlists, styler, true);
+}
+
+LexerModule lmD(SCLEX_D, ColouriseDDoc, "d", FoldDDoc, dWordLists);
